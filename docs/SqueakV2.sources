Object subclass: #Magnitude	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Numeric-Magnitudes'!!Magnitude commentStamp: 'di 5/22/1998 16:35' prior: 0!Magnitude comment:'I am an abstract representation of objects that measure something linear. Examples are dates, times, and numbers.'!!Magnitude methodsFor: 'comparing'!< aMagnitude 	"Answer whether the receiver is less than the argument."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!<= aMagnitude 	"Answer whether the receiver is less than or equal to the argument."	^(self > aMagnitude) not! !!Magnitude methodsFor: 'comparing'!= aMagnitude 	"Compare the receiver with the argument and answer with true if the 	receiver is equal to the argument. Otherwise answer false."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!> aMagnitude 	"Answer whether the receiver is greater than the argument."	^aMagnitude < self! !!Magnitude methodsFor: 'comparing'!>= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^(self < aMagnitude) not! !!Magnitude methodsFor: 'comparing'!between: min and: max 	"Answer whether the receiver is less than or equal to the argument, max, 	and greater than or equal to the argument, min."	^self >= min and: [self <= max]! !!Magnitude methodsFor: 'comparing'!hash	"Hash must be redefined whenever = is redefined."	^self subclassResponsibility! !!Magnitude methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Magnitude methodsFor: 'testing'!max: aMagnitude 	"Answer the receiver or the argument, whichever has the greater 	magnitude."	self > aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]! !!Magnitude methodsFor: 'testing'!min: aMagnitude 	"Answer the receiver or the argument, whichever has the lesser 	magnitude."	self < aMagnitude		ifTrue: [^self]		ifFalse: [^aMagnitude]! !!Magnitude methodsFor: 'testing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !TabsMorph subclass: #MappedTabsMorph	instanceVariableNames: 'tabsInOrder '	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-EToy-Support'!!MappedTabsMorph methodsFor: 'all' stamp: 'sw 9/30/97 09:59'!addButtonShowing: aString named: aName selector: aSymbol arguments: argList atIndex: anIndex	| bb |	bb _ super addButtonShowing: aString named: aName 			selector: aSymbol arguments: argList atIndex: anIndex.	tabsInOrder ifNil: [tabsInOrder _ OrderedCollection new].	tabsInOrder addLast: bb.	^ bb! !!MappedTabsMorph methodsFor: 'all' stamp: 'jm 5/21/1998 15:48'!selectTabNamed: aString	self world abandonAllHalos.	ScheduledControllers scheduledWindowControllers do:		[:c | ((c view isKindOf: ProjectView)			and: [c model name = aString])			 ifTrue: [self highlightTabName: 'unhighlightduetonomatch!!'.					c model enter: false]].! !StringMorph subclass: #MenuItemMorph	instanceVariableNames: 'isInTransition isEnabled subMenu isSelected target selector arguments '	classVariableNames: 'SubMenuMarker '	poolDictionaries: ''	category: 'Morphic-Menus'!!MenuItemMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:46'!initialize	super initialize.	bounds _ 0@0 extent: 10@10.	color _ Color black.	font _ nil.	contents _ ''.	hasFocus _ false.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!arguments	^ arguments! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!arguments: aCollection	arguments _ aCollection.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!isEnabled	^ isEnabled! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!isEnabled: aBoolean	isEnabled = aBoolean ifTrue: [^ self].	isEnabled _ aBoolean.	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color gray]).! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!selector	^ selector! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!selector: aSymbol	selector _ aSymbol.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!subMenu	^ subMenu! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!subMenu: aMenuMorph	subMenu _ aMenuMorph.	self changed.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!target	^ target! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!target: anObject	target _ anObject.! !!MenuItemMorph methodsFor: 'drawing' stamp: 'jm 11/4/97 07:46'!drawOn: aCanvas	(isSelected & isEnabled) ifTrue: [		aCanvas fillRectangle: self bounds color: owner color darker].	super drawOn: aCanvas.	subMenu == nil ifFalse: [		aCanvas			image: SubMenuMarker			at: (self right - 8 @ ((self top + self bottom - SubMenuMarker height) // 2))].! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 5/20/1998 11:05'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	self isInMenu ifFalse: [^ super mouseDown: evt].	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	self bringMenuChainToFront.	self selectFromHand: evt hand.! !!MenuItemMorph methodsFor: 'events' stamp: 'di 2/23/98 16:22'!mouseMove: evt	| m |	m _ evt hand recipientForMouseDown: evt hand lastEvent.	m == self		ifTrue: [isSelected ifFalse: [m selectFromHand: evt hand]]		ifFalse: [self deselectForNewMorph: m.				((m isKindOf: MenuItemMorph) and: [m isInMenu]) ifTrue:					[m selectFromHand: evt hand]].! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 11/4/97 07:46'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe w |	self deselectItem.	mouseInMe _ self bounds containsPoint: evt cursorPoint.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:]) ifFalse: [			w _ owner world.			owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				w ifNotNil: [w displayWorld].				owner invokeItem: self]]].! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!hResizing	^ #spaceFill! !!MenuItemMorph methodsFor: 'layout' stamp: 'di 5/7/1998 01:21'!isAlignmentMorph	^ true! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!layoutInWidth: w height: h	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	self extent: ((scanner stringWidth: contents) @ (scanner lineHeight) max: w@h).! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minHeight	^ self extent y! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minWidth	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!MenuItemMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!vResizing	^ #shrinkWrap! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:03'!bringMenuChainToFront	| menusToPopUp menu owningItem |	menusToPopUp _ OrderedCollection new.	menu _ self owner.	[menu isKindOf: MenuMorph] whileTrue: [		menusToPopUp addFirst: menu.		owningItem _ menu popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [menu _ owningItem owner]			ifFalse: [menu _ nil]].	menusToPopUp do: [:m | m owner addMorphFront: m].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!deletePopupBackToCommonMenuWith: menuOrMenuItem	| m menuToKeepUp owningItem |	(menuOrMenuItem isKindOf: MenuMorph)		ifTrue: [m _ menuOrMenuItem]		ifFalse: [			(menuOrMenuItem isKindOf: MenuItemMorph)				ifTrue: [m _ menuOrMenuItem owner]				ifFalse: [^ self]].	menuToKeepUp _ IdentitySet new.	[m isKindOf: MenuMorph] whileTrue: [		menuToKeepUp add: m.		owningItem _ m popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [m _ owningItem owner]			ifFalse: [m _ nil]].	m _ self owner.	[m isKindOf: MenuMorph] whileTrue: [		(menuToKeepUp includes: m) ifTrue: [^ self].		m stayUp ifFalse: [m delete].		(m popUpOwner isKindOf: MenuItemMorph) ifTrue: [m popUpOwner isSelected: false].		owningItem _ m popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [m _ owningItem owner]			ifFalse: [m _ nil]].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 2/23/98 19:58'!deselectForNewMorph: aMorph	aMorph == owner		ifTrue: [^ self isSelected: false].   "in my menu but not over any item"	(aMorph == subMenu or: [aMorph owner == subMenu])		ifTrue: [^ self].  "selecting my submenu or an item in it, leave me selected"	self isSelected: false.	subMenu ifNotNil: [subMenu stayUp ifFalse: [subMenu delete]].	self deletePopupBackToCommonMenuWith: aMorph.	aMorph owner ~= self owner ifFalse: [		self deletePopupBackToCommonMenuWith: aMorph].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 2/23/98 16:24'!deselectItem	| item |	self isSelected: false.	subMenu ifNotNil: [subMenu deleteIfPopUp].	(owner isKindOf: MenuMorph) ifTrue:		[item _ owner popUpOwner.		(item isKindOf: MenuItemMorph) ifTrue: [item deselectItem]].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!hideSubmenu	subMenu ifNotNil: [subMenu deleteIfPopUp].	(owner isKindOf: MenuMorph) ifTrue: [owner deleteIfPopUp].! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!isInMenu	^ owner isKindOf: MenuMorph! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:46'!isSelected: aBoolean	isSelected _ aBoolean.	self changed.! !!MenuItemMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:58'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAt: self bounds topRight + (10@0)			forHand: aHand			from: self].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MenuItemMorph class	instanceVariableNames: ''!!MenuItemMorph class methodsFor: 'class initialization' stamp: 'jm 11/16/97 09:17'!initialize	"MenuItemMorph initialize"	| f |	f _ Form		extent: 5@9		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)		offset: 0@0.	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.! !Morph subclass: #MenuLineMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!!MenuLineMorph methodsFor: 'drawing' stamp: 'jm 11/4/97 07:46'!drawOn: aCanvas	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: owner color darker.	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: owner color lighter.! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!hResizing	^ #spaceFill! !!MenuLineMorph methodsFor: 'layout' stamp: 'di 5/7/1998 01:21'!isAlignmentMorph	^ true! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!layoutInWidth: w height: h	self extent: w@h.! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minHeight	^ 2! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!minWidth	^ 10! !!MenuLineMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:46'!vResizing	^ #shrinkWrap! !AlignmentMorph subclass: #MenuMorph	instanceVariableNames: 'defaultTarget lastSelection stayUp originalEvent popUpOwner '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Menus'!!MenuMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:46'!initialize	super initialize.	self setColor: (Color r: 0.8 g: 0.8 b: 0.8) borderWidth: 2 borderColor: #raised.	inset _ 3.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!hasSubMenu: aMenuMorph	| sub |	self items do: [:each |		sub _ each subMenu.		sub ifNotNil: [			sub == aMenuMorph ifTrue: [^ true].			(sub hasSubMenu: aMenuMorph) ifTrue: [^ true]]].	^ false! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!items	^ submorphs select: [:m | m isKindOf: MenuItemMorph]! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!lastSelection	"Return the label of the last selected item or nil."	lastSelection == nil		ifTrue: [^ lastSelection selector]		ifFalse: [^ nil].! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!lastSelection: aString	"Set the last selection so that it is selected by default when this menu first pops up."	lastSelection _ self items		detect: [:each | each selector == aString] ifNone: [nil].! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!popUpOwner	^ popUpOwner! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!popUpOwner: aMenuItemMorph	popUpOwner _ aMenuItemMorph.! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!stayUp	^ stayUp! !!MenuMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!stayUp: aBoolean	stayUp _ aBoolean.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString action: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."	self add: aString		target: defaultTarget		selector: aSymbol		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 5/1/1998 00:48'!add: aString selector: aSymbol argument: arg	self add: aString		target: defaultTarget		selector: aSymbol		argumentList: (Array with: arg)! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString subMenu: aMenuMorph	"Append the given submenu with the given label."	| item |	item _ MenuItemMorph new.	item contents: aString;		subMenu: aMenuMorph.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 4/17/1998 22:45'!add: aString target: aTarget action: aSymbol	self add: aString		target: aTarget		selector: aSymbol		argumentList: EmptyArray! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: anObject selector: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object."	self add: aString		target: anObject		selector: aSymbol		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: target selector: aSymbol argument: arg	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."	self add: aString		target: target		selector: aSymbol		argumentList: (Array with: arg)! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!add: aString target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument."	| item |	item _ MenuItemMorph new		contents: aString;		target: target;		selector: aSymbol;		arguments: argList asArray.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 5/20/1998 10:50'!addLine	"Append a divider line to this menu. Suppress duplicate lines."	submorphs isEmpty ifTrue: [^ self].	(self lastSubmorph isKindOf: MenuLineMorph)		ifFalse: [self addMorphBack: MenuLineMorph new].! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 10:13'!addList: listOfPairs	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)."	listOfPairs do:		[:aPair | self add: aPair first action: aPair last].! !!MenuMorph methodsFor: 'construction' stamp: 'sw 4/16/1998 23:43'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'keep this menu up'		target: self		selector: #toggleStayUp:		argumentList: EmptyArray.! !!MenuMorph methodsFor: 'construction' stamp: 'di 5/16/1998 22:14'!addTitle: aString	"Add a title line at the top of this menu."	| title |	title _ AlignmentMorph new setColor: (Color r: 0.5 g: 1 b: 0.75) borderWidth: 1 borderColor: #inset.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	(aString asString findTokens: String cr) do:		[:line | title addMorphBack: (StringMorph new contents: line)].	self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!defaultTarget: anObject	"Set the default target for adding menu items."	defaultTarget _ anObject.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 5/6/1998 19:48'!labels: labelString lines: lineArray selections: selectorArray	"Supports MVC-compatible menu creation protocol"	| labelArray lineNo |	labelArray _ labelString findTokens: String cr.	lineNo _ 1.	labelArray with: selectorArray do:		[:label :sel |		self add: label action: sel.		(lineArray includes: lineNo) ifTrue: [self addLine].		lineNo _ lineNo + 1]! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'add title...' action: #addTitle.	aCustomMenu add: 'set target...' action: #setTarget:.	defaultTarget ifNotNil: [		aCustomMenu add: 'add item...' action: #addItem].	aCustomMenu add: 'remove item' action: #removeItem:.	aCustomMenu add: 'add line' action: #addLine.	(self canDetachSubMenu: aHandMorph)		ifTrue: [aCustomMenu add: 'detach submenu' action: #detachSubMenu:].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addItem	| string sel |	string _ FillInTheBlank request: 'Label for new item?'.	string isEmpty ifTrue: [^ self].	sel _ FillInTheBlank request: 'Selector?'.	sel isEmpty ifFalse: [sel _ sel asSymbol].	self add: string action: sel.! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addTitle	| string |	string _ FillInTheBlank request: 'Title for this menu?'.	string isEmpty ifTrue: [^ self].	self addTitle: string.! !!MenuMorph methodsFor: 'menu' stamp: 'di 2/23/98 22:23'!canDetachSubMenu: hand	| possibleTargets item arg |	(arg _ hand argumentOrNil) ifNil: [^ false].	possibleTargets _ arg morphsAt: hand targetOffset.	item _ possibleTargets		detect: [:each | each isKindOf: MenuItemMorph]		ifNone: [^ false].	^ item subMenu notNil! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!detachSubMenu: evt	| possibleTargets item subMenu |	possibleTargets _ evt hand argumentOrNil morphsAt: evt hand targetOffset.	item _ possibleTargets detect: [:each | each isKindOf: MenuItemMorph] ifNone: [^ self].	subMenu _ item subMenu.	subMenu ifNotNil: [		item subMenu: nil.		item delete.		subMenu stayUp: true.		subMenu popUpOwner: nil.		subMenu addTitle: item contents.		evt hand attachMorph: subMenu].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!removeItem: evt	| possibleTargets item |	possibleTargets _ evt hand argumentOrNil morphsAt: evt hand targetOffset.	item _ possibleTargets		detect: [:each |					(each isKindOf: MenuItemMorph) or:					 [each isKindOf: MenuLineMorph]]		ifNone: [^ self].	item delete.! !!MenuMorph methodsFor: 'menu' stamp: 'di 4/11/98 14:25'!setInvokingView: invokingView	"Re-work every menu item of the form		<target> perform: <selector>	to the form		<target> perform: <selector> orSendTo: <invokingView>.	This supports MVC's vectoring of non-model messages to the editPane."	self items do:		[:item |		item arguments isEmpty ifTrue:  "only the simple messages"			[item arguments: (Array with: item selector with: invokingView).			item selector: #perform:orSendTo:]]! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!setTarget: evt	"Set the default target object to be used for add item commands, and re-target all existing items to the new target or the the invoking hand."	| rootMorphs old |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [defaultTarget _ rootMorphs at: 2]		ifFalse: [^ self].	"re-target all existing items"	self items do: [:item |		old _ item target.		old isHandMorph			ifTrue: [item target: evt hand. evt hand setArgument: defaultTarget]			ifFalse: [item target: defaultTarget]].! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleStayUp: evt	"Toggle my 'stayUp' flag and adjust the menu item to reflect its new state."	stayUp _ stayUp not.	self items do: [:item |		item selector = #toggleStayUp: ifTrue: [			stayUp				ifTrue: [item contents: 'dismiss this menu']				ifFalse: [item contents: 'stay up']]].	stayUp ifFalse: [self delete].! !!MenuMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:15'!minHeightWhenEmpty	^ 10! !!MenuMorph methodsFor: 'layout' stamp: 'jm 11/4/97 07:15'!minWidthWhenEmpty	^ 20! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!deleteIfPopUp	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."	stayUp ifFalse: [self delete].	(popUpOwner notNil and: [popUpOwner isKindOf: MenuItemMorph]) ifTrue: [		popUpOwner isSelected: false.		(popUpOwner owner isKindOf: MenuMorph)			ifTrue: [popUpOwner owner deleteIfPopUp]].! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!invokeItem: aMenuItem	"Perform the action associated with the given menu item."	| sel target args selArgCount |	aMenuItem isEnabled ifFalse: [^ self].	lastSelection _ aMenuItem.	"to do: report lastSelection"	sel _ aMenuItem selector.	target _ aMenuItem target.	args _ aMenuItem arguments.	selArgCount _ sel numArgs.	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		selArgCount = 0			ifTrue: [target perform: sel]			ifFalse: [				selArgCount = args size					ifTrue: [target perform: sel withArguments: args]					ifFalse: [target perform: sel withArguments: (args copyWith: originalEvent)]]].! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!popUpAt: aPoint event: evt	"Present this menu at the given point in response to the given event."	originalEvent _ evt.	self popUpAt: aPoint forHand: evt hand.! !!MenuMorph methodsFor: 'control' stamp: 'jm 11/4/97 07:46'!popUpAt: aPoint forHand: hand	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	self position: aPoint - selectedItem position + self position.	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !!MenuMorph methodsFor: 'control' stamp: 'jm 5/21/1998 07:30'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ sourceItem.	originalEvent _ MorphicEvent new setHand: hand.	selectedItem _ self items detect:		 [:each | each == lastSelection] ifNone: [self items first].	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MenuMorph class	instanceVariableNames: ''!!MenuMorph class methodsFor: 'example' stamp: 'jm 11/4/97 07:46'!example	"MenuMorph example"	| menu |	menu _ MenuMorph new.	menu addStayUpItem.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu! !!MenuMorph class methodsFor: 'instance creation' stamp: 'jm 5/14/1998 17:21'!entitled: aString	"Answer a new instance of me with the given title."	^ self new addTitle: aString! !Object subclass: #Message	instanceVariableNames: 'selector args '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!Message commentStamp: 'di 5/22/1998 16:35' prior: 0!Message comment:'I represent a selector and its argument values.	Generally, the system does not use instances of Message for efficiency reasons. However, when a message is not understood by its receiver, the interpreter will make up an instance of me in order to capture the information involved in an actual message transmission. This instance is sent it as an argument with the message doesNotUnderstand: to the receiver.'!!Message methodsFor: 'accessing'!argument	"Answer the first (presumably sole) argument"	^args at: 1! !!Message methodsFor: 'accessing'!argument: newValue	"Change the first argument to newValue and answer self"	args at: 1 put: newValue! !!Message methodsFor: 'accessing'!arguments	"Answer the arguments of the receiver."	^args! !!Message methodsFor: 'accessing'!selector	"Answer the selector of the receiver."	^selector! !!Message methodsFor: 'accessing'!sends: aSelector	"answer whether this message's selector is aSelector"	^selector == aSelector! !!Message methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'a Message with selector: '.	selector printOn: aStream.	aStream nextPutAll: ' and arguments: '.	args printOn: aStream.	^aStream! !!Message methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	aStream nextPut: $(.	aStream nextPutAll: 'Message selector: '.	selector storeOn: aStream.	aStream nextPutAll: ' arguments: '.	args storeOn: aStream.	aStream nextPut: $)! !!Message methodsFor: 'private'!setSelector: aSymbol arguments: anArray	selector _ aSymbol.	args _ anArray! !!Message methodsFor: 'sending'!sentTo: receiver	"answer the result of sending this message to receiver"	^receiver perform: selector withArguments: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Message class	instanceVariableNames: ''!!Message class methodsFor: 'instance creation'!selector: aSymbol	"Answer an instance of me with unary selector, aSymbol."	^self new setSelector: aSymbol arguments: (Array new: 0)! !!Message class methodsFor: 'instance creation'!selector: aSymbol argument: anObject 	"Answer an instance of me whose selector is aSymbol and single 	argument is anObject."	^self new setSelector: aSymbol arguments: (Array with: anObject)! !!Message class methodsFor: 'instance creation'!selector: aSymbol arguments: anArray 	"Answer an instance of me with selector, aSymbol, and arguments, 	anArray."	^self new setSelector: aSymbol arguments: anArray! !ParseNode subclass: #MessageNode	instanceVariableNames: 'receiver selector precedence special arguments sizes pc equalNode caseErrorNode '	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers StdTypers ThenFlag '	poolDictionaries: ''	category: 'System-Compiler'!!MessageNode commentStamp: 'di 5/22/1998 16:35' prior: 0!MessageNode comment:'I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.'!!MessageNode methodsFor: 'initialize-release'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	special _ MacroSelectors indexOf: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder 	"Compile."	self receiver: rcvr		arguments: args		precedence: p.	special _ MacroSelectors indexOf: selName.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ SelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: selName.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'initialize-release'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder sourceRange: range 	"Compile."	encoder noteSourceRange: range forNode: self.	^self		receiver: rcvr		selector: selName		arguments: args		precedence: p		from: encoder! !!MessageNode methodsFor: 'testing'!canCascade	^(receiver == NodeSuper or: [special > 0]) not! !!MessageNode methodsFor: 'testing'!isComplex		^(special between: 1 and: 10) or: [arguments size > 2 or: [receiver isComplex]]! !!MessageNode methodsFor: 'testing'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"Answer whether selector is selSymbol, and the predicates rcvrPred and argsPred	 evaluate to true with respect to receiver and the list of arguments.  If selSymbol or	 either predicate is nil, it means 'don't care'.  Note that argsPred takes numArgs	 arguments.  All block arguments are ParseNodes."	^(selSymbol isNil or: [selSymbol==selector key]) and:		[(rcvrPred isNil or: [rcvrPred value: receiver]) and:			[(argsPred isNil or: [argsPred valueWithArguments: arguments])]]! !!MessageNode methodsFor: 'testing'!isReturningIf	^(special between: 3 and: 4)		and: [arguments first returns and: [arguments last returns]]! !!MessageNode methodsFor: 'testing'!isTemp	"May be masquerading for debugger access to temps."	^ selector key == #tempAt:! !!MessageNode methodsFor: 'testing'!prefersValue	"return true of this node generates shorter code when it leaves a value	on the stack"	^ (special =3 or: [special =4]) and: [self isReturningIf not]! !!MessageNode methodsFor: 'testing'!toDoIncrement: variable	(receiver = variable and: [selector key = #+]) 		ifFalse: [^ nil].	arguments first isConstantNumber		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'testing'!toDoLimit: variable	(receiver = variable and: [selector key = #<= or: [selector key = #>=]]) 		ifTrue: [^ arguments first]		ifFalse: [^ nil]! !!MessageNode methodsFor: 'cascading'!cascadeReceiver	"Nil out rcvr (to indicate cascade) and return what it had been."	| rcvr |	rcvr _ receiver.	receiver _ nil.	^rcvr! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 7/13/97 10:48'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [(initStmt isMemberOf: AssignmentNode) and:				[initStmt variable isTemp]])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: MessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ BlockNode new			statements: body allButLast			returns: false.	toDoBlock arguments: (Array with: variable).	^ MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'macro transformations'!toDoWithLimit: limitStmt	"The receiver is a to:do: statement, preceded by a statement	that might be of the form {iLimiT _ expr}.  If so, replace the	limit argument by the given expr and return a new to:do: node.	Otherwise, return nil"	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable = arguments first])		ifFalse: [^ nil].	limitStmt variable key = (arguments last firstArgument key , 'LimiT')		ifFalse: [^ nil].  "Must be a generated temp"	arguments at: 1 put: (limitStmt value)! !!MessageNode methodsFor: 'macro transformations'!transform: encoder	special = 0 ifTrue: [^false].	(self perform: (MacroTransformers at: special) with: encoder)		ifTrue: 			[^true]		ifFalse: 			[special _ 0. ^false]! !!MessageNode methodsFor: 'macro transformations'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (BlockNode withJust: NodeFalse).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformBoolean: encoder	^self		checkBlock: (arguments at: 1)		as: 'argument'		from: encoder! !!MessageNode methodsFor: 'macro transformations'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (BlockNode withJust: NodeNil)					with: (arguments at: 1).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformIfFalseIfTrue: encoder	((self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'True arg' from: encoder])		ifTrue: 			[selector _ #ifTrue:ifFalse:.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (arguments at: 1)					with: (BlockNode withJust: NodeNil).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformIfTrueIfFalse: encoder	^ (self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'False arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments _ 				Array 					with: (BlockNode withJust: NodeTrue)					with: (arguments at: 1).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations'!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				increment isConstantNumber ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	block _ arguments last.	blockVar _ block firstArgument.	initStmt _ AssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ AssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ MessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder.	incStmt _ AssignmentNode new			variable: blockVar			value: (MessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!MessageNode methodsFor: 'macro transformations'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder)		ifFalse: [^ false].	arguments size = 0   "transform bodyless form to body form"		ifTrue: [selector _ SelectorNode new					key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])					code: #macro.				arguments _ Array with: (BlockNode withJust: NodeNil).				^ true]		ifFalse: [^ self transformBoolean: encoder]! !!MessageNode methodsFor: 'code generation'!emitAs: stack on: strm value: forValue 	" {...} as: .. -- handoff to receiver, which already incorporates argument."	forValue		ifTrue: [receiver emitForValue: stack on: strm]		ifFalse: [receiver emitForEffect: stack on: strm]! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:24'!emitCase: stack on: strm value: forValue	| braceNode sizeStream thenSize elseSize |	forValue not		ifTrue: [^super emitForEffect: stack on: strm].	braceNode _ arguments first.	sizeStream _ ReadStream on: sizes.	receiver emitForValue: stack on: strm.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		thenSize _ sizeStream next.		elseSize _ sizeStream next.		last ifFalse: [strm nextPut: Dup. stack push: 1].		keyNode emitForEvaluatedValue: stack on: strm.		equalNode emit: stack args: 1 on: strm.		self emitBranchOn: false dist: thenSize pop: stack on: strm.		last ifFalse: [strm nextPut: Pop. stack pop: 1].		valueNode emitForEvaluatedValue: stack on: strm.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse: [self emitJump: elseSize on: strm]].	arguments size = 2		ifTrue:			[arguments last emitForEvaluatedValue: stack on: strm] "otherwise: [...]"		ifFalse:			[NodeSelf emitForValue: stack on: strm.			caseErrorNode emit: stack args: 0 on: strm]! !!MessageNode methodsFor: 'code generation'!emitForEffect: stack on: strm	special > 0		ifTrue: 			[self perform: (MacroEmitters at: special) with: stack with: strm with: false.			pc _ 0]		ifFalse: 			[super emitForEffect: stack on: strm]! !!MessageNode methodsFor: 'code generation'!emitForValue: stack on: strm	special > 0		ifTrue: 			[self perform: (MacroEmitters at: special) with: stack with: strm with: true.			pc _ 0]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitForValue: stack on: strm].			arguments do: [:argument | argument emitForValue: stack on: strm].			selector				emit: stack				args: arguments size				on: strm				super: receiver == NodeSuper.			pc _ strm position]! !!MessageNode methodsFor: 'code generation'!emitIf: stack on: strm value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize _ sizes at: 1.	elseSize _ sizes at: 2.	(forValue not and: [(elseSize*thenSize) > 0])		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super emitForEffect: stack on: strm].	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	receiver emitForValue: stack on: strm.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitBranchOn: false dist: thenSize pop: stack on: strm.			thenExpr emitForEvaluatedValue: stack on: strm.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not				ifTrue:  "Elide jump over else after a return"					[self emitJump: elseSize on: strm].			elseExpr emitForEvaluatedValue: stack on: strm]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitBranchOn: false dist: thenSize pop: stack on: strm.					thenExpr emitForEvaluatedEffect: stack on: strm]				ifFalse:					[self emitBranchOn: true dist: elseSize pop: stack on: strm.					elseExpr emitForEvaluatedEffect: stack on: strm]]! !!MessageNode methodsFor: 'code generation'!emitToDo: stack on: strm value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt _ arguments at: 4.	limitInit _ arguments at: 7.	test _ arguments at: 5.	block _ arguments at: 3.	incStmt _ arguments at: 6.	blockSize _ sizes at: 1.	loopSize _ sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitForEffect: stack on: strm].	initStmt emitForEffect: stack on: strm.	test emitForValue: stack on: strm.	self emitBranchOn: false dist: blockSize pop: stack on: strm. 	block emitForEvaluatedEffect: stack on: strm.	incStmt emitForEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!MessageNode methodsFor: 'code generation'!emitWhile: stack on: strm value: forValue 	" L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ sizes at: 1.	loopSize _ sizes at: 2.	cond emitForEvaluatedValue: stack on: strm.	self emitBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack on: strm.   "Btp for whileFalse"	stmt emitForEvaluatedEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!MessageNode methodsFor: 'code generation'!pc	"Used by encoder source mapping."	pc==nil ifTrue: [^0] ifFalse: [^pc]! !!MessageNode methodsFor: 'code generation'!sizeAs: encoder value: forValue 	"Only receiver generates any code."	^forValue		ifTrue: [receiver sizeForValue: encoder]		ifFalse: [receiver sizeForEffect: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:25'!sizeCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize |	forValue not		ifTrue: [^super sizeForEffect: encoder].	equalNode _ encoder encodeSelector: #=.	braceNode _ arguments first.	sizes _ Array new: 2 * braceNode numElements.	sizeIndex _ sizes size.	elseSize _ arguments size = 2		ifTrue:			[arguments last sizeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode _ encoder encodeSelector: #caseError.			 1 + (caseErrorNode size: encoder args: 0 super: false)]. "self caseError"	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize _ valueNode sizeForEvaluatedValue: encoder.		last ifFalse: [thenSize _ thenSize + 1]. "Pop"		valueNode returns ifFalse: [thenSize _ thenSize + (self sizeJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize _ elseSize + 1]. "Dup"		elseSize _ elseSize + (keyNode sizeForEvaluatedValue: encoder) +			(equalNode size: encoder args: 1 super: false) +			(self sizeBranchOn: false dist: thenSize) + thenSize.		sizeIndex _ sizeIndex - 2].	^(receiver sizeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation'!sizeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeForEffect: encoder! !!MessageNode methodsFor: 'code generation'!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector _ selector copy "only necess for splOops"].	total _ selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total _ total + (receiver sizeForValue: encoder)].	sizes _ arguments collect: 					[:arg | 					argSize _ arg sizeForValue: encoder.					total _ total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation'!sizeIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr _ arguments at: 1.	elseExpr _ arguments at: 2.	(forValue		or: [(thenExpr isJust: NodeNil)		or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super sizeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize _ elseExpr sizeForEvaluatedValue: encoder.			thenSize _ (thenExpr sizeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeJump: elseSize]).			branchSize _ self sizeBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize _ 0.					thenSize _ thenExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: false dist: thenSize]				ifFalse:					[thenSize _ 0.					elseSize _ elseExpr sizeForEvaluatedEffect: encoder.					branchSize _ self sizeBranchOn: true dist: elseSize]].	sizes _ Array with: thenSize with: elseSize.	^ (receiver sizeForValue: encoder) + branchSize			+ thenSize + elseSize! !!MessageNode methodsFor: 'code generation'!sizeToDo: encoder value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize blockVar initSize limitInit |	block _ arguments at: 3.	blockVar _ block firstArgument.	initStmt _ arguments at: 4.	test _ arguments at: 5.	incStmt _ arguments at: 6.	limitInit _ arguments at: 7.	initSize _ initStmt sizeForEffect: encoder.	limitInit == nil		ifFalse: [initSize _ initSize + (limitInit sizeForEffect: encoder)].	blockSize _ (block sizeForEvaluatedEffect: encoder)			+ (incStmt sizeForEffect: encoder) + 2.  "+2 for Jmp backward"	loopSize _ (test sizeForValue: encoder)			+ (self sizeBranchOn: false dist: blockSize)			+ blockSize.	sizes _ Array with: blockSize with: loopSize.	^ initSize + loopSize			+ (forValue ifTrue: [1] ifFalse: [0])    " +1 for value (push nil) "! !!MessageNode methodsFor: 'code generation'!sizeWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond _ receiver.	stmt _ arguments at: 1.	stmtSize _ (stmt sizeForEvaluatedEffect: encoder) + 2.	branchSize _ self sizeBranchOn: (selector key == #whileFalse:)  "Btp for whileFalse"					dist: stmtSize.	loopSize _ (cond sizeForEvaluatedValue: encoder)			+ branchSize + stmtSize.	sizes _ Array with: stmtSize with: loopSize.	^ loopSize    " +1 for value (push nil) "		+ (forValue ifTrue: [1] ifFalse: [0])! !!MessageNode methodsFor: 'debugger temp access'!asStorableNode: encoder	"This node is a message masquerading as a temporary variable.	It currently has the form {homeContext tempAt: offset}.	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack.	This, in turn will get turned into {homeContext tempAt: offset put: expr}	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"	^ MessageNode new		receiver: nil  "suppress code generation for reciever already on stack"		selector: #storeAt:inTempFrame:		arguments: (arguments copyWith: receiver)		precedence: precedence		from: encoder! !!MessageNode methodsFor: 'debugger temp access'!emitStorePop: stack on: codeStream	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self emitForEffect: stack on: codeStream! !!MessageNode methodsFor: 'debugger temp access'!sizeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self sizeForEffect: encoder! !!MessageNode methodsFor: 'debugger temp access'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #tempAt: 		ifTrue: [^self error: 'cant transform this message'].	^MessageNode new		receiver: receiver		selector: #tempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!MessageNode methodsFor: 'printing'!precedence	^precedence! !!MessageNode methodsFor: 'printing'!printAsOn: aStream indent: level	self printKeywords: #as:		arguments: arguments		on: aStream		indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 7/13/97 14:50'!printCaseOn: aStream indent: level	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode _ arguments first.	otherwise _ arguments last.	((arguments size = 1) or: [otherwise isJustCaseError])		ifTrue: [otherwise _ nil].	receiver printOn: aStream indent: level precedence: 3.	aStream nextPutAll: ' caseOf: '.	braceNode isVariableReference		ifTrue: [braceNode printOn: aStream indent: level]		ifFalse:	[aStream nextPutAll: '{'; crtab: level+1.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		keyNode printOn: aStream indent: level+1.	 	aStream nextPutAll: ' -> '.		extra _ valueNode isComplex ifTrue: [aStream crtab: level+2. 1] ifFalse: [0].	 	valueNode printOn: aStream indent: level+1+extra.	 	last ifTrue: [aStream nextPut: $}] ifFalse: [aStream nextPut: $.; crtab: level+1]]].	otherwise isNil		ifFalse:			[aStream crtab: level+1; nextPutAll: 'otherwise: '.			 extra _ otherwise isComplex ifTrue: [aStream crtab: level+2. 1] ifFalse: [0].			 otherwise printOn: aStream indent: level+1+extra]! !!MessageNode methodsFor: 'printing'!printIfOn: aStream indent: level	(arguments last isJust: NodeNil) ifTrue:		[^self printKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^self printKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^self printKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^self printKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 11/4/97 20:11'!printKeywords: key arguments: args on: aStream indent: level	| keywords prev arg indent thisKey |	args size = 0 		ifTrue: [aStream space; nextPutAll: key. ^ self].	keywords _ key keywords.	prev _ receiver.	1 to: keywords size do:		[:part | arg _ args at: part.		thisKey _ keywords at: part.		(prev isMemberOf: BlockNode)		 | ((prev isMemberOf: MessageNode) and: [prev precedence >= 3])		 | ((arg isMemberOf: BlockNode) and: [arg isComplex and: [thisKey ~= #do:]])		 | (args size > 2)		 | (key = #ifTrue:ifFalse:)			ifTrue: [aStream crtab: level+1. indent _ 1] "newline after big args"			ifFalse: [aStream space. indent _ 0].		aStream nextPutAll: thisKey; space.		arg  printOn: aStream indent: level + 1 + indent			 precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence]).		prev _ arg]! !!MessageNode methodsFor: 'printing'!printOn: aStream indent: level	| printer |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(printer == #printCaseOn:indent:) ifTrue: 		[^self printCaseOn: aStream indent: level].	receiver == nil 		ifFalse: [receiver printOn: aStream indent: level precedence: precedence].	(special > 0)		ifTrue: 			[self perform: printer with: aStream with: level]		ifFalse: 			[self 				printKeywords: selector key				arguments: arguments				on: aStream				indent: level]! !!MessageNode methodsFor: 'printing'!printOn: strm indent: level precedence: p	| parenthesize |	parenthesize _ 		precedence > p or: [p = 3 and: [precedence = 3 "both keywords"]].	parenthesize ifTrue: [strm nextPutAll: '('].	self printOn: strm indent: level.	parenthesize ifTrue: [strm nextPutAll: ')']! !!MessageNode methodsFor: 'printing'!printToDoOn: aStream indent: level	| limitNode |	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode _ arguments first]		ifFalse: [limitNode _ arguments last value].	(selector key = #to:by:do:			and: [(arguments at: 2) isConstantNumber				and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'printing'!printWhileOn: aStream indent: level	(arguments first isJust: NodeNil) ifTrue:			[selector _ SelectorNode new					key: (selector key == #whileTrue:						ifTrue: [#whileTrue] ifFalse: [#whileFalse])					code: #macro.			arguments _ Array new].	^ self 		printKeywords: selector key		arguments: arguments		on: aStream		indent: level! !!MessageNode methodsFor: 'private'!checkBlock: node as: nodeName from: encoder	node canBeSpecialArgument ifTrue: [^node isMemberOf: BlockNode].	((node isKindOf: BlockNode) and: [node numberOfArguments > 0])		ifTrue:	[^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be 0-argument block']		ifFalse: [^encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' must be a block or variable']! !!MessageNode methodsFor: 'private'!pvtCheckForPvtSelector: encoder	"If the code being compiled is trying to send a private message (e.g. 'pvtCheckForPvtSelector:') to anyone other than self, then complain to encoder."	selector isPvtSelector ifTrue:		[receiver isSelfPsuedoVariable ifFalse:			[encoder notify: 'Private messages may only be sent to self']].! !!MessageNode methodsFor: 'private'!receiver: rcvr arguments: args precedence: p	receiver _ rcvr.	arguments _ args.	sizes _ Array new: arguments size.	precedence _ p! !!MessageNode methodsFor: 'private'!transformAs: encoder	(receiver isKindOf: BraceNode)		ifTrue: 			[receiver collClass: arguments first.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'private'!transformCase: encoder	| caseNode |	caseNode _ arguments first.	(caseNode isKindOf: BraceNode)		ifTrue:			[^(caseNode blockAssociationCheck: encoder) and:			 	[arguments size = 1 or:					[self checkBlock: arguments last as: 'otherwise arg' from: encoder]]].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not])		ifTrue:			[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'equation translation'!arguments	^arguments! !!MessageNode methodsFor: 'equation translation'!receiver	^receiver! !!MessageNode methodsFor: 'equation translation'!receiver: val	^receiver _ val! !!MessageNode methodsFor: 'equation translation'!selector	^selector! !!MessageNode methodsFor: 'C translation'!asTranslatorNode	"selector is sometimes a Symbol, sometimes a SelectorNode!!	On top of this, numArgs is needed due to the (truly grody) use of	arguments as a place to store the extra expressions needed to generate	code for in-line to:by:do:, etc.  see below, where it is used."	| sel args |	sel _ (selector isMemberOf: Symbol) ifTrue: [selector] ifFalse: [selector key].	args _ (1 to: sel numArgs) collect:			[:i | (arguments at: i) asTranslatorNode].	(sel = #to:by:do: and: [arguments size = 7 and: [(arguments at: 7) notNil]])		ifTrue: ["Restore limit expr that got moved by transformToDo:"				args at: 1 put: (arguments at: 7) value asTranslatorNode].	(sel = #or: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformOr:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	(sel = #ifFalse: and: [arguments size = 2 and: [(arguments at: 2) notNil]])		ifTrue: ["Restore argument block that got moved by transformIfFalse:"				args at: 1 put: (arguments at: 2) asTranslatorNode].	^ TSendNode new		setSelector: sel		receiver: ((receiver == nil)					ifTrue: [nil]					ifFalse: [receiver asTranslatorNode])		arguments: args! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageNode class	instanceVariableNames: ''!!MessageNode class methodsFor: 'class initialization' stamp: 'di 7/13/97 10:31'!initialize		"MessageNode initialize"	MacroSelectors _ 		#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise: as: ).	MacroTransformers _ 		#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase: transformAs: ).	MacroEmitters _ 		#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value: emitAs:on:value: ).	MacroSizers _ 		#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value: sizeAs:value: ).	MacroPrinters _ 		#(printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent: printAsOn:indent: )! !Browser subclass: #MessageSet	instanceVariableNames: 'messageList autoSelectString '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Browser'!!MessageSet commentStamp: 'di 5/22/1998 16:35' prior: 0!MessageSet comment:'I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a StringHolder, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.'!!MessageSet methodsFor: 'message list'!messageList	"Answer the current list of messages."	^messageList! !!MessageSet methodsFor: 'message list' stamp: 'tk 4/25/1998 00:11'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	contents _ 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	"update my selection"	self changed: #contents.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].! !!MessageSet methodsFor: 'message list' stamp: 'tk 4/4/98 21:28'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!MessageSet methodsFor: 'message list'!selectedMessageName	"Answer the name of the currently selected message."	self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'message functions' stamp: 'tk 4/25/1998 00:06'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self initializeMessageList: (messageList copyWithout: self selection).		"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self changed: #contents.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'tk 4/25/1998 00:05'!removeMessageFromBrowser	"Remove the selected message from the browser."	messageListIndex = 0 ifTrue: [^ self].	self initializeMessageList: (messageList copyWithout: self selection).	"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self changed: #contents.! !!MessageSet methodsFor: 'message functions' stamp: 'tk 4/9/98 14:05'!showBytecodes	"Show the bytecodes of the selected method."	"Set a mode for contents!!"	((self messageListIndex = 0) | (self okToChange not))		ifTrue: [^ self changed: #flash].	contents _ (self selectedClassOrMetaClass compiledMethodAt: 					self selectedMessageName) symbolic asText.	self changed: #contents.! !!MessageSet methodsFor: 'message functions'!spawn: aString 	"Create and schedule a message browser with the edited, but not yet 	accepted, code (aString) displayed in the text view part of the browser."	^self buildMessageBrowserEditString: aString! !!MessageSet methodsFor: 'class list'!metaClassIndicated	"Answer the boolean flag that indicates whether	this is a class method."	^ self selectedClassOrMetaClass isMeta! !!MessageSet methodsFor: 'class list'!selectedClass 	"Return the base class for the current selection.  1/17/96 sw fixed up so that it doesn't fall into a debugger in a msg browser that has no message selected"	| aClass |	^ (aClass _ self selectedClassOrMetaClass) == nil		ifTrue:			[nil]		ifFalse:			[aClass theNonMetaClass]! !!MessageSet methodsFor: 'class list' stamp: 'tk 4/4/98 18:50'!selectedClassName	"Answer the name of class of the currently selected message. Answer nil if no selection 	exists."	| cls |	(cls _ self selectedClass) ifNil: [^ nil].	^ cls name! !!MessageSet methodsFor: 'class list'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:c :s | ^c]! !!MessageSet methodsFor: 'class list'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	messageListIndex = 0 ifTrue: [^ nil].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!MessageSet methodsFor: 'contents'!contents	contents == nil		ifTrue: [^ '']		ifFalse: [^ contents]! !!MessageSet methodsFor: 'contents' stamp: 'di 5/20/1998 20:53'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	^ true! !!MessageSet methodsFor: 'private'!autoSelectString	"Return the string to be highlighted when making new selections"	^ autoSelectString! !!MessageSet methodsFor: 'private'!autoSelectString: aString	"Set the string to be highlighted when making new selections"	autoSelectString _ aString! !!MessageSet methodsFor: 'private'!defaultBackgroundColor	^ #lightBlue! !!MessageSet methodsFor: 'private' stamp: 'tk 4/9/98 14:52'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0.	contents _ ''! !!MessageSet methodsFor: 'private'!selection	"Answer the item in the list that is currently selected."	^messageList at: messageListIndex! !!MessageSet methodsFor: 'private'!setClassAndSelectorIn: csBlock	"Decode strings of the form <className> [class] <selectorName>."	^ MessageSet parse: self selection toClassAndSelector: csBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageSet class	instanceVariableNames: ''!!MessageSet class methodsFor: 'instance creation'!messageList: anArray 	"Answer an instance of me with message list anArray."	^self new initializeMessageList: anArray! !!MessageSet class methodsFor: 'instance creation' stamp: 'di 5/8/1998 22:31'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView |	World ifNotNil: [^ self openAsMorph: aMessageSet name: aString].	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'di 5/20/1998 20:58'!openAsMorph: aMessageSet name: labelString 	"Create a SystemWindow aMessageSet, with the label labelString."	| window |	window _ (SystemWindow labelled: labelString) model: aMessageSet.	window addMorph: (PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0 extent: 1@0.2).	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.2 corner: 1@1).	window openInWorld! !!MessageSet class methodsFor: 'instance creation'!openMessageList: anArray name: aString 	"Create a standard system view for the message set on the list, anArray. 	The label of the view is aString."	self open: (self messageList: anArray) name: aString! !!MessageSet class methodsFor: 'instance creation' stamp: 'tk 5/8/1998 10:52'!openMessageList: messageList name: labelString autoSelect: autoSelectString	"Open a system view for a MessageSet on messageList. 	 1/24/96 sw: the there-are-no msg now supplied by my sender"	| messageSet |	messageSet _ self messageList: messageList.	messageSet autoSelectString: autoSelectString.	World ifNotNil: [^ self openAsMorph: messageSet name: labelString].	ScheduledControllers scheduleActive: 					(self open: messageSet name: labelString)! !!MessageSet class methodsFor: 'instance creation' stamp: 'tk 4/21/1998 21:45'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	tuple _ messageString findTokens: ' .'.	cl _ Smalltalk at: tuple first asSymbol.	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !Magnitude subclass: #MessageTally	instanceVariableNames: 'class method tally receivers senders '	classVariableNames: 'ObservedProcess Timer '	poolDictionaries: ''	category: 'System-Support'!!MessageTally commentStamp: 'di 5/22/1998 16:35' prior: 0!MessageTally comment:'My instances observe and report the amount of time spent in methods. Observing a method implies observing all messages it sends.'!!MessageTally methodsFor: 'initialize-release'!close	(Timer isMemberOf: Process) ifTrue: [Timer terminate].	Timer _ ObservedProcess _ nil.	class _ method _ tally _ receivers _ nil! !!MessageTally methodsFor: 'initialize-release'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay _ Delay forMilliseconds: millisecs.	Timer _		[[true] whileTrue: 			[startTime _ Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value _ aBlock value.		"cancel the probe and return the value"	Timer terminate.	^value! !!MessageTally methodsFor: 'comparing'!< aMessageTally 	"Refer to the comment in Magnitude|<."	^tally > aMessageTally tally! !!MessageTally methodsFor: 'comparing'!= aMessageTally	^aMessageTally method == method! !!MessageTally methodsFor: 'comparing'!> aMessageTally 	"Refer to the comment in Magnitude|>."	^tally < aMessageTally tally! !!MessageTally methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^method asOop! !!MessageTally methodsFor: 'comparing'!isPrimitives	"Detect pseudo node used to carry tally of local hits"	^ receivers == nil! !!MessageTally methodsFor: 'comparing'!sonsOver: threshold	| hereTally last sons |	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].	hereTally _ tally.	sons _ receivers select:  "subtract subNode tallies for primitive hits here"		[:son |		hereTally _ hereTally - son tally.		son tally > threshold].	hereTally > threshold		ifTrue: 			[last _ MessageTally new class: class method: method.			^sons copyWith: (last primitives: hereTally)].	^sons! !!MessageTally methodsFor: 'tallying'!bumpBy: count	tally _ tally + count! !!MessageTally methodsFor: 'tallying'!tally: context by: count	"Explicitly tally the specified context and its stack."	| root |	context method == method ifTrue: [^self bumpBy: count].	(root _ context home sender) == nil		ifTrue: [^ (self bumpBy: count) tallyPath: context by: count].	^ (self tally: root by: count) tallyPath: context by: count! !!MessageTally methodsFor: 'tallying'!tallyPath: context by: count	| aMethod path |	aMethod _ context method.	receivers do: 		[:aMessageTally | 		aMessageTally method == aMethod ifTrue: [path _ aMessageTally]].	path == nil ifTrue: 		[path _ MessageTally new class: context receiver class method: aMethod.		receivers _ receivers copyWith: path].	^ path bumpBy: count! !!MessageTally methodsFor: 'collecting leaves'!bump: hitCount	tally _ tally + hitCount! !!MessageTally methodsFor: 'collecting leaves'!bump: hitCount fromSender: senderTally	"Add this hitCount to the total, and include a reference to the	sender responsible for the increment"	self bump: hitCount.	senders == nil ifTrue: [senders _ OrderedCollection new].	senderTally == nil		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !!MessageTally methodsFor: 'collecting leaves'!into: leafDict fromSender: senderTally	| leafNode |	leafNode _ leafDict at: method		ifAbsent: [leafDict at: method			put: (MessageTally new class: class method: method)].	leafNode bump: tally fromSender: senderTally! !!MessageTally methodsFor: 'collecting leaves'!leavesInto: leafDict fromSender: senderTally	| rcvrs |	rcvrs _ self sonsOver: 0.	rcvrs size = 0		ifTrue: [self into: leafDict fromSender: senderTally]		ifFalse: [rcvrs do:				[:node |				node isPrimitives					ifTrue: [node leavesInto: leafDict fromSender: senderTally]					ifFalse: [node leavesInto: leafDict fromSender: self]]]! !!MessageTally methodsFor: 'reporting'!report: strm 	"Print a report, with cutoff percentage of each element of the tree 	(leaves, roots, tree)=2, on the stream, strm."	self report: strm cutoff: 2! !!MessageTally methodsFor: 'reporting'!report: strm cutoff: threshold 	tally = 0		ifTrue: [strm nextPutAll: ' - no tallies obtained']		ifFalse: 			[strm nextPutAll: ' - '; print: tally; nextPutAll: ' tallies.'; cr; cr.			self fullPrintOn: strm tallyExact: false orThreshold: threshold]! !!MessageTally methodsFor: 'printing'!fullPrintOn: aStream tallyExact: isExact orThreshold: perCent	| threshold |  	isExact ifFalse: [threshold _ (perCent asFloat / 100 * tally) rounded].	aStream nextPutAll: '**Tree**'; cr.	self treePrintOn: aStream		tabs: OrderedCollection new		thisTab: ''		total: tally		tallyExact: isExact		orThreshold: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self leavesPrintOn: aStream		tallyExact: isExact		orThreshold: threshold! !!MessageTally methodsFor: 'printing'!leavesPrintOn: aStream tallyExact: isExact orThreshold: threshold	| dict |	dict _ IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	isExact ifTrue: 		[dict asSortedCollection			do: [:node |				node printOn: aStream total: tally tallyExact: isExact.				node printSenderCountsOn: aStream]]		ifFalse:		[(dict asOrderedCollection				select: [:node | node tally > threshold])			asSortedCollection			do: [:node |				node printOn: aStream total: tally tallyExact: isExact]]! !!MessageTally methodsFor: 'printing'!printOn: aStream	| aSelector className |	aSelector _ class selectorAtMethod: method setClass: [:aClass].	className _ aClass name contractTo: 30.	aStream nextPutAll: className; nextPutAll: ' >> ';			nextPutAll: (aSelector contractTo: 60-className size)! !!MessageTally methodsFor: 'printing' stamp: 'di 2/10/98 16:53'!printOn: aStream total: total tallyExact: isExact	| aSelector className myTally |	isExact ifTrue:		[myTally _ tally.		receivers == nil			ifFalse: [receivers do: [:r | myTally _ myTally - r tally]].		aStream print: myTally; space]		ifFalse:		[aStream print: (tally asFloat / total * 100.0 roundTo: 0.1); space].	receivers == nil		ifTrue: [aStream nextPutAll: 'primitives'; cr]		ifFalse: 			[aSelector _ class selectorAtMethod: method setClass: [:aClass].			className _ aClass name contractTo: 30.			aStream nextPutAll: class name;				nextPutAll: (aClass = class ifTrue: ['>>']								ifFalse: ['(' , aClass name , ')>>']);				nextPutAll: (aSelector contractTo: 60-className size); cr]! !!MessageTally methodsFor: 'printing'!printSenderCountsOn: aStream	| mergedSenders mergedNode |	mergedSenders _ IdentityDictionary new.	senders do:		[:node |		mergedNode _ mergedSenders at: node method ifAbsent: [nil].		mergedNode == nil			ifTrue: [mergedSenders at: node method put: node]			ifFalse: [mergedNode bump: node tally]].	mergedSenders asSortedCollection do:		[:node | 		10 to: node tally printString size by: -1 do: [:i | aStream space].		node printOn: aStream total: tally tallyExact: true]! !!MessageTally methodsFor: 'printing'!treePrintOn: aStream tabs: tabs thisTab: myTab	total: total tallyExact: isExact orThreshold: threshold	| sons sonTab |	tabs do: [:tab | aStream nextPutAll: tab].	tabs size > 0 ifTrue: [self printOn: aStream total: total tallyExact: isExact].	sons _ isExact		ifTrue: [receivers]		ifFalse: [self sonsOver: threshold].	sons isEmpty ifFalse:		[tabs addLast: myTab.		sons _ sons asSortedCollection.		(1 to: sons size) do: 			[:i |			sonTab _ i < sons size ifTrue: ['  |'] ifFalse: ['  '].			(sons at: i) treePrintOn: aStream				tabs: (tabs size < 18					ifTrue: [tabs]					ifFalse: [(tabs select: [:x | x = '[']) copyWith: '['])				thisTab: sonTab total: total				tallyExact: isExact orThreshold: threshold].		tabs removeLast]! !!MessageTally methodsFor: 'private'!class: aClass method: aMethod	class _ aClass.	method _ aMethod.	tally _ 0.	receivers _ Array new: 0! !!MessageTally methodsFor: 'private'!copyWithTally: hitCount	^ (MessageTally new class: class method: method) bump: hitCount! !!MessageTally methodsFor: 'private'!method	^method! !!MessageTally methodsFor: 'private'!primitives: anInteger	tally _ anInteger.	receivers _ nil! !!MessageTally methodsFor: 'private'!tally	^tally! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MessageTally class	instanceVariableNames: ''!!MessageTally class methodsFor: 'spying' stamp: 'tk 5/4/1998 17:01'!spyOn: aBlock    "MessageTally spyOn: [100 timesRepeat: [3.14159 printString]]"	| node |	node _ self new.	node spyEvery: 16 on: aBlock.	(StringHolder new contents: (String streamContents: [:s | node report: s; close]))		openLabel: 'Spy Results'! !!MessageTally class methodsFor: 'spying'!spyOn: aBlock toFileNamed: fileName 	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| file value node |	node _ self new.	value _ node spyEvery: 16 on: aBlock.	file _ FileStream newFileNamed: fileName.	node report: file; close.	file close.	^value! !!MessageTally class methodsFor: 'spying'!tallySends: aBlock   "MessageTally tallySends: [3.14159 printString]"	^ self tallySendsTo: nil inBlock: aBlock showTree: true! !!MessageTally class methodsFor: 'spying' stamp: 'tk 5/4/1998 17:01'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"MessageTally tallySends: [3.14159 printString]"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class							method: aBlock method.	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].			tallies close]))		openLabel: 'Spy Results'! !!MessageTally class methodsFor: 'spying'!time: aBlock	^ Time millisecondsToRun: aBlock! !ClassDescription subclass: #Metaclass	instanceVariableNames: 'thisClass '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!Metaclass commentStamp: 'di 5/22/1998 16:35' prior: 0!Metaclass comment:'My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.'!!Metaclass methodsFor: 'initialize-release'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true.				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'initialize-release'!newNamed: aSymbol 	"Answer an instance of me whose name is the argument, aSymbol."	^(self class subclassOf: self) new		superclass: Object		methodDict: MethodDictionary new		format: Object format		name: aSymbol		organization: (ClassOrganizer defaultList: Array new)		instVarNames: nil		classPool: nil		sharedPools: nil! !!Metaclass methodsFor: 'initialize-release'!subclassOf: superMeta 	"Change the receiver to be a subclass of the argument, superMeta, a 	metaclass. Reset the receiver's method dictionary and properties."	superclass _ superMeta.	methodDict _ MethodDictionary new.	format _ superMeta format.	instanceVariables _ nil! !!Metaclass methodsFor: 'accessing'!isMeta	^ true! !!Metaclass methodsFor: 'accessing'!name	"Answer a String that is the name of the receiver, either 'Metaclass' or 	the name of the receiver's class followed by ' class'."	thisClass == nil		ifTrue: [^'a Metaclass']		ifFalse: [^thisClass name , ' class']! !!Metaclass methodsFor: 'accessing'!soleInstance	"The receiver has only one instance. Answer it."	^thisClass! !!Metaclass methodsFor: 'accessing'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^thisClass! !!Metaclass methodsFor: 'copying'!copy	"Make a copy of the receiver without a list of subclasses. Share the 	reference to the sole instance."	| copy t |	t _ thisClass.	thisClass _ nil.	copy _ super copy.	thisClass _ t.	^copy! !!Metaclass methodsFor: 'copying'!copyForValidation	"Special copy for ClassDescription| validateFrom:in:fields:methods:. Answer 	a copy of the receiver without the subclasses."	^super copy! !!Metaclass methodsFor: 'instance creation'!new	"The receiver can only have one instance. Create it or complain that	one already exists."	thisClass == nil		ifTrue: [^thisClass _ super new]		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !!Metaclass methodsFor: 'instance variables'!addInstVarName: aString 	"Add the argument, aString, as one of the receiver's instance variables."	| fullString |	fullString _ aString.	self instVarNames do: [:aString2 | fullString _ aString2 , ' ' , fullString].	self instanceVariableNames: fullString! !!Metaclass methodsFor: 'instance variables'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newArray newString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newArray _ self instVarNames copyWithout: aString.	newString _ ''.	newArray do: [:aString2 | newString _ aString2 , ' ' , newString].	self instanceVariableNames: newString! !!Metaclass methodsFor: 'pool variables'!classPool	"Answer the dictionary of class variables."	^thisClass classPool! !!Metaclass methodsFor: 'class hierarchy' stamp: 'di 2/1/98 09:55'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ 		changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | (newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	wasPresent | true		ifTrue: [Smalltalk changes changeClass: newClass]		ifFalse: [Smalltalk changes addClass: newClass].	^ newClass! !!Metaclass methodsFor: 'class hierarchy'!subclasses	"Answer the receiver's subclasses."	| temp |	self == Class class 		ifTrue: ["Meta-Object is exceptional subclass of Class"				temp _ thisClass subclasses copy.				temp remove: Object class.				^temp collect: [:aSubClass | aSubClass class]].	thisClass == nil		ifTrue: [^Set new]		ifFalse: [^thisClass subclasses collect: [:aSubClass | aSubClass class]]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses."	self == Class class		ifTrue: ["Don't include Object class class in Class class's subclasses (heh heh)"				thisClass subclassesDo: [:aSubclass | aSubclass == Object class											ifFalse: [aBlock value: aSubclass class]]]		ifFalse: [thisClass == nil				ifFalse: [thisClass subclassesDo: [:aSubclass | aBlock value: aSubclass class]]]! !!Metaclass methodsFor: 'compiling'!acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.  6/18/96 sw"	^ thisClass acceptsLoggingOfCompilation! !!Metaclass methodsFor: 'compiling'!possibleVariablesFor: misspelled continuedFrom: oldResults	^ thisClass possibleVariablesFor: misspelled continuedFrom: oldResults! !!Metaclass methodsFor: 'compiling'!scopeHas: name ifTrue: assocBlock  	^thisClass scopeHas: name ifTrue: assocBlock! !!Metaclass methodsFor: 'compiling'!wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.The metaclass follows the rule of the class itself.  7/12/96 sw"	^ thisClass wantsChangeSetLogging! !!Metaclass methodsFor: 'fileIn/Out'!definition 	"Refer to the comment in ClassDescription|definition."	| aStream names |	aStream _ WriteStream on: (String new: 300).	self printOn: aStream.	names _ self instVarNames."	names isEmpty ifTrue: [^  aStream contents]."	aStream nextPutAll: '	instanceVariableNames: '''.	1 to: names size do: [:i | aStream nextPutAll: (names at: i); space].	aStream nextPut: $'.	^ aStream contents! !!Metaclass methodsFor: 'fileIn/Out'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	super fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	(moveSource not and: [methodDict includesKey: #initialize]) ifTrue: 		[aFileStream cr.		aFileStream cr.		aFileStream nextChunkPut: thisClass name , ' initialize'.		aFileStream cr]! !!Metaclass methodsFor: 'fileIn/Out'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [methodDict size > 0]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 3/24/98 10:16'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	^ DiskProxy global: self theNonMetaClass name selector: #class			args: (Array new)! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 3/26/98 10:19'!storeDataOn: aDataStream	"I don't get stored.  Use a DiskProxy"	self error: 'use a DiskProxy to store a Class'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Metaclass class	instanceVariableNames: ''!!Metaclass class methodsFor: 'instance creation'!subclassOf: superMeta 	"Answer an instance of me that is a subclass of the metaclass, superMeta."	^self new subclassOf: superMeta! !ContextPart variableSubclass: #MethodContext	instanceVariableNames: 'method receiverMap receiver '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodContext commentStamp: 'di 5/22/1998 16:35' prior: 0!MethodContext comment:'My instances hold all the dynamic state associated with the execution of a CompiledMethod. In addition to their inherited state, this includes the receiver, a method, and temporary space in the variable part of the context.	MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.'!!MethodContext methodsFor: 'initialize-release'!restart	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	stackp _ method numArgs + method numTemps! !!MethodContext methodsFor: 'initialize-release'!restartWith: aCompiledMethod 	"Reinitialize the receiver as though it had been for a different method. 	Used by a Debugger when one of the methods to which it refers is 	recompiled."	method _ aCompiledMethod.	^self restart! !!MethodContext methodsFor: 'accessing'!home 	"Refer to the comment in ContextPart|home."	^self! !!MethodContext methodsFor: 'accessing'!method	^method! !!MethodContext methodsFor: 'accessing'!receiver 	"Refer to the comment in ContextPart|receiver."	^receiver! !!MethodContext methodsFor: 'accessing'!removeSelf	"Nil the receiver pointer and answer its former value."	| tempSelf |	tempSelf _ receiver.	receiver _ nil.	^tempSelf! !!MethodContext methodsFor: 'accessing'!tempAt: index 	"Refer to the comment in ContextPart|tempAt:."	^self at: index! !!MethodContext methodsFor: 'accessing'!tempAt: index put: value 	"Refer to the comment in ContextPart|tempAt:put:."	^self at: index put: value! !!MethodContext methodsFor: 'private'!setSender: s receiver: r method: m arguments: args 	"Create the receiver's initial state."	sender _ s.	receiver _ r.	method _ m.	pc _ method initialPC.	stackp _ method numTemps.	1 to: args size do: [:i | self at: i put: (args at: i)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodContext class	instanceVariableNames: ''!!MethodContext class methodsFor: 'instance creation'!sender: s receiver: r method: m arguments: args 	"Answer an instance of me with attributes set to the arguments."	^(self new: m frameSize) setSender: s receiver: r method: m arguments: args! !Dictionary variableSubclass: #MethodDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodDictionary methodsFor: 'accessing'!add: anAssociation	^ self at: anAssociation key put: anAssociation value! !!MethodDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock	| index |	index _ self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	^ array at: index! !!MethodDictionary methodsFor: 'accessing'!at: key put: value	"Set the value at key to be value."	| index |	index _ self findElementOrNil: key.	(self basicAt: index) == nil		ifTrue: 			[tally _ tally + 1.			self basicAt: index put: key].	array at: index put: value.	self fullCheck.	^ value! !!MethodDictionary methodsFor: 'accessing'!includesKey: aSymbol	"This override assumes that pointsTo is a fast primitive"	^ super pointsTo: aSymbol! !!MethodDictionary methodsFor: 'accessing'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value == (array at: index)			ifTrue:				[(theKey _ self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!MethodDictionary methodsFor: 'removing'!removeKey: key ifAbsent: errorBlock 	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then atomically become that copy"	| copy |	copy _ self copy.	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].	self become: copy! !!MethodDictionary methodsFor: 'enumeration'!associationsDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: (Association key: key									value: (array at: i))]]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'to 1/14/98 10:13'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (self basicAt: i) == nil ifFalse:			[aBlock value: (array at: i)]]! !!MethodDictionary methodsFor: 'enumeration'!keysDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil			ifFalse: [aBlock value: key]]! !!MethodDictionary methodsFor: 'private' stamp: 'tk 8/21/97 16:26'!copy	^ self shallowCopy withArray: array shallowCopy! !!MethodDictionary methodsFor: 'private' stamp: 'di 11/4/97 20:11'!grow 	| newSelf key |	newSelf _ self species new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private'!keyAt: index	^ self basicAt: index! !!MethodDictionary methodsFor: 'private'!methodArray	^ array! !!MethodDictionary methodsFor: 'private'!rehash 	| newSelf key |	newSelf _ self species new: self size.	1 to: self basicSize do:		[:i | key _ self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!MethodDictionary methodsFor: 'private'!removeDangerouslyKey: key ifAbsent: aBlock	"This is not really dangerous.  But if normal removal	were done WHILE a MethodDict were being used, the	system might crash.  So instead we make a copy, then do	this operation (which is NOT dangerous in a copy that is	not being used), and then use the copy after the removal."	| index element |	index _ self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	element _ array at: index.	array at: index put: nil.	self basicAt: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^ element! !!MethodDictionary methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject identityHash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!MethodDictionary methodsFor: 'private'!swap: oneIndex with: otherIndex	| element |	element _ self basicAt: oneIndex.	self basicAt: oneIndex put: (self basicAt: otherIndex).	self basicAt: otherIndex put: element.	super swap: oneIndex with: otherIndex.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodDictionary class	instanceVariableNames: ''!!MethodDictionary class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:11'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2.	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"	| size |	size _ 1 bitShift: nElements highBit.	^ (self basicNew: size) init: size! !ParseNode subclass: #MethodNode	instanceVariableNames: 'selectorOrFalse precedence arguments block literals primitive encoder temporaries '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!MethodNode commentStamp: 'di 5/22/1998 16:35' prior: 0!MethodNode comment: 'I am the root of the parse tree.'!!MethodNode methodsFor: 'initialize-release'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	"Initialize the receiver with respect to the arguments given."	encoder _ anEncoder.	selectorOrFalse _ selOrFalse.	precedence _ p.	arguments _ args.	temporaries _ temps.	block _ blk.	primitive _ prim! !!MethodNode methodsFor: 'code generation'!encoder	^ encoder! !!MethodNode methodsFor: 'code generation'!generate: trailer	"The receiver is the root of a parse tree. Answer a CompiledMethod. The 	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs |	self generateIfQuick: 		[:method | 		1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].		method cacheTempNames: self tempNames.		^method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	encoder maxTemp > 31		ifTrue: [^self error: 'Too many temporary variables'].		literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	1 to: trailer size do: [:i | method at: method size - trailer size + i put: (trailer at: i)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation'!generateIfQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v _ block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: CompiledMethod toReturnSelf].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256)]! !!MethodNode methodsFor: 'code generation'!selector 	"Answer the message selector for the method represented by the receiver."	(selectorOrFalse isMemberOf: Symbol)		ifTrue: [^selectorOrFalse].	^selectorOrFalse key! !!MethodNode methodsFor: 'code generation'!sourceMap	"Answer a SortedCollection of associations of the form: pc (byte offset in 	me) -> sourceRange (an Interval) in source text."	self generate: #(0 0 0 0).	^encoder sourceMap! !!MethodNode methodsFor: 'converting'!decompileString 	"Answer a string description of the parse tree whose root is the receiver."	^ String streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'converting'!decompileText 	"Answer a string description of the parse tree whose root is the receiver."	^ Text streamContents: [:strm | self printOn: strm]! !!MethodNode methodsFor: 'printing'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[primitive < 256 ifTrue:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing'!printPrimitiveOn: aStream	aStream nextPutAll: '<primitive: '; print: primitive.	aStream nextPutAll: '>'! !!MethodNode methodsFor: 'printing'!tempNames	^ encoder tempNames! !!MethodNode methodsFor: 'C translation' stamp: 'jm 2/12/98 11:52'!asTMethodFromClass: aClass 	^ TMethod new		setSelector: selectorOrFalse		args: arguments		locals: encoder tempsAndBlockArgs		block: block		primitive: primitive! !Object subclass: #MidiPrimTester	instanceVariableNames: 'port '	classVariableNames: 'CanSetClock CanUseSemaphore ClockTicksPerSec EchoOn EventsAvailable FlushDriver HasBuffer HasDurs HasInputClock Installed UseControllerCache Version '	poolDictionaries: ''	category: 'System-Serial Port'!!MidiPrimTester commentStamp: 'di 5/22/1998 16:35' prior: 0!This class simply demonstrates and tests the MIDI primitives. MIDI applications should use Stephen Pope's MIDIPort class, which will replace this one.The Macintosh, and perhaps some other platforms, can send and receive MIDI data over a serial port by using an external clock signal supplied by an external MIDI adapter to generate the correct MIDI baud rate. Typical clock speeds of such adapters are 1, 2, or 0.5 MHz. This clock speed can be specified when a MIDI port is opened. On other platforms, this clock speed parameter is ignored.!!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 10:30'!getDriverParameters	"Return a string that describes this platform's MIDI parameters."	"MidiPrimTester new getDriverParameters"	| s parameterNames v |	parameterNames _ #(Installed Version HasBuffer HasDurs CanSetClock CanUseSemaphore EchoOn UseControllerCache EventsAvailable FlushDriver ClockTicksPerSec HasInputClock).	s _ WriteStream on: String new.	s cr.	1 to: parameterNames size do: [:i |		v _ self primMIDIParameterGet: i.		s nextPutAll: (parameterNames at: i).		s nextPutAll: ' = '.		s print: v; cr].	s nextPutAll: 'MIDI Echoing is '.	(self canTurnOnParameter: EchoOn)		ifTrue: [s nextPutAll: 'supported.'; cr]		ifFalse: [s nextPutAll: 'not supported.'; cr].	s nextPutAll: 'Controller Caching is '.	(self canTurnOnParameter: UseControllerCache)		ifTrue: [s nextPutAll: 'supported.'; cr]		ifFalse: [s nextPutAll: 'not supported.'; cr].	^ s contents! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:33'!getInputForSeconds: seconds onPort: portNum	"Collect MIDI input from the given port for the given number of seconds, and answer a string describing the data read."	"MidiPrimTester new getInputForSeconds: 5 onPort: 0"	| buf bufList endTime n midiStartTime s t |	"collect the data"	self openPort: portNum andDo: [		buf _ ByteArray new: 1000.		bufList _ OrderedCollection new.		midiStartTime _ self primMIDIGetClock.		endTime _ Time millisecondClockValue + (seconds * 1000).		[Time millisecondClockValue < endTime] whileTrue: [			n _ self primMIDIReadPort: portNum into: buf.			n > 0 ifTrue: [bufList add: (buf copyFrom: 1 to: n)].			(Delay forMilliseconds: 5) wait]].	"format the data into a string"	s _ WriteStream on: String new.	s cr.	bufList do: [:b |		t _ (self bufferTimeStampFrom: b) - midiStartTime.		s print: t.		s nextPutAll: ': '.		5 to: b size do: [:i | s print: (b at: i); space].		s cr].	^ s contents! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 10:05'!getPortList	"Return a string that describes this platform's MIDI ports."	"MidiPrimTester new getPortList"	| s portCount dir directionString |	s _ WriteStream on: String new.	s cr; nextPutAll: 'MIDI Ports:'; cr.	portCount _ self primMIDIGetPortCount.	0 to: portCount - 1 do: [:i |		s tab.		s print: i; nextPutAll: ': '. 		s nextPutAll: (self primMIDIGetPortName: i).		dir _ self primMIDIGetPortDirectionality: i.		directionString _ dir printString.  "default"		dir = 1 ifTrue: [directionString _ '(in)'].		dir = 2 ifTrue: [directionString _ '(out)'].		dir = 3 ifTrue: [directionString _ '(in/out)'].		s space; nextPutAll: directionString; cr].	^ s contents! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 11:24'!playDrumRoll: mSecsBetweenNotes count: tapCount onPort: portNum	"MidiPrimTester new playDrumRoll: 75 count: 64 onPort: 0"	"Play middle-C tapCount times with the given space between notes. This example works best with a short percussive voice, like a drum."	"Details: This test can be used to investigate the real-time performance of your system. On a 110 MHz PowerPC Mac, this method can genererate very fast and smooth drum rolls up to about 100 beats/sec (10 mSecs between notes). However, many factors can prevent one from seeing this level of performance including a slow CPU, lack of a level-2 cache, networking or other background processes stealing chunks of processor time from Squeak, or a sluggish MIDI synthesizer."	"Details: By default, this method does an incremental GC on every note. While not really needed for this example, it illustrates a useful technique for real-time processing in Squeak: do an incremental GC when you know you have a few milliseconds of idle time to avoid triggering one during a time-critical task. In this case, we're also using the GC time to provide a small delay between the note-on and note-off events. If the GC time is too short, as it could be on a fast machine, the note may not sound at all unless you add a few milliseconds of additional delay!!"	"Note: This example works best if the VM's millisecond clock has 1 millisecond resolution."	| gcDuringNote noteOn noteOff endTime waitTime |	gcDuringNote _ true.	"these events use running status, so the command byte is omitted"	noteOn _ #(60 100) as: ByteArray.	noteOff _ #(60 0) as: ByteArray.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: 1000000.	"send an initial event with command byte to initiate running status"	self primMIDIWritePort: portNum from: (#(144 60 0) as: ByteArray) at: 0.	1 to: tapCount do: [:i |		endTime _ Time millisecondClockValue + mSecsBetweenNotes.		self primMIDIWritePort: portNum from: noteOn at: 0.		gcDuringNote			ifTrue: [				"do quick GC; takes a few milliseconds and provides the note-down time"				"Note: if GC is too fast on your machine, you need to add a few mSecs delay!!"				Smalltalk garbageCollectMost]			ifFalse: [(Delay forMilliseconds: 3) wait].		self primMIDIWritePort: portNum from: noteOff at: 0.		waitTime _ endTime - Time millisecondClockValue.		waitTime > 0 ifTrue: [(Delay forMilliseconds: waitTime) wait]].	self primMIDIClosePort: portNum.! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:16'!playNoteOnPort: portNum	"MidiPrimTester new playNoteOnPort: 0"	| noteOn noteOff bytesWritten |	noteOn _ #(144 60 100) as: ByteArray.	noteOff _ #(144 60 0) as: ByteArray.	self openPort: portNum andDo: [		bytesWritten _ self primMIDIWritePort: portNum from: noteOn at: 0.		(Delay forMilliseconds: 500) wait.		bytesWritten _ bytesWritten + (self primMIDIWritePort: portNum from: noteOff at: 0)].	bytesWritten = 6 ifFalse: [self error: 'not all bytes were sent'].! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:17'!playScale: mSecsPerNote onPort: portNum	"MidiPrimTester new playScale: 130 onPort: 0"	| noteOn noteOff |	noteOn _ #(144 0 100) as: ByteArray.	noteOff _ #(144 0 0) as: ByteArray.	self openPort: portNum andDo: [		#(60 62 64 65 67 69 71 72 74 72 71 69 67 65 64 62 60) do: [:midiKey | 			noteOn at: 2 put: midiKey.			noteOff at: 2 put: midiKey.			self primMIDIWritePort: portNum from: noteOn at: 0.			(Delay forMilliseconds: mSecsPerNote - 10) wait.			self primMIDIWritePort: portNum from: noteOff at: 0.			(Delay forMilliseconds: 10) wait]].! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:36'!primMIDIClosePort: portNum	<primitive: 521>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:36'!primMIDIGetClock	<primitive: 522>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIGetPortCount	<primitive: 523>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIGetPortDirectionality: portNum	<primitive: 524>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIGetPortName: portNum	<primitive: 525>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIParameterGet: whichParameter	<primitive: 527>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/17/1998 21:37'!primMIDIParameterSet: whichParameter to: newValue	<primitive: 527>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/18/1998 11:31'!primMIDIReadPort: portNum into: byteArray	<primitive: 528>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'primitives' stamp: 'jm 5/18/1998 11:31'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	<primitive: 529>	self primitiveFailed.! !!MidiPrimTester methodsFor: 'private' stamp: 'jm 5/18/1998 12:48'!bufferTimeStampFrom: aByteArray	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."	^ ((aByteArray at: 1) bitShift: 24) +	  ((aByteArray at: 2) bitShift: 16) +	  ((aByteArray at: 3) bitShift: 8) +	   (aByteArray at: 4)! !!MidiPrimTester methodsFor: 'private' stamp: 'jm 5/18/1998 12:48'!canTurnOnParameter: whichParameter	"Return true if the given MIDI parameter can be turned on. Leave the parameter in its orginal state."	| old canSet |	old _ self primMIDIParameterGet: whichParameter.	self primMIDIParameterSet: whichParameter to: 1.	canSet _ (self primMIDIParameterGet: whichParameter) = 1.	self primMIDIParameterSet: whichParameter to: old.	^ canSet! !!MidiPrimTester methodsFor: 'private' stamp: 'jm 5/18/1998 15:32'!openPort: portNum andDo: aBlock	"Open the given MIDI port, evaluate the block, and close the port again. Answer the value of the block."	| result |	self primMIDIClosePort: portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: 1000000.	result _ aBlock value.	self primMIDIClosePort: portNum.	^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MidiPrimTester class	instanceVariableNames: ''!!MidiPrimTester class methodsFor: 'class initialization' stamp: 'jm 5/18/1998 09:50'!initialize	"Initialize the MIDI parameter constants."	"MidiPrimTester initialize"	Installed _ 1.		"Read-only. Return 1 if a MIDI driver is installed, 0 if not.		 On OMS-based MIDI drivers, this returns 1 only if the OMS		 system is properly installed and configured."	Version _ 2.		"Read-only. Return the integer version number of this MIDI driver.		 The version numbering sequence is relative to a particular driver.		 That is, version 3 of the Macintosh MIDI driver is not necessarily		 related to version 3 of the Win95 MIDI driver."	HasBuffer _ 3.		"Read-only. Return 1 if this MIDI driver has a time-stamped output		 buffer, 0 otherwise. Such a buffer allows the client to schedule		 MIDI output packets to be sent later. This can allow more precise		 timing, since the driver uses timer interrupts to send the data		 at the right time even if the processor is in the midst of a		 long-running Squeak primitive or is running some other application		 or system task."	HasDurs _ 4.		"Read-only. Return 1 if this MIDI driver supports an extended		 primitive for note-playing that includes the note duration and		 schedules both the note-on and the note-off messages in the		 driver. Otherwise, return 0."	CanSetClock _ 5.		"Read-only. Return 1 if this MIDI driver�s clock can be set		 via an extended primitive, 0 if not."	CanUseSemaphore _ 6.		"Read-only. Return 1 if this MIDI driver can signal a semaphore		 when MIDI input arrives. Otherwise, return 0. If this driver		 supports controller caching and it is enabled, then incoming		 controller messages will not signal the semaphore."	EchoOn _ 7.		"Read-write. If this flag is set to a non-zero value, and if		 the driver supports echoing, then incoming MIDI events will		 be echoed immediately. If this driver does not support echoing,		 then queries of this parameter will always return 0 and		 attempts to change its value will do nothing."	UseControllerCache _ 8.		"Read-write. If this flag is set to a non-zero value, and if		 the driver supports a controller cache, then the driver will		 maintain a cache of the latest value seen for each MIDI controller,		 and control update messages will be filtered out of the incoming		 MIDI stream. An extended MIDI primitive allows the client to		 poll the driver for the current value of each controller. If		 this driver does not support a controller cache, then queries		 of this parameter will always return 0 and attempts to change		 its value will do nothing."	EventsAvailable _ 9.		"Read-only. Return the number of MIDI packets in the input queue."	FlushDriver _ 10.		"Write-only. Setting this parameter to any value forces the driver		 to flush its I/0 buffer, discarding all unprocessed data. Reading		 this parameter returns 0. Setting this parameter will do nothing		 if the driver does not support buffer flushing."	ClockTicksPerSec _ 11.		"Read-only. Return the MIDI clock rate in ticks per second."	HasInputClock _ 12.		"Read-only. Return 1 if this MIDI driver timestamps incoming		 MIDI data with the current value of the MIDI clock, 0 otherwise.		 If the driver does not support such timestamping, then the		 client must read input data frequently and provide its own		 timestamping."! !AbstractSound subclass: #MixedSound	instanceVariableNames: 'sounds leftVols rightVols soundDone '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!MixedSound methodsFor: 'initialization' stamp: 'jm 2/4/98 09:57'!initialize	super initialize.	sounds _ Array new.	leftVols _ Array new.	rightVols _ Array new.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	1 to: sounds size do: [:i | (sounds at: i) doControl].! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 13:42'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| snd left right |	1 to: sounds size do: [:i |		(soundDone at: i) ifFalse: [			snd _ sounds at: i.			left _ (leftVol * (leftVols at: i)) // ScaleFactor.			right _ (rightVol * (rightVols at: i)) // ScaleFactor.			snd samplesRemaining > 0				ifTrue: [					snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]				ifFalse: [soundDone at: i put: true]]].! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:07'!reset	super reset.	sounds do: [:snd | snd reset].	soundDone _ (Array new: sounds size) atAllPut: false.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 12/8/97 17:08'!samplesRemaining	| remaining r |	remaining _ 0.	1 to: sounds size do: [:i |		r _ (sounds at: i) samplesRemaining.		r > remaining ifTrue: [remaining _ r]].	^ remaining! !!MixedSound methodsFor: 'composition'!+ aSound	"Return the mix of the receiver and the argument sound."	^ self add: aSound! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound	"Add the given sound with a pan setting of centered and no attenuation."	self add: aSound pan: 0.5 volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 13:47'!add: aSound pan: leftRightPan	"Add the given sound with the given left-right panning and no attenuation."	self add: aSound pan: leftRightPan volume: 1.0.! !!MixedSound methodsFor: 'composition' stamp: 'jm 1/5/98 17:33'!add: aSound pan: leftRightPan volume: volume	"Add the given sound with the given left-right pan, where 0.0 is full left, 1.0 is full right, and 0.5 is centered. The loudness of the sound will be scaled by volume, which ranges from 0 to 1.0."	| pan vol |	pan _ ((leftRightPan * ScaleFactor) asInteger max: 0) min: ScaleFactor.	vol _ ((volume * ScaleFactor) asInteger max: 0) min: ScaleFactor.	sounds _ sounds copyWith: aSound.	leftVols _ leftVols copyWith: ((ScaleFactor - pan) * vol) // ScaleFactor.	rightVols _ rightVols copyWith: (pan * vol) // ScaleFactor.! !!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sounds."	^ super copy copySounds! !!MixedSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:33'!copySounds	"Private!! Support for copying. Copy my component sounds and settings array."	sounds _ sounds collect: [:s | s copy].	leftVols _ leftVols copy.	rightVols _ rightVols copy.! !!MixedSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:37'!sounds	^ sounds! !Controller subclass: #ModalController	instanceVariableNames: 'modeActive '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Framework'!!ModalController commentStamp: 'di 5/22/1998 16:35' prior: 0!I am a controller that puts the poor user into a mode by not relinquishing control. However, I do pass control onto my underlings. Some underling is expected to end the mode by sending me 'close'. Watch out Larry Tesler, the mode lives on...!!ModalController methodsFor: 'all' stamp: 'jm 5/1/1998 07:05'!close	"This is how we leave the mode." 	modeActive _ false.! !!ModalController methodsFor: 'all' stamp: 'jm 5/1/1998 07:02'!controlInitialize	modeActive _ true.	^ super controlInitialize! !!ModalController methodsFor: 'all' stamp: 'jm 5/1/1998 07:00'!isControlActive	^ modeActive! !!ModalController methodsFor: 'all' stamp: 'jm 5/1/1998 07:00'!isControlWanted	^ modeActive! !Object subclass: #Model	instanceVariableNames: 'dependents '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Framework'!!Model commentStamp: 'di 5/22/1998 16:35' prior: 0!Model comment:'Provides a superclass for classes that function as models.  The only behavior provided is fast dependents maintentance, which bypasses the generic DependentsFields mechanism.  1/23/96 sw'!!Model methodsFor: 'dependents'!addDependent: anObject	"Make the given object one of the receiver's dependents."	dependents == nil		ifTrue: [dependents _ Array with: anObject]		ifFalse: [			"done if anObject is already a dependent"			dependents do: [:o | o == anObject ifTrue: [^ self]].			"otherwise, add it"			dependents _ dependents copyWith: anObject].! !!Model methodsFor: 'dependents'!breakDependents	"Remove all of the receiver's dependents."	dependents _ nil.! !!Model methodsFor: 'dependents' stamp: 'tk 4/13/1998 23:03'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	dependents == nil ifTrue: [^ true].	^ super canDiscardEdits! !!Model methodsFor: 'dependents'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	dependents == nil ifTrue: [^ #()].	^ dependents! !!Model methodsFor: 'dependents' stamp: 'jm 3/24/98 15:12'!hasUnacceptedEdits	"Answer true if any of the views on this model has unaccepted edits."	dependents == nil ifTrue: [^ false].	^ super hasUnacceptedEdits! !!Model methodsFor: 'dependents' stamp: 'jm 3/24/98 15:00'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| newDependents |	dependents == nil ifTrue: [^ self].	newDependents _ dependents select: [:d | (d == anObject) not].	newDependents isEmpty		ifTrue: [dependents _ nil]		ifFalse: [dependents _ newDependents].! !!Model methodsFor: 'dependents' stamp: 'jm 5/22/1998 13:25'!topView	"Find the first top view on me. Is there any danger of their being two with the same model?  Any danger from ungarbage collected old views?  Ask if schedulled?"	dependents ifNil: [^ nil].	World ifNotNil: [		dependents do:			[:v | ((v isKindOf: SystemWindow) and: [v isInWorld]) ifTrue: [^ v]].		^ nil].	dependents do: [:v | v superView ifNil: [v model == self ifTrue: [^ v]]].	^ nil! !!Model methodsFor: 'text links' stamp: 'di 1/15/98 23:32'!linkMethod: classAndMethod	"Make a linked message list and put this method in it"	| list |	list _ OrderedCollection new.	list add: classAndMethod.	LinkedMessageSet openMessageList: list name: 'Linked by HyperText'.! !!Model methodsFor: 'menus' stamp: 'tk 3/31/98 16:17'!doMenuItem: selector paneID: textSelector from: aController	"Selector was just chosen from a menu by a user.  If I want to respond, perform it on myself. If not, make aController perform it.   textSelector is what I told the pluggable pane to ask me to get the contents of this pane, here so I can identify which pane is was." 	"default is that the controller does all!!"	aController perform: selector! !!Model methodsFor: 'menus' stamp: 'di 4/11/98 11:34'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	"default is that the editor does all"	^ otherTarget perform: selector.! !!Model methodsFor: 'menus' stamp: 'tk 4/17/1998 17:28'!selectedClass	"All owners of TextViews are asked this during a doIt"	^ nil! !!Model methodsFor: 'menus' stamp: 'di 4/17/1998 08:29'!step	"Default for moephic models is no-op"! !!Model methodsFor: 'keyboard' stamp: 'di 5/22/1998 00:26'!arrowKey: aChar from: view	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index.  Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |     (keyEvent := aChar asciiValue) > 31 ifTrue: [^ self].	"Quick return, out of range"     oldSelection := view getCurrentSelectionIndex.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view numSelectionsInView.	"get this exactly??"     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[self okToChange			ifTrue:				[view changeModelSelection: nextSelection.				"view controller moveMarker"]]			! !Object subclass: #Morph	instanceVariableNames: 'bounds owner submorphs fullBounds color eventHandler properties costumee '	classVariableNames: 'EmptyArray '	poolDictionaries: ''	category: 'Morphic-Kernel'!!Morph commentStamp: 'di 5/22/1998 16:35' prior: 0!Morph comment:'A morph (from the Greek "shape" or "form") is an interactive graphical object.'!!Morph methodsFor: 'initialization' stamp: 'sw 10/2/97 23:08'!initialExtent	| ext |	(ext _ self valueOfProperty: #initialExtent)		ifNotNil:			[^ ext].	^ super initialExtent! !!Morph methodsFor: 'initialization'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.	! !!Morph methodsFor: 'initialization' stamp: 'di 5/15/1998 09:58'!openInMVC	Smalltalk isMorphic ifTrue: [^ self openInWorld].	MorphWorldView openWorldWith: self labelled: self defaultLabelForInspector! !!Morph methodsFor: 'initialization' stamp: 'di 5/15/1998 09:53'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	World addMorph: self! !!Morph methodsFor: 'initialization' stamp: 'sw 4/21/1998 22:58'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	^ (pal _ (aPresenter _ self presenter) ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner _ aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'classification' stamp: 'di 5/7/1998 01:21'!isAlignmentMorph	^ false! !!Morph methodsFor: 'classification' stamp: 'jm 4/17/1998 00:44'!isFlexMorph	^ false! !!Morph methodsFor: 'classification'!isHandMorph	^ false! !!Morph methodsFor: 'classification' stamp: 'di 5/7/1998 01:25'!isLayoutMorph	self error: 'OBSOLETE PROTOCOL -- use isAlignmentMorph'.	^ self isAlignmentMorph! !!Morph methodsFor: 'classification'!isMorph	^ true! !!Morph methodsFor: 'classification' stamp: 'jm 5/7/1998 13:45'!isRenderer	"A *renderer* morph transforms the appearance of its submorph in some manner. For example, it might supply a drop shadow or scale and rotate the morph it encases. Answer true if this morph acts as a renderer. This default implementation returns false."	"Details: A renderer is assumed to have a single submorph. Renderers may be nested to concatenate their transformations. It is useful to be able to find the outer-most renderer. This can be done by ascending the owner chain from the rendered morph. To find the morph being rendered, one can descend through the (singleton) submorph lists of the renderer chain until a non-renderer is encountered."	^ false! !!Morph methodsFor: 'classification'!isWorldMorph	^ false! !!Morph methodsFor: 'classification'!isWorldOrHandMorph	^ self isWorldMorph or: [self isHandMorph]! !!Morph methodsFor: 'accessing' stamp: 'jm 4/29/1998 19:40'!balloonHelpTextForHandle: aHandle	| colorName |	colorName _ aHandle color name.	#(	(blue					'Rotate')		(yellow					'Change size') 		(green					'Make another')		(black					'Pick up')		(red						'Menu')		(lightBlue				'Help')		(lightBrown				'Make a Tile')		(lightGray				'Repaint')		(cyan					'View me')		(transparent			'Remove')		(lightGray				'Repaint')		(lightOrange			'Change scale') 		(veryVeryLightGray		'Paint new object'))	do:		[:pair | colorName == pair first ifTrue: [^ pair last]].	^ 'If you click on the ' , aHandle color name , ' handle,it will ' , (#('probably not do anything.'		'let you change the font'		'let you change the style'		'let you change the emphasis')	at: (#(none  lightGreen lightRed lightBrown ) indexOf: colorName ifAbsent: [1]))! !!Morph methodsFor: 'accessing'!color	^ color! !!Morph methodsFor: 'accessing' stamp: 'jm 8/24/97 21:26'!color: aColor	color = aColor ifFalse: [		color _ aColor.		self changed].! !!Morph methodsFor: 'accessing' stamp: 'sw 2/16/98 03:44'!colorForInsets	"Return the color to be used for shading inset borders.  The default is my own color, but it might want to be, eg, my owner's color.  Whoever's color ends up prevailing, the color itself gets the last chance to determine, so that when, for example, an InfiniteForm serves as the color, callers won't choke on some non-Color object being returned"	^ color colorForInsets! !!Morph methodsFor: 'accessing'!eventHandler	^ eventHandler! !!Morph methodsFor: 'accessing' stamp: 'tk 5/22/97'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "	eventHandler _ anEventHandler.! !!Morph methodsFor: 'accessing' stamp: 'jm 4/25/1998 05:19'!rotationDegrees	"Default implementation."	^ 0.0! !!Morph methodsFor: 'copying'!copy	^ self copyWithoutSubmorphs! !!Morph methodsFor: 'copying' stamp: 'tk 8/21/97 15:05'!fullCopy	"Produce a copy of me with my entire tree of submorphs.  Morphsmentioned more than once are all directed to a single new copy.  Simpleinst vars are not copied, so you must override to copy Arrays, etc.  "	| dict new |	dict _ IdentityDictionary new: 1000.	new _ self copyRecordingIn: dict.	new allMorphsDo: [:m | m updateReferencesUsing: dict].	^ new! !!Morph methodsFor: 'copying' stamp: 'tk 8/21/97 15:50'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: oldifAbsent: [old])]].	eventHandler ifNotNil:		[eventHandler _ eventHandler copy.		1 to: eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put:(aDictionary at: old ifAbsent: [old])]]].	properties ifNotNil: [		properties associationsDo: [:ass |			ass value: (aDictionary at: ass value ifAbsent:[ass value])]].	"note side effecting"! !!Morph methodsFor: 'copying' stamp: 'sw 4/30/1998 21:55'!veryDeepCopyWithoutCostumee	"Note: Ted's veryDeepCopy should be in Morph, not in Object"	| hold copy holdState |	hold _ costumee.	holdState _ self valueOfProperty: #actorState.	holdState ifNotNil: [self removeProperty: #actorState].	costumee _ nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy setProperty: #actorState toValue: (holdState copyWithPlayerReferenceNilled)].	costumee _ hold.	holdState ifNotNil: [self setProperty: #actorState toValue: holdState].	^ copy! !!Morph methodsFor: 'structure' stamp: 'jm 7/8/97 10:08'!isInWorld	"Return true if this morph is in a world."	^ self world ~~ nil! !!Morph methodsFor: 'structure' stamp: 'sw 4/27/1998 23:49'!nearestOwnerThat: aBlock	"Return the first enclosing morph for which aBlock evaluates to true, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[(aBlock value: current) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure' stamp: 'sw 9/26/97 10:30'!outermostMorphThat: aBlock	"Return the outermost containing morph for which aBlock is true, or nil if none"	| current outermost |	current _ owner.	[current == nil] whileFalse:			[(aBlock value: current) ifTrue: [outermost _ current].			current _ current owner].	^ outermost! !!Morph methodsFor: 'structure'!owner	"Returns the owner of this morph, which may be nil."	^ owner! !!Morph methodsFor: 'structure' stamp: 'tk 10/12/97 17:30'!ownerThatIsA: aClass	"Return the first enclosing morph that is a kind of aClass, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[(current isKindOf: aClass) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure' stamp: 'jm 5/7/1998 15:49'!renderedMorph	"If the receiver is a renderer morph, answer the rendered morph. Otherwise, answer the receiver. A renderer morph with no submorphs answers itself. See the comment in Morph>isRenderer."	self isRenderer ifFalse: [^ self].	submorphs size = 0 ifTrue: [^ self].	^ self firstSubmorph renderedMorph.! !!Morph methodsFor: 'structure'!root	"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph."	(owner = nil or: [owner isWorldOrHandMorph]) ifTrue: [^ self].	^ owner root! !!Morph methodsFor: 'structure' stamp: 'jm 5/7/1998 13:48'!topRendererOrSelf	"Answer the topmost renderer for this morph, or this morph itself if it has no renderer. See the comment in Morph>isRenderer."	| top topsOwner |	owner ifNil: [^ self].	top _ self.	topsOwner _ top owner.	[(topsOwner ~~ nil) and: [topsOwner isRenderer]] whileTrue: [		top _ topsOwner.		topsOwner _ top owner].	^ top! !!Morph methodsFor: 'structure' stamp: 'jm 7/5/97 17:05'!world	"Return the WorldMorph that contains this morph, or nil if this morph is not in a world."	| o |	o _ self root owner.	o ifNil: [^ nil].	o isWorldMorph ifTrue: [^ o].	o isHandMorph ifTrue: [^ o owner].! !!Morph methodsFor: 'submorphs-accessing'!allMorphs	"Return a collection containing all morphs in this composite morph (including the receiver)."	| all |	all _ OrderedCollection new: 100.	self allMorphsDo: [: m | all add: m].	^ all! !!Morph methodsFor: 'submorphs-accessing'!allMorphsDo: aBlock	"Evaluate the given block for all morphs in this composite morph (including the receiver)."	submorphs size > 0 ifTrue: [		submorphs do: [:m | m allMorphsDo: aBlock].	].	aBlock value: self.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 10/31/97 20:05'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy (put in primarily for bookmorphs)"	^ OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 5/29/97'!couldBeOwnedBy: aMorph	"Return true if self has no WorldMorph in its owner chain (it is not installed anywhere) or has aMorph in owner chain.  Returns false if self is definately owned by someone else, not aMorph.  Used for writing a subtree on the disk.  Need to include morphs with nil owner who are held in inst vars.  "	| nextOwner prev |	"is aMorph in my owner chain?"	nextOwner _ self.	prev _ nil.	[nextOwner == aMorph ifTrue: [^ true].		nextOwner == nil] whileFalse: [prev _ nextOwner.								nextOwner _ nextOwner owner].	^ prev isWorldMorph not	"If chain ends with no WorldMorph, not installed and might be held by aMorph"	"If installed in a world, and aMorph is in NOT on my owner chain, ^ false"	! !!Morph methodsFor: 'submorphs-accessing'!findA: aClass	"Return the first submorph of the receiver that is descended from the given class. Return nil if there is no such submorph. Clients of this code should always check for a nil return value so that the code will be robust if the user takes the morph apart."	submorphs do: [:each | (each isKindOf: aClass) ifTrue: [^ each]].	^ nil! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/7/97 10:38'!findInWorldA: aClass	"Return the first submorph of the receiver's world that is descended from the given class. Return nil if there is no such submorph. Clients of this code should always check for a nil return value so that the code will be robust if the user takes the morph apart."	^ self world findA: aClass! !!Morph methodsFor: 'submorphs-accessing'!firstSubmorph	^ submorphs at: 1! !!Morph methodsFor: 'submorphs-accessing'!hasSubmorphs	^ submorphs size > 0! !!Morph methodsFor: 'submorphs-accessing'!lastSubmorph	^ submorphs at: submorphs size! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 2/21/98 21:20'!morphsAt: aPoint	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  The order is deepest embedding first."	^ self morphsAt: aPoint addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:48'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  Must do this recursively because of transforms.  "	submorphs size > 0 ifTrue:		[submorphs do: [:m | m morphsAt: aPoint addTo: mList]].	(self containsPoint: aPoint) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing'!submorphCount	^ submorphs size! !!Morph methodsFor: 'submorphs-accessing'!submorphs	^ submorphs copy! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:30'!submorphsBehind: aMorph do: aBlock	| behind |	behind _ false.	submorphs do:		[:m | m == aMorph ifTrue: [behind _ true]						ifFalse: [behind ifTrue: [aBlock value: m]]].! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 5/13/1998 20:42'!submorphsDo: aBlock	submorphs size = 0 ifTrue: [^ self].	submorphs do: aBlock.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:29'!submorphsInFrontOf: aMorph do: aBlock	| behind |	behind _ false.	submorphs do:		[:m | m == aMorph ifTrue: [behind _ true]						ifFalse: [behind ifFalse: [aBlock value: m]]].! !!Morph methodsFor: 'submorphs-accessing'!submorphsReverseDo: aBlock	submorphs reverseDo: aBlock.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'jm 7/29/97 15:09'!uncoveredAt: aPoint	"Return true if the receiver is not covered by any submorphs at the given point."	| morphsAbove |	morphsAbove _ self world morphsAt: aPoint.	^ morphsAbove first = self or:	 [(morphsAbove first isKindOf: HaloMorph) and:	 [(morphsAbove at: 2) = self]]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:45'!unlockedMorphsAt: aPoint	"Return a collection of all unlocked morphs in this morph structure that contain the given point, possibly including the receiver itself.  Simplified "	^ self unlockedMorphsAt: aPoint addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 2/10/98 15:47'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  Must do this recursively because of transforms.  "	(self fullBounds containsPoint: aPoint) ifFalse: [^ mList].  "quick elimination"	self isLocked ifTrue: [^ mList].	submorphs size > 0 ifTrue:		[submorphs do: [:m | m unlockedMorphsAt: aPoint addTo: mList]].	(self containsPoint: aPoint) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-add/remove'!addAllMorphs: aCollection	aCollection do: [:m |		m owner ifNotNil: [m owner privateRemoveMorph: m].		m layoutChanged.		m privateOwner: self].	submorphs _ submorphs, aCollection.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove'!addMorph: aMorph	self addMorphFront: aMorph.! !!Morph methodsFor: 'submorphs-add/remove'!addMorphBack: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ submorphs copyWith: aMorph.	aMorph changed.  "need to paint morphs now front, if any"	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove'!addMorphCentered: aMorph	self addMorphFront: aMorph.	aMorph position: bounds center - (aMorph extent // 2)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 7/30/97 15:49'!addMorphFront: aMorph	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ (Array with: aMorph), submorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 2/25/98 20:22'!addMorphFront: aMorph fromWorldPosition: wp	self addMorphFront: aMorph.	aMorph position: (self transformFromWorld transform: wp)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 4/16/1998 21:48'!addMorphNearBack: aMorph	| bg |	submorphs last mustBeBackmost ifTrue:		[bg _ submorphs last.		bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 10/27/97 23:26'!copyWithoutSubmorph: sub	"Needed to get a morph to draw without one of its submorphs.	NOTE:  This must be thrown away immediately after use."	^ self clone privateSubmorphs: (submorphs copyWithout: sub)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 2/12/98 12:39'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[costumee ifNotNil: [aWorld _ self world].		owner privateRemoveMorph: self.		owner _ nil.		costumee ifNotNil: [costumee noteDeletionOf: self fromWorld: aWorld]].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 4/9/98 22:44'!goBehind	owner addMorphNearBack: self.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 2/15/98 23:34'!privateDelete	"Remove the receiver as a submorph of its owner and make its new owner be nil, without informing anyone other than my owner"	owner ifNotNil:		[owner privateRemoveMorph: self.		owner _ nil].! !!Morph methodsFor: 'submorphs-add/remove'!removeAllMorphs	self changed.	submorphs do: [:m | m privateOwner: nil].	submorphs _ EmptyArray.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 5/13/1998 22:47'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	self autoLineLayout		ifTrue:			[self fixLayout]! !!Morph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color.! !!Morph methodsFor: 'drawing' stamp: 'di 11/14/97 10:52'!drawOnFills: aRectangle	"May be overridden by any subclasses whose drawOn: method	may completely fill the rectangle"	^ false! !!Morph methodsFor: 'drawing'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse: [		submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'drawing' stamp: 'jm 4/10/98 21:53'!fullDrawOn: aCanvas butDoNotDraw: morphNotToDraw	self == morphNotToDraw ifTrue: [^ self].	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].	submorphs isEmpty ifFalse:		[submorphs reverseDo: [:m |			m fullDrawOn: aCanvas butDoNotDraw: morphNotToDraw]].! !!Morph methodsFor: 'drawing' stamp: 'jm 6/11/97 17:21'!imageForm	^ self imageFormForRectangle: self fullBounds! !!Morph methodsFor: 'drawing'!imageFormForRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent.	self fullDrawOn: (canvas copyOffset: rect topLeft negated).	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'di 5/13/1998 20:46'!topDownDrawOn: aCanvas	"Draw me and then my submorphs from back to front.	Return true if I completely fill the canvas clipping region."	| clipRect |	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	clipRect _ aCanvas clipRect.	self submorphsDo:  "Front to back..."		[:m | "Look for a submorph that fills the region"		(m drawOnFills: clipRect) ifTrue:				["If any submorph fills the region, then display it				and those in front, and return."				(submorphs findFirst: [:x | x==m]) to: 1 by: -1 do:					[:i | (submorphs at: i) topDownDrawOn: aCanvas].				^ self]].	"Otherwise do a normal display"	self fullDrawOn: aCanvas! !!Morph methodsFor: 'geometry' stamp: 'di 7/24/97 11:55'!align: aPoint1 with: aPoint2	"Translate by aPoint2 - aPoint1."	^ self position: self position + (aPoint2 - aPoint1)! !!Morph methodsFor: 'geometry'!bottom	^ bounds bottom! !!Morph methodsFor: 'geometry' stamp: 'sw 5/5/1998 01:24'!bottom: aNumber	self position: (bounds left @ (aNumber - self height))! !!Morph methodsFor: 'geometry' stamp: 'tk 9/8/97 10:44'!bottomLeft	^ bounds bottomLeft! !!Morph methodsFor: 'geometry' stamp: 'di 6/12/97 11:17'!bottomRight	^ bounds bottomRight! !!Morph methodsFor: 'geometry' stamp: 'jm 8/3/97 15:50'!bounds	"Return the bounds of this morph."	"Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."	^ bounds! !!Morph methodsFor: 'geometry'!bounds: newBounds	self position: newBounds topLeft; extent: newBounds extent! !!Morph methodsFor: 'geometry' stamp: 'jm 5/22/1998 12:46'!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) invertRect: bounds.! !!Morph methodsFor: 'geometry'!center	^ bounds center! !!Morph methodsFor: 'geometry'!extent	^ bounds extent! !!Morph methodsFor: 'geometry' stamp: 'jm 8/24/97 21:27'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds _ bounds topLeft extent: aPoint.		self layoutChanged.		self changed].! !!Morph methodsFor: 'geometry' stamp: 'jm 10/16/97 09:36'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		self submorphsDo: [:m | fullBounds _ fullBounds quickMerge: m fullBounds]].	^ fullBounds! !!Morph methodsFor: 'geometry' stamp: 'jm 4/29/1998 19:32'!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) invertRect: self fullBounds.! !!Morph methodsFor: 'geometry'!height	^ bounds height! !!Morph methodsFor: 'geometry' stamp: 'jm 1/29/98 14:26'!height: aNumber	self extent: self width@aNumber asInteger.! !!Morph methodsFor: 'geometry'!innerBounds	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."	^ bounds! !!Morph methodsFor: 'geometry'!left	^ bounds left! !!Morph methodsFor: 'geometry' stamp: 'sw 5/5/1998 01:22'!left: aNumber	self position: (aNumber @ bounds top)! !!Morph methodsFor: 'geometry' stamp: 'sw 8/11/97 14:35'!nextOwnerPage	"Tell my container to advance to the next page"	| targ |	targ _ owner.	[targ respondsTo: #nextPage] whileFalse: [targ _ targ owner].	targ nextPage! !!Morph methodsFor: 'geometry' stamp: 'jm 5/22/1998 12:49'!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) invert: aPoint.! !!Morph methodsFor: 'geometry'!position	^ bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'di 4/8/98 20:35'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self changed.	self privateFullMoveBy: delta.	self changed.! !!Morph methodsFor: 'geometry' stamp: 'sw 8/11/97 23:03'!previousOwnerPage	"Tell my container to advance to the previous page"	| targ |	targ _ owner.	[targ respondsTo: #previousPage] whileFalse: [targ _ targ owner].	targ previousPage! !!Morph methodsFor: 'geometry'!right	^ bounds right! !!Morph methodsFor: 'geometry' stamp: 'sw 5/5/1998 01:23'!right: aNumber	self position: ((aNumber - bounds width) @ bounds top)! !!Morph methodsFor: 'geometry' stamp: 'sw 8/20/97 23:36'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta! !!Morph methodsFor: 'geometry'!top	^ bounds top! !!Morph methodsFor: 'geometry' stamp: 'sw 5/5/1998 01:23'!top: aNumber	self position: (bounds left @ aNumber)! !!Morph methodsFor: 'geometry' stamp: 'di 6/12/97 11:07'!topLeft	^ bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'sw 8/20/97 23:04'!topRight	^ bounds topRight! !!Morph methodsFor: 'geometry'!width	^ bounds width! !!Morph methodsFor: 'geometry' stamp: 'jm 1/29/98 14:26'!width: aNumber	self extent: aNumber asInteger@self height.! !!Morph methodsFor: 'geometry' stamp: 'di 2/23/98 11:36'!worldBounds	^ self world bounds! !!Morph methodsFor: 'geometry testing'!containsPoint: aPoint	^ self bounds containsPoint: aPoint! !!Morph methodsFor: 'geometry testing' stamp: 'jm 2/24/98 08:41'!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"	submorphs do: [:m |		m allMorphsDo: [:n |			(n containsPoint: aPoint) ifTrue: [^ true]]].	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	self addMorph: aMorph.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 2/25/98 15:35'!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them. This default implementation returns false."	^ (self valueOfProperty: #openToDragAndDrop) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:16'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self removeProperty: #partsDonor! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 2/25/98 15:35'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped into the world by a hand in response to the given event. This default implementation returns false."	^ (self valueOfProperty: #openToDragAndDrop) == true! !!Morph methodsFor: 'event handling'!click: evt	"Handle a single-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!doubleClick: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!drag: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!handlesMouseDown: evt	"Return true if this morph handles mouse events (mouseDown, mouseMove, mouseUp) itself or if its event handler does. Subclasses that implement mouse events typically override this message."	eventHandler ifNotNil: [^ eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 5/22/97'!handlesMouseOver: evt	"Do I respond to mouseDown, mouseStillDown, or mouseUp?  "	eventHandler ifNotNil: [^ eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing."! !!Morph methodsFor: 'event handling'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	eventHandler ifNotNil:		[eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 7/2/97 08:02'!mouseUpBalk: evt	"May be sent to me when a user moves out of a button I own and then lets up the mouse.  For radion buttons, I need to select some button.  tk 7/2/97 08:02"	"do nothing as default"! !!Morph methodsFor: 'event handling'!on: eventName send: selector to: recipient	eventHandler ifNil: [eventHandler _ EventHandler new].	eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: '6/9/97 06:22 di'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	eventHandler ifNil: [eventHandler _ EventHandler new].	eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling'!passToEventHandler: evt	"Pass the given event to my event handler, if any."	eventHandler ifNotNil:		[eventHandler handleEvent: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'sw 8/11/97 18:36'!preemptsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed over a submorph that also wishes to handle mouse down events. Responding true to this message allows a morph to reverse the normal policy that control is given to the inner-most submorph that wants it. This can be used, for example, to allow buttons in a parts bin to be copied when clicked, instead of being activated."	^ self isPartsDonor! !!Morph methodsFor: 'event handling'!transformFrom: uberMorph	"Return a transform to be used to map coordinates in a morph above me into my local coordinates, or vice-versa. This is used to support scrolling, scaling, and/or rotation. This default implementation just returns my owner's transform or the identity transform if my owner is nil."	owner == uberMorph ifTrue: [^ MorphicTransform identity].	owner ifNil: [^ MorphicTransform identity].	^ owner transformFrom: uberMorph! !!Morph methodsFor: 'event handling'!transformFromWorld	"Return a transform to map world coordinates into my local coordinates"	^ self transformFrom: nil! !!Morph methodsFor: 'event handling' stamp: 'sw 10/3/97 09:12'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	^ false! !!Morph methodsFor: 'stepping' stamp: 'sw 2/23/98 16:47'!arrangeToStartStepping	"Arrange to start getting sent the 'step' message, but don't do that initial #step call that startStepping does"	| w |	w _ self world.	w ifNotNil:		[w startStepping: self.		self changed]! !!Morph methodsFor: 'stepping'!startStepping	"Start getting sent the 'step' message."	| w |	self step.  "one to get started!!"	w _ self world.	w ifNotNil: [		w startStepping: self.		self changed].! !!Morph methodsFor: 'stepping' stamp: 'sw 1/28/98 14:27'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. This default implementation does nothing."	costumee ifNotNil: [costumee step]! !!Morph methodsFor: 'stepping' stamp: 'sw 2/4/98 02:16'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ costumee ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping'!stopStepping	"Stop getting sent the 'step' message."	| w |	w _ self world.	w ifNotNil: [		w stopStepping: self.		self changed].! !!Morph methodsFor: 'stepping' stamp: 'sw 5/13/1998 16:26'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	costumee ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menu' stamp: 'sw 5/21/1998 15:50'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [GIFImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	"costumee ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance]."	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	(aHandMorph argument pasteUpMorph morphsAt: aHandMorph menuTargetOffset) size > 2 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menu' stamp: 'sw 4/27/1998 03:44'!addCustomHaloMenuItems: aMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand from the halo.  To get started, we defer to the counterpart method used with the option-menu, but in time we can have separate menu choices for halo-menus and for option-menus"	self addCustomMenuItems: aMenu hand: aHandMorph! !!Morph methodsFor: 'menu' stamp: 'jm 4/27/1998 03:05'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].! !!Morph methodsFor: 'menu' stamp: 'di 2/20/98 15:30'!addDropShadow	| ds hadHalo |	(hadHalo _ self hasHalo) ifTrue: [self halo delete].	self owner addMorph: (ds _ DropShadowMorph new).	ds addMorph: self.	hadHalo ifTrue: [ds addHalo]! !!Morph methodsFor: 'menu' stamp: 'sw 5/12/1998 23:47'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self valueOfProperty: #actorState) ifNotNil:		[flexMorph setProperty: #actorState toValue: anActorState.		self removeProperty: #actorState].	(aName _ self valueOfProperty: #name) ifNotNil:		[flexMorph setProperty: #name toValue: aName.		self removeProperty: #name].	costumee ifNotNil:		[flexMorph costumee: costumee.		costumee rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'layout'!minHeight	"Return the minimum width for this morph. Ordinary morphs just answer their current height."	^ self fullBounds height! !!Morph methodsFor: 'layout'!minWidth	"Return the minimum width for this morph. Ordinary morphs just answer their current width."	^ self fullBounds width! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!changed	"Report that the area occupied by this morph should be redrawn."	self invalidRect: self fullBounds.! !!Morph methodsFor: 'change reporting'!invalidRect: damageRect	owner ifNotNil: [owner invalidRect: damageRect].! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'di 10/27/97 22:52'!ownerChanged	"Default no-op may be overridden as for text embedded in changing shape"	^ self! !!Morph methodsFor: 'printing'!colorString: aColor	aColor == nil ifTrue: [^ 'nil'].	Color colorNames do: [:colorName | aColor = (Color perform: colorName)								ifTrue: [^ 'Color ' , colorName]].	^ aColor storeString! !!Morph methodsFor: 'printing'!constructorString	^ String streamContents: [:s | self printConstructorOn: s indent: 0].! !!Morph methodsFor: 'printing' stamp: 'sw 1/12/98 16:48'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self externalName! !!Morph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: self class name , ' newBounds: (';		print: bounds;		nextPutAll: ') color: ' , (self colorString: color)! !!Morph methodsFor: 'printing'!initString	^ String streamContents: [:s | self fullPrintOn: s]! !!Morph methodsFor: 'printing'!printConstructorOn: aStream indent: level	^ self printConstructorOn: aStream indent: level nodeDict: IdentityDictionary new! !!Morph methodsFor: 'printing'!printConstructorOn: aStream indent: level nodeDict: nodeDict	| nodeString |	(nodeString _ nodeDict at: self ifAbsent: [nil])		ifNotNil: [^ aStream nextPutAll: nodeString].	submorphs isEmpty ifFalse: [aStream nextPutAll: '('].	aStream nextPutAll: '('.	self fullPrintOn: aStream.	aStream nextPutAll: ')'.	submorphs isEmpty ifTrue: [^ self].	submorphs size <= 4	ifTrue:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: (Array'.		1 to: submorphs size do:			[:i | aStream crtab: level+1; nextPutAll: 'with: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict].		aStream nextPutAll: '))']	ifFalse:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: ((Array new: ', submorphs size printString, ')'.		1 to: submorphs size do:			[:i |			aStream crtab: level+1; nextPutAll: 'at: ', i printString, ' put: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict.			aStream nextPutAll: ';'].		aStream crtab: level+1; nextPutAll: 'yourself))']! !!Morph methodsFor: 'printing' stamp: 'sw 8/4/97 12:05'!printOn: aStream	| string aName |	super printOn: aStream.	(aName _ self knownName) ~~ nil ifTrue:		[aStream nextPutAll: '<', aName, '>'].	string _ self findA: StringMorph.	aStream nextPutAll: '('.	string ifNotNil: [			aStream print: string contents; space]. 	aStream print: self identityHash;			nextPutAll: ')'.! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 5/16/1998 10:44'!beep	Smalltalk at: #SampledSound ifPresent: [:sampledSound |		(sampledSound new			setSamples: sampledSound coffeeCupClink			samplingRate: 12000) play.		^ self].	Smalltalk beep.! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 5/16/1998 10:36'!beep: soundName	self playSoundNamed: soundName.! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 4/10/98 23:07'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map canvas myBnds w |	"make a mask with black where sensitiveColor is, white elsewhere"	myImage _ self imageForm.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ (Color cachedColormapFrom: myImage depth to: 1) copy.	map primFill: 0.	map at: (sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form		at: 0@0		colorMap: map.	"get an image of the world without me"	myBnds _ self fullBounds.	canvas _ (FormCanvas extent: myBnds extent) copyOffset: myBnds topLeft negated.	canvas _ canvas copyClipRect: myBnds.	w _ self world.	w fullDrawOn: canvas butDoNotDraw: self.	w hands reverseDo: [:h | h fullDrawOn: canvas butDoNotDraw: self].	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: (sensitiveColor indexInMap: map) put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: canvas form boundingBox		from: canvas form		at: 0@0		clippingBox: canvas form boundingBox		rule: Form and		fillColor: nil		map: map.	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 5/22/1998 12:50'!colorUnder	"Return the color of under the receiver's center."	self isInWorld		ifTrue: [^ self world colorAt: (self pointInWorld: self center) belowMorph: self]		ifFalse: [^ self color].! !!Morph methodsFor: 'e-toy commands'!hide	"Move this morph way, way offstage!!"	self position < (5000@5000) ifTrue: [		self position: self position + (1000000@100000)].! !!Morph methodsFor: 'e-toy commands'!jumpTo: aPoint	"Let my owner decide how I move."	owner move: self toPosition: aPoint.! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 5/16/1998 10:38'!makeFenceSound	self world soundsEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!Morph methodsFor: 'e-toy commands' stamp: 'jm 5/2/1998 07:16'!referencePosition: aPosition	self position: aPosition - (bounds extent // 2).! !!Morph methodsFor: 'e-toy commands'!set: aPointOrNumber	"Set my position."	self jumpTo: aPointOrNumber.! !!Morph methodsFor: 'e-toy commands'!show	"Make sure this morph is on-stage."	(self fullBounds intersects: self world bounds) ifFalse: [		self position: self position - (1000000@100000).		self wrap].  "be sure I'm on-stage"! !!Morph methodsFor: 'e-toy commands'!start	"Start running my script. For ordinary morphs, this means start stepping."	self startStepping.! !!Morph methodsFor: 'e-toy commands'!stop	"Stop running my script. For ordinary morphs, this means stop stepping."	self stopStepping.! !!Morph methodsFor: 'e-toy commands' stamp: 'sw 2/12/98 01:16'!wearCostume: anotherMorph	"Modify the receiver so that it resembles anotherMorph"	self color: anotherMorph color! !!Morph methodsFor: 'e-toy commands' stamp: 'sw 1/13/98 20:39'!wrap	| myBox box newX newY wrapped |	owner ifNil: [^ self].	myBox _ self fullBounds.	box _ owner bounds.	newX _ self position x.	newY _ self position y.	wrapped _ false.	((myBox right < box left) or: [myBox left > box right]) ifTrue: [		newX _ box left + ((self position x - box left) \\ box width).		wrapped _ true].	((myBox bottom < box top) or: [myBox top > box bottom]) ifTrue: [		newY _ box top + ((self position y - box top) \\ box height).		wrapped _ true].	self position: newX@newY.	(wrapped and: [owner isPlayfieldLike])		ifTrue: [owner changed].  "redraw all turtle trails if wrapped"! !!Morph methodsFor: 'e-toy support' stamp: 'tk 3/16/98 12:49'!allMorphsAndBookPagesInto: aSet	"Return a set of all submorphs.  Don't forget the hidden ones like BookMorph pages that are not showing." 	submorphs do: [:m | m allMorphsAndBookPagesInto: aSet].	self allNonSubmorphMorphs do: [:m | 		(aSet includes: m) ifFalse: [		"Stop infinite recursion"			m allMorphsAndBookPagesInto: aSet]].	aSet add: self.	^ aSet	! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/13/1998 00:42'!allMorphsIncludingBookPages	"Like allMorphs, but includes the hidden ones like BookMorph pages that are not showing." 	^ self allMorphsAndBookPagesInto: Set new! !!Morph methodsFor: 'e-toy support'!asNumber: aPointOrNumber	"Support for e-toy demo."	aPointOrNumber class = Point		ifTrue: [^ aPointOrNumber r]		ifFalse: [^ aPointOrNumber].! !!Morph methodsFor: 'e-toy support'!canHaveScript	"Return true if this morph can have an E-Toy tile script."	^ self respondsTo: #scriptEditorFor:! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/11/98 00:31'!choosePartNameSilently	^ self world model namePartSilently: self assuredCostumee! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/13/1998 00:14'!externalName	| aName aHolder |	(aName _ self knownName) ifNotNil: [^ aName].	^ (aHolder _ self standardHolder)		ifNil:			[self innocuousName]		ifNotNil:			[aName _ aHolder chooseExternalNameFor: self.			self setNamePropertyTo: aName.			aName]! !!Morph methodsFor: 'e-toy support'!goHome	| box |	owner ifNotNil: [		box _ owner.		self left < box left ifTrue: [self position: box left@self position y].		self right > box right ifTrue: [self position: (box right - self width)@self position y].		self top < box top ifTrue: [self position: self position x@box top].		self bottom > box bottom ifTrue: [self position: self position x@(box bottom - self height)]].! !!Morph methodsFor: 'e-toy support' stamp: 'tk 10/1/97 18:23'!isTileLike	"Cannot be dropped into a script"	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/11/98 23:38'!makeAllTilesColored	(self allMorphsAndBookPagesInto: Set new) do:		[:m | m restoreTypeColor]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/11/98 23:40'!makeAllTilesGreen	(self allMorphsAndBookPagesInto: Set new) do:		[:m | m useUniformTileColor]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/1/1998 23:07'!mouseX	"Return the horizontal position of the mouse with respect to my reference playfield"	| aPlayfield anX |	anX _ self primaryHand lastEvent targetPoint x.	aPlayfield _ self referencePlayfield.	^ aPlayfield == nil		ifTrue: [anX]		ifFalse: [anX - aPlayfield left]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/1/1998 23:09'!mouseY	"Return the vertical position of the mouse with respect to my reference playfield"	| aPlayfield aY w |	aY _ self primaryHand lastEvent targetPoint y.	w _ self world.	w ifNil: [^ bounds top].	aPlayfield _ self referencePlayfield.	^ aPlayfield == nil		ifTrue: [w bottom - aY]		ifFalse: [aPlayfield bottom - aY]! !!Morph methodsFor: 'e-toy support'!move: aMorph toPosition: aPointOrNumber	"Support for e-toy demo. Move the given submorph to the given position. Allows the morph's owner to determine the policy for motion. For example, moving forward through a table might mean motion only in the x-axis with wrapping modulo the table size."	aMorph position: aPointOrNumber asPoint.! !!Morph methodsFor: 'e-toy support'!nameInModel	"Return the name for this morph in the underlying model or nil."	| w |	w _ self world.	w == nil		ifTrue: [^ nil]		ifFalse: [^ w model nameFor: self].! !!Morph methodsFor: 'e-toy support' stamp: 'jm 4/25/1998 05:41'!referencePlayfield	| pf |	owner ifNil: [self halt: 'no owner for morph'].	owner isPlayfieldLike ifTrue: [^ owner].	(owner isKindOf: HandMorph) ifTrue:		[((pf _ owner formerOwner) ~~ nil and: [pf isPlayfieldLike]) ifTrue: [^ owner formerOwner]].	self isInWorld ifFalse: [^ nil].	^ self world submorphNamed: 'playfield'! !!Morph methodsFor: 'e-toy support' stamp: 'jm 4/29/1998 11:28'!referencePosition	^ bounds center! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/11/98 23:49'!restoreTypeColor	costumee ifNotNil: [costumee allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/12/1998 10:50'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			eventHandler ifNotNil: [				eventHandler mouseDownSelector ifNotNil: [					hh _ eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				eventHandler mouseUpSelector ifNotNil: [					hh _ eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/12/1998 16:41'!standardHolder	| p |	^ (p _ self presenter) ifNil: [nil] ifNotNil: [p standardHolder]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 2/11/98 23:39'!useUniformTileColor	costumee ifNotNil:		[costumee allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 4/9/98 14:29'!x	"Return my horizontal position relative to the left edge of a relevant playfield"	| aPlayfield |	aPlayfield _ self referencePlayfield.	^ aPlayfield == nil		ifTrue: [self referencePosition x]		ifFalse: [self referencePosition x - aPlayfield left]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 4/9/98 17:28'!x: aNumber	"Set my horizontal position relative to the left edge of the playfield or the world."	|  offset  aPlayfield newX |	aPlayfield _ self referencePlayfield.	offset _ self left - self referencePosition x.	aPlayfield == nil		ifTrue: [newX _ aNumber + offset]		ifFalse: [newX _ aPlayfield left + aNumber + offset].	self position: newX@bounds top.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 4/9/98 14:31'!y	"Return my vertical position relative to the bottom of the playfield or the world. Note that larger y values are closer to the top of the screen."	| w aPlayfield |	w _ self world.	w ifNil: [^ bounds top].	aPlayfield _ self referencePlayfield.	^ aPlayfield == nil		ifTrue: [w bottom - self referencePosition y]		ifFalse: [aPlayfield bottom - self referencePosition y]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 4/9/98 17:21'!y: aNumber	"Set my vertical position relative to the bottom of the playfield or the world. Note that larger y values are closer to the top of the screen."	| w offset newY aPlayfield |	w _ self world.	w ifNil: [^ self position: bounds left@aNumber].	aPlayfield _ self referencePlayfield.	offset _ self top - self referencePosition y.	aPlayfield == nil		ifTrue: [newY _ (w bottom - aNumber) + offset]		ifFalse: [newY _ (aPlayfield bottom - aNumber) + offset].	self position: bounds left@newY.! !!Morph methodsFor: 'model access' stamp: 'di 4/26/1998 10:29'!choosePartName	"Pick an unused name for this morph."	| className |	(self world model isKindOf: Component) ifTrue:		[self knownName ifNil: [^ self nameMeIn: self world]					ifNotNil: [^ self renameMe]].	className _ self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	^ self world model addPartNameLike: className withValue: self! !!Morph methodsFor: 'model access' stamp: 'sw 2/16/98 01:31'!innocuousName	"Choose an innocuous name for the receiver -- one that does not end in the word Morph"	| className allKnownNames |	className _ self class defaultNameStemForInstances.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className _ className copyFrom: 1 to: className size - 5].	className _ className asString.	allKnownNames _ self world ifNil: [OrderedCollection new] ifNotNil: [self world allKnownNames].	^ Utilities keyLike: className asString satisfying:		[:aName | (allKnownNames includes: aName) not]! !!Morph methodsFor: 'model access'!installModelIn: ignored	"Simple morphs have no model"	"See MorphicApp for other behavior"! !!Morph methodsFor: 'other' stamp: 'sw 8/11/97 12:40'!flash	| w |	w _ self world.	w ifNotNil: [		Display flash: (bounds translateBy: w viewBox origin)].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:35'!fullLoadCachedState	"Load the cached state of the receiver and its full submorph tree."	self allMorphsDo: [:m | m loadCachedState].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:34'!fullReleaseCachedState	"Release the cached state of the receiver and its full submorph tree."	self allMorphsDo: [:m | m releaseCachedState].! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:37'!loadCachedState	"Load the cached state of this morph. This method may be called to pre-load the cached state of a morph to avoid delays when it is first used. (Cached state can always be recompued on demand, so a morph should not rely on this method being called.) Implementations of this method should do 'super loadCachedState'. This default implementation does nothing."! !!Morph methodsFor: 'other' stamp: 'tk 3/13/98 22:53'!objectToStoreOnDataStream	"I am being written out on an object file"	self prepareToBeSaved.		"Amen"	^ self! !!Morph methodsFor: 'other' stamp: 'di 11/14/97 10:24'!prepareToBeSaved	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."	self releaseCachedState.	fullBounds _ nil.! !!Morph methodsFor: 'other' stamp: 'jm 11/13/97 16:33'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'. This default implementation does nothing."! !!Morph methodsFor: 'other' stamp: 'tk 3/15/98 12:50'!storeDataOn: aDataStream	"Let all Morphs be written out.  DataStream.typeIDFor: catches the ones that are outside our tree (most notably, the root's owner).  For now let everthing try to write out.  "	| cntInstVars cntIndexedVars ti localInstVars got |	"block my owner unless he is written out by someone else"	got _ aDataStream references at: owner ifAbsent: [nil].	got ifNotNil: ["My owner has already started to go out.  OK to point at him"		^ super storeDataOn: aDataStream].	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	localInstVars _ Morph instVarNames.	ti _ 2.  	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:			[self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPut: nil.	"owner"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Morph methodsFor: 'private' stamp: 'tk 9/20/97 23:36'!copyRecordingIn: dict	"Recursively copy this entire composite morph, recording the correspondence between old and new morphs in the given dictionary. This dictionary will be used to update intra-composite references in the copy.  See updateReferencesUsing:	Rules:  All morphs being copied must be in the submorph&owner hierarchy of the first object being copied.  Any morph this is NOT in submorph&owner hierarchy, and is only held by an inst var or by an array, etc., MUST be copied by an override of this method for the class of the instance that holds onto it.  This is really hard to obey!!!!!!"	| new |	new _ self copy.	dict at: self put: new.	submorphs size > 0 ifTrue: [		new privateSubmorphs:			(submorphs collect: [:m |				(m copyRecordingIn: dict) privateOwner: new])].	new copyPropertiesFrom: self dict: dict.	^ new! !!Morph methodsFor: 'private'!copyWithoutSubmorphs	^ self clone		privateOwner: nil;		privateSubmorphs: EmptyArray;		privateBounds: (bounds origin corner: bounds corner)  "deep-copy bounds"! !!Morph methodsFor: 'private'!privateAddMorph: aMorph atIndex: index	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).	self layoutChanged.! !!Morph methodsFor: 'private'!privateBounds: boundsRect	"Private!! Use position: and/or extent: instead."	fullBounds _ nil.	bounds _ boundsRect.! !!Morph methodsFor: 'private' stamp: 'jm 7/8/97 08:32'!privateFullMoveBy: delta	"Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."	self privateMoveBy: delta.	1 to: submorphs size do: [:i |		(submorphs at: i) privateFullMoveBy: delta].! !!Morph methodsFor: 'private' stamp: 'jm 7/8/97 10:16'!privateMoveBy: delta	"Private!! Use 'position:' instead."	fullBounds == bounds ifTrue: [		"optimization: avoids recomputing fullBounds"		fullBounds _ bounds _ bounds translateBy: delta.	] ifFalse: [		bounds _ bounds translateBy: delta.		fullBounds _ nil].! !!Morph methodsFor: 'private'!privateOwner: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	owner _ aMorph.! !!Morph methodsFor: 'private'!privateRemoveMorph: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	aMorph changed.	submorphs _ submorphs copyWithout: aMorph.	self layoutChanged.! !!Morph methodsFor: 'private'!privateSubmorphs	"Private!! Use 'submorphs' instead."	^ submorphs! !!Morph methodsFor: 'private'!privateSubmorphs: aCollection	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs _ aCollection.! !!Morph methodsFor: 'naming' stamp: 'sw 5/13/1998 00:16'!knownName	^ self valueOfProperty: #name! !!Morph methodsFor: 'naming' stamp: 'sw 4/22/1998 14:54'!renameTo: aName	| aPresenter putInViewer |	self setNameTo: aName.	(aPresenter _ self world presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: costumee.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	self world allTileScriptingElements do:		[:m | m bringUpToDate]! !!Morph methodsFor: 'naming' stamp: 'sw 2/4/98 00:03'!setNamePropertyTo: aName	self setProperty: #name toValue: aName! !!Morph methodsFor: 'naming' stamp: 'sw 5/13/1998 00:16'!setNameTo: aName	self setNamePropertyTo: aName! !!Morph methodsFor: 'naming' stamp: 'sw 4/9/98 14:26'!submorphNamed: aName	^ self submorphNamed: aName ifNone: [nil]! !!Morph methodsFor: 'naming' stamp: 'sw 5/19/1998 13:10'!submorphNamed: aName ifNone: aBlock	^ self submorphs detect: [:p | p knownName = aName] ifNone: [aBlock value]! !!Morph methodsFor: 'naming' stamp: 'sw 9/21/97 14:13'!updateWorldAfterRenamingMe: aName	self setNameTo: aName! !!Morph methodsFor: 'locking' stamp: 'sw 8/5/97 20:08'!isLocked	^ (self valueOfProperty: #locked) == true! !!Morph methodsFor: 'locking' stamp: 'sw 8/4/97 12:05'!lock	self lock: true! !!Morph methodsFor: 'locking' stamp: 'sw 8/4/97 12:05'!lock: aBoolean	self setProperty: #locked toValue: aBoolean! !!Morph methodsFor: 'locking' stamp: 'sw 8/16/97 01:58'!unlock	self removeProperty: #locked! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 11:51'!addButtonNamed: label selector: aSymbol	"Elevated from EToyPaletterMorph to here, so that any kind of object can add one."	| b |	b _ StringButtonMorph new.	b	contents: label;		color: self buttonOffColor;		target: self;		actionSelector: aSymbol;		setNameTo: label.	self addMorphBack: b.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/4/97 17:50'!addLabel: aString	^ self addLabel: aString outset: (6@10)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/4/97 17:49'!addLabel: aString outset: aPoint	| m |	self removeAllMorphs.	m _ StringMorph new contents: aString.	self extent: (m width + aPoint x) @ (m height + aPoint y).	m position: self center - (m extent // 2).	self addMorph: m.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/13/97 20:06'!addTransparentSpacerOfSize: aPoint	self addMorphBack: ((Morph new extent: aPoint) color: Color transparent)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!beRepelling	self setProperty: #repelling toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 18:01'!beSticky		self setProperty: #sticky toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:13'!buttonOffColor		| val |	^ (val _ self valueOfProperty: #buttonOffColor)		ifNotNil:			[val]		ifNil:			[Color r: 0.4 g: 0.2 b: 0.6]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:10'!buttonOffColor: aColor	self setProperty: #buttonOffColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:13'!buttonOnColor		| val |	^ (val _ self valueOfProperty: #buttonOnColor)		ifNotNil:			[val]		ifNil:			[Color yellow]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/8/97 22:10'!buttonOnColor: aColor	self setProperty: #buttonOnColor toValue: aColor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/10/97 01:11'!colorSettable	"Answer whether it is meaningful for the receiver to have its color set from outside.  Most Morphs say yes, but some, such as SketchMorph, say no"	^ true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/1/97 00:18'!configureForKids	submorphs ifNotNil:		[submorphs do: [:m | m configureForKids]]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/20/97 23:19'!eachStepInOwnerChainDo: aBlock	"Perform aBlock for the receiver, its parent, etc., up the chain until nil reached"	aBlock value: self.	owner ifNotNil: [owner eachStepInOwnerChainDo: aBlock]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/1/97 14:51'!findDeepSubmorphThat: block1 ifAbsent: block2	^ self allMorphs detect: [:m | (block1 value: m) == true] ifNone: [block2 value]	! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 22:01'!findSubmorphThat: block1 ifAbsent: block2	^ submorphs detect: [:m | (block1 value: m) == true] ifNone: [block2 value]	! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 5/13/1998 16:15'!inPartsBin	| o |	(self hasProperty: #partsDonor) ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/11/97 13:18'!isPartsDonor	^ self hasProperty: #partsDonor! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 4/15/1998 12:45'!isSticky	^ (self valueOfProperty: #sticky) == true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 2/22/98 23:12'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	costumee ifNotNil:		[costumee justClonedFrom: aDonor costumee]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 5/4/1998 11:56'!justDuplicatedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the dup gets a chance to get things right.  If a costumee (Player) is involved, the duplication involved the creation of a fresh Player subclass rather than another instance of the original." 	costumee ifNotNil:		[costumee justDuplicatedFrom: aDonor costumee]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/5/97 20:08'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self setProperty: #partsDonor toValue: true! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 1/29/98 02:26'!morphToDropFrom: m	^ m! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 2/13/98 22:49'!morphToGrabFrom: m	^ m! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/3/97 01:57'!name: aName	(aName isKindOf: String) ifTrue:		[self setNameTo: aName]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:52'!nextPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #nextOwnerPage; label: '->'; color: Color yellow.	aButton setNameTo: 'next'.	^ aButton! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 2/16/98 02:08'!objectViewed	^ (self outermostMorphThat: [:o | o isKindOf: PartsViewer orOf: ScriptEditorMorph])  morph! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 4/18/1998 00:16'!playfield	^ self presenter playfield! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!positionAtBottomLeft	"Position the receiver at the bottom left of its owner.  Was handy recently though temporarily not in use"	self position: owner bounds bottomLeft - (0 @ self extent y)! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!positionAtBottomRight	"Position the receiver at the bottom right of its owner.  Was handy recently though temporarily not in use"	self position: owner bounds bottomRight - self extent! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/12/97 17:59'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/5/97 21:12'!primaryHand	| aWorld |	(aWorld _ self world) ifNil: [^ nil].	^ aWorld hands first ! !!Morph methodsFor: 'aug97 additions' stamp: 'di 5/7/1998 01:22'!removeEmptyLayoutMorphs	submorphs copy do: [:m |		m isAlignmentMorph			ifTrue:				[m submorphCount = 0					ifTrue:						[m delete]					ifFalse:						[m removeEmptyLayoutMorphs]]].	self fullBounds.	self layoutChanged! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ self hasProperty: #repelling! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 2/16/98 00:58'!rootForGrabOf: aMorph	^ self isSticky		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 10/18/97 18:03'!screenLocation	"If the receiver is currently in an mvc window, return its screen origin"	| aWorld aBox |	(aWorld _ self world) ifNil: [^ nil].	(aBox _ aWorld viewBox) ifNil: [^ nil].	^ self fullBounds origin + aBox origin! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/17/97 18:43'!screenRectangle	"If the receiver is currently in an mvc window, return its screen rectangle"	| aWorld aBox |	(aWorld _ self world) ifNil: [^ nil].	(aBox _ aWorld viewBox) ifNil: [^ nil].	^ (self fullBounds origin + aBox origin) extent: self extent! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 4/15/1998 12:34'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	self delete.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'aug97 additions' stamp: 'jm 10/22/97 07:46'!slideToTrash: evt	| aForm aWorld trash origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	trash _ aWorld findA: TrashCanMorph.	trash ifNil: [^ self].	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ trash position + origin.	self delete.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	trash acceptDroppingMorph: self event: evt.! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 22:03'!submorphsSatisfying: aBlock	^ submorphs select: [:m | (aBlock value: m) == true]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/15/97 23:59'!unlockContents	self submorphsDo:		[:m | m unlock]! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/16/97 17:16'!unlockOneSubpart	| unlockables aMenu reply |	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu _ SelectionMenu labelList: (unlockables collect: [:m | m externalName]) selections: unlockables.	reply _ aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply == nil ifTrue: [^ self].	reply unlock! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 3/11/98 16:39'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:	[NumericReadoutTile new typeColor: aColor]		ifFalse:	[StringReadoutTile new typeColor: aColor]. 	viewer _ UpdatingStringMorph new		target: self costumee;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat]		ifFalse:			[viewer useDefaultFormat].	aTile addMorphBack: viewer.	putSelector == #unused ifFalse: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 5/1/1998 20:30'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition + origin.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	aWorld soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 11/3/97 02:11'!wantsKeyboardFocusFor: aSubmorph	"Answer whether a plain mouse click on aSubmorph, a text-edit-capable thing, should result in a text selection there"	^ false! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 8/20/97 23:20'!withAllContainers	| aList |	aList _ OrderedCollection new.	self eachStepInOwnerChainDo:		[:m | aList add: m].	^ aList asArray! !!Morph methodsFor: 'aug97 additions' stamp: 'sw 5/6/1998 12:54'!wouldAcceptKeyboardFocus	"Answer whether a plain mouse click on the receiver should result in a text selection there"	^ false! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!assuredPropertyDictionary	"Return the receiver's property dictionary, creating it if necessary.  Properties are accessed only by symbol, so an IdentityDictionary is used for speed"	properties ifNil: [properties _ IdentityDictionary new].	^ properties! !!Morph methodsFor: 'properties' stamp: 'sw 5/18/1998 17:32'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	(val _ self valueOfProperty: #balloonText) ifNotNil: [^ val].	(val _ self valueOfProperty: #balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil! !!Morph methodsFor: 'properties' stamp: 'sw 5/18/1998 17:27'!balloonTextSelector: aSelector	self setProperty: #balloonTextSelector toValue: aSelector! !!Morph methodsFor: 'properties' stamp: 'tk 8/21/97 15:46'!copyPropertiesFrom: donorMorph dict: dict	properties _ donorMorph properties copy.	properties ifNotNil: [		properties associationsDo: [:ass |			ass value isMorph ifTrue: [				ass value owner ifNil: [ass value: (assvalue copyRecordingIn: dict)]]]].					"note side effecting.  Any un-ownedmorph belongs to us."! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	^ properties ~~ nil and:		[((prop _ properties at: propName ifAbsent: [nil]) ~~ false) and:			[prop ~~ nil]]! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!properties	^ properties! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!removeProperty: propName	properties ifNil: [^ self].	properties removeKey: propName ifAbsent: [].	properties size == 0 ifTrue: [properties _ nil]! !!Morph methodsFor: 'properties' stamp: 'jm 4/25/1998 02:55'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].	self assuredPropertyDictionary at: propName put: aValue.! !!Morph methodsFor: 'properties' stamp: 'sw 8/4/97 12:05'!valueOfProperty: propName	properties ifNil: [^ nil].	^ properties at: propName ifAbsent: [nil]! !!Morph methodsFor: 'object fileIn' stamp: 'tk 8/16/97 17:54'!convertbosfce0: varDict bosfcep0: smartRefStrm	"These variables are automatically stored into the new instance('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'eventHandler' ).	This method is for additional changes. Use statements like (foo _varDict at: 'foo')."	"Be sure to to fill in ('properties' ) and deal with theinformation in ()"	"OK if properties is nil"! !!Morph methodsFor: 'object fileIn' stamp: 'sw 2/26/98 20:16'!convertbosfcep0: varDict bosfcepc0: smartRefStrm	"These variables are automatically stored into the new instance ('bounds' 'owner' 'submorphs' 'fullBounds' 'color' 'eventHandler' 'properties' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('costumee' ) and deal with the information in ()"! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 2/20/98 15:20'!addHalo	| halo |	halo _ HaloMorph new.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 9/18/97 14:01'!addOptionalHandlesTo: aHalo box: box	! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 5/20/1998 20:47'!deleteBalloon	"If I am showing a balloon, delete it."	| balloon |	(balloon _ self valueOfProperty: #balloon) ifNil: [^ self].	balloon delete.	self setProperty: #balloon toValue: nil.! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 5/6/1998 14:30'!editBalloonHelpContent: aString	| reply |	reply _ FillInTheBlank		multiLineRequest: ('Edit the balloon help text for ', self externalName)		centerAt: Sensor cursorPoint		initialAnswer: aString		answerHeight: 200.	(reply size > 0 and: [reply asString ~= self noHelpString])		ifTrue: [self setBalloonText: reply].! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 11/3/97 13:27'!editBalloonHelpText	| str  |	str _ self valueOfProperty: #balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 2/20/98 15:22'!halo	self world haloMorphs do:		[:h | h target == self ifTrue: [^ h]].	^ nil! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 2/20/98 15:23'!hasHalo	self halo ifNil: [^ false] ifNotNil: [^ true]! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 5/20/1998 20:40'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	anEvent shiftPressed		ifTrue: [self editBalloonHelpContent: str]		ifFalse: [self showBalloon: str].! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 9/19/97 13:46'!noHelpString	^ 'Help not yet supplied'! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 2/20/98 15:24'!removeHalo	| h |	h _ self halo.	h ifNotNil: [h delete]! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 9/17/97 15:08'!setBalloonText: stringOrText	self setProperty: #balloonText toValue: stringOrText! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 5/20/1998 20:09'!showBalloon: msgString	"Pop up a balloon containing the given string, first removing any existing BalloonMorphs in the world."	| w balloon |	w _ self world.	w ifNil: [^ self].	balloon _ BalloonMorph string: msgString for: self corner: #bottomRight.	w submorphsDo: [:m |  "delete any existing balloons"		(m isKindOf: BalloonMorph) ifTrue: [m delete]].	w addMorphFront: balloon.	self setProperty: #balloon toValue: balloon.! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 5/18/1998 17:48'!wantsBalloon	^ self balloonText ~~ nil! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 4/13/1998 23:01'!wantsHalo	^ owner ~~ nil and: [owner wantsHaloFor: self]! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 4/8/98 13:26'!wantsHaloFor: aSubMorph	^ false! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 5/13/1998 12:18'!assuredCostumee	"Answer the receiver's costumee, a Player,, creating a new one if none currently exists"	costumee ifNil:		[self externalName.  "a default may be given if not named yet"		costumee _ self newPlayerInstance.  "Different morphs may demand different player types"		costumee costume: self.		self world flushPlayerListCache].	^ costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/22/1998 13:49'!choosePenColor: evt	self assuredCostumee choosePenColor: evt! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/22/1998 13:24'!choosePenSize	self assuredCostumee choosePenSize! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 12/16/97 09:29'!costumee	^ costumee! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 12/16/97 09:30'!costumee: anObject	costumee _ anObject! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 2/12/98 00:23'!formalCostumeName	^ self class name! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/22/1998 16:54'!getPenColor	^ costumee ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/22/1998 17:01'!getPenDown	costumee ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/22/1998 16:56'!getPenSize	costumee ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 1/29/98 21:51'!isPlayfieldLike	^ false! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/9/98 21:55'!jettisonScripts	costumee ifNotNil: [costumee class jettisonScripts]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 2/4/98 18:07'!liftPen	self assuredCostumee liftPen! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 2/4/98 14:57'!lowerPen	self assuredCostumee lowerPen! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 3/11/98 20:33'!maxScaleFactor	"NB SketchMorph overrides."	^ 50! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/25/1998 17:52'!newPlayerInstance	^ Player newUserInstance! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 3/3/98 01:50'!newScaleFactor: newScaleFactor previousScaleFactor: oldScaleFactor	"NB SketchMorph overrides."	| ratio |	ratio _ newScaleFactor asFloat / oldScaleFactor.	self extent: ((ratio * self width) @ (ratio * self height)) rounded! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 2/4/98 18:05'!penColor: aColor	self assuredCostumee penColor: aColor! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 1/31/98 01:11'!scriptEditorFor: aScriptName	^ self assuredCostumee scriptEditorFor: aScriptName! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 1/29/98 21:58'!scriptPerformer	^ costumee ifNil: [self] ifNotNil: [costumee]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 1/28/98 23:49'!showPlayerMenu	costumee ifNotNil:		[costumee showPlayerMenu]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 5/21/1998 15:21'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts.  Generic Morph has none, but check other implementors"	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:)				"(mouseX		number		readOnly	getMouseX			unused)"				"(mouseY		number		readOnly	getMouseY			unused)")]		ifFalse:			[Array new]! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 2/14/98 18:40'!tearOffTile	self assuredCostumee tearOffTileForSelf! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 3/13/98 17:40'!updateLiteralLabel	"Backstop -- updatingStringMorphs inform their owners with this message when they've changed; some Morphs care, others don't"! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 4/30/1998 22:28'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	costumee updateAllViewers.	self world addMorph: (anEditor _ costumee scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/22/1998 14:01'!actorState	| state |	state _ self valueOfProperty: #actorState.	state ifNil:		[self setProperty: #actorState toValue: (state _ ActorState new initializeFor: self assuredCostumee)].	^ state! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/13/1998 23:10'!actorState: anActorState	self setProperty: #actorState toValue: anActorState! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/21/1998 15:25'!addDebuggingItemsTo: aMenu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: aHandMorph.	subMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	subMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[subMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	subMenu add: 'browse morph class' action: #browseMorphClass.	costumee ifNotNil:		[subMenu add: 'inspect player' action: #inspectCostumee.		World ifNil: [subMenu add: 'inspect player (morphic)' action: #inspectArgumentsCostumeeInMorphic].		subMenu add: 'browse player class' action: #browsePlayerClass].	subMenu add: 'make own subclass' action: #subclassMorph.	subMenu add: 'internal name' action: #nameMorph.	subMenu add: 'save morph in file' action: #saveMorphInFile.	subMenu defaultTarget: self.	subMenu add: 'edit balloon help' action: #editBalloonHelpText.	subMenu add: 'temp command' action: #tempCommand.	aMenu add: 'debug...' subMenu: subMenu! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/16/1998 22:43'!addPaintingItemsTo: aMenu hand: aHandMorph	| subMenu movies |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'repaint' action: #editDrawing.	subMenu add: 'set rotation center' action: #setRotationCenter.	subMenu add: 'set rotation style' action: #setRotationStyle.	subMenu add: 'erase pixels of color' action: #erasePixelsOfColor:.	subMenu add: 'recolor of pixels of color' action: #recolorPixelsOfColor:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' action: #insertIntoMovie:].	aMenu add: 'painting...' subMenu: subMenu! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/18/1998 00:58'!allSubmorphNames	^ self submorphs select: [:m | m knownName ~~ nil] thenCollect: [:m | m externalName]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/2/98 14:16'!hasFocus	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/27/1998 19:04'!holdsDataForEachInstance	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/19/1998 01:47'!inspectInMorphic	self primaryHand attachMorph: ((Inspector openAsMorphOn: self) extent: 300@200)! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 13:11'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/21/1998 21:33'!isTileScriptingElement	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/16/1998 13:46'!mustBeBackmost	"Answer whether the receiver needs to be the backmost morph in its owner's submorph list"	^ false! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/18/1998 01:37'!openViewerForArgument	self presenter viewMorph: self! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/25/1998 23:58'!pasteUpMorph	"Answer the genetically closest containing morph that is a PasteUp morph"	^ self ownerThatIsA: PasteUpMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/16/1998 19:52'!presenter	^ owner ifNotNil: [owner presenter] ifNil: [nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/1/1998 00:41'!removeLink: actionCode	eventHandler ifNotNil:		[eventHandler on: actionCode send: nil to: nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/22/1998 14:45'!residesInPartsBin	"Answer true if the receiver is, or has some ancestor owner who is, a parts bin"	^ owner ifNotNil: [owner residesInPartsBin] ifNil: [false]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 11:50'!restoreSuspendedEventHandler	| savedHandler |	(savedHandler _ self valueOfProperty: #suspendedEventHandler) ifNotNil:		[self eventHandler: savedHandler]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/27/1998 00:22'!slotSpecifications	"Return a list of slots.  Each element will be tuple:		1	slot name (a symbol)		2	slot type (a symbol)		3	..."	^ Array new! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 11:49'!suspendEventHandler	eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: eventHandler.		eventHandler _ nil]! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/6/1998 13:27'!tempCommand	"To use this, comment out what's below here, and substitute your own code, or else reimplement in a subclass.  "	self inform: 'Morph tempCommandPut your own temporarydebugging code in this method, eitherin generic Morph or in some subclass,and you will be able to invoke it directlythe standard debugging menu.'.	"Later, give user a chance at this juncture to spawn a browser on this very method"! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 4/13/1998 18:50'!toggleStickiness	self setProperty: #sticky toValue: self isSticky not! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 17:33'!usableDuplicate	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	costumee ifNotNil:		[newPlayer _ costumee duplicatedPlayerForCostume: newMorph.			"nb newPlayer has had his costume set to newMorph in the above-called method"		self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"		newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer)].	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	newMorph justDuplicatedFrom: self.	newMorph removeProperty: #partsDonor.	newMorph privateOwner: nil.	(newPlayer ~~ nil and: [newMorph renderedMorph eventHandler ~~ nil]) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	newPlayer ifNotNil: [self world flushPlayerListCache].	^ newMorph! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 5/13/1998 23:04'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	newMorph _ self fullCopy.	newPlayer _ costumee class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph costumee: newPlayer]. "???"	newMorph actorState: (costumee actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[costumee ~~ nil ifTrue: [aName _ newMorph innocuousName]].  "Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self world flushPlayerListCache.	^ newMorph! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Morph class	instanceVariableNames: ''!!Morph class methodsFor: 'instance creation' stamp: 'sw 8/11/97 13:17'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		^ self new markAsPartsDonor! !!Morph class methodsFor: 'instance creation' stamp: 'sw 9/19/97 16:52'!authoringPrototypeIn: anEToyHolder	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		^ self authoringPrototype! !!Morph class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Return true for all classes that can be instantiated from the menu"	^ true! !!Morph class methodsFor: 'instance creation'!new	^ super new initialize! !!Morph class methodsFor: 'instance creation'!newBounds: bounds	^ self new privateBounds: bounds! !!Morph class methodsFor: 'instance creation'!newBounds: bounds color: color	^ (self new privateBounds: bounds) color: color! !!Morph class methodsFor: 'instance creation' stamp: 'sw 8/4/97 12:05'!newSticky	^ self new beSticky! !!Morph class methodsFor: 'instance creation' stamp: 'sw 8/4/97 18:26'!newWithExtent: extent	^ self new privateBounds: (0@0 extent: extent)! !!Morph class methodsFor: 'class initialization' stamp: 'sw 2/14/98 14:02'!formalCostumeName	"Answer the name to be presented to the user to describe an object of this class"	^ self name! !!Morph class methodsFor: 'class initialization'!initialize	"Morph initialize"	"this empty array object is shared by all morphs with no submorphs:"	EmptyArray _ Array new.! !Controller subclass: #MorphWorldController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!MorphWorldController commentStamp: 'di 5/22/1998 16:35' prior: 0!MorphWorldController comment:'I am a controller for SceneViews. I support gestures for scrolling, click-selection, and area selection of scene glyphs. (See the class comment in GestureController for more details about gestures.) I also support construction operations such as inserting new glyphs and merging glyphs to make them share a common point.The mapping of gestures to actions is as follows (see GestureController comment for more about gestures):  Click:	click on glyph				select glyph	shift-click on glyph			toggle selection of that glyph	click on background			clear selection  Double click:	double-click on glyph			inspect glyph	double-click on background		select all  Hold/Drag/Sweep:	hold (no movement)			yellow-button menu	drag (up/left movement)		scrolling hand	sweep (down/right movement)	select glyphs in region	shift-sweep					toggle selection of glyphs in region'!!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 2/20/98 13:37'!controlActivity	"Do one step of the Morphic interaction loop. Called repeatedly while window is active."	model doOneCycle.! !!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 5/20/1998 20:18'!controlInitialize	"This window is becoming active."	model canvas ifNil: [  "i.e., only on first entry"		"In case of, eg, inspect during balloon help..."		model submorphsDo: [:m |  "delete any existing balloons"			(m isKindOf: BalloonMorph) ifTrue: [m delete]].		model hands do: [:h | h initForEvents].		view displayView].  "initializes the WorldMorph's canvas"! !!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 2/20/98 14:34'!controlLoop 	sensor leftShiftDown ifTrue:		["Hold shift down when activating a Morphic window to take stats"		(self confirm: 'The shift key was down;do you really want to spy on Morphic?') ifTrue:			[^ MessageTally spyOn: [super controlLoop. Cursor normal show]]].	"Overridden to keep control active when the hand drags something out of the view"	[self viewHasCursor or:		[Sensor anyButtonPressed or: [model primaryHand submorphs size > 0]]]		whileTrue:			[self controlActivity. Processor yield].! !!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 2/20/98 13:36'!controlTerminate 	"This window is becoming inactive; restore the normal cursor."	Cursor normal show.! !!MorphWorldController methodsFor: 'control sequence' stamp: 'jm 6/17/97 10:29'!isControlActive	^ sensor redButtonPressed or: [self viewHasCursor]! !View subclass: #MorphWorldView	instanceVariableNames: ''	classVariableNames: 'FullColorWhenInactive '	poolDictionaries: ''	category: 'Morphic-Support'!!MorphWorldView commentStamp: 'di 5/22/1998 16:35' prior: 0!MorphWorldView comment:'I am a view used to display a Scene. I may be scrolled by adjusting my offset. My default controller is SceneController.SceneViews encapsulate the notion of a changing foreground and a fixed background during interactive updates. During an interaction (such as dragging), some of the glyphs will not change location or appearance. These are part of the "background". All glyphs that may change (the "foreground" glyphs) are painted against this unchanging backdrop during the interaction.Instance Variables:	offset				the current offset of this view (used for scrolling)	enclosingRect 		a rectangle large enough to contain all the objects in the scene, plus a small border (this is a cache that must be recomputed when glyphs are moved, added, or removed from the scene)	backgroundForm		a <Form> containing the fixed background	visibleForeground		the glyphs that are changing but not selected during an interaction	selectedForeground	the selected glyphs that are changing during an interaction'!!MorphWorldView methodsFor: 'all' stamp: 'jm 2/27/98 11:55'!deEmphasizeView 	"This window is becoming inactive."	Cursor normal show.    "restore the normal cursor"	model hands do:          "free dependents links if any"		[:h | h newKeyboardFocus: nil].	model canvas: nil.		"free model's canvas to save space"	model fullReleaseCachedState.	self topView cacheBitsAsTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		model displayWorldAsTwoTone].! !!MorphWorldView methodsFor: 'all'!defaultControllerClass	^ MorphWorldController! !!MorphWorldView methodsFor: 'all' stamp: 'di 2/26/98 15:44'!displayView	"This method is called by the system when the top view is framed or moved."	| topView |	model viewBox: self insetDisplayBox.	topView _ self topView.	(topView == ScheduledControllers scheduledControllers first view		or: [topView cacheBitsAsTwoTone not])		ifTrue: [model displayWorld]		ifFalse: [model displayWorldAsTwoTone].  "just restoring the screen"! !!MorphWorldView methodsFor: 'all' stamp: 'sw 9/26/97 20:56'!update: symbol	^ symbol == #newColor		ifTrue: [self topView backgroundColor: model color dominantColor; uncacheBits; display]		ifFalse: [super update: symbol].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MorphWorldView class	instanceVariableNames: ''!!MorphWorldView class methodsFor: 'instance creation'!fullColorWhenInactive	FullColorWhenInactive ifNil: [FullColorWhenInactive _ true].	^ FullColorWhenInactive! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'di 2/26/98 09:17'!fullColorWhenInactive: fullColor	"MorphWorldView fullColorWhenInactive: true"	"If FullColorWhenInactive is true then WorldMorphViews will created inside StandardSystemViews that cache their contents in full-color when the window is inactive. If it is false, only a half-tone gray approximation of the colors will be cached to save space."	FullColorWhenInactive _ fullColor.	"Retroactively convert all extant windows"	((fullColor ifTrue: [StandardSystemView] ifFalse: [ColorSystemView])		allInstances select:			[:v | v subViews notNil and: [v subViews isEmpty not and: [v firstSubView isKindOf: MorphWorldView]]])		do: [:v | v uncacheBits.			v controller toggleTwoTone]! !!MorphWorldView class methodsFor: 'instance creation'!openOn: aMorphWorld	"Open a view on the given WorldMorph."	self openOn: aMorphWorld label: 'A Morphic World'.! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 10/2/97 23:17'!openOn: aWorldMorph label: aString	"Open a view with the given label on the given WorldMorph."	^ self openOn: aWorldMorph label: aString model: (CautiousModel new initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'jm 1/31/98 20:24'!openOn: aWorldMorph label: aString extent: aPoint	"Open a view with the given label and extent on the given WorldMorph."	^ self openOn: aWorldMorph		label: aString		model: (CautiousModel new initialExtent: aPoint)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 5/4/1998 23:47'!openOn: aWorldMorph label: aString model: aModel	"Open a view with the given label on the given WorldMorph."	| topView |	topView _ self fullColorWhenInactive		ifTrue: [topView _ ColorSystemView new]		ifFalse: [topView _ StandardSystemView new].	topView model: aModel;		label: aString;		borderWidth: 1;		"minimumSize: aWorldMorph extent + (2@2); " "add border width"		addSubView: (self new initialize model: aWorldMorph);		backgroundColor: aWorldMorph color.	topView controller open.! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'di 4/16/1998 14:54'!openWorldWith: aMorph labelled: labelString	| w |	self openOn: (w _ WorldMorph new addMorph: aMorph)		label: labelString		extent: w fullBounds extent + 2.! !Object subclass: #MorphicEvent	instanceVariableNames: 'type cursorPoint buttons keyValue sourceHand '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!MorphicEvent methodsFor: 'initialization'!initialize	type _ #unknown.	cursorPoint _ 0@0.	buttons _ 0.	keyValue _ 0.	sourceHand _ nil.! !!MorphicEvent methodsFor: 'accessing'!buttons	"Return the a word encoding the mouse and modifier buttons for this event."	^ buttons! !!MorphicEvent methodsFor: 'accessing'!hand	"Return the hand that originated this event."	^ sourceHand! !!MorphicEvent methodsFor: 'accessing'!type	"Return a symbol indicating the type this event."	^ type! !!MorphicEvent methodsFor: 'classification'!isKeystroke	^ type == #keystroke! !!MorphicEvent methodsFor: 'classification'!isMouse	^ (type == #mouseMove) | (type == #mouseDown) | (type == #mouseUp)! !!MorphicEvent methodsFor: 'classification'!isMouseDown	^ type == #mouseDown! !!MorphicEvent methodsFor: 'classification'!isMouseMove	^ type == #mouseMove! !!MorphicEvent methodsFor: 'classification'!isMouseUp	^ type == #mouseUp! !!MorphicEvent methodsFor: 'equality' stamp: 'jm 11/4/97 07:15'!= aMorphicEvent	(aMorphicEvent isKindOf: self class) ifFalse: [^ false].	type = aMorphicEvent type ifFalse: [^ false].	cursorPoint = aMorphicEvent cursorPoint ifFalse: [^ false].	buttons = aMorphicEvent buttons ifFalse: [^ false].	keyValue = aMorphicEvent keyValue ifFalse: [^ false].	^ true! !!MorphicEvent methodsFor: 'equality' stamp: 'jm 11/4/97 07:15'!hash	^ cursorPoint hash + buttons hash + keyValue hash! !!MorphicEvent methodsFor: 'mouse'!anyButtonPressed	"Answer true if any mouse button is being pressed."	^ buttons anyMask: 7! !!MorphicEvent methodsFor: 'mouse'!blueButtonPressed	"Answer true if the blue mouse button is being pressed."	^ buttons anyMask: 1! !!MorphicEvent methodsFor: 'mouse'!cursorPoint	"Answer the location of the cursor's hotspot when this event occured."	^ cursorPoint! !!MorphicEvent methodsFor: 'mouse'!redButtonPressed	"Answer true if the red mouse button is being pressed."	^ buttons anyMask: 4! !!MorphicEvent methodsFor: 'mouse'!targetPoint	"Answer the location of the cursor's hotspot, adjusted by the offset	of the last mouseDown relative to the recipient morph."	^ cursorPoint - sourceHand targetOffset! !!MorphicEvent methodsFor: 'mouse'!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform transform: cursorPoint)! !!MorphicEvent methodsFor: 'mouse'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed."	^ buttons anyMask: 2! !!MorphicEvent methodsFor: 'keyboard'!commandKeyPressed	"Answer true if the command key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 64! !!MorphicEvent methodsFor: 'keyboard'!controlKeyPressed	"Answer true if the control key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 16! !!MorphicEvent methodsFor: 'keyboard'!keyCharacter	"Answer the character corresponding this keystroke. This is defined only for keystroke events."	^ keyValue asCharacter! !!MorphicEvent methodsFor: 'keyboard'!keyValue	"Answer the ascii value for this keystroke. This is defined only for keystroke events."	^ keyValue! !!MorphicEvent methodsFor: 'keyboard'!optionKeyPressed	"Answer whether the option key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard'!shiftPressed	"Answer true if either the left or right shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicEvent methodsFor: 'printing'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self cursorPoint printString; space.	aStream nextPutAll: type.	self isKeystroke ifTrue: [		self controlKeyPressed ifTrue: [			aStream nextPutAll: ' ''^'.			aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter.		] ifFalse: [			aStream nextPutAll: ' '''.			aStream nextPut: self keyCharacter.		].		aStream nextPut: $'.	].	aStream nextPut: $].! !!MorphicEvent methodsFor: 'printing' stamp: 'jm 11/4/97 07:15'!storeOn: aStream	aStream nextPutAll: type.	aStream space.	cursorPoint x storeOn: aStream.	aStream space.	cursorPoint y storeOn: aStream.	aStream space.	buttons storeOn: aStream.	aStream space.	keyValue storeOn: aStream.! !!MorphicEvent methodsFor: 'private'!setCursorPoint: aPoint	"Used for transforming events."	cursorPoint _ aPoint.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setHand: aHandMorph	"Set the hand that originated this event."	sourceHand _ aHandMorph.! !!MorphicEvent methodsFor: 'private'!setKeyValue: keyVal mousePoint: aPoint buttons: anInteger hand: hand	type _ #keystroke.	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ keyVal.	sourceHand _ hand.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setMousePoint: aPoint buttons: anInteger lastEvent: lastEvent hand: hand	cursorPoint _ aPoint.	buttons _ anInteger.	keyValue _ 0.	sourceHand _ hand.	self anyButtonPressed ifTrue: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseMove]			ifFalse: [type _ #mouseDown].	] ifFalse: [		lastEvent anyButtonPressed			ifTrue: [type _ #mouseUp]			ifFalse: [type _ #mouseMove]].! !!MorphicEvent methodsFor: 'private'!setType: newType	type _ newType.! !!MorphicEvent methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!setType: t cursorPoint: p buttons: b keyValue: k	type _ t.	cursorPoint _ p.	buttons _ b.	keyValue _ k.	sourceHand _ nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MorphicEvent class	instanceVariableNames: ''!!MorphicEvent class methodsFor: 'instance creation'!new	^ super new initialize! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'jm 11/4/97 07:15'!newWorldExtent: aPoint	"Answer an event that records a WorldMorph window size change."	^ self basicNew setType: #worldExtent		cursorPoint: aPoint		buttons: 0		keyValue: 0! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'jm 11/4/97 07:15'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| s type x y buttons keyValue |	s _ WriteStream on: ''.	[aStream peek isLetter] whileTrue: [s nextPut: aStream next].	type _ s contents asSymbol.	aStream skip: 1.	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.	^ self basicNew setType: type		cursorPoint: x@y		buttons: buttons		keyValue: keyValue! !BorderedMorph subclass: #MorphicModel	instanceVariableNames: 'model slotName open '	classVariableNames: 'TimeOfError '	poolDictionaries: ''	category: 'Morphic-Kernel'!!MorphicModel commentStamp: 'di 5/22/1998 16:35' prior: 0!MorphicModel comment:'MorphicModels are used to represent structures with state and behavior as well as graphical structure.  A morphicModel is usually the root of a morphic tree depicting its appearance.  The tree is constructed concretely by adding its consituent morphs to a world.When a part is named in a world, it is given a new slot in the model.  When a part is sensitized, it is named, and a set of mouse-driven methods is also generated in the model.  These may be edited to induce particular behavior.  When a variable is added through the morphic world, it is given a slot in the model, along with a set of access methods.In addition for public variables (and this is the default for now), methods are generated and called in any outer model in which this model gets embedded, thus propagating variable changes outward.'!!MorphicModel methodsFor: 'initialization' stamp: 'di 5/16/1998 17:08'!delete	(model isKindOf: MorphicModel) ifFalse: [^ super delete].	(PopUpMenu confirm:'Shall I remove the slot ', slotName, 'along with all associated methods?') ifTrue: [		(model class selectors select: [:s | s beginsWith: slotName])			do: [:s | model class removeSelector: s].		(model class instVarNames includes: slotName)			ifTrue: [model class removeInstVarName: slotName].	] ifFalse: [		(PopUpMenu confirm:'...but should I at least dismiss this morph?[choose no to leave everything unchanged]')			ifFalse: [^ self]].	super delete.! !!MorphicModel methodsFor: 'initialization' stamp: 'tk 4/15/97'!duplicate: newGuy from: oldGuy	"oldGuy has just been duplicated and will stay in this world.  Make sure all the MorphicModel requirements are carried out for the copy.  Ask user to rename it.  "	newGuy installModelIn: oldGuy world.	newGuy copySlotMethodsFrom: oldGuy slotName.! !!MorphicModel methodsFor: 'initialization' stamp: 'di 7/17/97 10:32'!initialize	super initialize.	open _ false.	bounds _ 0@0 corner: 200@100.	self color: Color transparent;		setBorderWidth: 2 borderColor: Color yellow! !!MorphicModel methodsFor: 'initialization' stamp: 'di 5/5/1998 00:18'!model: aModel	model _ aModel.	aModel ifNotNil: [aModel addDependent: self]! !!MorphicModel methodsFor: 'initialization' stamp: 'di 6/21/97 13:25'!model: thang slotName: nameOfThisPart	model _ thang.	slotName _ nameOfThisPart.	open _ false.! !!MorphicModel methodsFor: 'access' stamp: 'sw 2/23/98 00:10'!allKnownNames	"Answer a list of all the names of all named objects borne in my instance variable values"	^ self instanceVariableValues select: [:e | (e ~~ nil) and: [e knownName ~~ nil]] thenCollect: [:e | e knownName]! !!MorphicModel methodsFor: 'access'!model 	^ model! !!MorphicModel methodsFor: 'access'!slotName	^ slotName! !!MorphicModel methodsFor: 'access' stamp: '6/7/97 10:40 di'!wantsSlot	"Override this default for models that want to be installed in theri model"	^ false! !!MorphicModel methodsFor: 'geometry'!newBounds: newBounds	self bounds: newBounds! !!MorphicModel methodsFor: 'geometry'!recomputeBounds	| bnds |	bnds _ submorphs first bounds.	bounds _ bnds origin corner: bnds corner. "copy it!!"	fullBounds _ nil.	bounds _ self fullBounds.! !!MorphicModel methodsFor: 'printing'!initString	^ String streamContents:		[:s | s nextPutAll: self class name;			nextPutAll: ' newBounds: (';			print: bounds;			nextPutAll: ') model: self slotName: ';			print: slotName]! !!MorphicModel methodsFor: 'compilation'!addPartNameLike: className withValue: aMorph	| otherNames i default partName stem |	stem _ className first asLowercase asString , className allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (default _ stem, i printString)]		whileTrue: [i _ i + 1].	partName _ FillInTheBlank		request: 'Please give this part a name'		initialAnswer: default.	(otherNames includes: partName)		ifTrue: [self inform: 'Sorry, that name is already used'. ^ nil].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "Assumes added as last field"	^ partName! !!MorphicModel methodsFor: 'compilation' stamp: 'sw 4/28/1998 00:21'!assureNameFor: anObject	| aName |	(aName _ self nameFor: anObject) ifNotNil: [^ aName].	^ self namePartSilently: anObject! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 4/15/97'!choosePartName	"When I am renamed, get a slot, make default methods, move any existing methods.  ** Does not clean up old inst var name or methods**  "	| old |	old _ slotName.	super choosePartName.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: self world model slotName: slotName.	old == nil 		ifTrue: [self compilePropagationMethods]		ifFalse: [self copySlotMethodsFrom: old].			"old ones not erased!!"! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 4/18/97'!compileAccessForSlot: aSlotName	"Write the method to get at this inst var.  "	"Instead call the right thing to make this happen?"	| s  |	s _ WriteStream on: (String new: 2000).	s nextPutAll: aSlotName; cr; tab; nextPutAll: '^', aSlotName.	self class		compile: s contents		classified: 'public access'		notifying: nil.! !!MorphicModel methodsFor: 'compilation'!compileInitMethods	| s nodeDict varNames |	nodeDict _ IdentityDictionary new.	s _ WriteStream on: (String new: 2000).	varNames _ self class allInstVarNames.	s nextPutAll: 'initMorph'.	3 to: self class instSize do:		[:i | (self instVarAt: i) isMorph ifTrue:			[s cr; tab; nextPutAll: (varNames at: i) , ' _ '.			s nextPutAll: (self instVarAt: i) initString; nextPutAll: '.'.			nodeDict at: (self instVarAt: i) put: (varNames at: i)]].	submorphs do: 		[:m | s cr; tab; nextPutAll: 'self addMorph: '.		m printConstructorOn: s indent: 1 nodeDict: nodeDict.		s nextPutAll: '.'].	self class		compile: s contents		classified: 'initialization'		notifying: nil.! !!MorphicModel methodsFor: 'compilation'!compilePropagationMethods	| varName |	(self class organization listAtCategoryNamed: 'private - propagation' asSymbol)		do: [:sel | varName _ sel allButLast.			model class compilePropagationForVarName: varName slotName: slotName]! !!MorphicModel methodsFor: 'compilation' stamp: '6/7/97 10:43 di'!installModelIn: aWorld	self wantsSlot ifFalse: [^ self].  "No real need to install"	slotName _ aWorld model addPartNameLike: self class name withValue: self.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: aWorld model slotName: slotName.	self compilePropagationMethods.	aWorld model compileAccessForSlot: slotName.! !!MorphicModel methodsFor: 'compilation' stamp: 'sw 11/1/97 00:41'!instanceVariableValues	"MorphicModel76 someInstance instanceVariableValues"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!MorphicModel methodsFor: 'compilation'!nameFor: aMorph	"Return the name of the slot containing the given morph or nil if that morph has not been named."	| allNames start |	allNames _ self class allInstVarNames.	start _ MorphicModel allInstVarNames size + 1.	start to: allNames size do: [:i |		(self instVarAt: i) == aMorph ifTrue: [^ allNames at: i]].	^ nil! !!MorphicModel methodsFor: 'compilation' stamp: 'sw 1/29/98 21:44'!namePartSilently: anObject	| stem otherNames i partName |	stem _ anObject class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem _ stem copyFrom: 1 to: stem size - 5].	stem _ stem first asLowercase asString, stem allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (partName _ stem, i printString)]		whileTrue: [i _ i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: anObject.  "assumes added as last field"	self class compileAccessorsFor: partName.	^ partName! !!MorphicModel methodsFor: 'compilation'!propagate: value as: partStoreSelector	model ifNil: [^ self]."	Later we can cache this for more speed as follows...	(partName == cachedPartName and: [slotName == cachedSlotName])		ifFalse: [cachedPartName _ partName.				cachedSlotName _ slotName.				cachedStoreSelector _ (slotName , partStoreSelector) asSymbol].	model perform: cachedStoreSelector with: value]."	model perform: (self slotSelectorFor: partStoreSelector) with: value! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 10/31/97 12:33'!removeAll	"Clear out all script methods and subpart instance variables in me.  Start over."	"self removeAll"	"MorphicModel2 removeAll"self class == MorphicModel ifTrue: [^ self].	"Must be a subclass!!"self class removeCategory: 'scripts'.self class instVarNames do: [:nn | self class removeInstVarName: nn].! !!MorphicModel methodsFor: 'compilation'!slotSelectorFor: selectorBody	| selector |	model ifNil: [^ nil].	"Make up selector from slotname if any"	selector _ (slotName ifNil: [selectorBody]					ifNotNil: [slotName , selectorBody]) asSymbol.	(model canUnderstand: selector) ifFalse:		[self halt: 'Compiling a null response for ' , model class name , '>>' , selector].	^ selector! !!MorphicModel methodsFor: 'compilation'!use: cachedSelector orMakeModelSelectorFor: selectorBody in: selectorBlock	| selector |	model ifNil: [^ nil].	cachedSelector ifNil:			["Make up selector from slotname if any"			selector _ (slotName ifNil: [selectorBody]								ifNotNil: [slotName , selectorBody]) asSymbol.			(model class canUnderstand: selector) ifFalse:				[(self confirm: 'Shall I compile a null response for'							, Character cr asString							, model class name , '>>' , selector)						ifFalse: [self halt].				model class compile: (String streamContents:								[:s | selector keywords doWithIndex:										[:k :i | s nextPutAll: k , ' arg' , i printString].								s cr; nextPutAll: '"Automatically generated null response."'.								s cr; nextPutAll: '"Add code below for appropriate behavior..."'.])							classified: 'input events'							notifying: nil]]		ifNotNil:			[selector _ cachedSelector].	^ selectorBlock value: selector! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!allowSubmorphExtraction	^ self isOpen! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:16'!isOpen	"Support drag/drop and other edits."	^ open! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!openToDragNDrop	"Support drag/drop when open to edits."	^ self isOpen! !!MorphicModel methodsFor: 'drag and drop' stamp: 'di 6/22/97 23:17'!wantsDroppedMorph: aMorph event: evt	"Supports adding morphs by dropping."	^ self isOpen! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:39'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self isOpen ifTrue: [aCustomMenu add: 'close editing' action: #closeToEdits]			ifFalse: [aCustomMenu add: 'open editing' action: #openToEdits].! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!closeToEdits	"Disable this morph's ability to add and remove morphs via drag-n-drop."	open _ false! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!openToEdits	"Enable this morph's ability to add and remove morphs via drag-n-drop."	open _ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MorphicModel class	instanceVariableNames: 'prototype '!!MorphicModel class methodsFor: 'instance creation' stamp: 'di 2/21/98 11:01'!includeInNewMorphMenu	"Only include Models that are appropriate"	^ false! !!MorphicModel class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:26'!new	"Return a copy of the prototype, if there is one.	Otherwise create a new instance normally."	self hasPrototype ifTrue: [^ prototype fullCopy].	^ super new! !!MorphicModel class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:27'!newBounds: bounds model: thang slotName: nameOfThisPart	^ (super new model: thang slotName: nameOfThisPart)		newBounds: bounds! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 5/13/1998 14:33'!acceptsLoggingOfCompilation	"Dont log sources for my automatically-generated subclasses.  Can easily switch this back when it comes to deal with Versions, etc."	^ self == MorphicModel or: [(name last isDigit) not]! !!MorphicModel class methodsFor: 'compilation' stamp: 'tk 3/10/98 18:03'!categoryForSubclasses	^ 'Morphic-Models'! !!MorphicModel class methodsFor: 'compilation'!chooseNewName	"Rename this class."	| oldName newName |	oldName _ self name.		[newName _ (FillInTheBlank request: 'Please give this Model a name'					initialAnswer: oldName) asSymbol.		newName = oldName ifTrue: [^ self].		Smalltalk includesKey: newName]		whileTrue:		[PopUpMenu notify: 'Sorry, that name is already in use.'].	self rename: newName.! !!MorphicModel class methodsFor: 'compilation'!compileAccessorsFor: varName	self compile: ('&var	"Return the value of &var"	^ &var'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&varPut: newValue	"Assign newValue to &var.	Add code below to update related graphics appropriately..."	&var _ newValue.'			copyReplaceAll: '&var' with: varName)		classified: 'public access' notifying: nil.	self compile: ('&var: newValue	"Assigns newValue to &var and updates owner"	&var _ newValue.	self propagate: &var as: ''&var:'''			copyReplaceAll: '&var' with: varName)		classified: 'private - propagation' notifying: nil.! !!MorphicModel class methodsFor: 'compilation'!compilePropagationForVarName: varName slotName: slotName	self compile: (('&slot&var: newValue	"The value of &var in &slot has changed to newValue.	This value can be read elsewhere in code with		&slot &var	and it can be stored into with		&slot &varPut: someValue"	"Add code for appropriate response here..."'			copyReplaceAll: '&var' with: varName)			copyReplaceAll: '&slot' with: slotName)		classified: 'input events' notifying: nil.! !!MorphicModel class methodsFor: 'compilation'!newSubclass	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Morphic-Models'! !!MorphicModel class methodsFor: 'compilation' stamp: 'tk 3/15/98 20:13'!officialClass	"We want to make a new instance of the receiver, which is a subclass of MorphicModel.  Answer who to make a new subclass of.  Also used to tell if a given class is a UniClass, existing only for its single instance."	^ self name last isDigit ifTrue: [MorphicModel] ifFalse: [self]		"MorphicModel7 can not have subclasses, but Slider and SystemWindow may"! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 8/4/97 17:16'!wantsChangeSetLogging	"Log changes for MorphicModel itself and for things like PlayWithMe2, but not for automatically-created subclasses like MorphicModel1, MorphicModel2, etc."	^ self == MorphicModel or:		[(self class name beginsWith: 'Morphic') not]! !!MorphicModel class methodsFor: 'queries'!hasPrototype	"Return true if there is a prototype for this morph."	^ prototype ~~ nil! !!MorphicModel class methodsFor: 'prototype access'!prototype	"Return the prototype for this morph."	^ prototype! !!MorphicModel class methodsFor: 'prototype access'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph fullCopy.	(prototype isKindOf: MorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!MorphicModel class methodsFor: 'housekeeping' stamp: 'jm 7/30/97 16:40'!removeUninstantiatedModels	"With the user's permission, remove the classes of any models that have neither instances nor subclasses."	"MorphicModel removeUninstantiatedModels"	| candidatesForRemoval ok |	Smalltalk garbageCollect.	candidatesForRemoval _		MorphicModel subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c |		ok _ self confirm: 'Are you certain that youwant to delete the class ', c name, '?'.		ok ifTrue: [c removeFromSystem]].! !MorphicModel subclass: #MorphicModel1	instanceVariableNames: 'player11 player21 '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!!MorphicModel1 methodsFor: 'public access'!player11	^ player11! !!MorphicModel1 methodsFor: 'public access'!player11Put: t1 	player11 _ t1! !!MorphicModel1 methodsFor: 'public access'!player21	^ player21! !!MorphicModel1 methodsFor: 'public access'!player21Put: t1 	player21 _ t1! !!MorphicModel1 methodsFor: 'private - propagation'!player11: t1 	player11 _ t1.	self propagate: player11 as: 'player11:'! !!MorphicModel1 methodsFor: 'private - propagation'!player21: t1 	player21 _ t1.	self propagate: player21 as: 'player21:'! !MorphicModel subclass: #MorphicModel2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!MorphicModel subclass: #MorphicModel3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!MorphicModel subclass: #MorphicModel4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!Object subclass: #MorphicTransform	instanceVariableNames: 'offset angle scale '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!MorphicTransform commentStamp: 'di 5/22/1998 16:35' prior: 0!This class implements simple translation, scaling and rotation for points, as well as inverse transformations.  These transformations are used in TransformMorphs (clipping scrollers) and TransformationMorphs (general flex-morph wrappers) to map, eg, global mouse coords into local coords, and to invert, eg, local damage rectangles into global damage rectangles.!!MorphicTransform methodsFor: 'accessing'!angle	^ angle! !!MorphicTransform methodsFor: 'accessing'!offset	^ offset! !!MorphicTransform methodsFor: 'accessing'!scale	^ scale! !!MorphicTransform methodsFor: 'accessing'!withAngle: a	"Return a copy of me with a different Angle"	^ self copy setAngle: a! !!MorphicTransform methodsFor: 'accessing'!withOffset: a	"Return a copy of me with a different Offset"	^ self copy setOffset: a! !!MorphicTransform methodsFor: 'accessing'!withScale: a	"Return a copy of me with a different Scale"	^ self copy setScale: a! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 3/4/98 19:10'!composedWith: aTransform	"Return a new transform that has the effect of transforming points first by the receiver and then by the argument."	self isIdentity ifTrue: [^ aTransform].	aTransform isIdentity ifTrue: [^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransform! !!MorphicTransform methodsFor: 'transformations'!invert: aPoint	"Transform the given point from local to global coordinates."	| p3 p2 |	self isPureTranslation ifTrue: [^ aPoint - offset].	p3 _  aPoint * scale.	p2 _ ((p3 x * angle cos) + (p3 y * angle sin))		@ ((p3 y * angle cos) - (p3 x * angle sin)).	^ (p2 - offset) asIntegerPoint! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 2/21/98 22:32'!invertRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		^ outerRect topLeft corner: outerRect bottomRight + (1@1)]! !!MorphicTransform methodsFor: 'transformations'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ self isPureTranslation and: [offset = (0@0)]! !!MorphicTransform methodsFor: 'transformations'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^ angle = 0.0 and: [scale = 1.0]! !!MorphicTransform methodsFor: 'transformations'!sourceQuadFor: aRectangle	^ aRectangle innerCorners collect: 		[:p | self transform: p]! !!MorphicTransform methodsFor: 'transformations'!transform: aPoint	"Transform the given point from global to local coordinates."	| p2 p3 |	self isPureTranslation ifTrue: [^ aPoint + offset].	p2 _ aPoint + offset.	p3 _ (((p2 x * angle cos) - (p2 y * angle sin))		@ ((p2 y * angle cos) + (p2 x * angle sin)))			/ scale.	^ p3 asIntegerPoint! !!MorphicTransform methodsFor: 'private'!setAngle: aFloat	angle _ aFloat.! !!MorphicTransform methodsFor: 'private'!setOffset: aPoint	offset _ aPoint.! !!MorphicTransform methodsFor: 'private'!setOffset: aPoint angle: a scale: s	offset _ aPoint.	angle _ a.	scale _ s! !!MorphicTransform methodsFor: 'private'!setScale: aFloat	scale _ aFloat.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MorphicTransform class	instanceVariableNames: ''!!MorphicTransform class methodsFor: 'instance creation'!identity	^ self offset: 0@0 angle: 0.0 scale: 1.0! !!MorphicTransform class methodsFor: 'instance creation'!new	^ self offset: 0@0! !!MorphicTransform class methodsFor: 'instance creation'!offset: aPoint	^ self offset: aPoint angle: 0.0 scale: 1.0! !!MorphicTransform class methodsFor: 'instance creation'!offset: aPoint angle: a scale: s	^ self basicNew setOffset: aPoint angle: a scale: s! !MouseSensorMorph subclass: #MouseDownMorph	instanceVariableNames: 'mouseDownSelector mouseMoveSelector mouseUpSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/25/1998 21:45'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph."template..."	aCustomMenu addLine.	aCustomMenu add: 'rename me' action: #renameMe.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model slot' action: #plugMouseDownToSlot.	aCustomMenu add: 'plug mouseMove to model slot' action: #plugMouseMoveToSlot.	aCustomMenu add: 'plug all to model slots' action: #plugAllToSlots.	aCustomMenu addLine.	aCustomMenu add: 'plug mouseDown to model' action: #plugMouseDownToModel.	aCustomMenu add: 'plug mouseMove to model' action: #plugMouseMoveToModel.	aCustomMenu add: 'plug all to model' action: #plugAllToModel.	aCustomMenu addLine.	aCustomMenu add: 'set target...' action: #setTarget.	aCustomMenu add: 'set mouseDown selector...' action: #setMouseDownSelector.	aCustomMenu add: 'set mouseMove selector...' action: #setMouseMoveSelector.	aCustomMenu add: 'set mouseUp selector...' action: #setMouseUpSelector.! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/16/98 08:13'!plugAllToModel	self plugMouseDownToModel; plugMouseMoveToSlot! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/16/98 08:13'!plugAllToSlots	self plugMouseDownToSlot; plugMouseMoveToSlot.! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/25/1998 21:45'!plugMouseDownToModel	mouseDownSelector _ (self knownName , 'MouseDown:event:') asSymbol.	model class compile: ('&nameMouseDown: trueOrFalse event: event	"A mouseDown event has occurred.	Add code to handle it here below..."'			copyReplaceAll: '&name' with: self knownName)		classified: 'input events' notifying: nil! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/25/1998 21:45'!plugMouseDownToSlot	| varName |	mouseDownSelector _ (self knownName , 'MouseDown:event:') asSymbol.	varName _ self knownName , 'MouseDown'.	model class addSlotNamed: varName.	model class compile: ('&name: trueOrFalse event: event	"A mouseDown event has occurred.	Add code to handle it here below..."	&name _ trueOrFalse.'			copyReplaceAll: '&name' with: varName)		classified: 'input events' notifying: nil! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/25/1998 21:44'!plugMouseMoveToModel	mouseMoveSelector _ (self knownName , 'MouseMove:event:') asSymbol.	model class compile: ('&nameMouseMove: location event: event	"A mouseMove event has occurred.	Add code to handle it here below..."'			copyReplaceAll: '&name' with: self knownName)		classified: 'input events' notifying: nil! !!MouseDownMorph methodsFor: 'menu' stamp: 'di 4/25/1998 21:44'!plugMouseMoveToSlot	| varName |	mouseMoveSelector _ (self knownName , 'MouseMove:event:') asSymbol.	varName _ self knownName , 'MouseMove'.	model class addSlotNamed: varName.	model class compile: ('&name: location event: event	"A mouseMove event has occurred.	Add code to handle it here below..."	&name _ location.'			copyReplaceAll: '&name' with: varName)		classified: 'input events' notifying: nil! !!MouseDownMorph methodsFor: 'event handling' stamp: 'di 4/13/98 15:55'!handlesMouseDown: evt	^ model ~~ nil! !!MouseDownMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 13:52'!mouseDown: event	"Relay a mouseDown event to my model."	mouseDownSelector ifNotNil:		[mouseDownSelector numArgs = 0			ifTrue: [^ model perform: mouseDownSelector].		mouseDownSelector numArgs = 1			ifTrue: [^ model perform: mouseDownSelector with: event].		mouseDownSelector numArgs = 2			ifTrue: [^ model perform: mouseDownSelector with: true with: event].		^ self error: 'mouseDownselector must take 0, 1, or 2 arguments']! !!MouseDownMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 14:11'!mouseMove: event	"Relay a mouseMove event to my model."	mouseMoveSelector ifNotNil:		[mouseMoveSelector numArgs = 0			ifTrue: [^ model perform: mouseMoveSelector].		mouseMoveSelector numArgs = 1			ifTrue: [^ model perform: mouseMoveSelector with: event cursorPoint].		mouseMoveSelector numArgs = 2			ifTrue: [^ model perform: mouseMoveSelector with: event cursorPoint with: event].		^ self error: 'mouseMoveSelector must take 0, 1, or 2 arguments']! !!MouseDownMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 13:53'!mouseUp: event	"Relay a mouseUp event to my model."	mouseUpSelector ifNotNil:		[mouseUpSelector numArgs = 0			ifTrue: [^ model perform: mouseUpSelector].		mouseUpSelector numArgs = 1			ifTrue: [^ model perform: mouseUpSelector with: event].		^ self error: 'mouseUpselector must take 0, or 1 argument'].	mouseDownSelector ifNotNil:		["Or send mouseDown: false..."		mouseDownSelector numArgs = 2			ifTrue: [^ model perform: mouseDownSelector with: false with: event].		^ self error: 'mouseDownselector must take 2 arguments']! !Controller subclass: #MouseMenuController	instanceVariableNames: 'redButtonMenu redButtonMessages yellowButtonMenu yellowButtonMessages blueButtonMenu blueButtonMessages '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!MouseMenuController commentStamp: 'di 5/22/1998 16:36' prior: 0!MouseMenuController comment:'I am a Controller that modifies the scheduling of user activities so that the three mouse buttons can be used to make selections or display menus. The menu items are unary messages to the value of sending my instance the message menuMessageReceiver.'!!MouseMenuController methodsFor: 'initialize-release'!release	super release.	redButtonMenu release.	yellowButtonMenu release.	blueButtonMenu release! !!MouseMenuController methodsFor: 'initialize-release'!reset	"Eliminate references to all mouse button menus."	redButtonMenu _ nil.	redButtonMessages _ nil.	yellowButtonMenu _ nil.	yellowButtonMessages _ nil.	blueButtonMenu _ nil.	blueButtonMessages _ nil! !!MouseMenuController methodsFor: 'control defaults'!controlActivity 	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint _ Sensor cursorPoint.	super controlActivity.	cursorPoint = Sensor cursorPoint	ifTrue: [ sensor redButtonPressed & self viewHasCursor 				ifTrue: [^self redButtonActivity].			sensor yellowButtonPressed & self viewHasCursor 				ifTrue: [^self yellowButtonActivity].			sensor blueButtonPressed & self viewHasCursor 				ifTrue: [^self blueButtonActivity]]! !!MouseMenuController methodsFor: 'control defaults'!isControlActive 	"Refer to the comment in Controller|isControlActive."	Sensor blueButtonPressed ifTrue: [^ false].	^ view containsPoint: sensor cursorPoint! !!MouseMenuController methodsFor: 'menu setup'!blueButtonMenu: aSystemMenu blueButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	blue mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	blueButtonMenu release.	blueButtonMenu _ aSystemMenu.	blueButtonMessages _ anArray! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu _ aSystemMenu.	redButtonMessages _ anArray! !!MouseMenuController methodsFor: 'menu setup' stamp: 'sw 1/15/98 18:59'!shiftedYellowButtonMenu	"Serves as a default backstop; every situation where a shifted menu is anticipated should reimplement this"	^ PopUpMenu labels: 'noshiftmenuavailable' lines: #()! !!MouseMenuController methodsFor: 'menu setup'!shiftedYellowButtonMessages	"Refer to comment under shiftedYellowButtonMenu.  2/5/96 sw"	^ #(notYetImplemented notYetImplemented notYetImplemented notYetImplemented)! !!MouseMenuController methodsFor: 'menu setup'!yellowButtonMenu: aSystemMenu yellowButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	yellow mouse button to be aSystemMenu. The corresponding messages 	that should be sent are listed in the array, anArray."	yellowButtonMenu release.	yellowButtonMenu _ aSystemMenu.	yellowButtonMessages _ anArray! !!MouseMenuController methodsFor: 'menu messages'!blueButtonActivity	"Determine which item in the blue button pop-up menu is selected. If 	one is selected, then send the corresponding message to the object 	designated as the menu message receiver."	| index |	blueButtonMenu ~~ nil		ifTrue: 			[index _ blueButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(blueButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages'!menuMessageReceiver	"Answer the object that should be sent a message when a menu item is 	selected."	^self! !!MouseMenuController methodsFor: 'menu messages'!performMenuMessage: aSelector	"Perform a menu command by sending self the message aSelector.	 Default does nothing special."	^self perform: aSelector! !!MouseMenuController methodsFor: 'menu messages'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self menuMessageReceiver perform:							(redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 1/25/96'!shiftedYellowButtonActivity	"Present the alternate (shifted) menu and take action accordingly.  .	: let #shiftedYellowButtonActivity: do the work"	| index shiftMenu |	(shiftMenu _ self shiftedYellowButtonMenu) == nil ifTrue:		[^ super controlActivity].	self shiftedYellowButtonActivity: shiftMenu! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 1/26/96'!shiftedYellowButtonActivity: shiftMenu	"Present the alternate (shifted) menu and take action accordingly.  If we get here, shiftMenu is known to be non-nil.  "	| index  |	(index _ shiftMenu startUp) ~= 0		ifTrue:			[self menuMessageReceiver performMenuMessage: (self shiftedYellowButtonMessages at: index)]		ifFalse:			[super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 7/29/97 17:36'!startUpYellowButtonMenu	"Factored out so that subclasses can use a caption if desired"	^ yellowButtonMenu startUp! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sw 7/29/97 17:37'!unshiftedYellowButtonActivity	"Put up the regular yellow-button menu and take action as appropriate"	| index  |	yellowButtonMenu ~~ nil		ifTrue: 			[index _ self startUpYellowButtonMenu.			index ~= 0 				ifTrue: [self menuMessageReceiver performMenuMessage:							(yellowButtonMessages at: index)]]		ifFalse:			[super controlActivity]! !!MouseMenuController methodsFor: 'menu messages'!yellowButtonActivity	"Determine which item in the yellow button pop-up menu is selected. If 	one is selected, then send the corresponding message to the object 	designated as the menu message receiver.	1/18/96 sw: added the escape to shifted variant	1/24/96 sw: separate methods for shifted and unshifted variant.	1/25/96 sw: speeded up by passing shifted menu along"	| shiftMenu |	^ (Sensor leftShiftDown and: [(shiftMenu _ self shiftedYellowButtonMenu) notNil])		ifTrue: [self shiftedYellowButtonActivity: shiftMenu]		ifFalse:	[self unshiftedYellowButtonActivity]! !MouseSensorMorph subclass: #MouseOverMorph	instanceVariableNames: 'mouseEnterSelector mouseMoveSelector mouseLeaveSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!MouseOverMorph methodsFor: 'event handling' stamp: 'di 4/13/98 15:55'!handlesMouseOver: evt	^ model ~~ nil! !!MouseOverMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 13:55'!mouseEnter: event	"Relay a mouseEnter event to my model."	mouseEnterSelector ifNotNil:		[mouseEnterSelector numArgs = 0			ifTrue: [^ model perform: mouseEnterSelector].		mouseEnterSelector numArgs = 1			ifTrue: [^ model perform: mouseEnterSelector with: event].		mouseEnterSelector numArgs = 2			ifTrue: [^ model perform: mouseEnterSelector with: true with: event].		^ self error: 'mouseEnterselector must take 0, 1, or 2 arguments']! !!MouseOverMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 14:15'!mouseLeave: event	"Relay a mouseLeave event to my model."	mouseLeaveSelector ifNotNil:		[mouseLeaveSelector numArgs = 0			ifTrue: [^ model perform: mouseLeaveSelector].		mouseLeaveSelector numArgs = 1			ifTrue: [^ model perform: mouseLeaveSelector with: event].		^ self error: 'mouseLeaveSelector must take 0, or 1 argument'].	mouseEnterSelector ifNotNil:		["Or send mouseEnter: false..."		mouseEnterSelector numArgs = 2			ifTrue: [^ model perform: mouseEnterSelector with: false with: event].		^ self error: 'mouseEnterSelector must take 2 arguments']! !!MouseOverMorph methodsFor: 'event handling' stamp: 'di 4/17/1998 14:14'!mouseMove: event	"Relay a mouseMove event to my model."	mouseMoveSelector ifNotNil:		[mouseMoveSelector argumentCount = 0			ifTrue: [^ model perform: mouseMoveSelector].		mouseMoveSelector argumentCount = 1			ifTrue: [^ model perform: mouseMoveSelector with: event cursorPoint].		mouseMoveSelector argumentCount = 2			ifTrue: [^ model perform: mouseMoveSelector with: event cursorPoint with: event].		^ self error: 'mouseMoveSelector must take 0, 1, or 2 arguments']! !Component subclass: #MouseSensorMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!MouseSensorMorph methodsFor: 'initialization' stamp: 'di 4/13/98 12:18'!initialize	super initialize.	self bounds: (0@0 extent: 20@20)! !!MouseSensorMorph methodsFor: 'testing' stamp: 'di 5/7/1998 00:41'!installedself halt: 'under construction'"	^ (owner ~~ nil) and: [owner isWorldOrHandMorph not]"! !!MouseSensorMorph methodsFor: 'drawing' stamp: 'di 4/15/98 21:03'!fullDrawOn: aCanvas	self installed ifFalse: [self drawOn: aCanvas]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MouseSensorMorph class	instanceVariableNames: ''!!MouseSensorMorph class methodsFor: 'as yet unclassified' stamp: 'di 4/15/98 21:53'!includeInNewMorphMenu	"Only include instances of subclasses of me"	^ self ~~ MouseSensorMorph! !Morph subclass: #MovieMorph	instanceVariableNames: 'playMode msecsPerFrame rotationDegrees scalePoint frameList currentFrameIndex dwellCount '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!MovieMorph methodsFor: 'initialization' stamp: 'jm 7/24/97 15:05'!initialize	super initialize.	color _ (Color r: 1 g: 0 b: 1).	playMode _ #stop.  "#stop, #playOnce, or #loop"	msecsPerFrame _ 200.	rotationDegrees _ 0.	scalePoint _ 1.0@1.0.	frameList _ EmptyArray.	currentFrameIndex _ 1.	dwellCount _ 0.! !!MovieMorph methodsFor: 'accessing'!form	^ self currentFrame form! !!MovieMorph methodsFor: 'accessing' stamp: 'sw 3/11/98 20:33'!maxScaleFactor	^ 5! !!MovieMorph methodsFor: 'accessing' stamp: 'sw 3/3/98 01:59'!newScaleFactor: scaleFactor previousScaleFactor: oldScaleFactor	self scalePoint: scaleFactor asPoint! !!MovieMorph methodsFor: 'accessing'!rotationDegrees	^ rotationDegrees! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!rotationDegrees: newRotationDegrees	| frame |	newRotationDegrees ~= rotationDegrees ifTrue: [		self changed.		rotationDegrees _ newRotationDegrees.		frame _ self currentFrame.		frame ifNotNil: [frame rotationDegrees: newRotationDegrees].		self layoutChanged.		self changed].! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!scalePoint	^ scalePoint! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!scalePoint: newScalePoint	| frame |	newScalePoint ~= scalePoint ifTrue: [		self changed.		scalePoint _ newScalePoint.		frame _ self currentFrame.		frame ifNotNil: [frame scalePoint: newScalePoint].		self layoutChanged.		self changed].! !!MovieMorph methodsFor: 'drawing'!drawOn: aCanvas	| frame |	frame _ self currentFrame.	frame ~~ nil		ifTrue: [^ frame drawOn: aCanvas]		ifFalse: [^ super drawOn: aCanvas].! !!MovieMorph methodsFor: 'geometry-testing'!containsPoint: p	| frame |	frame _ self currentFrame.	((frame ~~ nil) and: [playMode = #stop])		ifTrue: [^ frame containsPoint: p]		ifFalse: [^ super containsPoint: p].! !!MovieMorph methodsFor: 'stepping'!step	playMode = #stop ifTrue: [^ self].	dwellCount > 0 ifTrue: [		dwellCount _ dwellCount - 1.		^ self].	currentFrameIndex < frameList size		ifTrue: [^ self setFrame: currentFrameIndex + 1].	playMode = #loop		ifTrue: [self setFrame: 1]		ifFalse: [playMode _ #stop].! !!MovieMorph methodsFor: 'stepping'!stepTime	^ msecsPerFrame! !!MovieMorph methodsFor: 'menu' stamp: 'sw 4/16/1998 22:45'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu _ MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' action: #editDrawing.		subMenu add: 'set rotation center' action: #setRotationCenter.		subMenu add: 'play once' action: #playOnce.		subMenu add: 'play loop' action: #playLoop.		subMenu add: 'stop playing' action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' action: #nextFrame]].	subMenu add: 'extract this frame' action: #extractFrame:.	movies _		(self world rootMorphsAt: aHandMorph targetOffset)			select: [:m | (m isKindOf: MovieMorph) or:						[m isKindOf: SketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' action: #insertIntoMovie:].	aCustomMenu add: 'movie...' subMenu: subMenu! !!MovieMorph methodsFor: 'menu'!advanceFrame	currentFrameIndex < frameList size		ifTrue: [self setFrame: currentFrameIndex + 1]		ifFalse: [self setFrame: 1].! !!MovieMorph methodsFor: 'menu' stamp: 'sw 4/22/1998 17:29'!editDrawing	| frame |	frame _ self currentFrame.	frame ~~ nil ifTrue: [frame editDrawingIn: self pasteUpMorph forBackground: false]! !!MovieMorph methodsFor: 'menu'!extractFrame: evt	| f |	f _ self currentFrame.	f ifNil: [^ self].	frameList _ frameList copyWithout: f.	frameList isEmpty		ifTrue: [self position: f position]		ifFalse: [self setFrame: currentFrameIndex].	evt hand attachMorph: f.! !!MovieMorph methodsFor: 'menu' stamp: 'sw 4/2/98 15:48'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isKindOf: SketchMorph) ifTrue:		[aTarget _ aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!MovieMorph methodsFor: 'menu'!nextFrame	currentFrameIndex < frameList size		ifTrue: [self setFrame: currentFrameIndex + 1].! !!MovieMorph methodsFor: 'menu'!playLoop	playMode _ #loop.! !!MovieMorph methodsFor: 'menu'!playOnce	self setFrame: 1.	playMode _ #playOnce.! !!MovieMorph methodsFor: 'menu'!previousFrame	currentFrameIndex > 1		ifTrue: [self setFrame: currentFrameIndex - 1].! !!MovieMorph methodsFor: 'menu' stamp: 'jm 7/24/97 15:05'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!MovieMorph methodsFor: 'menu'!stopPlaying	playMode _ #stop.	self setFrame: 1.! !!MovieMorph methodsFor: 'private'!currentFrame	frameList isEmpty ifTrue: [^ nil].	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	^ frameList at: currentFrameIndex! !!MovieMorph methodsFor: 'private'!insertFrames: newFrames	"Insert the given collection of frames into this movie just after the currentrame."	frameList isEmpty ifTrue: [		frameList _ newFrames asArray copy.		self setFrame: 1.		^ self].	frameList _		frameList			copyReplaceFrom: currentFrameIndex + 1  "insert before"			to: currentFrameIndex			with: newFrames.! !!MovieMorph methodsFor: 'private' stamp: 'jm 7/24/97 15:05'!setFrame: newFrameIndex	| oldFrame p newFrame |	oldFrame _ self currentFrame.	oldFrame ifNil: [^ self].	self changed.	p _ oldFrame referencePosition.	currentFrameIndex _ newFrameIndex.	currentFrameIndex > frameList size		ifTrue: [currentFrameIndex _ frameList size].	currentFrameIndex < 1		ifTrue: [currentFrameIndex _ 1].	newFrame _ frameList at: currentFrameIndex.	newFrame rotationDegrees: rotationDegrees scalePoint: scalePoint.	newFrame referencePosition: p.	oldFrame delete.	self addMorph: newFrame.	dwellCount _ newFrame framesToDwell.	self layoutChanged.	self changed.! !SketchMorph subclass: #MultiuserTinyPaint	instanceVariableNames: 'drawState '	classVariableNames: 'LastMouseIndex PenColorIndex PenIndex PenSizeIndex '	poolDictionaries: ''	category: 'Morphic-Widgets'!!MultiuserTinyPaint commentStamp: 'di 5/22/1998 16:36' prior: 0!MultiuserTinyPaint comment:'A very simple paint program that handles multiple users (hands).Each user has their own brush size and color.'!!MultiuserTinyPaint methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	color _ Color veryVeryLightGray.	drawState _ IdentityDictionary new.	self clear.! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!handlesMouseDown: evt	^ true! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseDown: evt	| state |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	state at: LastMouseIndex put: evt cursorPoint.! !!MultiuserTinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseMove: evt	| state lastP p pen |	state _ drawState at: evt hand ifAbsent: [^ self].	lastP _ state at: LastMouseIndex.	p _ evt cursorPoint.	p = lastP ifTrue: [^ self].	pen _ state at: PenIndex.	pen drawFrom: lastP - bounds origin to: p - bounds origin.	self invalidRect: (		((lastP min: p) - pen sourceForm extent) corner:		((lastP max: p) + pen sourceForm extent)).	state at: LastMouseIndex put: p.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 9/26/97 14:50'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'clear' action: #clear.	aCustomMenu add: 'pen color' action: #setPenColor:.	aCustomMenu add: 'pen size' action: #setPenSize:."	aCustomMenu add: 'fill' action: #fill:."! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor hand: hand	| state |	(drawState includesKey: hand) ifFalse: [self createDrawStateFor: hand].	state _ drawState at: hand.	(state at: PenIndex) color: aColor.	state at: PenColorIndex put: aColor.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!clear	| newPen |	self form: ((Form extent: 400@300 depth: 8) fillColor: color).	drawState do: [:state |		newPen _ Pen newOnForm: originalForm.		newPen roundNib: (state at: PenSizeIndex).		newPen color: (state at: PenColorIndex).		state at: PenIndex put: newPen].! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!fill: evt	| state fillPt |	(drawState includesKey: evt hand) ifFalse: [self createDrawStateFor: evt hand].	state _ drawState at: evt hand.	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self world viewBox origin - self position].	originalForm shapeFill: (state at: PenColorIndex) interiorPoint: fillPt.	self changed.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 9/26/97 14:47'!penSize: anInteger hand: hand	| state |	(drawState includesKey: hand) ifFalse: [self createDrawStateFor: hand].	state _ drawState at: hand.	state at: PenSizeIndex put: anInteger.	(state at: PenIndex) roundNib: anInteger.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor:hand:.! !!MultiuserTinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!setPenSize: evt	| menu sizes |	menu _ MenuMorph new.	sizes _ (0 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:hand:			argumentList: (Array with: w with: evt hand)].	menu popUpAt: evt hand position event: evt.! !!MultiuserTinyPaint methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!createDrawStateFor: aHand	| pen state |	pen _ Pen newOnForm: originalForm.	state _ Array new: 4.	state at: PenIndex put: pen.	state at: PenSizeIndex put: 3.	state at: PenColorIndex put: Color red.	state at: LastMouseIndex put: nil.	drawState at: aHand put: state.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MultiuserTinyPaint class	instanceVariableNames: ''!!MultiuserTinyPaint class methodsFor: 'class initialization' stamp: 'jm 11/4/97 07:15'!initialize	"MultiuserTinyPaint initialize"	"indices into the state array for a given hand"	PenIndex _ 1.	PenSizeIndex _ 2.	PenColorIndex _ 3.	LastMouseIndex _ 4.! !Object subclass: #NetNameResolver	instanceVariableNames: ''	classVariableNames: 'DefaultHostName ResolverBusy ResolverError ResolverReady ResolverSemaphore ResolverUninitialized '	poolDictionaries: ''	category: 'System-Network'!!NetNameResolver commentStamp: 'di 5/22/1998 16:36' prior: 0!NetNameResolver comment:'This class implements TCP/IP style network name lookup and translation facilities.'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NetNameResolver class	instanceVariableNames: ''!!NetNameResolver class methodsFor: 'class initialization' stamp: 'jm 9/17/97 16:18'!initialize	"NetNameResolver initialize"	"Note: On the Mac, the name resolver is asynchronous (i.e., Squeak can do other things while it is working), but can only handle one request at a time. On other platforms, such as Unix, the resolver is synchronous; a call to, say, the name lookup primitive will block all Squeak processes until it returns."	"Resolver Status Values"	ResolverUninitialized _ 0.	"network is not initialized"	ResolverReady _ 1.			"resolver idle, last request succeeded"	ResolverBusy _ 2.			"lookup in progress"	ResolverError _ 3.			"resolver idle, last request failed"	DefaultHostName _ ''.! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 06:19'!addressFromString: addressString	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."	"NetNameResolver addressFromString: '1.2.3.4'"	"NetNameResolver addressFromString: '1,2,3,4'"	"NetNameResolver addressFromString: '1 2 3 4'"	| newAddr s byte delimiter |	newAddr _ ByteArray new: 4.	s _ ReadStream on: addressString.	s skipSeparators.	1 to: 4 do: [:i |		byte _ self readDecimalByteFrom: s.		byte = nil ifTrue: [^ nil].		newAddr at: i put: byte.		i < 4 ifTrue: [			delimiter _ s next.			((delimiter = $.) or: [(delimiter = $,) or: [delimiter = $ ]])				ifFalse: [^ nil]]].	^ newAddr! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 16:52'!stringFromAddress: addr	"Return a string representing the given host address as four decimal bytes delimited with decimal points."	"NetNameResolver stringFromAddress: NetNameResolver localHostAddress"	| s |	s _ WriteStream on: ''.	1 to: 3 do: [ :i | (addr at: i) printOn: s. s nextPut: $.].	(addr at: 4) printOn: s.	^ s contents! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:44'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	| deadline ready success |	(hostName isEmpty not and: [hostName first isDigit]) ifTrue: [		"assume a numeric host address if first character is a digit"		^ self addressFromString: hostName].	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfName: hostName.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primNameLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:52'!localAddressString	"Return a string representing the local host address as four decimal bytes delimited with decimal points."	"NetNameResolver localAddressString"	^ NetNameResolver stringFromAddress: NetNameResolver localHostAddress! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:31'!localHostAddress	"Return the local address of this host."	"NetNameResolver localHostAddress"	^ self primLocalAddress! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/15/97 16:46'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.40')		timeout: 30"	| deadline ready success |	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfAddress: hostAddress.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primAddressLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 9/17/97 16:26'!promptUserForHostAddress	"Ask the user for a host name and return its address."	"NetNameResolver promptUserForHostAddress"	^ NetNameResolver promptUserForHostAddressDefault: ''! !!NetNameResolver class methodsFor: 'lookups' stamp: 'jm 11/4/97 07:15'!promptUserForHostAddressDefault: defaultName	"Ask the user for a host name and return its address. If the default name is the empty string, use the last host name as the default."	"NetNameResolver promptUserForHostAddressDefault: ''"	| default hostName serverAddr |	Socket initializeNetwork.	defaultName isEmpty		ifTrue: [default _ DefaultHostName]		ifFalse: [default _ defaultName].	hostName _ FillInTheBlank		request: 'Host name or address?'		initialAnswer: default.	hostName isEmpty ifTrue: [^ 0].	serverAddr _ NetNameResolver addressForName: hostName timeout: 15.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', hostName].	hostName size > 0 ifTrue: [DefaultHostName _ hostName].	^ serverAddr! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'jm 3/9/98 13:00'!initializeNetworkIfFail: errorBlock	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetworkIfFail: [self error: 'network initialization failed']"	| semaIndex result |	self primNameResolverStatus = ResolverUninitialized		ifFalse: [^ self].  "network is already initialized"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [result _ self primInitializeNetwork: semaIndex].	"result is nil if network initialization failed, self if it succeeds"	result ifNil: [errorBlock value].! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'jm 3/9/98 12:56'!primInitializeNetwork: resolverSemaIndex	"Initialize the network drivers on platforms that need it, such as the Macintosh, and return nil if network initialization failed or the reciever if it succeeds. Since mobile computers may not always be connected to a network, this method should NOT be called automatically at startup time; rather, it should be called when first starting a networking application. It is a noop if the network driver has already been initialized. If non-zero, resolverSemaIndex is the index of a VM semaphore to be associated with the network name resolver. This semaphore will be signalled when the resolver status changes, such as when a name lookup query is completed."	"Note: some platforms (e.g., Mac) only allow only one name lookup query at a time, so a manager process should be used to serialize resolver lookup requests."	<primitive: 200>	^ nil  "return nil if primitive fails"! !!NetNameResolver class methodsFor: 'primitives'!primAbortLookup	"Abort the current lookup operation, freeing the name resolver for the next query."	<primitive: 205>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primAddressLookupResult	"Return the host name found by the last host address lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 204>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primLocalAddress	"Return the local address of this host."	<primitive: 206>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameLookupResult	"Return the host address found by the last host name lookup. Returns nil if the last lookup was unsuccessful."	<primitive: 202>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameResolverError	"Return an integer reflecting the error status of the last network name resolver request. Zero means no error."	<primitive: 208>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primNameResolverStatus	"Return an integer reflecting the status of the network name resolver. For a list of possible values, see the comment in the 'initialize' method of this class."	<primitive: 207>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primStartLookupOfAddress: hostAddr	"Look up the given host address in the Domain Name Server to find its name. This call is asynchronous. To get the results, wait for it to complete or time out and then use primAddressLookupResult."	<primitive: 203>	self primitiveFailed! !!NetNameResolver class methodsFor: 'primitives'!primStartLookupOfName: hostName	"Look up the given host name in the Domain Name Server to find its address. This call is asynchronous. To get the results, wait for it to complete or time out and then use primNameLookupResult."	<primitive: 201>	self primitiveFailed! !!NetNameResolver class methodsFor: 'private'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255."	| digitSeen value digit |	digitSeen _ false.	value _ 0.	[aStream atEnd] whileFalse: [		digit _ aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			digitSeen ifFalse: [^ nil].			^ value].		digitSeen _ true.		value _ (value * 10) + digit].	(digitSeen and: [value <= 255]) ifFalse: [^ nil].	value > 255 ifTrue: [^ nil].  "exceeds the range of a single byte integer"	^ value! !!NetNameResolver class methodsFor: 'private' stamp: 'jm 3/12/98 11:01'!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primNameResolverStatus].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [			status = ResolverBusy ifTrue: [self primAbortLookup].			^ false].! !!NetNameResolver class methodsFor: 'private' stamp: 'jm 9/15/97 16:56'!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self primNameResolverStatus.	status = ResolverUninitialized ifTrue: [^ false].	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primNameResolverStatus].	^ status ~= ResolverBusy! !HandleMorph subclass: #NewHandleMorph	instanceVariableNames: 'hand offset lastPointBlock waitingForClickInside '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!NewHandleMorph methodsFor: 'all' stamp: 'di 5/18/1998 15:27'!followHand: aHand forEachPointDo: block1 lastPointDo: block2	hand _ aHand.	pointBlock _ block1.	lastPointBlock _ block2.	self position: hand lastEvent cursorPoint - (self extent // 2)! !!NewHandleMorph methodsFor: 'all' stamp: 'di 5/17/1998 21:24'!initialize	waitingForClickInside _ true.	super initialize! !!NewHandleMorph methodsFor: 'all' stamp: 'di 5/17/1998 21:57'!step	| evt |	evt _ hand lastEvent.	evt anyButtonPressed		ifTrue: [waitingForClickInside _ false.				self position: evt cursorPoint - (self extent // 2).				pointBlock value: self center]		ifFalse: [waitingForClickInside					ifTrue: [(self containsPoint: evt cursorPoint)								ifFalse: ["mouse wandered out before clicked"										^ self delete]]					ifFalse: [lastPointBlock value: self center.							^ self delete]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NewHandleMorph class	instanceVariableNames: ''!!NewHandleMorph class methodsFor: 'as yet unclassified' stamp: 'di 5/3/1998 10:08'!includeInNewMorphMenu	^ false! !Object subclass: #NewParagraph	instanceVariableNames: 'text textStyle firstCharacterIndex container lines positionWhenComposed offsetToEnd maxRightX selectionStart selectionStop '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!NewParagraph commentStamp: 'di 5/22/1998 16:36' prior: 0!NewParagraph comment:'A Paragraph represents text that has been laid out, or composed, in some container.	text 		A Text with encoded per-character emphasis.	textStyle	A TextStyle with font set, line height and horizontal alignment.	firstCharacterIndex    The starting index in text for this paragraph, allowing				composition of a long text into a number of containers.	container	A Rectangle or TextContainer that determines where text can go.	lines		An Array of TextLines comprising the final layout of the text				after it has been composed within its container.	positionWhenComposed   As its name implies.  Allows display at new locations				without the need to recompose the text.Lines are ordered vertically.  However, for a given y, there may be several lines in left to right order.  Lines must never be empty, even if text is empty.'!!NewParagraph methodsFor: 'access' stamp: 'di 11/16/97 09:02'!adjustedFirstCharacterIndex	"Return the index in the text where this paragraph WOULD begin if nothing had changed, except the size of the text -- ie if there have only been an insertion of deletion in the preceding morphs"	offsetToEnd ifNil: [^ -1].	^ text size - offsetToEnd! !!NewParagraph methodsFor: 'access' stamp: 'di 10/24/97 17:38'!extent	^ container width @ (lines last bottom - lines first top)! !!NewParagraph methodsFor: 'access' stamp: 'di 11/8/97 15:41'!firstCharacterIndex	^ firstCharacterIndex! !!NewParagraph methodsFor: 'access' stamp: 'di 10/23/97 21:01'!lastCharacterIndex	^ lines last last! !!NewParagraph methodsFor: 'access' stamp: 'sw 1/13/98 21:31'!string	^ text string! !!NewParagraph methodsFor: 'access' stamp: 'di 10/21/97 14:39'!text	^ text! !!NewParagraph methodsFor: 'access' stamp: 'jm 11/19/97 20:27'!textOwner: ignored  "See TextOnCurve"! !!NewParagraph methodsFor: 'access' stamp: 'di 10/21/97 14:39'!textStyle	^ textStyle! !!NewParagraph methodsFor: 'access' stamp: 'di 10/23/97 19:33'!textStyle: aTextStyle 	"Set the style by which the receiver should display its text."	textStyle _ aTextStyle! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/8/97 15:31'!compose: t style: ts from: startingIndex in: textContainer	text _ t.	textStyle _ ts.	firstCharacterIndex _ startingIndex.	offsetToEnd _ text size - firstCharacterIndex.	container _ textContainer.	self composeAll! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/15/97 09:21'!composeAll	self composeLinesFrom: firstCharacterIndex		withLines: OrderedCollection new		atY: container top.! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/15/97 09:21'!composeAllStartingAt: characterIndex	firstCharacterIndex _ characterIndex.	offsetToEnd _ text size - firstCharacterIndex.	self composeAll! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/16/97 16:15'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'composition' stamp: 'di 10/22/97 11:13'!compositionRectangle	^ container! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/16/97 16:12'!recomposeFrom: characterIndex orLineAbove: lineAbove	"lineAbove is true when there is need to recompose the prior line (not strictly the one above) as well, owing to edits that may have affected, eg, word breaks."	| priorLines startLine |	startLine _ self lineIndexForCharacter: characterIndex.	lineAbove ifTrue: [startLine _ startLine-1 max: 1].	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	priorLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | priorLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first		withLines: priorLines		atY: (lines at: startLine) top! !!NewParagraph methodsFor: 'selection' stamp: 'di 11/8/97 11:45'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: (aPoint adhereTo: line rectangle) index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 5/19/1998 20:39'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: line last+1)		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'jm 11/19/97 22:56'!containsPoint: aPoint	^ (lines at: (self lineIndexForPoint: aPoint)) rectangle		containsPoint: aPoint! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/2/97 14:31'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 11/30/97 12:10'!selectionRects	"Return an array of rectangles representing the selection region."	selectionStart ifNil: [^ Array new].	^ self selectionRectsFrom: selectionStart to: selectionStop! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/1/97 09:56'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomLeft)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [:i | rects addLast: (lines at: i) rectangle].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/2/97 19:57'!selectionStart: startBlock selectionStop: stopBlock	selectionStart _ startBlock.	selectionStop _ stopBlock.! !!NewParagraph methodsFor: 'editing' stamp: 'di 5/22/1998 09:22'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range boxes box |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]."				*This doesn't work in morphic*				Need to replace by a highlighting morph that waits for moueUp.				Utilities awaitMouseUpIn: (editor transform invertRect: box)						repeating: []						ifSucceed: [(att actOnClickFor: model) ifTrue: [action _ true]]."								(att actOnClickFor: model)					ifTrue: [Sensor waitNoButton.  "FIX THIS"							action _ true]				].			].	^ action! !!NewParagraph methodsFor: 'editing' stamp: 'di 11/11/97 09:33'!replaceFrom: start to: stop with: aText displaying: displayBoolean 	"Compatibility with old Paragraph" 	text replaceFrom: start to: stop with: aText.		"Update the text."	self recomposeFrom: start orLineAbove: true! !!NewParagraph methodsFor: 'display' stamp: 'di 12/1/97 19:52'!caretWidth	^ 2! !!NewParagraph methodsFor: 'display' stamp: 'di 5/7/1998 09:21'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle _ aCanvas clipRect.	offset _ somePosition - positionWhenComposed.	leftInRun _ 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line _ lines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun _ displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!NewParagraph methodsFor: 'display' stamp: 'di 12/2/97 19:56'!displaySelectionInLine: line on: aCanvas	| leftX rightX w |	selectionStart ifNil: [^ self].  "No selection"	selectionStart = selectionStop		ifTrue: ["Only show caret on line where clicked"				selectionStart textLine ~= line ifTrue: [^ self]]		ifFalse: ["Test entire selection before or after here"				(selectionStop stringIndex < line first					or: [selectionStart stringIndex > (line last+1)])					ifTrue: [^ self].  "No selection on this line"				(selectionStop stringIndex = line first					and: [selectionStop textLine ~= line])					ifTrue: [^ self].  "Selection ends on line above"				(selectionStart stringIndex = (line last+1)					and: [selectionStop textLine ~= line])					ifTrue: [^ self]].  "Selection begins on line below"	selectionStart stringIndex < line first		ifTrue: [leftX _ line left]		ifFalse: [leftX _ selectionStart left].	(selectionStop stringIndex > (line last+1)			or: [selectionStop stringIndex = (line last+1)					and: [selectionStop textLine ~= line]])		ifTrue: [rightX _ line right]		ifFalse: [rightX _ selectionStop left].	selectionStart = selectionStop ifTrue:		[rightX _ rightX + 1.		w _ self caretWidth.		1 to: w do:			[:i |  "Draw caret triangles at top and bottom"			aCanvas fillRectangle: ((leftX-w+i-1)@(line top+i-1) extent: (w-i*2+3)@1)				color: self selectionColor.			aCanvas fillRectangle: ((leftX-w+i-1)@(line bottom-i) extent: (w-i*2+3)@1)				color: self selectionColor]].	aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: self selectionColor.! !!NewParagraph methodsFor: 'display' stamp: 'di 11/30/97 12:09'!selectionColor	^ (Color r: 0.4 g: 1.0 b: 0)! !!NewParagraph methodsFor: 'private' stamp: 'di 11/8/97 15:47'!adjustLineIndicesBy: delta	firstCharacterIndex _ firstCharacterIndex + delta.	lines do: [:line | line slide: delta].! !!NewParagraph methodsFor: 'private' stamp: 'di 10/26/97 15:57'!adjustRightX	| shrink |	shrink _ container right - maxRightX.	lines do: [:line | line paddingWidth: (line paddingWidth - shrink)].	container _ container withRight: maxRightX! !!NewParagraph methodsFor: 'private' stamp: 'di 5/21/1998 21:45'!deepCopy	"Don't want to copy the container (etc) or fonts in the TextStyle."	| new |	new _ self copy.	new textStyle: textStyle copy		lines: lines copy		text: text deepCopy.	^ new! !!NewParagraph methodsFor: 'private' stamp: 'di 4/14/98 13:17'!fastFindFirstLineSuchThat: lineBlock	"Perform a binary search of the lines array and return the index	of the first element for which lineBlock evaluates as true.	This assumes the condition is one that goes from false to true for	increasing line numbers (as, eg, yval > somey or start char > somex).	If lineBlock is not true for any element, return size+1."	| index low high |	low _ 1.	high _ lines size.	[index _ high + low // 2.	low > high]		whileFalse: 			[(lineBlock value: (lines at: index))				ifTrue: [high _ index - 1]				ifFalse: [low _ index + 1]].	^ low! !!NewParagraph methodsFor: 'private' stamp: 'di 4/14/98 13:11'!lineIndexForCharacter: index	"Answer the index of the line in which to select the character at index."	^ (self fastFindFirstLineSuchThat: [:line | line first > index]) - 1 max: 1! !!NewParagraph methodsFor: 'private' stamp: 'di 4/14/98 13:13'!lineIndexForPoint: aPoint	"Answer the index of the line in which to select the character nearest to aPoint."	| i py |	py _ aPoint y truncated.	"Find the first line at this y-value"	i _ (self fastFindFirstLineSuchThat: [:line | line bottom > py]) min: lines size.	"Now find the first line at this x-value"	[i < lines size and: [(lines at: i+1) top = (lines at: i) top				and: [aPoint x >= (lines at: i+1) left]]]		whileTrue: [i _ i + 1].	^ i! !!NewParagraph methodsFor: 'private' stamp: 'di 10/24/97 17:40'!lines	^ lines! !!NewParagraph methodsFor: 'private' stamp: 'di 11/7/97 12:00'!moveBy: delta	lines do: [:line | line moveBy: delta].	positionWhenComposed _ positionWhenComposed + delta.	container _ container translateBy: delta! !!NewParagraph methodsFor: 'private' stamp: 'di 10/21/97 21:36'!positionWhenComposed: pos	positionWhenComposed _ pos! !!NewParagraph methodsFor: 'private' stamp: 'di 5/21/1998 21:47'!textStyle: ts lines: l text: t	"Private -- just a service for deepCopy"	textStyle _ ts.	lines _ l.	text _ t.! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!centered 	textStyle centered! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!justified 	textStyle justified! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!leftFlush 	textStyle leftFlush! !!NewParagraph methodsFor: 'alignment' stamp: 'di 10/25/97 19:26'!rightFlush 	textStyle rightFlush! !!NewParagraph methodsFor: 'object fileIn' stamp: 'jm 11/13/97 10:31'!convertttfclpm0: varDict ttfclpom0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('offsetToEnd' ) and deal with the information in ()"! !!NewParagraph methodsFor: 'object fileIn' stamp: 'tk 12/29/97 12:14'!convertttfclpm0: varDict ttfclpomss0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('offsetToEnd' 'selectionStart' 'selectionStop' ) and deal with the information in ()"! !!NewParagraph methodsFor: 'object fileIn' stamp: 'di 1/9/98 11:23'!convertttfclpom0: varDict ttfclpomss0: smartRefStrm	"These variables are automatically stored into the new instance ('text' 'textStyle' 'firstCharacterIndex' 'container' 'lines' 'positionWhenComposed' 'offsetToEnd' 'maxRightX' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('selectionStart' 'selectionStop' ) and deal with the information in ()"! !Controller subclass: #NoController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Framework'!!NoController commentStamp: 'di 5/22/1998 16:36' prior: 0!NoController comment:'I represent a controller that never wants control. I am the controller for views that are non-interactive.'!!NoController methodsFor: 'basic control sequence'!startUp	"I do nothing."	^self! !!NoController methodsFor: 'control defaults'!isControlActive 	"Refer to the comment in Controller|isControlActive."	^false! !!NoController methodsFor: 'control defaults'!isControlWanted 	"Refer to the comment in Controller|isControlWanted."	^false! !Object subclass: #Note	instanceVariableNames: 'author timestamp text children title parent url '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!Note commentStamp: 'di 5/22/1998 16:36' prior: 0!Notes are general structures for users notes.  Being used in the Comment application and others.!!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:19'!addChild: aNote	children add: aNote! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!author	^author! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!author: anAuthor	author _ anAuthor! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!children	^children! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:39'!children: aCollection	children _ aCollection.! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:26'!parent	^parent! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:26'!parent: whatever	parent _ whatever! !!Note methodsFor: 'access' stamp: 'mjg 11/24/97 15:12'!storeOn: aStream	aStream nextPutAll: '(Note new;'.	aStream nextPutAll: 'author: ',self author storeString,';'.	aStream nextPutAll: 'text: ',self text storeString,';'.	aStream nextPutAll: 'parent: ',self parent storeString,';'.	aStream nextPutAll: 'timestamp: ',self timestamp storeString,';'.	aStream nextPutAll: 'title: ',self title storeString,';'.	aStream nextPutAll: 'url: ',self url storeString,';'.	aStream nextPutAll: 'yourself)'.! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!text	^text! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!text: aString	text _ aString! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!timestamp	^timestamp! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:18'!timestamp: aDateandTime	timestamp _ aDateandTime! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!title	^title! !!Note methodsFor: 'access' stamp: 'mjg 11/17/97 14:17'!title: aString	title _ aString! !!Note methodsFor: 'access' stamp: 'mjg 11/19/97 10:45'!url	^url! !!Note methodsFor: 'access' stamp: 'mjg 11/19/97 10:45'!url: aString	url_aString.! !AbstractScoreEvent subclass: #NoteEvent	instanceVariableNames: 'duration midiKey velocity channel '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!NoteEvent commentStamp: 'di 5/22/1998 16:36' prior: 0!Represents a note on or off event in a MIDI score.!!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!channel	^ channel! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:02'!channel: midiChannel	channel _ midiChannel.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 19:10'!duration	^ duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:49'!duration: aNumber	duration _ aNumber.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 22:07'!key: midiKeyNum velocity: midiVelocity channel: midiChannel	midiKey _ midiKeyNum.	velocity _ midiVelocity.	channel _ midiChannel.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/18/97 20:58'!midiKey	^ midiKey! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:35'!midiKey: midiKeyNum	midiKey _ midiKeyNum.! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 1/4/98 11:51'!pitch	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/30/97 09:32'!velocity	^ velocity! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 12/31/97 11:51'!velocity: midiVelocity	velocity _ midiVelocity.! !!NoteEvent methodsFor: 'classification' stamp: 'jm 12/31/97 11:48'!isNoteEvent	^ true! !!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:58'!keyName	"Return a note name for my pitch."	| pitchName octave |	pitchName _ #(c cs d ef e f fs g af a bf b) at: (midiKey \\ 12) + 1.	octave _ (#(-1 0 1 2 3 4 5 6 7 8 9) at: (midiKey // 12) + 1) printString.	^ pitchName, octave! !!NoteEvent methodsFor: 'printing' stamp: 'jm 1/3/98 08:59'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': '.	aStream nextPutAll: self keyName.	aStream space.	duration printOn: aStream.	aStream nextPut: $).! !Magnitude subclass: #Number	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Numeric-Numbers'!!Number commentStamp: 'di 5/22/1998 16:36' prior: 0!Number comment:'I am an abstract representation of a number. My subclasses Float, Fraction, and Integer, and their subclasses, provide concrete representations of a numeric quantity.All my subclasses participate in a simple type coercion mechanism that supports mixed-mode arithmetic and comparisons.  It works as follows:  If	self<typeA> op: arg<typeB>fails because of incompatible types, then it is retried in the following guise:	(arg adaptTypeA: self) op: arg adaptToTypeA.This gives the arg of typeB an opportunity to resolve the incompatibility, knowing exactly what two types are involved.  If self is more general, then arg will be converted, and viceVersa.  This mechanism is extensible to any new number classes that one might wish to add to Squeak.  The only requirement is that every subclass of Number must support a pair of conversion methods specific to each of the other subclasses of Number.'!!Number methodsFor: 'arithmetic'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!+ aNumber 	"Answer the sum of the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!- aNumber 	"Answer the difference between the receiver and aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!/ aNumber 	"Answer the result of dividing the receiver by aNumber."	self subclassResponsibility! !!Number methodsFor: 'arithmetic'!// aNumber 	"Integer quotient defined by division with truncation toward negative 	infinity. 9//4 = 2, -9//4 = -3. -0.9//0.4 = -3. \\ answers the remainder 	from this division."	^(self / aNumber) floor! !!Number methodsFor: 'arithmetic'!abs	"Answer a Number that is the absolute value (positive magnitude) of the 	receiver."	self < 0		ifTrue: [^self negated]		ifFalse: [^self]! !!Number methodsFor: 'arithmetic'!negated	"Answer a Number that is the negation of the receiver."	^0 - self! !!Number methodsFor: 'arithmetic'!quo: aNumber 	"Integer quotient defined by division with truncation toward zero. -9 quo: 	4 = -2, -0.9 quo: 0.4 = -2. rem: answers the remainder from this division."	^(self / aNumber) truncated! !!Number methodsFor: 'arithmetic'!reciprocal	"Answer 1 divided by the receiver. Create an error notification if the 	receiver is 0."	self = 0		ifTrue: [^self error: 'zero has no reciprocal']		ifFalse: [^1 / self]! !!Number methodsFor: 'arithmetic'!rem: aNumber 	"Remainder defined in terms of quo:. Answer a Number with the same 	sign as self. e.g. 9 rem: 4 = 1, -9 rem: 4 = -1. 0.9 rem: 0.4 = 0.1."	^self - ((self quo: aNumber) * aNumber)! !!Number methodsFor: 'arithmetic'!\\ aNumber 	"modulo. Remainder defined in terms of //. Answer a Number with the 	same sign as aNumber. e.g. 9\\4 = 1, -9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1."	^self - (self // aNumber * aNumber)! !!Number methodsFor: 'mathematical functions'!arcCos 	"The receiver is the cosine of an angle. Answer the angle measured in 	radians."	^self asFloat arcCos! !!Number methodsFor: 'mathematical functions'!arcSin	"The receiver is the sine of an angle. Answer the angle measured in 	radians."	^self asFloat arcSin! !!Number methodsFor: 'mathematical functions'!arcTan	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^self asFloat arcTan! !!Number methodsFor: 'mathematical functions'!cos	"The receiver represents an angle measured in radians. Answer its cosine."	^self asFloat cos! !!Number methodsFor: 'mathematical functions'!exp	"Answer the exponential of the receiver as a floating point number."	^self asFloat exp! !!Number methodsFor: 'mathematical functions' stamp: 'jm 3/27/98 06:16'!floorLog: radix	"Answer the floor of the log base radix of the receiver."	^ self asFloat floorLog: radix! !!Number methodsFor: 'mathematical functions'!ln	"Answer the natural log of the receiver."	^self asFloat ln! !!Number methodsFor: 'mathematical functions'!log: aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln! !!Number methodsFor: 'mathematical functions'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	(aNumber isInteger)		ifTrue: ["Do the special case of integer power"				^self raisedToInteger: aNumber].	aNumber = 0 ifTrue: [^1].		"Special case of exponent=0"	aNumber = 1 ifTrue: [^self].		"Special case of exponent=1"	^(aNumber * self ln) exp		"Otherwise raise it to the power using logarithms"! !!Number methodsFor: 'mathematical functions'!raisedToInteger: anInteger 	"Answer the receiver raised to the power anInteger where the argument 	must be a kind of Integer. This is a special case of raisedTo:."	(anInteger isInteger)		ifFalse: [^self error: 'raisedToInteger: only works for integral arguments'].	anInteger = 0 ifTrue: [^1].	anInteger = 1 ifTrue: [^self].	anInteger > 1 		ifTrue: [^(self * self raisedToInteger: anInteger // 2)					* (self raisedToInteger: anInteger \\ 2)].	^(self raisedToInteger: anInteger negated) reciprocal! !!Number methodsFor: 'mathematical functions'!sin	"The receiver represents an angle measured in radians. Answer its sine."	^self asFloat sin! !!Number methodsFor: 'mathematical functions'!sqrt	"Answer the square root of the receiver."	^self asFloat sqrt! !!Number methodsFor: 'mathematical functions'!squared	"Answer the receiver multipled by itself."	^self * self! !!Number methodsFor: 'mathematical functions'!tan	"The receiver represents an angle measured in radians. Answer its 	tangent."	^self asFloat tan! !!Number methodsFor: 'truncation and round off'!ceiling	"Answer the integer nearest the receiver toward positive infinity."	self <= 0.0		ifTrue: [^self truncated]		ifFalse: [^self negated floor negated]! !!Number methodsFor: 'truncation and round off' stamp: 'di 2/19/98 21:58'!detentBy: detent atMultiplesOf: grid snap: snap	"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor."	| r1 r2 |	r1 _ self roundTo: grid.  "Nearest multiple of grid"	(self roundTo: detent) = r1 ifTrue: [^ r1].  "Snap to that multiple..."	snap ifTrue: [^ self].  "...or return self"	r2 _ self < r1  "Nearest end of dead zone"		ifTrue: [r1 - (detent asFloat/2)]		ifFalse: [r1 + (detent asFloat/2)].	"Scale values between dead zones to fill range between multiples"	^ r1 + ((self - r2) * grid asFloat / (grid - detent))"	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] 	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]	(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] 	(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]"! !!Number methodsFor: 'truncation and round off'!floor	"Answer the integer nearest the receiver toward negative infinity."	| truncation |	truncation _ self truncated.	self >= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation - 1]! !!Number methodsFor: 'truncation and round off'!rounded	"Answer the integer nearest the receiver."	^(self + (self sign / 2)) truncated! !!Number methodsFor: 'truncation and round off'!roundTo: aNumber 	"Answer the integer that is a multiple of aNumber that is nearest the 	receiver."	^(self / aNumber) rounded * aNumber! !!Number methodsFor: 'truncation and round off'!roundUpTo: aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the 	receiver."	^(self/aNumber) ceiling * aNumber! !!Number methodsFor: 'truncation and round off'!truncated	"Answer an integer nearest the receiver toward zero."	^self quo: 1! !!Number methodsFor: 'truncation and round off'!truncateTo: aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the 	receiver."	^(self quo: aNumber)		* aNumber! !!Number methodsFor: 'testing' stamp: 'sw 4/25/1998 12:50'!basicType	^ #number! !!Number methodsFor: 'testing'!even	"Answer whether the receiver is an even number."	^self \\ 2 = 0! !!Number methodsFor: 'testing'!isFloat	^ false! !!Number methodsFor: 'testing'!isFraction	^ false! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isInf	^ false! !!Number methodsFor: 'testing' stamp: 'tao 4/19/98 23:33'!isInfinite	^ false! !!Number methodsFor: 'testing'!isInteger	^ false! !!Number methodsFor: 'testing' stamp: 'tao 10/10/97 16:36'!isNaN	^ false! !!Number methodsFor: 'testing'!isNumber	^ true! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:18'!negative	"Answer whether the receiver is mathematically negative."	^ self < 0! !!Number methodsFor: 'testing'!odd	"Answer whether the receiver is an odd number."	^self even == false! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:17'!positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ self >= 0! !!Number methodsFor: 'testing'!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'testing' stamp: 'di 4/23/1998 11:02'!strictlyPositive	"Answer whether the receiver is mathematically positive."	^ self > 0! !!Number methodsFor: 'converting'!@ y 	"Primitive. Answer a Point whose x value is the receiver and whose y 	value is the argument. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 18>	^Point x: self y: y! !!Number methodsFor: 'converting'!adaptFloat: aFloat	"If I am involved in arithmetic with a Float, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptFraction: aFraction	"If I am involved in arithmetic with a Fraction, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptInteger: anInteger	"If I am involved in arithmetic with an Integer, I must know whether to convert it."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToFloat	"If I am involved in arithmetic with a Float, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToFraction	"If I am involved in arithmetic with a Fraction, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting'!adaptToInteger	"If I am involved in arithmetic with an Integer, I must know whether to be converted."	self subclassResponsibility! !!Number methodsFor: 'converting'!asInteger	"Answer an Integer nearest the receiver toward zero."	^self truncated! !!Number methodsFor: 'converting'!asPoint	"Answer a Point with the receiver as both coordinates; often used to 	supply the same value in two dimensions, as with symmetrical gridding 	or scaling."	^self @ self! !!Number methodsFor: 'converting' stamp: 'sw 9/8/97 16:30'!asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| pos |	pos _ self \\ 360.	pos > 180 ifTrue: [pos _ pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!Number methodsFor: 'converting'!degreesToRadians	"The receiver is assumed to represent degrees. Answer the conversion to 	radians."	^self asFloat degreesToRadians! !!Number methodsFor: 'converting'!radiansToDegrees	"The receiver is assumed to represent radians. Answer the conversion to 	degrees."	^self asFloat radiansToDegrees! !!Number methodsFor: 'intervals'!to: stop	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by 1."	^Interval from: self to: stop by: 1! !!Number methodsFor: 'intervals'!to: stop by: step	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by step."	^Interval from: self to: stop by: step! !!Number methodsFor: 'intervals'!to: stop by: step do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| nextValue |	nextValue _ self.	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]! !!Number methodsFor: 'intervals'!to: stop do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: 1)."	| nextValue |	nextValue _ self.	[nextValue <= stop]		whileTrue: 			[aBlock value: nextValue.			nextValue _ nextValue + 1]! !!Number methodsFor: 'printing'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Number methodsFor: 'printing' stamp: 'sw 10/31/97 13:54'!newTileMorphRepresentative	^ TileMorph new addArrows; setLiteral: self; addSuffixIfCan! !!Number methodsFor: 'printing'!printOn: aStream	"Default print radix is 10"	self printOn: aStream base: 10! !!Number methodsFor: 'printing'!printStringBase: base	^ String streamContents:		[:strm | self printOn: strm base: base]! !!Number methodsFor: 'printing'!storeOn: aStream 	"Normal printing is OK for storing"	self printOn: aStream! !!Number methodsFor: 'printing'!storeOn: aStream base: base	"Append my printed representation to aStream, incuding the base."	self printOn: aStream base: base! !!Number methodsFor: 'printing'!storeStringBase: base	^ String streamContents: [:strm | self storeOn: strm base: base]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Number class	instanceVariableNames: ''!!Number class methodsFor: 'instance creation' stamp: 'tao 4/23/98 12:19'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value * sign) < 2 ifTrue: [^self error: 'Invalid radix'].			sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].			value _ Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!Number class methodsFor: 'instance creation' stamp: 'tao 4/23/98 12:24'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	| aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	^ self readRemainderOf: (Integer readFrom: aStream base: base)			from: aStream base: base withSign: sign! !!Number class methodsFor: 'instance creation' stamp: 'tao 4/23/98 12:12'!readRemainderOf: integerPart from: aStream base: base withSign: sign	"Read optional fractional part and exponent, and return the final result"	| value fraction fracpos |	value _ integerPart.	(aStream peekFor: $.)		ifTrue: 			["<integer>.<fraction>"			(aStream atEnd not and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: 					[fracpos _ aStream position.					fraction _ Integer readFrom: aStream base: base.					fraction _ 						fraction asFloat / (base raisedTo: aStream position - fracpos).					value _ value asFloat + fraction]				ifFalse: 					["oops - just <integer>."					aStream skip: -1.		"un-gobble the period"					^ value * sign					"Number readFrom: '3r-22.2'"]].	(aStream peekFor: $e)		ifTrue: 			["<integer>e<exponent>"			value _ value * (base raisedTo: (Integer readFrom: aStream))].	(value isFloat and: [value = 0.0 and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !TileMorph subclass: #NumericReadoutTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!NumericReadoutTile methodsFor: 'all' stamp: 'di 1/21/98 09:38'!arrowAction: delta	"Update value based on delta"	self literal: literal + delta! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 5/13/1998 15:20'!literal: anObject	literal _ anObject.	self updateLiteralLabel.	submorphs last informTarget.	"self acceptNewLiteral."		"Show that we are out of date, install is needed"	"self updateLiteralLabel"! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 5/13/1998 15:20'!literal: anObject width: w	literal _ anObject.	self updateLiteralLabelClipped.	submorphs last		setWidth: w;		informTarget.	self updateLiteralLabelClipped.	"self acceptNewLiteral."		"Show that we are out of date, install is needed"	"self updateLiteralLabel"! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 1/29/98 00:49'!mouseMove: evt	"Copied from TileMorph mouseMove to use literal:width: rather than literal:."	| p label |	upArrow ifNotNil:		[p _ evt cursorPoint.		label _ self findA: UpdatingStringMorph.		label ifNotNil: [literal _ label valueFromContents].		(upArrow containsPoint: p)			ifTrue: [self readyForAnotherTick ifTrue:				[self literal: (self numericValue + 1) width: label width.				^ self]].		(downArrow containsPoint: p)			ifTrue: [self readyForAnotherTick ifTrue:				[self literal: (self numericValue - 1) width: label width.				^ self]]].	super mouseMove: evt.! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 10/31/97 13:05'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal _ anObject.	self updateLiteralLabelClipped.	submorphs last		setWidth: w.	self updateLiteralLabelClipped! !!NumericReadoutTile methodsFor: 'all' stamp: 'sw 11/5/97 14:03'!wantsKeyboardFocusFor: aSubmorph	^ aSubmorph putSelector notNil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NumericReadoutTile class	instanceVariableNames: ''!!NumericReadoutTile class methodsFor: 'all' stamp: 'sw 10/3/97 13:59'!defaultW	^ 26! !nil subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields '	poolDictionaries: ''	category: 'Kernel-Objects'!!Object commentStamp: 'di 5/22/1998 16:36' prior: 0!Object comment:'I am the superclass of all classes. I provide default behavior common to all objects, such as class access, copying and printing.'!!Object methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:18'!addInstanceVarNamed: aName withValue: aValue	"Add an instance variable named aName and give it value aValue"	self class addInstVarName: aName asString.	self instVarAt: self class instSize put: aValue! !!Object methodsFor: 'accessing'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger		ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!at: index add: amount	"Add a number to an element of a collection"	self at: index put: (self at: index) + amount! !!Object methodsFor: 'accessing'!at: index modify: aBlock	"Replace the element of the collection with itself transformed by the block"	^ self at: index put: (aBlock value: (self at: index))! !!Object methodsFor: 'accessing'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!atPin: index 	"Return this element of an indexable object.  Return the first or last element if index is out of bounds.  See Object at:. 6/18/96 tk"	<primitive: 60>	self emptyCheck.	index isInteger ifTrue: [		^ index < 1 ifTrue: [self first] ifFalse: [self last]].	index isNumber		ifTrue: [^self atPin: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!atWrap: index 	"Return this element of an indexable object.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds.  See Object at:. 6/18/96 tk"	<primitive: 60>	self size = 0 ifTrue: [self halt].	index isInteger ifTrue: [		^ self at: (index - 1 \\ self size + 1)].	index isNumber		ifTrue: [^self atWrap: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'tk 7/2/97 12:48'!atWrap: index put: value	"Store into this element of an indexable object.  If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds.  6/18/96 tk"^ self at: (index - 1 \\ self size + 1) put: value! !!Object methodsFor: 'accessing'!basicAt: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !!Object methodsFor: 'accessing'!bindWithTemp: aBlock	^ aBlock value: self value: nil! !!Object methodsFor: 'accessing'!do: aBlock	"Singleton objects just upply themselves to the block"	"This is a convenient way to bind a simple variable	to the result of some expression"	^ aBlock value: self! !!Object methodsFor: 'accessing'!readFromString: aString	"Create an object based on the contents of aString."	^self readFrom: (ReadStream on: aString)! !!Object methodsFor: 'accessing'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!Object methodsFor: 'accessing'!yourself	"Answer self."! !!Object methodsFor: 'testing' stamp: 'sw 4/25/1998 12:50'!basicType	"number string boolean player collection sound color etc"	^ #object! !!Object methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!haltIfNil! !!Object methodsFor: 'testing'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Object methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock value! !!Object methodsFor: 'testing'!isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing'!isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing'!isMorph	^ false! !!Object methodsFor: 'testing'!isNil	"Coerces nil to true and everything else to false."	^false! !!Object methodsFor: 'testing'!isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^false! !!Object methodsFor: 'testing'!isText	^ false! !!Object methodsFor: 'testing' stamp: 'tk 10/21/97 12:45'!isTransparent	^ false! !!Object methodsFor: 'testing' stamp: 'sw 2/23/98 00:09'!knownName	^ self name! !!Object methodsFor: 'testing' stamp: 'sw 9/27/96'!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	^ self printString! !!Object methodsFor: 'testing'!notNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!Object methodsFor: 'comparing'!= anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject! !!Object methodsFor: 'comparing'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Object methodsFor: 'comparing'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash! !!Object methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'comparing' stamp: 'di 9/27/97 20:27'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'comparing' stamp: 'di 9/27/97 20:23'!identityHashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Object methodsFor: 'comparing'!~= anObject 	"Answer whether the receiver and the argument do not represent the 	same object."	^self = anObject == false! !!Object methodsFor: 'comparing'!~~ anObject	"Answer whether the receiver and the argument are not the same object 	(do not have the same object pointer)."	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Object methodsFor: 'copying'!clone	<primitive: 148>	self primitiveFailed! !!Object methodsFor: 'copying'!copy	"Answer another instance just like the receiver. Subclasses typically 	override this method; they typically do not override shallowCopy."	^self shallowCopy! !!Object methodsFor: 'copying' stamp: 'sw 5/4/1998 11:28'!copyAddedStateFrom: anotherObject	"Copy the values of instance variables added by the receiver's class from anotherObject to the receiver"	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying'!deepCopy	"Answer a copy of the receiver with its own copy of each instance 	variable."	| newObject class index |	class _ self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index _ self basicSize.			newObject _ class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index _ index - 1]]		ifFalse: [newObject _ class basicNew].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index _ index - 1].	^newObject! !!Object methodsFor: 'copying' stamp: 'jm 11/14/97 11:08'!shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables."	| class newObject index |	<primitive: 148>	class _ self class.	class isVariable		ifTrue: 			[index _ self basicSize.			newObject _ class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index _ index - 1]]		ifFalse: [newObject _ class basicNew].	index _ class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index _ index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'tk 12/4/97 13:21'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream"	| dummy refs class index sub val hashers new |	self allMorphsDo: [:m | m prepareToBeSaved].		"Actors fix open scriptEditors"	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: self.	"inform him about the root"	dummy nextPut: self.	"Do the traverse of the tree"	refs _ dummy references.	"all the objects"	"For each object, make a simple copy, then replace all fields with new copy from dict"	refs keysDo: [:each | refs at: each put: each shallowCopy].		"Watch out for classes that do extra things in copy but not in shallowCopy"	hashers _ OrderedCollection new.	refs associationsDo: [:assoc | 		assoc key == assoc value ifFalse: ["is a new object"			new _ assoc value.			class _ new class.			class isVariable				ifTrue: 					[index _ new basicSize.					[index > 0] whileTrue: 						[sub _ new basicAt: index.						(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [								"If not in refs, then the right value is already in the field"								new basicAt: index put: val].						index _ index - 1]].			index _ class instSize.			[index > 0] whileTrue: 				[sub _ new instVarAt: index.				(val _ refs at: sub ifAbsent: [nil]) ifNotNil: [						"If not in refs, then the right value is already in the field"						new instVarAt: index put: val].				index _ index - 1].			(new respondsTo: #rehash) ifTrue: [hashers add: new].			]].	"Force new sets and dictionaries to rehash"	hashers do: [:each | each rehash].	^ refs at: self! !!Object methodsFor: 'dependents access'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	dependents do: [:o | o == anObject ifTrue: [^ self]].  "anObject is already a dependent"	DependentsFields at: self put: (dependents copyWith: anObject).! !!Object methodsFor: 'dependents access'!breakDependents	"Remove all of the receiver's dependents."	DependentsFields removeKey: self ifAbsent: [].! !!Object methodsFor: 'dependents access' stamp: 'tk 4/13/1998 23:02'!canDiscardEdits	"Return true if this model has no dirty panes."	self dependents do: [:vv |		vv == self ifFalse: [			vv canDiscardEdits ifFalse: [^ false]]].	^ true! !!Object methodsFor: 'dependents access'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	(DependentsFields includesKey: self)		ifTrue: [^ DependentsFields at: self]		ifFalse: [^ #()].! !!Object methodsFor: 'dependents access'!evaluate: actionBlock wheneverChangeIn: aspectBlock	| viewerThenObject objectThenViewer |	objectThenViewer _ self.	viewerThenObject _ ObjectViewer on: objectThenViewer.	objectThenViewer become: viewerThenObject.	"--- Then ---"	objectThenViewer xxxViewedObject: viewerThenObject			evaluate: actionBlock			wheneverChangeIn: aspectBlock! !!Object methodsFor: 'dependents access' stamp: 'jm 3/24/98 15:11'!hasUnacceptedEdits	"Answer true if any of the views on this object has unaccepted edits."	self dependents do: [:v |		v == self ifFalse: [			v hasUnacceptedEdits ifTrue: [^ true]]].	^ false ! !!Object methodsFor: 'dependents access'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self breakDependents! !!Object methodsFor: 'dependents access'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents newDependents |	dependents _ self dependents.	newDependents _ dependents select: [ :d | (d == anObject) not].	newDependents isEmpty		ifTrue: [DependentsFields removeKey: self ifAbsent: []]		ifFalse: [DependentsFields at: self put: newDependents].! !!Object methodsFor: 'updating'!changed	"Receiver changed in a general way; inform all the dependents by 	sending each dependent an update: message."	self changed: self! !!Object methodsFor: 'updating'!changed: aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self dependents do: [:aDependent | aDependent update: aParameter]! !!Object methodsFor: 'updating' stamp: 'tk 5/8/1998 11:55'!modelWakeUp	"A window with me as model is being entered.  Override this to make me examine my state and issue (self changed: #xxx)." ! !!Object methodsFor: 'updating'!okToChange	"Allows a controller to ask this of any model"	^ true! !!Object methodsFor: 'updating'!update: aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^self! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 08:57'!fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:s | self printOn: s]! !!Object methodsFor: 'printing'!isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^false! !!Object methodsFor: 'printing'!longPrintOn: aStream 	"Append to the argument, aStream, the names and values of all its instance variables."	self class allInstVarNames		doWithIndex: [:title :index |			aStream nextPutAll: title; nextPut: $:; space; tab.			(self instVarAt: index) printOn: aStream.			aStream cr].! !!Object methodsFor: 'printing'!longPrintString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream _ WriteStream on: (String new: 100).	self longPrintOn: aStream.	^aStream contents! !!Object methodsFor: 'printing'!printOn: aStream 	"Append to the argument, aStream, a sequence of characters that 	identifies the receiver."	| title |	title _ self class name.	aStream nextPutAll: ((title at: 1) isVowel							ifTrue: ['an ']							ifFalse: ['a '])						, title! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:22'!printString	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limit limitedString |	limit _ 50000.	limitedString _ String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'printing'!storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream nextPutAll: self class name, ' basicNew'].	1 to: self class instSize do:		[:i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:12'!storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:s | self storeOn: s]! !!Object methodsFor: 'printing' stamp: 'sw 5/2/1998 13:55'!stringForReadout	^ self stringRepresentation! !!Object methodsFor: 'printing'!stringRepresentation	"Answer a string that represents the receiver.  For most objects this is simply its printString, but for strings themselves, it's themselves.  6/12/96 sw"	^ self printString ! !!Object methodsFor: 'class membership'!class	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!Object methodsFor: 'class membership'!isKindOf: aClass 	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!Object methodsFor: 'class membership' stamp: 'sw 2/16/98 02:08'!isKindOf: aClass orOf: anotherClass	"Answer whether either of the classes, aClass or anotherClass,, is a superclass or class of the receiver.  A convenience; could be somewhat optimized"	^ (self isKindOf: aClass) or: [self isKindOf: anotherClass]! !!Object methodsFor: 'class membership'!isMemberOf: aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Object methodsFor: 'class membership'!respondsTo: aSymbol 	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^self class canUnderstand: aSymbol! !!Object methodsFor: 'message handling'!perform: aSymbol 	"Primitive. Send the receiver the unary message indicated by the 	argument. The argument is the selector of the message. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not zero. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message handling'!perform: aSymbol with: anObject 	"Primitive. Send the receiver the keyword message indicated by the 	arguments. The first argument is the selector of the message. The other 	argument is the argument of the message to be sent. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not one. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: 'message handling'!perform: aSymbol with: firstObject with: secondObject 	"Primitive. Send the receiver the keyword message indicated by the 	arguments. The first argument is the selector of the message. The other 	arguments are the arguments of the message to be sent. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not two. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message handling'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Primitive. Send the receiver the keyword message indicated by the 	arguments. The first argument is the selector of the message. The other 	arguments are the arguments of the message to be sent. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not three. Optional. See Object documentation 	whatIsAPrimitive."	<primitive: 83>	^self perform: aSymbol withArguments: (Array			with: firstObject			with: secondObject			with: thirdObject)! !!Object methodsFor: 'message handling'!perform: selector withArguments: anArray 	"Primitive. Send the receiver the keyword message indicated by the 	arguments. The argument, selector, is the selector of the message. The 	arguments of the message are the elements of anArray. Invoke 	messageNotUnderstood: if the number of arguments expected by the 	selector is not the same as the length of anArray. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 84>	(selector isMemberOf: Symbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	self primitiveFailed! !!Object methodsFor: 'error handling'!caseError	"Report an error from an in-line or explicit case statement."	self error: 'Case not found, and no otherwise clause'! !!Object methodsFor: 'error handling'!confirm: queryString 	"Put up a yes/no menu with caption aString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"nil confirm: 'Are you hungry?'"	^ SelectionMenu confirm: queryString! !!Object methodsFor: 'error handling'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString.	Answer true if the response is yes, false if no.	If cancel is chosen, evaluate cancelBlock."	| choice |	[true] whileTrue:	[choice _ (PopUpMenu labels:'yesnocancel') startUpWithCaption: aString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	choice = 3 ifTrue: [^ cancelBlock value]]! !!Object methodsFor: 'error handling' stamp: 'tk 4/16/1998 15:53'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Unless the receiver has an error handler defined for the active process, report to the user that the receiver does not understand the argument, aMessage, as a message."	"Testing: (3 activeProcess)"	| handler errorString |	(Preferences autoAccessors and: [self tryToDefineVariableAccess: aMessage])		ifTrue: [^ aMessage sentTo: self].	errorString _ 'Message not understood: ', aMessage selector.	(handler _ Processor activeProcess errorHandler) notNil		ifTrue: [handler value: errorString value: self]		ifFalse: [Debugger openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!Object methodsFor: 'error handling' stamp: 'tk 4/16/1998 15:53'!error: aString 	"The default behavior for error: is the same as halt:. The code is 	replicated in order to avoid showing an extra level of message sending 	in the Debugger. This additional message is the one a subclass should 	override in order to change the error handling behavior."	| handler |	(handler _ Processor activeProcess errorHandler) notNil		ifTrue:			[handler  value: aString value: self]		ifFalse: 			[Debugger				openContext: thisContext				label: aString				contents: thisContext shortStack]	"nil error: 'error message'."! !!Object methodsFor: 'error handling' stamp: 'tk 4/16/1998 15:54'!halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	Debugger		openContext: thisContext		label: 'Halt encountered.'		contents: thisContext shortStack	"nil halt."! !!Object methodsFor: 'error handling' stamp: 'tk 4/16/1998 15:54'!halt: aString 	"This is the typical message to use for inserting breakpoints during 	debugging. It creates and schedules a Notifier with the argument, 	aString, as the label."	Debugger		openContext: thisContext		label: aString		contents: thisContext shortStack	"nil halt: 'Test of halt:.'."! !!Object methodsFor: 'error handling' stamp: 'tk 4/16/1998 15:54'!notify: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Debugger		openContext: thisContext		label: 'Notifier'		contents: aString	"nil notify: 'confirmation message'"! !!Object methodsFor: 'error handling'!notify: aString at: location	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed. Subclasses can	override this and insert an error message at location within aString."	self notify: aString	"nil notify: 'confirmation message' at: 12"! !!Object methodsFor: 'error handling'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	self error: 'a primitive has failed'! !!Object methodsFor: 'error handling'!shouldNotImplement	"Announce that, although the receiver inherits this message, it should 	not implement it."	self error: 'This message is not appropriate for this object'! !!Object methodsFor: 'error handling'!subclassResponsibility	"This message sets up a framework for the behavior of the class' 	subclasses. Announce that the subclass should have implemented this 	message."	self error: 'My subclass should have overridden one of my messages.'! !!Object methodsFor: 'error handling'!tryToDefineVariableAccess: aMessage	"See if the message just wants to get at an instance variable of this class.  Ask the user if its OK.  If so, define the message to read or write that instance or class variable and retry."	| ask newMessage sel |	aMessage arguments size > 1 ifTrue: [^ false].	sel _ aMessage selector asString.	"works for 0 args"	aMessage arguments size = 1 ifTrue: [		sel last = $: ifFalse: [^ false].		sel _ sel copyWithout: $:].	(self class instVarNames includes: sel) ifFalse: [		(self class classVarNames includes: sel asSymbol) ifFalse: [			^ false]].	ask _ self confirm: 'A ', thisContext sender sender receiver 		class printString, ' wants to ', 		(aMessage arguments size = 1 ifTrue: ['write into'] ifFalse: ['read from']), '', sel ,' in class ', self class printString, '.Define a this access message?'.	ask ifTrue: [		aMessage arguments size = 1 			ifTrue: [newMessage _ aMessage selector, ' anObject	', sel, ' _ anObject']			ifFalse: [newMessage _ aMessage selector, '	^', aMessage selector].		self class compile: newMessage classified: 'accessing' notifying: nil].	^ ask! !!Object methodsFor: 'user interface'!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	Inspector openOn: self withEvalPane: false! !!Object methodsFor: 'user interface'!beep	"Make a beep sound.  Every object would like to be able to speak.  6/10/96 sw"	Smalltalk beep! !!Object methodsFor: 'user interface'!defaultBackgroundColor	"Answer the symbol representing the default background color to use if the receiver is used as the model for a StandardSystemView.  4/30/96 sw"	^ #white! !!Object methodsFor: 'user interface'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name! !!Object methodsFor: 'user interface' stamp: 'sw 8/15/97 17:25'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	| adj |	adj _ (3 * Preferences scrollBarWidth) @ 0.	^ Rectangle origin: adj extent: (DisplayScreen actualScreenSize - adj)! !!Object methodsFor: 'user interface' stamp: 'tk 11/3/97 17:47'!inform: aString	"Display a message for the user to read and then dismiss.  6/9/96 sw"	aString size > 0 ifTrue: [(PopUpMenu labels: '  OK  ') startUpWithCaption: aString]! !!Object methodsFor: 'user interface'!initialExtent	"Answer the desired extent for the receiver when a view on it is first opened on the screen. 	5/22/96 sw: in the absence of any override, obtain from RealEstateAgent"	^ RealEstateAgent standardWindowExtent! !!Object methodsFor: 'user interface' stamp: 'di 5/19/1998 20:43'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	Inspector openOn: self withEvalPane: true! !!Object methodsFor: 'user interface'!inspectWithLabel: aLabel	Inspector openOn: self withEvalPane: true withLabel: aLabel! !!Object methodsFor: 'user interface' stamp: 'sw 8/22/97 13:14'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!Object methodsFor: 'user interface'!notYetImplemented	self inform: 'Not yet implemented'! !!Object methodsFor: 'user interface' stamp: 'sw 7/28/97 17:11'!smartInspect	"Like inspect, but for collections with only one element, inspects that element"	^ self inspect! !!Object methodsFor: 'system primitives'!asOop	"Primitive. Answer a SmallInteger whose value is half of the receiver's 	object pointer (interpreting object pointers as 16-bit signed quantities). 	Fail if the receiver is a SmallInteger. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'system primitives'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!Object methodsFor: 'system primitives'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'system primitives'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!Object methodsFor: 'system primitives' stamp: 'tk 5/5/97'!instVarNamed: aString	"Return the value of the instance variabvle in me with that name.  Slow and unclean, but very useful.  "	^ self instVarAt: ((self class allInstVarNames) indexOf: aString)! !!Object methodsFor: 'system primitives' stamp: 'tk 5/5/97'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful.  "	^ self instVarAt: ((self class allInstVarNames) indexOf: aString) put: aValue! !!Object methodsFor: 'system primitives'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!Object methodsFor: 'system primitives'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!Object methodsFor: 'system primitives'!someObject	"Primitive. Answer the first object in the enumeration of all	 objects."	<primitive: 138>	self primitiveFailed.! !!Object methodsFor: 'system primitives' stamp: 'di 1/12/98 14:43'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118>	^ #simulatorFail! !!Object methodsFor: 'private'!errorImproperStore	"Create an error notification that an improper store was attempted."	self error: 'Improper store into indexable object'! !!Object methodsFor: 'private'!errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	self error: 'only integers should be used as indices'! !!Object methodsFor: 'private'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	self error: 'subscript is out of bounds: ' , index printString! !!Object methodsFor: 'private'!mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the	interpreter."	self error: 'NonBoolean receiver--proceed for truth.'.	^true! !!Object methodsFor: 'private' stamp: 'di 5/4/1998 21:53'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System error handling failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		20 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	ScheduledControllers searchForActiveController! !!Object methodsFor: 'private'!species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	^self class! !!Object methodsFor: 'private'!storeAt: offset inTempFrame: aContext	"This message had to get sent to an expression already on the stack	as a Block argument being accessed by the debugger.	Just re-route it to the temp frame."	^ aContext tempAt: offset put: self! !!Object methodsFor: 'associating'!-> anObject	"Answer an Association between self and anObject"	^Association new key: self value: anObject! !!Object methodsFor: 'converting'!as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self! !!Object methodsFor: 'converting'!asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'casing'!caseOf: aBlockAssociationCollection	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Object methodsFor: 'casing'!caseOf: aBlockAssociationCollection otherwise: aBlock	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z _ {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z _ {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'binding'!bindingOf: aString	^nil! !!Object methodsFor: 'macpal' stamp: 'sw 5/7/1998 23:00'!codeStrippedOut: messageString	"When a method is stripped out for external release, it is replaced by a method that calls this"	self halt: 'Code stripped out -- ', messageString, '-- do not proceed.'! !!Object methodsFor: 'macpal' stamp: 'jm 5/6/1998 22:35'!flash	"Do nothing."! !!Object methodsFor: 'macpal' stamp: 'sw 10/13/97 16:38'!ifKindOf: aClass thenDo: aBlock	^ (self isKindOf: aClass) ifTrue: [aBlock value: self]! !!Object methodsFor: 'macpal' stamp: 'jm 5/16/1998 10:32'!playSoundNamed: soundName	"Play the sound with the given name. Do nothing if this image lacks sound playing facilities."	Smalltalk at: #SampledSound ifPresent: [:sampledSound |		sampledSound playSoundNamed: soundName asString].! !!Object methodsFor: 'flagging' stamp: 'sw 2/1/98 16:53'!flag: aSymbol	"Send this message, with a relevant symbol as argument, to flag a message for subsequent retrieval.  For example, you might put the following line in a number of messages:	self flag: #returnHereUrgently	Then, to retrieve all such messages, browse all senders of #returnHereUrgently."! !!Object methodsFor: 'flagging' stamp: 'sw 8/4/97 16:49'!isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging'!isThisEverCalled: msg	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached.  2/5/96 sw"	self halt: 'This is indeed called: ', msg printString! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logEntry	Transcript show: 'Entered ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logExecution	Transcript show: 'Executing ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:22'!logExit	Transcript show:  'Exited ', thisContext sender printString; cr.! !!Object methodsFor: 'translation support'!cCode: codeString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!cCoerce: value to: cType	"Type coercion for translation only; just return the value when running in Smalltalk."	^ value! !!Object methodsFor: 'translation support'!inline: inlineFlag	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!returnTypeC: typeString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!sharedCodeNamed: label inCase: caseNumber	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'translation support'!var: varSymbol declareC: declString	"For translation only; noop when running in Smalltalk."! !!Object methodsFor: 'objects from disk'!comeFullyUpOnReload	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	^ self! !!Object methodsFor: 'objects from disk'!objectToStoreOnDataStream    "Return an object to store on a data stream (externalize myself)."    ^ self! !!Object methodsFor: 'objects from disk' stamp: 'tk 3/24/98 12:51'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method. Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must match its corresponding storeDataOn: method. Also, it must send beginReference: after instantiating the new object but before reading any objects from aDataStream that might reference it.	Allow fewer inst vars, instance does reading, see SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	self class isVariable		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars _ 0.				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self! !!Object methodsFor: 'objects from disk' stamp: 'tk 6/26/97 13:48'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  Does not file out the class of the object.  tk 6/26/97 13:48"	| aFileName fileStream |	aFileName _ self class name asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name?' initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	fileStream _ FileStream newFileNamed: aFileName.	fileStream fileOutClass: nil andObject: self.! !!Object methodsFor: 'objects from disk' stamp: 'jm 12/3/97 21:46'!storeDataOn: aDataStream	"Store myself on a DataStream. Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.	 NOTE: This method must send 'aDataStream beginInstance:size:'		and then put a number of objects (via aDataStream nextPut:/nextPutWeak:).	 Cf. readDataFrom:size:, which must read back what this puts	when given the size that it gave to beginInstance:size:. -- 11/15/92 jhm"	| cntInstVars cntIndexedVars |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object class	instanceVariableNames: ''!!Object class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 17:44'!categoryForUniclasses	"Answer the category into which to place unique-class instances"	^ 'UserObjects'! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!chooseUniqueClassName	| i className |	i _ 1.	[className _ (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i _ i + 1].	^ className! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 12:46'!initialInstance	"Answer the first instance of the receiver, generate an error if there is one already"	self instanceCount > 0 ifTrue: [self error: 'instance(s) already exist.'].	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 12:22'!instanceOfUniqueClass	^ self instanceOfUniqueClassWithInstVarString: '' andClassInstVarString: ''! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 17:44'!instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString	"Create a unique class for the receiver, and answer an instance of it"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass initialInstance! !!Object class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 12:22'!instanceOfUniqueClassWithInstanceVariableNames: aString	"Create a unique class for the receiver, and answer an instance of it"	^ self instanceOfUniqueClassWithInstVarString: aString andClassInstVarString: ''! !!Object class methodsFor: 'instance creation' stamp: 'tk 3/15/98 20:15'!isSystemDefined	"Answer true if the receiver is a system-defined class, and not a UniClass (an instance-specific lightweight class)"	^ self == self officialClass! !!Object class methodsFor: 'instance creation'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject.  If the classes have any instance varaibles with the same names, copy them across.  If this is bad for a class, override this method."	| myInstVars similarInstVars any inst good |	myInstVars _ self allInstVarNames.	similarInstVars _ aSimilarObject class allInstVarNames.	inst _ self new.	myInstVars doWithIndex: [:each :index |		good _ similarInstVars indexOf: each.		good > 0 ifTrue: [			inst instVarAt: index put: 				(aSimilarObject instVarAt: good).			any _ true]].	any == nil ifTrue: ["not related at all"		self subclassResponsibility].	^ inst! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self instanceOfUniqueClass! !!Object class methodsFor: 'instance creation' stamp: 'tk 3/15/98 20:14'!officialClass	"I am not a UniClass.  (See Player officialClass).  Return the class of which to make new subclasses."	^ self! !!Object class methodsFor: 'instance creation'!readFrom: aStream	"Create an object based on the contents of aStream."	| object |	object _ Compiler evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'documentation'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Object class methodsFor: 'documentation'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !!Object class methodsFor: 'private'!initializeDependentsFields	DependentsFields _ IdentityDictionary new: 4	"Object initializeDependentsFields"! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  "	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]! !Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount child field parentField freeBlock lastHash freeLargeContexts freeSmallContexts allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount interruptCheckCounter checkAssertions allocationsBetweenGCs tenuringThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows displayBits '	classVariableNames: 'AllButHashBits AllButMarkBit AllButMarkBitAndTypeMask AllButRootBit AllButTypeMask BaseHeaderSize CharacterTable ClassArray ClassBitmap ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassFloat ClassInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassPseudoContext ClassSemaphore ClassString ClassTranslatedMethod CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero Done ExternalObjectsArray FalseObject FreeSizeMask GCTopMarker HashBits HashBitsOffset HeaderTypeClass HeaderTypeFree HeaderTypeGC HeaderTypeShort HeaderTypeSizeAndClass LargeContextSize MarkBit MinimumForwardTableBytes NilContext NilObject RemapBufferSize RootBit RootTableSize SchedulerAssociation SelectorCannotReturn SelectorDoesNotUnderstand SelectorMustBeBoolean SmallBlockContext SmallContextSize SmallMethodContext SpecialSelectors StackStart StartField StartObj TheDisplay TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject TypeMask Upward '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!ObjectMemory commentStamp: 'di 5/22/1998 16:36' prior: 0!ObjectMemory comment:'This class describes a 32-bit direct-pointer object memory for Smalltalk.  The model is very simple in principle:  a pointer is either a SmallInteger or a 32-bit direct object pointer.SmallIntegers are tagged with a low-order bit equal to 1, and an immediate 31-bit 2s-complement signed value in the rest of the word.All object pointers point to a header, which may be followed by a number of data fields.  This object memory achieves considerable compactness by using a variable header size (the one complexity of the design).  The format of the 0th header word is as follows:	3 bits	reserved for gc (mark, old, dirty)	12 bits	object hash (for HashSets)	5 bits	compact class index	4 bits	object format	6 bits	object size in 32-bit words	2 bits	header type (0: 3-word, 1: 2-word, 2: forbidden, 3: 1-word)If a class is in the compact class table, then this is the only header information needed.  If it is not, then it will have another header word at offset -4 bytes with its class in the high 30 bits, and the header type repeated in its low 2 bits.  It the objects size is greater than 255 bytes, then it will have yet another header word at offset -8 bytes with its full word size in the high 30 bits and its header type repeated in the low two bits.The object format field provides the remaining information as given in the formatOf: method (including isPointers, isVariable, isBytes, and the low 2 size bits of byte-sized objects).This implementation includes incremental (2-generation) and full garbage collection, each with compaction and rectification of direct pointers.  It also supports a bulk-become (exchange object identity) feature that allows many objects to be becomed at once, as when all instances of a class must be grown or shrunk.'!!ObjectMemory methodsFor: 'initialization'!adjustAllOopsBy: bytesToShift	"Adjust all oop references by the given number of bytes. This is done just after reading in an image when the new base address of the object heap is different from the base address in the image."	| oop last |	bytesToShift = 0 ifTrue: [ ^ nil ].	oop _ self firstObject.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self adjustFieldsAndClassOf: oop by: bytesToShift. 		].		last _ oop.		oop _ self objectAfter: oop.	].! !!ObjectMemory methodsFor: 'initialization'!adjustFieldsAndClassOf: oop by: offsetBytes	"Adjust all pointers in this object by the given offset."	| fieldAddr fieldOop classHeader newClassOop |	fieldAddr _ oop + (self lastPointerOf: oop).	[fieldAddr > oop] whileTrue: [		fieldOop _ self longAt: fieldAddr.		(self isIntegerObject: fieldOop) ifFalse: [			self longAt: fieldAddr put: (fieldOop + offsetBytes).		].		fieldAddr _ fieldAddr - 4.	].	(self headerType: oop) ~= HeaderTypeShort ifTrue: [		"adjust class header if not a compact class"		classHeader _ self longAt: (oop - 4).		newClassOop _			(classHeader bitAnd: AllButTypeMask) + offsetBytes.		self longAt: (oop - 4) put: (newClassOop bitOr: (classHeader bitAnd: TypeMask)).	].! !!ObjectMemory methodsFor: 'initialization'!initializeMemoryFirstFree: firstFree 	"Initialize endOfMemory to the top of oop storage space, reserving some space for forwarding blocks, and create the freeBlock from which space is allocated. Also create a fake free chunk at endOfMemory to act as a sentinal for memory scans."	"Note: The amount of space reserved for forwarding blocks should be chosen to ensure that incremental compactions can usually be done in a single pass. However, there should be enough forwarding blocks so a full compaction can be done in a reasonable number of passes, say ten. (A full compaction requires N object-moving passes, where N = number of non-garbage objects / number of forwarding blocks)."	| fwdBlockBytes |	"reserve space for forwarding blocks"	fwdBlockBytes _ MinimumForwardTableBytes.	(memoryLimit - fwdBlockBytes) >= (firstFree + BaseHeaderSize) ifFalse: [		"reserve enough space for a minimal free block of BaseHeaderSize bytes"		fwdBlockBytes _ memoryLimit - (firstFree + BaseHeaderSize).	].	"set endOfMemory and initialize freeBlock"	endOfMemory _ memoryLimit - fwdBlockBytes.	freeBlock _ firstFree.	self setSizeOfFree: freeBlock to: (endOfMemory - firstFree).  "bytes available for oops"	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	checkAssertions ifTrue: [		((freeBlock < endOfMemory) and: [endOfMemory < memoryLimit])			ifFalse: [ self error: 'error in free space computation' ].			(self oopFromChunk: endOfMemory) = endOfMemory			ifFalse: [ self error: 'header format must have changed' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'free block not properly initialized' ].	].! !!ObjectMemory methodsFor: 'initialization' stamp: 'jm 5/8/1998 07:00'!initializeObjectMemory: bytesToShift	"Initialize object memory variables at startup time. Assume endOfMemory is initially set (by the image-reading code) to the end of the last object in the image. Initialization redefines endOfMemory to be the end of the object allocation area based on the total available memory, but reserving some space for forwarding blocks."	"Assume: image reader initializes the following variables:		memory		endOfMemory		memoryLimit		specialObjectsOop		lastHash	"	self inline: false.	checkAssertions _ false.  "set this early to allow assertions in initialization code to use it"	"set the start of the young object space"	youngStart _ endOfMemory.	self initializeMemoryFirstFree: endOfMemory.		"initializes endOfMemory, freeBlock"	"image may be at a different address; adjust oops for new location"	self adjustAllOopsBy: bytesToShift.	specialObjectsOop _ specialObjectsOop + bytesToShift.	"heavily used special objects"	nilObj	_ self splObj: NilObject.	falseObj	_ self splObj: FalseObject.	trueObj	_ self splObj: TrueObject.	rootTableCount _ 0.	child _ 0.	field _ 0.	parentField _ 0.	freeLargeContexts _ NilContext.	freeSmallContexts _ NilContext.	allocationCount _ 0.	lowSpaceThreshold _ 0.	signalLowSpace _ false.	compStart _ 0.	compEnd _ 0.	fwdTableNext _ 0.	fwdTableLast _ 0.	remapBufferCount _ 0.	allocationsBetweenGCs _ 4000.  "do incremental GC after this many allocations"	tenuringThreshold _ 2000.  "tenure all suriving objects if count is over this threshold"	"garbage collection statistics"	statFullGCs _ 0.	statFullGCMSecs _ 0.	statIncrGCs _ 0.	statIncrGCMSecs _ 0.	statTenures _ 0.	statRootTableOverflows _ 0.	displayBits _ 0.  "support for the Acorn VM; ignored if zero"! !!ObjectMemory methodsFor: 'interpreter access'!fetchByte: byteIndex ofObject: oop	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex! !!ObjectMemory methodsFor: 'interpreter access'!fetchClassOf: oop	| ccIndex |	self inline: true.	(self isIntegerObject: oop)		ifTrue: [ ^ self splObj: ClassInteger ].	ccIndex _ (((self baseHeader: oop) >> 12) bitAnd: 16r1F) - 1.	ccIndex < 0		ifTrue: [ ^ (self classHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [			"look up compact class"			^ self fetchPointer: ccIndex				ofObject: (self fetchPointer: CompactClasses ofObject: specialObjectsOop)		].! !!ObjectMemory methodsFor: 'interpreter access'!fetchPointer: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)! !!ObjectMemory methodsFor: 'interpreter access'!fetchWord: fieldIndex ofObject: oop	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)! !!ObjectMemory methodsFor: 'interpreter access'!fetchWordLengthOf: objectPointer	| sz |	sz _ self sizeBitsOf: objectPointer.	^ (sz - BaseHeaderSize) >> 2! !!ObjectMemory methodsFor: 'interpreter access'!instantiateClass: classPointer indexableSize: size	| hash header1 header2 cClass byteSize format inc binc header3 hdrSize fillWord newObj sizeHiBits |"	NOTE: This method supports the backward-compatible split instSize field of the	class format word.  The sizeHiBits will go away and other shifts change by 2	when the split fields get merged in an (incompatible) image change."	self inline: false.	checkAssertions ifTrue: [		size < 0 ifTrue: [ self error: 'cannot have a negative indexable field count' ]].	hash _ self newObjectHash.	header1 _ self formatOfClass: classPointer. "Low 2 bits are 0"	sizeHiBits _ (header1 bitAnd: 16r60000) >> 9.	header1 _ (header1 bitAnd: 16r1FFFF) bitOr: (hash << 17 bitAnd: 16r1FFE0000).	header2 _ classPointer.	header3 _ 0.	cClass _ header1 bitAnd: 16r1F000. "compact class field from format word"	byteSize _ (header1 bitAnd: 16rFC) + sizeHiBits. "size in bytes -- low 2 bits are 0"	format _ (header1 >> 8) bitAnd: 16rF.	format < 8 ifTrue: [		"Bitmaps and Arrays"		inc _ size * 4.	] ifFalse: [		"Strings and Methods"		inc _ (size + 3) bitAnd: 16r1FFFFFFC. "round up"		binc _ 3 - ((size + 3) bitAnd: 3). "odd bytes"		"low bits of byte size go in format field"		header1 _ header1 bitOr: (binc << 8).	].	(byteSize + inc) > 255 ifTrue: [		"requires size header word"		header3 _ byteSize + inc.		header1 _ header1 - (byteSize bitAnd: 16rFF).  "Clear qsize field"	] ifFalse: [		header1 _ header1 + inc.	].	byteSize _ byteSize + inc.	header3 > 0 ifTrue: [		"requires full header"		hdrSize _ 3.	] ifFalse: [		cClass = 0			ifTrue: [ hdrSize _ 2 ]			ifFalse: [ hdrSize _ 1 ].	].	format < 4  "if pointers, fill with nil oop"		ifTrue: [ fillWord _ nilObj ]		ifFalse: [ fillWord _ 0 ].	newObj _ self allocate: byteSize headerSize: hdrSize h1: header1 h2: header2 h3: header3 fill: fillWord.	^ newObj! !!ObjectMemory methodsFor: 'interpreter access'!instantiateSmallClass: classPointer sizeInBytes: sizeInBytes fill: fillValue	"This version of instantiateClass assumes that the total object size is under 256 bytes, the limit for objects with only one or two header words. Note that the size is specified in bytes and should include four bytes for the base header word."	| hash header1 header2 hdrSize |	hash _ self newObjectHash.	header1 _ ((hash << 17) bitAnd: 16r1FFE0000) bitOr:			   (self formatOfClass: classPointer).	header1 _ header1 + (sizeInBytes - (header1 bitAnd: 16rFC)).	header2 _ classPointer.	(header1 bitAnd: 16r1F000) = 0 "is compact class field from format word zero?"		ifTrue: [ hdrSize _ 2 ]		ifFalse: [ hdrSize _ 1 ].	^ self allocate: sizeInBytes headerSize: hdrSize h1: header1 h2: header2 h3: 0 fill: fillValue! !!ObjectMemory methodsFor: 'interpreter access'!integerObjectOf: value	value < 0		ifTrue: [^ ((16r80000000 + value) << 1) + 1]		ifFalse: [^ (value << 1) + 1]! !!ObjectMemory methodsFor: 'interpreter access'!integerValueOf: objectPointer	"Translator produces 'objectPointer >> 1'"	((objectPointer bitAnd: 16r80000000) ~= 0)		ifTrue: ["negative"				^ ((objectPointer bitAnd: 16r7FFFFFFF) >> 1)					- 16r3FFFFFFF - 1  "Faster than -16r40000000 (a LgInt)"]		ifFalse: ["positive"				^ objectPointer >> 1]! !!ObjectMemory methodsFor: 'interpreter access'!isIntegerObject: objectPointer	^ (objectPointer bitAnd: 1) > 0! !!ObjectMemory methodsFor: 'interpreter access'!isIntegerValue: intValue	"Return true if the given value can be represented as a Smalltalk integer value."	"Details: This trick is from Tim Rowledge. Use a shift and XOR to set the sign bit if and only if the top two bits of the given value are the same, then test the sign bit. Note that the top two bits are equal for exactly those integers in the range that can be represented in 31-bits."	^ (intValue bitXor: (intValue << 1)) >= 0! !!ObjectMemory methodsFor: 'interpreter access'!nilObject  "For access from BitBlt module"	^ nilObj! !!ObjectMemory methodsFor: 'interpreter access'!popRemappableOop	"Pop and return the possibly remapped object from the remap buffer."	| oop |	oop _ remapBuffer at: remapBufferCount.	remapBufferCount _ remapBufferCount - 1.	^ oop! !!ObjectMemory methodsFor: 'interpreter access'!pushRemappableOop: oop	"Record the given object in a the remap buffer. Objects in this buffer are remapped when a compaction occurs. This facility is used by the interpreter to ensure that objects in temporary variables are properly remapped."	remapBuffer at: (remapBufferCount _ remapBufferCount + 1) put: oop.! !!ObjectMemory methodsFor: 'interpreter access'!splObj: index	"Return one of the objects in the SpecialObjectsArray"	^ self fetchPointer: index ofObject: specialObjectsOop! !!ObjectMemory methodsFor: 'interpreter access'!storeByte: byteIndex ofObject: oop withValue: valueByte	^ self byteAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + byteIndex		put: valueByte! !!ObjectMemory methodsFor: 'interpreter access'!storePointer: fieldIndex ofObject: oop withValue: valuePointer	"Note must check here for stores of young objects into old ones."	(oop < youngStart) ifTrue: [		self possibleRootStoreInto: oop value: valuePointer.	].	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valuePointer! !!ObjectMemory methodsFor: 'interpreter access'!storePointerUnchecked: fieldIndex ofObject: oop withValue: valuePointer	"Like storePointer:ofObject:withValue:, but the caller guarantees that the object being stored into is a young object or is already marked as a root."	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)			put: valuePointer! !!ObjectMemory methodsFor: 'interpreter access'!storeWord: fieldIndex ofObject: oop withValue: valueWord	^ self longAt: (self cCoerce: oop to: 'char *') + BaseHeaderSize + (fieldIndex << 2)		put: valueWord! !!ObjectMemory methodsFor: 'memory access'!checkAddress: byteAddress	"Keep this method around for debugging the C code."	byteAddress < (self startOfMemory) ifTrue: [		self error: 'bad address: negative'.	].	byteAddress >= memoryLimit ifTrue: [		self error: 'bad address: past end of heap'.	].! !!ObjectMemory methodsFor: 'memory access'!checkedByteAt: byteAddress	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	^ self byteAt: byteAddress! !!ObjectMemory methodsFor: 'memory access'!checkedByteAt: byteAddress put: byte	"Assumes zero-based array indexing."	self checkAddress: byteAddress.	self byteAt: byteAddress put: byte.! !!ObjectMemory methodsFor: 'memory access'!checkedLongAt: byteAddress	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	^ self longAt: byteAddress! !!ObjectMemory methodsFor: 'memory access'!checkedLongAt: byteAddress put: a32BitInteger	"Assumes zero-based array indexing. For testing in Smalltalk, this method should be overridden in a subclass."	self checkAddress: byteAddress.	self checkAddress: byteAddress + 3.	self longAt: byteAddress put: a32BitInteger.! !!ObjectMemory methodsFor: 'header access'!baseHeader: oop	^ self longAt: oop! !!ObjectMemory methodsFor: 'header access'!classHeader: oop	^ self longAt: oop - 4! !!ObjectMemory methodsFor: 'header access'!formatOf: oop"       0      no fields        1      fixed fields only (possibly containing pointers)        2      indexable fields only (possibly containing pointers)        3      both fixed and indexable fields (possibly containing pointers)         4      unused  -- may use for contexts (size = stackPointer for scanning purposes)        5      unused        6      indexable word fields only (no pointers)        7      unused     8-11      indexable byte fields only (no pointers) (low 2 bits are low 2 bits of size)   12-15     compiled methods:                   # of literal oops specified in method header,                   followed by indexable bytes (same interpretation of low 2 bits as above)"	^ ((self baseHeader: oop) >> 8) bitAnd: 16rF! !!ObjectMemory methodsFor: 'header access'!hashBitsOf: oop	^ ((self baseHeader: oop) >> 17) bitAnd: 16rFFF! !!ObjectMemory methodsFor: 'header access'!headerType: oop	^ (self longAt: oop) bitAnd: TypeMask! !!ObjectMemory methodsFor: 'header access'!isBytes: oop	"Answer true if the argument contains indexable bytes. See comment in formatOf:"	"Note: Includes CompiledMethods."	^ (self formatOf: oop)  >= 8! !!ObjectMemory methodsFor: 'header access'!isFreeObject: oop	^ (self headerType: oop) = HeaderTypeFree! !!ObjectMemory methodsFor: 'header access'!isPointers: oop	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	^ (self formatOf: oop) <= 4! !!ObjectMemory methodsFor: 'header access'!isWords: oop	"Answer true if the argument contains only indexable words (no oops). See comment in formatOf:"	^ (self formatOf: oop) = 6! !!ObjectMemory methodsFor: 'header access'!isWordsOrBytes: oop	"Answer true if the contains only indexable words or bytes (no oops). See comment in formatOf:"	"Note: Excludes CompiledMethods."	| fmt |	fmt _ self formatOf: oop.	^ fmt = 6 or: [(fmt >= 8) and: [fmt <= 11]]! !!ObjectMemory methodsFor: 'header access'!newObjectHash	"Answer a new 16-bit pseudo-random number for use as an identity hash."	lastHash _ 13849 + (27181 * lastHash) bitAnd: 65535.	^ lastHash! !!ObjectMemory methodsFor: 'header access'!rightType: headerWord	"Computer the correct header type for an object based on the size and compact class fields of the given base header word, rather than its type bits. This is used during marking, when the header type bits are used to record the state of tracing."	(headerWord bitAnd: 16rFC) = 0  "zero size field in header word"		ifTrue: [ ^ HeaderTypeSizeAndClass ]		ifFalse: [			(headerWord bitAnd: 16r1F000) = 0  "zero compact class field  in header word"				ifTrue: [ ^ HeaderTypeClass ]				ifFalse: [ ^ HeaderTypeShort ]].! !!ObjectMemory methodsFor: 'header access'!setSizeOfFree: chunk to: byteSize	"Set the header of the given chunk to make it be a free chunk of the given size."	self longAt: chunk put: ((byteSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).! !!ObjectMemory methodsFor: 'header access'!sizeBitsOf: oop	"Answer the number of bytes in the given object, including its base header, rounded up to an integral number of words."	"Note: byte indexable objects need to have low bits subtracted from this size."	| header |	header _ self baseHeader: oop.	(header bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].! !!ObjectMemory methodsFor: 'header access'!sizeBitsOfSafe: oop	"Compute the size of the given object from the cc and size fields in its header. This works even if its type bits are not correct."	| header type |	header _ self baseHeader: oop.	type _ self rightType: header.	type = HeaderTypeSizeAndClass		ifTrue: [ ^ (self sizeHeader: oop) bitAnd: AllButTypeMask ]		ifFalse: [ ^ header bitAnd: 16rFC ].! !!ObjectMemory methodsFor: 'header access'!sizeHeader: oop	^ self longAt: oop - 8! !!ObjectMemory methodsFor: 'header access'!sizeOfFree: oop	"Return the size of the given chunk in bytes. Argument MUST be a free chunk."	^ (self longAt: oop) bitAnd: FreeSizeMask! !!ObjectMemory methodsFor: 'object enumeration'!accessibleObjectAfter: oop	"Return the accessible object following the given object or free chunk in the heap. Return nil when heap is exhausted."	| obj |	self inline: false.	obj _ self objectAfter: oop.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	^ nil! !!ObjectMemory methodsFor: 'object enumeration'!firstAccessibleObject	"Return the first accessible object in the heap."	| obj |	obj _ self firstObject.	[obj < endOfMemory] whileTrue: [		(self isFreeObject: obj) ifFalse: [ ^obj ].		obj _ self objectAfter: obj.	].	self error: 'heap is empty'! !!ObjectMemory methodsFor: 'object enumeration'!firstObject	"Return the first object or free chunk in the heap."	^ self oopFromChunk: self startOfMemory! !!ObjectMemory methodsFor: 'object enumeration'!initialInstanceOf: classPointer	"Support for instance enumeration. Return the first instance of the given class, or nilObj if it has no instances."	| thisObj thisClass |	thisObj _ self firstAccessibleObject.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj! !!ObjectMemory methodsFor: 'object enumeration'!instanceAfter: objectPointer	"Support for instance enumeration. Return the next instance of the class of the given object, or nilObj if the enumeration is complete."	| classPointer thisObj thisClass |	classPointer _ (self fetchClassOf: objectPointer).	thisObj _ self accessibleObjectAfter: objectPointer.	[thisObj = nil] whileFalse: [		thisClass _ self fetchClassOf: thisObj.		thisClass = classPointer ifTrue: [ ^thisObj ].		thisObj _ self accessibleObjectAfter: thisObj.	].	^nilObj! !!ObjectMemory methodsFor: 'object enumeration'!lastPointerOf: objectPointer	"Return the byte offset of the last pointer field of the given object. Works with CompiledMethods, as well as ordinary objects. Can be used even when the type bits are not correct."	| fmt sz methodHeader |	self inline: true.	fmt _ self formatOf: objectPointer.	fmt < 4 ifTrue: [		sz _ self sizeBitsOfSafe: objectPointer.		^ sz - BaseHeaderSize  "all pointers"	].	fmt < 12 ifTrue: [ ^0 ].  "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader _ self longAt: objectPointer + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'object enumeration'!objectAfter: oop	"Return the object or free chunk immediately following the given object or free chunk in memory. Return endOfMemory when enumeration is complete."	| sz |	self inline: true.	checkAssertions ifTrue: [		oop >= endOfMemory ifTrue: [ self error: 'no objects after the end of memory' ].	].	(self isFreeObject: oop)		ifTrue: [ sz _ self sizeOfFree: oop ]		ifFalse: [ sz _ self sizeBitsOf: oop ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'object enumeration'!startOfMemory	"Return the start of object memory."	^ self cCode: '(int) memory'! !!ObjectMemory methodsFor: 'oop/chunk conversion'!chunkFromOop: oop	"Compute the chunk of this oop by subtracting its extra header bytes."	| extra |	extra _ self extraHeaderBytes: oop.	^ oop - extra! !!ObjectMemory methodsFor: 'oop/chunk conversion'!extraHeaderBytes: oopOrChunk	"Return the number of extra bytes used by the given object's header."	"Warning: This method should not be used during marking, when the header type bits of an object may be incorrect."	| type extra |	self inline: true.	type _ self headerType: oopOrChunk.	type > 1 ifTrue: [		extra _ 0.  "free chunk (type 2) or 1-word header (type 3); most common"	] ifFalse: [		type = 1			ifTrue: [ extra _ 4.  "2-word header (type 1)" ]			ifFalse: [ extra _ 8.  "3-word header (type 0)" ].	].	^ extra! !!ObjectMemory methodsFor: 'oop/chunk conversion'!oopFromChunk: chunk	"Compute the oop of this chunk by adding its extra header bytes."	| extra |	extra _ self extraHeaderBytes: chunk.	^ chunk + extra! !!ObjectMemory methodsFor: 'allocation'!allocate: byteSize headerSize: hdrSize h1: baseHeader h2: classOop h3: extendedSize fill: fillWord	"Allocate a new object of the given size and number of header words. (Note: byteSize already includes space for the base header word.) Initialize the header fields of the new object and fill the remainder of the object with the given value."	| newObj remappedClassOop end i |	self inline: true.	"remap classOop in case GC happens during allocation"	hdrSize > 1 ifTrue: [ self pushRemappableOop: classOop ].  	newObj _ self allocateChunk: byteSize + ((hdrSize - 1) * 4).	hdrSize > 1 ifTrue: [ remappedClassOop _ self popRemappableOop ].	hdrSize = 3 ifTrue: [		self longAt: newObj      put: (extendedSize bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 4 put: (remappedClassOop bitOr: HeaderTypeSizeAndClass).		self longAt: newObj + 8 put: (baseHeader bitOr: HeaderTypeSizeAndClass).		newObj _ newObj + 8.	].	hdrSize = 2 ifTrue: [		self longAt: newObj      put: (remappedClassOop bitOr: HeaderTypeClass).		self longAt: newObj + 4 put: (baseHeader bitOr: HeaderTypeClass).		newObj _ newObj + 4.	].	hdrSize = 1 ifTrue: [		self longAt: newObj put: (baseHeader bitOr: HeaderTypeShort).	].	"clear new object"	end _ newObj + byteSize.	i _ newObj + 4.	[i < end] whileTrue: [		self longAt: i put: fillWord.		i _ i + 4.	].	checkAssertions ifTrue: [		self okayOop: newObj.		self oopHasOkayClass: newObj.		(self objectAfter: newObj) = freeBlock			ifFalse: [ self error: 'allocate bug: did not set header of new oop correctly' ].		(self objectAfter: freeBlock) = endOfMemory			ifFalse: [ self error: 'allocate bug: did not set header of freeBlock correctly' ].	].	^ newObj! !!ObjectMemory methodsFor: 'allocation' stamp: 'jm 9/14/97 11:14'!allocateChunk: byteSize 	"Allocate a chunk of the given size. Sender must be sure that the requested size includes enough space for the header word(s)."	"Details: To limit the time per incremental GC, do one every so many allocations."	| enoughSpace newFreeSize newChunk |	self inline: true.	allocationCount >= allocationsBetweenGCs ifTrue: [		"do an incremental GC every so many allocations to keep pauses short"		self incrementalGC.	].	enoughSpace _ self sufficientSpaceToAllocate: byteSize.	enoughSpace ifFalse: [		"signal that space is running low, put proceed with allocation if possible"		signalLowSpace _ true.		lowSpaceThreshold _ 0.  "disable additional interrupts until lowSpaceThreshold is reset by image"		interruptCheckCounter _ 0.	].	(self sizeOfFree: freeBlock) < (byteSize + BaseHeaderSize) ifTrue: [		self error: 'out of memory'.	].	"if we get here, there is enough space for allocation to succeed"	newFreeSize _ (self sizeOfFree: freeBlock) - byteSize.	newChunk _ freeBlock.	freeBlock _ freeBlock + byteSize.	"Assume: client will initialize object header of free chunk, so following is not needed:"	"self setSizeOfFree: newChunk to: byteSize."	self setSizeOfFree: freeBlock to: newFreeSize.	allocationCount _ allocationCount + 1.	^ newChunk! !!ObjectMemory methodsFor: 'allocation'!allocateOrRecycleContext: smallContextWanted	"Return a recycled context or a newly allocated one if none is available for recycling. The argument indicates that a small context is wanted."	| cntxt |	self inline: true.	smallContextWanted ifTrue: [		freeSmallContexts ~= NilContext ifTrue: [			cntxt _ freeSmallContexts.			freeSmallContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								 sizeInBytes: SmallContextSize										 fill: nilObj.		].	] ifFalse: [		freeLargeContexts ~= NilContext ifTrue: [			cntxt _ freeLargeContexts.			freeLargeContexts _ self fetchPointer: 0 ofObject: cntxt.		] ifFalse: [			cntxt _ self instantiateSmallClass: (self splObj: ClassMethodContext)								sizeInBytes: LargeContextSize										fill: nilObj.		].	].	^ cntxt! !!ObjectMemory methodsFor: 'allocation'!clone: oop	"Return a shallow copy of the given object."	"Assume: Oop is a real object, not a small integer."	| extraHdrBytes bytes newChunk remappedOop fromIndex toIndex lastFrom newOop header hash |	self inline: false.	extraHdrBytes _ self extraHeaderBytes: oop.	bytes _ self sizeBitsOf: oop.	bytes _ bytes + extraHdrBytes.	"allocate space for the copy, remapping oop in case of a GC"	self pushRemappableOop: oop.	newChunk _ self allocateChunk: bytes.	remappedOop _ self popRemappableOop.	"copy old to new including all header words"	toIndex _ newChunk - 4.  "loop below uses pre-increment"	fromIndex _ (remappedOop - extraHdrBytes) - 4.	lastFrom _ fromIndex + bytes.	[fromIndex < lastFrom] whileTrue: [		self longAt: (toIndex _ toIndex + 4)			put: (self longAt: (fromIndex _ fromIndex + 4)).	].	newOop _ newChunk + extraHdrBytes.  "convert from chunk to oop"	"fix base header: compute new hash and clear Mark and Root bits"	hash _ self newObjectHash.	header _ (self longAt: newOop) bitAnd: 16r1FFFF.		"use old ccIndex, format, size, and header-type fields"	header _ header bitOr: ((hash << 17) bitAnd: 16r1FFE0000).	self longAt: newOop put: header.	^ newOop! !!ObjectMemory methodsFor: 'allocation'!recycleContextIfPossible: cntxOop methodContextClass: methodCntxClass	"If possible, save the given context on a list of free contexts to be recycled."	"Note: The context is not marked free, so it can be reused with minimal fuss. It's fields are nil-ed out when it is re-used. The recycled context lists are cleared at every garbage collect."	"Note: This code was found to be critical to good send/return speed, so it has been ruthlessly hand-tuned."	| cntxHeader ccField isMethodCntx |	self inline: true.	"only recycle young contexts (which should be most of them)"	cntxOop >= youngStart ifTrue: [		"is the context of class methodCntxClass?"		cntxHeader _ self baseHeader: cntxOop.		ccField _ cntxHeader bitAnd: 16r1F000.		ccField = 0 ifTrue: [			isMethodCntx _ ((self classHeader: cntxOop) bitAnd: AllButTypeMask) = methodCntxClass.		] ifFalse: [			"compare ccField with compact class bits from format word of methodCntxClass"			isMethodCntx _ ccField = ((self formatOfClass: methodCntxClass) bitAnd: 16r1F000).		].		isMethodCntx ifTrue: [			"Note: The following test depends on the format of object headers			 and the fact that both small and large contexts are small enough			 for their size to be encoded in the base object header. If these			 assumptions is false, contexts won't be recycled properly, but the			 code should not break."			(cntxHeader bitAnd: 16rFC) = SmallContextSize ifTrue: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeSmallContexts.				freeSmallContexts _ cntxOop.				] ifFalse: [				self storePointerUnchecked: 0 ofObject: cntxOop withValue: freeLargeContexts.				freeLargeContexts _ cntxOop.				].		].	].! !!ObjectMemory methodsFor: 'allocation'!sufficientSpaceAfterGC: minFree	"Return true if there is enough free space after doing a garbage collection. If not, signal that space is low."	self inline: false.	self incrementalGC.  "try to recover some space"	(self sizeOfFree: freeBlock) < minFree ifTrue: [		signalLowSpace ifTrue: [ ^ false ].  "give up; problem is already noted"		self fullGC.  "try harder"		"for stability, require more free space after doing an expensive full GC"		(self sizeOfFree: freeBlock) < (minFree + 15000) ifTrue: [ ^ false ].  "still not enough"	].	^ true! !!ObjectMemory methodsFor: 'allocation'!sufficientSpaceToAllocate: bytes	"Return true if there is enough space to allocate the given number of bytes, perhaps after doing a garbage collection."	| minFree |	self inline: true.	minFree _ lowSpaceThreshold + bytes + BaseHeaderSize.	"check for low-space"	(self sizeOfFree: freeBlock) >= minFree ifTrue: [		^ true.	] ifFalse: [		^ self sufficientSpaceAfterGC: minFree.	].! !!ObjectMemory methodsFor: 'garbage collection'!beRootIfOld: oop	"Record that the given oop in the old object area may point to an object in the young area."	| header |	self inline: false.	((oop < youngStart) and: [(self isIntegerObject: oop) not]) ifTrue: [		"oop is in the old object area"		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'garbage collection'!clearRootsTable	"Clear the root bits of the current roots, then empty the roots table."	"Caution: This should only be done when the young object space is empty."	| oop |	"reset the roots table (after this, all objects are old so there are no roots)"	1 to: rootTableCount do: [ :i |		"clear root bits of current root table entries"		oop _ rootTable at: i.		self longAt: oop put: ((self longAt: oop) bitAnd: AllButRootBit).		rootTable at: i put: 0.	].	rootTableCount _ 0.! !!ObjectMemory methodsFor: 'garbage collection'!fullCompaction	"Move all accessible objects down to leave one big free chunk at the end of memory."	"Assume: Incremental GC has just been done to maximimize forwarding table space."	"need not move objects below the first free chunk"	compStart _ self lowestFreeAfter: (self startOfMemory).	compStart = freeBlock ifTrue: [		"memory is already compact; only free chunk is at the end"		^ self initializeMemoryFirstFree: freeBlock	].	"work up through memory until all free space is at the end"	[compStart < freeBlock] whileTrue: [		"free chunk returned by incCompBody becomes start of next compaction"		compStart _ self incCompBody.  "bubble of free space moves up each time"	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'ikp 1/14/98 01:11'!fullGC	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	self inline: false.	self preGCAction: true.	startTime _ self ioMicroMSecs.	self clearRootsTable.	youngStart _ self startOfMemory.  "process all of memory"	self markPhase.	self sweepPhase.	self fullCompaction.	allocationCount _ 0.	statFullGCs _ statFullGCs + 1.	statFullGCMSecs _ statFullGCMSecs + (self ioMicroMSecs - startTime).	youngStart _ freeBlock.  "reset the young object boundary"	self postGCAction.! !!ObjectMemory methodsFor: 'garbage collection'!incrementalCompaction	"Move objects down to make one big free chunk. Compact the last N objects (where N = number of forwarding table entries) of the young object area."	"Assume: compStart was set during the sweep phase"	compStart = freeBlock ifTrue: [		"Note: If compStart = freeBlock then either the young space is already compact		 or there are enough forwarding table entries to do a one-pass incr. compaction."		self initializeMemoryFirstFree: freeBlock.	] ifFalse: [		self incCompBody.	].! !!ObjectMemory methodsFor: 'garbage collection' stamp: 'jm 2/3/98 11:18'!incrementalGC	"Do a mark/sweep garbage collection of just the young object area of object memory (i.e., objects above youngStart), using the root table to identify objects containing pointers to young objects from the old object area."	| survivorCount startTime |	self inline: false.	rootTableCount >= RootTableSize ifTrue: [		"root table overflow; cannot do an incremental GC (this should be very rare)"		statRootTableOverflows _ statRootTableOverflows + 1.		^ self fullGC	].	self preGCAction: false.	"incremental GC and compaction"	startTime _ self ioMicroMSecs.	self markPhase.	survivorCount _ self sweepPhase.	self incrementalCompaction.	allocationCount _ 0.	statIncrGCs _ statIncrGCs + 1.	statIncrGCMSecs _ statIncrGCMSecs + (self ioMicroMSecs - startTime).	survivorCount > tenuringThreshold ifTrue: [		"move up the young space boundary if there are too many survivors;		 this limits the number of objects that must be processed on future		 incremental GC's"		statTenures _ statTenures + 1.		self clearRootsTable.		youngStart _ freeBlock.  "reset the young object boundary"	].	self postGCAction.! !!ObjectMemory methodsFor: 'garbage collection'!lowestFreeAfter: chunk	"Return the first free block after the given chunk in memory."	| oop oopHeader oopHeaderType oopSize |	self inline: false.	oop _ self oopFromChunk: chunk.	[oop < endOfMemory] whileTrue: [		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeFree)			ifTrue: [ ^ oop ]			ifFalse: [				oopHeaderType = HeaderTypeSizeAndClass					ifTrue: [ oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask ]					ifFalse: [ oopSize _ oopHeader bitAnd: 16rFC ].			].		oop _ self oopFromChunk: (oop + oopSize).	].	self error: 'expected to find at least one free object'.! !!ObjectMemory methodsFor: 'garbage collection'!possibleRootStoreInto: oop value: valueObj	"Called when storing the given value object into the given old object. If valueObj is young, record the fact that oldObj is now a root for incremental garbage collection."	"Warning: No young objects should be recorded as roots."	| header |	self inline: false.	((valueObj >= youngStart) and:	 [(self isIntegerObject: valueObj) not]) ifTrue: [		header _ self longAt: oop.		(header bitAnd: RootBit) = 0 ifTrue: [			"record oop as root only if not already recorded"			rootTableCount < RootTableSize ifTrue: [				"record root only if there is room in the roots table"				rootTableCount _ rootTableCount + 1.				rootTable at: rootTableCount put: oop.				self longAt: oop put: (header bitOr: RootBit).			].		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!aComment	"The mark phase is based on a pointer reversing traversal. This is a little tricky because the class, which is needed by the traversal, may be in either the header (as a compact class index) or in the word above the header. See memo 'Revised object format'.	Compact classes are marked and traced separately.	How do you know that you are returning from having marked a class? Parent pointer has 10 in low bits.Here are the states an object may be in, followed by what to do next in brackets []:  Start Object: parentField is set, [obj _ child]:	obj is pointed at by a field in parent that is being traced now. obj is marked.		[(parent goes up to the next field) field addr _ obj. go to Upward]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has no pointers.		[put 10 into low bits of header. field addr _ obj. go to Start Field (to process class word)]	obj is pointed at by a field in parent that is being traced now. obj is unmarked. obj has pointers.		[put 10 into low bits of header. point to last field. go to Start Field]  Start Field: 	Field ends in 10. It is the header. Short Class is not 0.		[Set low bits to correct value. (have parent pointer) go to Upward]	Field ends in 10. It is the header. Short Class is 0.		[child _ word above header. low bits of child _ 01. class word _ parentField. parentField _ loc of class word. go to Start Obj]	Field is Integer.		[point one word up, go to Start Field]	Field is oop.		[child _ field. field _ parentField. parentField _ loc of field. go to Start Obj]  Upward [restore low bits of header (at field addr)]:	parentField is 3. (bits 11, int 1).		[done!!]	parentField ends in 00.		[child _ field addr. field addr _ parentField. parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr - 4. go to Start Field]	parentField ends in 01. Were tracing the class.		[child _ field addr. field addr _ parentField (loc of class word). parentField _ field addr contents.		field addr contents _ child (addr of prev object. its oop). field addr + 4 (header). go to Upward]"! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'ikp 1/3/98 23:10'!markAndTrace: oop	"Mark all objects reachable from the given one. Trace from the given object even if it is old or already marked. Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action |	"record tracing status in object's header"	header _ self longAt: oop.	header _ (header bitAnd: AllButTypeMask) bitOr: HeaderTypeGC.	oop >= youngStart ifTrue: [ header _ header bitOr: MarkBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField _ GCTopMarker.	child _ oop.	lastFieldOffset _ self lastPointerOf: oop.	field _ oop + lastFieldOffset.	action _ StartField.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		action = StartField	ifTrue: [ action _ self startField ].		action = StartObj		ifTrue: [ action _ self startObj ].		action = Upward		ifTrue: [ action _ self upward ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!markPhase	"Mark phase of the mark and sweep garbage collector. Set the mark bits of all reachable objects. Free chunks are untouched by this process."	"Assume: All non-free objects are initially unmarked. Root objects were unmarked when they were made roots. (Make sure this stays true!!!!)."	| oop |	self inline: false.	"clear the recycled context lists"	freeSmallContexts _ NilContext.	freeLargeContexts _ NilContext.	"trace the interpreter's objects, including the active stack and special objects array"	self markAndTraceInterpreterOops.	"trace the roots"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		(self isIntegerObject: oop) ifFalse: [ self markAndTrace: oop ].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!startField	"Examine and possibly trace the next field of the object being traced. See comment in markAndTrace for explanation of tracer state variables."	| typeBits childType |	child _ self longAt: field.	typeBits _ child bitAnd: TypeMask.	(typeBits bitAnd: 1) = 1 ifTrue: [		"field contains a SmallInteger; skip it"		field _ field - 4.		^ StartField	].	typeBits = 0 ifTrue: [		"normal oop, go down"		self longAt: field put: parentField.		parentField _ field.		^ StartObj	].	typeBits = 2 ifTrue: [		"reached the header; do we need to process the class word?"		(child bitAnd: 16r1F000) ~= 0 ifTrue: [			"object's class is compact; we're done"			"restore the header type bits"			child _ child bitAnd: AllButTypeMask.			childType _ self rightType: child.			self longAt: field put: (child bitOr: childType).			^ Upward		] ifFalse: [			"object has a full class word; process that class"			child _ self longAt: (field - 4).  "class word"			child _ child bitAnd: AllButTypeMask.  "clear type bits"			self longAt: (field - 4) put: parentField.			parentField _ (field - 4) bitOr: 1.  "point at class word; mark as working on the class."			^ StartObj		].	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!startObj	"Start tracing the object 'child' and answer the next action. The object may be anywhere in the middle of being swept itself. See comment in markAndTrace for explanation of tracer state variables."	| oop header lastFieldOffset |	oop _ child.	oop < youngStart ifTrue: [		"old object; skip it"		 field _ oop.		^ Upward	].	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [		"unmarked; mark and trace"		header _ header bitAnd: AllButTypeMask.		header _ (header bitOr: MarkBit) bitOr: HeaderTypeGC.		self longAt: oop put: header.		lastFieldOffset _ self lastPointerOf: oop.		field _ oop + lastFieldOffset.		^ StartField	"trace its fields and class"	] ifFalse: [		"already marked; skip it"		field _ oop.		^ Upward	].! !!ObjectMemory methodsFor: 'gc -- mark and sweep' stamp: 'jm 5/8/1998 07:04'!sweepPhase	"Sweep memory from youngStart through the end of memory. Free all inaccessible objects and coalesce adjacent free chunks. Clear the mark bits of accessible objects. Compute the starting point for the first pass of incremental compaction (compStart). Return the number of surviving objects."	"Details: Each time a non-free object is encountered, decrement the number of available forward table entries. If all entries are spoken for (i.e., entriesAvailable reaches zero), set compStart to the last free chunk before that object or, if there is no free chunk before the given object, the first free chunk after it. Thus, at the end of the sweep phase, compStart through compEnd spans the highest collection of non-free objects that can be accomodated by the forwarding table. This information is used by the first pass of incremental compaction to ensure that space is initially freed at the end of memory. Note that there should always be at least one free chunk--the one at the end of the heap."	| entriesAvailable survivors freeChunk firstFree oop oopHeader oopHeaderType hdrBytes oopSize freeChunkSize |	self inline: false.	entriesAvailable _ self fwdTableInit.	survivors _ 0.	freeChunk _ nil.	firstFree _ nil.  "will be updated later"	oop _ self oopFromChunk: youngStart.	[oop < endOfMemory] whileTrue: [		"get oop's header, header type, size, and header size"		oopHeader _ self baseHeader: oop.		oopHeaderType _ oopHeader bitAnd: TypeMask.		(oopHeaderType = HeaderTypeShort) ifTrue: [			oopSize _ oopHeader bitAnd: 16rFC.			hdrBytes _ 0.		] ifFalse: [			(oopHeaderType = HeaderTypeClass) ifTrue: [				oopSize _ oopHeader bitAnd: 16rFC.				hdrBytes _ 4.			] ifFalse: [				(oopHeaderType = HeaderTypeSizeAndClass) ifTrue: [					oopSize _ (self sizeHeader: oop) bitAnd: AllButTypeMask.					hdrBytes _ 8.				] ifFalse: [  "free chunk"					oopSize _ oopHeader bitAnd: FreeSizeMask.					hdrBytes _ 0.				].			].		].		(oopHeader bitAnd: MarkBit) = 0 ifTrue: [			"object is not marked; free it"			freeChunk ~= nil ifTrue: [				"enlarge current free chunk to include this oop"				freeChunkSize _ freeChunkSize + oopSize + hdrBytes.			] ifFalse: [				"start a new free chunk"				freeChunk _ oop - hdrBytes.  "chunk may start 4 or 8 bytes before oop"				freeChunkSize _ oopSize + (oop - freeChunk).  "adjust size for possible extra header bytes"				firstFree = nil ifTrue: [ firstFree _ freeChunk ].			].		] ifFalse: [			"object is marked; clear its mark bit and possibly adjust the compaction start"			self longAt: oop put: (oopHeader bitAnd: AllButMarkBit).			entriesAvailable > 0 ifTrue: [				entriesAvailable _ entriesAvailable - 1.			] ifFalse: [				"start compaction at the last free chunk before this object"				firstFree _ freeChunk.			].			freeChunk ~= nil ifTrue: [				"record the size of the last free chunk"				self longAt: freeChunk					    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).			].			freeChunk _ nil.			survivors _ survivors + 1.		].		oop _ self oopFromChunk: (oop + oopSize).  "get next oop"	].	freeChunk ~= nil ifTrue: [		"record size of final free chunk"		self longAt: freeChunk			    put: ((freeChunkSize bitAnd: FreeSizeMask) bitOr: HeaderTypeFree).	].	oop = endOfMemory		ifFalse: [ self error: 'sweep failed to find exact end of memory' ].	firstFree = nil		ifTrue: [ self error: 'expected to find at least one free object' ]		ifFalse: [ compStart _ firstFree ].	displayBits = 0 ifFalse: [		"TPR: clear mark bit of Acorn's displayBits object, which may lie outside object space"		oopHeader _ self baseHeader: displayBits.		self longAt: displayBits put: (oopHeader bitAnd: AllButMarkBit)].		^ survivors! !!ObjectMemory methodsFor: 'gc -- mark and sweep'!upward	"Return from marking an object below. Incoming:		field = oop we just worked on, needs to be put away		parentField = where to put it in our object	NOTE: Type field of object below has already been restored!!!!!!"	| type header |	(parentField bitAnd: 1) = 1 ifTrue: [		parentField = GCTopMarker ifTrue: [			"top of the chain"			header _ (self longAt: field) bitAnd: AllButTypeMask.			type _ self rightType: header.			self longAt: field put: header + type.  "install type on class oop"			^ Done		] ifFalse: [			"was working on the extended class word"			child _ field.	"oop of class"			field _ parentField - 1.  "class word, ** clear the low bit **"			parentField _ self longAt: field.			header _ self longAt: field+4.  "base header word"			type _ self rightType: header.			self longAt: field put: child + type.  "install type on class oop"			field _ field + 4.  "point at header"			"restore type bits"			header _ header bitAnd: AllButTypeMask.			self longAt: field put: (header + type).			^ Upward		].	] ifFalse: [		"normal"		child _ field.  "who we worked on below"		field _ parentField.  "where to put it"		parentField _ self longAt: field.		self longAt: field put: child.		field _ field - 4.  "point at header"		^ StartField	].! !!ObjectMemory methodsFor: 'gc -- compaction'!beRootWhileForwarding: oop	"Record that the given oop in the old object area points to an object in the young area when oop may be forwarded. Like beRoot:"	"Warning: No young objects should be recorded as roots. Callers are responsible for ensuring this constraint is not violated."	| header forwarding fwdBlock newHeader |	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		forwarding _ true.		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	] ifFalse: [		forwarding _ false.	].	(header bitAnd: RootBit) = 0 ifTrue: [		"record oop as root only if not already recorded"		rootTableCount < RootTableSize ifTrue: [			"record root only if there is room in the roots table"			rootTableCount _ rootTableCount + 1.			rootTable at: rootTableCount put: oop.			newHeader _ header bitOr: RootBit.			forwarding				ifTrue: [ self longAt: (fwdBlock + 4) put: newHeader ]				ifFalse: [ self longAt: oop put: newHeader ].		].	].! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdBlockGet	"Return the address of a two-word forwarding block or nil if no more entries are available."	fwdTableNext _ fwdTableNext + 8.	fwdTableNext <= fwdTableLast		ifTrue: [ ^ fwdTableNext ]		ifFalse: [ ^ nil ].  "no more forwarding blocks available"! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdBlockValidate: addr	"Raise an error if the given address is not a valid forward table entry."	(( addr > endOfMemory) and:	 [(addr <= fwdTableNext) and:	 [(addr bitAnd: 3) = 0]])		ifFalse: [ self error: 'invalid fwd table entry' ].! !!ObjectMemory methodsFor: 'gc -- compaction'!fwdTableInit	"Set the limits for a table of two-word forwarding blocks above the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used for compaction of memory and become-ing objects. Returns the number of forwarding blocks available."	self inline: false.	"set endOfMemory to just after a minimum-sized free block"	self setSizeOfFree: freeBlock to: BaseHeaderSize.	endOfMemory _ freeBlock + BaseHeaderSize.	"make a fake free chunk at endOfMemory for use as a sentinal in memory scans"	self setSizeOfFree: endOfMemory to: BaseHeaderSize.	"use all memory free between freeBlock and memoryLimit for forwarding table"	fwdTableNext _ endOfMemory + BaseHeaderSize.	fwdTableLast _ memoryLimit - 8.  "last forwarding table entry"	(checkAssertions and: [(fwdTableLast bitAnd: MarkBit) ~= 0]) ifTrue: [		"Note: Address bits must not interfere with the mark bit in header of		 an object, which shows that the object is forwarded."		self error: 'fwd table must be in low half of the 32-bit address space'.	].	"return the number of forwarding blocks available"	^ (fwdTableLast - fwdTableNext) // 8  "round down"! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompBody	"Move objects to consolidate free space into one big chunk. Return the newly created free chunk."	| bytesFreed |	self inline: false.	"reserve memory for forwarding table"	self fwdTableInit.	"assign new oop locations, reverse their headers, and initialize forwarding blocks"	bytesFreed _ self incCompMakeFwd.	"update pointers to point at new oops"	self mapPointersInObjectsFrom: youngStart to: endOfMemory.	"move the objects and restore their original headers; return the new free chunk"	^ self incCompMove: bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompMakeFwd	"Create and initialize forwarding blocks for all non-free objects following compStart. If the supply of forwarding blocks is exhausted, set compEnd to the first chunk above the area to be compacted; otherwise, set it to endOfMemory. Return the number of bytes to be freed."	| bytesFreed oop fwdBlock newOop |	bytesFreed _ 0.	oop _ self oopFromChunk: compStart.	[oop < endOfMemory] whileTrue: [		(self isFreeObject: oop) ifTrue: [			bytesFreed _ bytesFreed + (self sizeOfFree: oop).		] ifFalse: [			"create a forwarding block for oop"			fwdBlock _ self fwdBlockGet.			fwdBlock = nil ifTrue: [				"stop; we have used all available forwarding blocks"				compEnd _ self chunkFromOop: oop.				^ bytesFreed			].			newOop _ oop - bytesFreed.			self initForwardBlock: fwdBlock mapping: oop to: newOop.		].		oop _ self objectAfterWhileForwarding: oop.	].	compEnd _ endOfMemory.	^ bytesFreed! !!ObjectMemory methodsFor: 'gc -- compaction'!incCompMove: bytesFreed	"Move all non-free objects between compStart and compEnd to their new locations, restoring their headers in the process. Create a new free block at the end of memory. Return the newly created free chunk."	"Note: The free block used by the allocator always must be the last free block in memory. It may take several compaction passes to make all free space bubble up to the end of memory."	| oop next fwdBlock newOop header bytesToMove firstWord lastWord newFreeChunk sz |	newOop _ nil.	oop _ self oopFromChunk: compStart.	[oop < compEnd] whileTrue: [		next _ self objectAfterWhileForwarding: oop.		(self isFreeObject: oop) ifFalse: [			"a moving object; unwind its forwarding block"			fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			header _ self longAt: fwdBlock + 4.			self longAt: oop put: header.  "restore the original header"			bytesToMove _ oop - newOop.			"move the oop (including any extra header words)"			sz _ self sizeBitsOf: oop.			firstWord _ oop - (self extraHeaderBytes: oop).			lastWord _ (oop + sz) - BaseHeaderSize.			firstWord to: lastWord by: 4 do: [ :w |				self longAt: (w - bytesToMove) put: (self longAt: w).			].		].		oop _ next.	].	newOop = nil ifTrue: [		"no objects moved"		oop _ self oopFromChunk: compStart.		((self isFreeObject: oop) and: [(self objectAfter: oop) = (self oopFromChunk: compEnd)])			ifTrue: [ newFreeChunk _ oop ]			ifFalse: [ newFreeChunk _ freeBlock ].	] ifFalse: [		"initialize the newly freed memory chunk"		"newOop is the last object moved; free chunk starts right after it"		newFreeChunk _ newOop + (self sizeBitsOf: newOop).		self setSizeOfFree: newFreeChunk to: bytesFreed.	].	checkAssertions ifTrue: [		(self objectAfter: newFreeChunk) = (self oopFromChunk: compEnd)			ifFalse: [ self error: 'problem creating free chunk after compaction' ].	].	(self objectAfter: newFreeChunk) = endOfMemory ifTrue: [		self initializeMemoryFirstFree: newFreeChunk.	] ifFalse: [		"newFreeChunk is not at end of memory; re-install freeBlock"		self initializeMemoryFirstFree: freeBlock.	].	^ newFreeChunk! !!ObjectMemory methodsFor: 'gc -- compaction'!initForwardBlock: fwdBlock mapping: oop to: newOop	"Initialize the given forwarding block to map oop to newOop, and replace oop's header with a pointer to the fowarding block."	"Details: The mark bit is used to indicate that an oop is forwarded. When an oop is forwarded, its header (minus the mark bit) contains the address of its forwarding block. The first word of the forwarding block is the new oop; the second word is the oop's orginal header. The type bits of the forwarding header are the same as those of the original header."	| originalHeader originalHeaderType |	self inline: true.	originalHeader _ self longAt: oop.	checkAssertions ifTrue: [		fwdBlock = nil			ifTrue: [ self error: 'ran out of forwarding blocks in become' ].		(originalHeader bitAnd: MarkBit) ~= 0			ifTrue: [ self error: 'object already has a forwarding table entry' ].	].	originalHeaderType _ originalHeader bitAnd: TypeMask.	self longAt: fwdBlock put: newOop.	self longAt: fwdBlock + 4 put: originalHeader.	self longAt: oop put: (fwdBlock bitOr: (MarkBit bitOr: originalHeaderType)).! !!ObjectMemory methodsFor: 'gc -- compaction'!isObjectForwarded: oop	"Return true if the given object has a forwarding table entry during a compaction or become operation."	^ (oop bitAnd: 1) = 0 "(isIntegerObject: oop) not" and:	   [ ((self longAt: oop) bitAnd: MarkBit) ~= 0 ]! !!ObjectMemory methodsFor: 'gc -- compaction'!lastPointerWhileForwarding: oop	"The given object may have its header word in a forwarding block. Find the offset of the last pointer in the object in spite of this obstacle."	| header fwdBlock fmt size methodHeader |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) ~= 0 ifTrue: [		"oop is forwarded; get its real header from its forwarding table entry"		fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		header _ self longAt: fwdBlock + 4.	].	fmt _ (header >> 8) bitAnd: 16rF.	fmt < 4 ifTrue: [		"do sizeBitsOf: using the header we obtained"		(header bitAnd: TypeMask) = HeaderTypeSizeAndClass			ifTrue: [ size _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]			ifFalse: [ size _ header bitAnd: 16rFC ].		^ size - BaseHeaderSize	].	fmt < 12 ifTrue: [ ^ 0 ].  "no pointers"	methodHeader _ self longAt: oop + BaseHeaderSize.	^ ((methodHeader >> 10) bitAnd: 16rFF) * 4 + BaseHeaderSize! !!ObjectMemory methodsFor: 'gc -- compaction'!mapPointersInObjectsFrom: memStart to: memEnd	"Use the forwarding table to update the pointers of all non-free objects in the given range of memory. Also remap pointers in root objects which may contains pointers into the given memory range."	| oop |	self inline: false.	"update interpreter variables"	self mapInterpreterOops.	"update pointers in root objects"	1 to: rootTableCount do: [ :i | 		oop _ rootTable at: i.		((oop < memStart) or: [oop >= memEnd]) ifTrue: [			"Note: must not remap the fields of any object twice!!"			"remap this oop only if not in the memory range covered below"			self remapFieldsAndClassOf: oop.		].	].	"update pointers in the given memory range"	oop _ self oopFromChunk: memStart.	[oop < memEnd] whileTrue: [		(self isFreeObject: oop) ifFalse: [			self remapFieldsAndClassOf: oop.		].		oop _ self objectAfterWhileForwarding: oop.	].! !!ObjectMemory methodsFor: 'gc -- compaction'!objectAfterWhileForwarding: oop	"Return the oop of the object after the given oop when the actual header of the oop may be in the forwarding table."	| header fwdBlock realHeader sz |	self inline: true.	header _ self longAt: oop.	(header bitAnd: MarkBit) = 0 ifTrue: [ ^ self objectAfter: oop ].  "oop not forwarded"	"Assume: mark bit cannot be set on a free chunk, so if we get here,	 oop is not free and it has a forwarding table entry"	fwdBlock _ header bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].	realHeader _ self longAt: fwdBlock + 4.	"following code is like sizeBitsOf:"	(realHeader bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz _ (self sizeHeader: oop) bitAnd: 16rFFFFFFC ]		ifFalse: [ sz _ realHeader bitAnd: 16rFC ].	^ self oopFromChunk: (oop + sz)! !!ObjectMemory methodsFor: 'gc -- compaction'!remap: oop	"Map the given oop to its new value during a compaction or become: operation. If it has no forwarding table entry, return the oop itself."	| fwdBlock |	self inline: false.	(self isObjectForwarded: oop) ifTrue: [		"get the new value for oop from its forwarding block"		fwdBlock _ (self longAt: oop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		^ self longAt: fwdBlock	].	^ oop! !!ObjectMemory methodsFor: 'gc -- compaction'!remapClassOf: oop	"Update the class of the given object, if necessary, using its forwarding table entry."	"Note: Compact classes need not be remapped since the compact class field is just an index into the compact class table. The header type bits show if this object has a compact class; we needn't look up the oop's real header."	| classHeader classOop fwdBlock newClassOop newClassHeader |	(self headerType: oop) = HeaderTypeShort ifTrue: [ ^nil ].  "compact classes needn't be mapped"	classHeader _ self longAt: (oop - 4).	classOop _ classHeader bitAnd: AllButTypeMask.	(self isObjectForwarded: classOop) ifTrue: [		fwdBlock _ (self longAt: classOop) bitAnd: AllButMarkBitAndTypeMask.		checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].		newClassOop _ self longAt: fwdBlock.		newClassHeader _ newClassOop bitOr: (classHeader bitAnd: TypeMask).		self longAt: (oop - 4) put: newClassHeader.		"The following ensures that become: into an old object's class makes it a root.		  It does nothing during either incremental or full compaction because		  oop will never be < youngStart."		((oop < youngStart) and: [newClassOop >= youngStart])			ifTrue: [ self beRootWhileForwarding: oop ].	].! !!ObjectMemory methodsFor: 'gc -- compaction'!remapFieldsAndClassOf: oop	"Replace all forwarded pointers in this object with their new oops, using the forwarding table. Remap its class as well, if necessary."	"Note: The given oop may be forwarded itself, which means that its real header is in its forwarding table entry."	| fieldOffset fieldOop fwdBlock newOop |	self inline: true.	fieldOffset _ self lastPointerWhileForwarding: oop.	[fieldOffset >= BaseHeaderSize] whileTrue: [		fieldOop _ self longAt: (oop + fieldOffset).		(self isObjectForwarded: fieldOop) ifTrue: [			"update this oop from its forwarding block"			fwdBlock _ (self longAt: fieldOop) bitAnd: AllButMarkBitAndTypeMask.			checkAssertions ifTrue: [ self fwdBlockValidate: fwdBlock ].			newOop _ self longAt: fwdBlock.			self longAt: (oop + fieldOffset) put: newOop.			"The following ensures that become: into old object makes it a root.			  It does nothing during either incremental or full compaction because			  oop will never be < youngStart."			((oop < youngStart) and: [newOop >= youngStart])				ifTrue: [ self beRootWhileForwarding: oop ].		].		fieldOffset _ fieldOffset - 4.	].	self remapClassOf: oop.! !!ObjectMemory methodsFor: 'become'!allYoung: array1 and: array2	"Return true if all the oops in both arrays, and the arrays themselves, are in the young object space."	| fieldOffset |	array1 < youngStart ifTrue: [ ^ false ].	array2 < youngStart ifTrue: [ ^ false ].	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self longAt: array1 + fieldOffset) < youngStart ifTrue: [ ^ false ].		(self longAt: array2 + fieldOffset) < youngStart ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!become: array1 with: array2	"All references to each object in array1 are swapped with all references to the corresponding object in array2. That is, all pointers to one object are replaced with with pointers to the other. The arguments must be arrays of the same length. Returns true if the primitive succeeds."	"Implementation: Uses forwarding blocks to update references as done in compaction."	(self fetchClassOf: array1) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self fetchClassOf: array2) = (self splObj: ClassArray) ifFalse: [ ^ false ].	(self lastPointerOf: array1) = (self lastPointerOf: array2) ifFalse: [ ^ false ].	(self containOnlyOops: array1 and: array2) ifFalse: [ ^ false ].	(self prepareForwardingTableForBecoming: array1 with: array2) ifFalse: [		^ false  "fail; not enough space for forwarding table"	].	(self allYoung: array1 and: array2) ifTrue: [		"sweep only the young objects plus the roots"		self mapPointersInObjectsFrom: youngStart to: endOfMemory.	] ifFalse: [		"sweep all objects"		self mapPointersInObjectsFrom: (self startOfMemory) to: endOfMemory.	].	self restoreHeadersAfterBecoming: array1 with: array2.	self initializeMemoryFirstFree: freeBlock.  "re-initialize memory used for forwarding table"	^ true  "success"! !!ObjectMemory methodsFor: 'become'!containOnlyOops: array1 and: array2	"Return true if neither array contains a small integer. You can't become: integers!!"	| fieldOffset |	fieldOffset _ self lastPointerOf: array1.  "same size as array2"	[fieldOffset >= BaseHeaderSize] whileTrue: [		(self isIntegerObject: (self longAt: array1 + fieldOffset)) ifTrue: [ ^ false ].		(self isIntegerObject: (self longAt: array2 + fieldOffset)) ifTrue: [ ^ false ].		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!exchangeHashBits: oop1 with: oop2	| hdr1 hdr2 |	hdr1 _ self longAt: oop1.	hdr2 _ self longAt: oop2.	self longAt: oop1 put:		((hdr1 bitAnd: AllButHashBits) bitOr: (hdr2 bitAnd: HashBits)).	self longAt: oop2 put:		((hdr2 bitAnd: AllButHashBits) bitOr: (hdr1 bitAnd: HashBits)).! !!ObjectMemory methodsFor: 'become'!prepareForwardingTableForBecoming: array1 with: array2	"Ensure that there are enough forwarding blocks to accomodate this become, then prepare forwarding blocks for the pointer swap. Return true if successful."	"Details: Doing a GC might generate enough space for forwarding blocks if we're short. However, this is an uncommon enough case that it is better handled by primitive fail code at the Smalltalk level."	| entriesNeeded entriesAvailable fieldOffset oop1 oop2 fwdBlock |	entriesNeeded _ 2 * ((self lastPointerOf: array1) // 4).  "need enough entries for both directions"	entriesAvailable _ self fwdTableInit.	entriesAvailable < entriesNeeded ifTrue: [		self initializeMemoryFirstFree: freeBlock.  "re-initialize the free block"		^ false	].	fieldOffset _ self lastPointerOf: array1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: array1 + fieldOffset.		oop2 _ self longAt: array2 + fieldOffset.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop1 to: oop2.		fwdBlock _ self fwdBlockGet.		self initForwardBlock: fwdBlock mapping: oop2 to: oop1.		fieldOffset _ fieldOffset - 4.	].	^ true! !!ObjectMemory methodsFor: 'become'!restoreHeaderOf: oop	"Restore the original header of the given oop from its forwarding block."	| fwdHeader fwdBlock |	fwdHeader _ self longAt: oop.	fwdBlock _ fwdHeader bitAnd: AllButMarkBitAndTypeMask.	checkAssertions ifTrue: [		(fwdHeader bitAnd: MarkBit) = 0 ifTrue: [			self error: 'attempting to restore the header of an object that has no forwarding block'.		].		self fwdBlockValidate: fwdBlock.	].	self longAt: oop put: (self longAt: fwdBlock + 4).  "restore orginal header"! !!ObjectMemory methodsFor: 'become'!restoreHeadersAfterBecoming: list1 with: list2	"Restore the headers of all oops in both lists. Exchange their hash bits so becoming objects in identity sets and dictionaries doesn't change their hash value."	| fieldOffset oop1 oop2 |	fieldOffset _ self lastPointerOf: list1.	[fieldOffset >= BaseHeaderSize] whileTrue: [		oop1 _ self longAt: list1 + fieldOffset.		oop2 _ self longAt: list2 + fieldOffset.		self restoreHeaderOf: oop1.		self restoreHeaderOf: oop2.		self exchangeHashBits: oop1 with: oop2.		fieldOffset _ fieldOffset - 4.	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjectMemory class	instanceVariableNames: ''!!ObjectMemory class methodsFor: 'initialization' stamp: 'ikp 1/3/98 23:10'!initialize	"ObjectMemory initialize"	self initializeSpecialObjectIndices.	self initializeObjectHeaderConstants.	LargeContextSize _ 156.	SmallContextSize _ 76.	NilContext _ 1.  "the oop for the integer 0; used to mark the end of context lists"	MinimumForwardTableBytes _ 16000.  "bytes reserved for forwarding table (8 bytes/entry)"	RemapBufferSize _ 25.	RootTableSize _ 1000.  "number of root table entries (4 bytes/entry)"	"tracer actions"	StartField _ 1.	StartObj _ 2.	Upward _ 3.	Done _ 4.! !!ObjectMemory class methodsFor: 'initialization'!initializeObjectHeaderConstants	BaseHeaderSize _ 4.	"masks for type field"	TypeMask _ 3.	AllButTypeMask _ 16rFFFFFFFF - TypeMask.	"type field values"	HeaderTypeSizeAndClass _ 0.	HeaderTypeClass _ 1.	HeaderTypeFree _ 2.	HeaderTypeShort _ 3.	"type field values used during the mark phase of GC"	HeaderTypeGC _ 2.	GCTopMarker _ 3.  "neither an oop, nor an oop+1, this value signals that we have crawled back up to the top of the marking phase."	"mask for a free chunk size"	FreeSizeMask _ 16r1FFFFFFC.	"base header word bit fields"	HashBits _ 16r1FFE0000.	AllButHashBits _ 16rFFFFFFFF - HashBits.	HashBitsOffset _ 17.	"masks for root and mark bits"	MarkBit _ 16r80000000.	RootBit _ 16r40000000.	AllButMarkBit _ 16rFFFFFFFF - MarkBit.	AllButRootBit _ 16rFFFFFFFF - RootBit.	AllButMarkBitAndTypeMask _ AllButTypeMask - MarkBit.! !!ObjectMemory class methodsFor: 'initialization' stamp: 'ikp 1/1/98 23:45'!initializeSpecialObjectIndices	"Initialize indices into specialObjects array."	NilObject _ 0.	FalseObject _ 1.	TrueObject _ 2.	SchedulerAssociation _ 3.	ClassBitmap _ 4.	ClassInteger _ 5.	ClassString _ 6.	ClassArray _ 7.	"SmalltalkDictionary _ 8."  "Do not delete!!"	ClassFloat _ 9.	ClassMethodContext _ 10.	ClassBlockContext _ 11.	ClassPoint _ 12.	ClassLargePositiveInteger _ 13.	TheDisplay _ 14.	ClassMessage _ 15.	ClassCompiledMethod _ 16.	TheLowSpaceSemaphore _ 17.	ClassSemaphore _ 18.	ClassCharacter _ 19.	SelectorDoesNotUnderstand _ 20.	SelectorCannotReturn _ 21.	TheInputSemaphore _ 22.	SpecialSelectors _ 23.	CharacterTable _ 24.	SelectorMustBeBoolean _ 25.	ClassByteArray _ 26.	ClassProcess _ 27.	CompactClasses _ 28.	TheTimerSemaphore _ 29.	TheInterruptSemaphore _ 30.	SmallMethodContext _ 34.	SmallBlockContext _ 36.	ExternalObjectsArray _ 38.	ClassPseudoContext _ 39.	ClassTranslatedMethod _ 40.! !!ObjectMemory class methodsFor: 'translation'!declareCVarsIn: aCCodeGenerator	aCCodeGenerator var: 'memory'		declareC: 'unsigned char *memory'.	aCCodeGenerator var: 'remapBuffer'		declareC: 'int remapBuffer[', (RemapBufferSize + 1) printString, ']'.	aCCodeGenerator var: 'rootTable'		declareC: 'int rootTable[', (RootTableSize + 1) printString, ']'.! !Object subclass: #ObjectScanner	instanceVariableNames: 'pvt3SmartRefStrm '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Object Storage'!!ObjectScanner commentStamp: 'di 5/22/1998 16:36' prior: 0!An instance of this class is the compiler's context for filing in a SmartRefStream containing instance-specific classes.  When the old name of a new object's class conflicts with an existing class name, install a class var in me.  It has the old name but points at the new class.  The compiler uses it when compiling the code in the fileIn.  Fill the SmartRefStream's renamed class dictionary.An object fileout:!!ObjectScanner new initialize!!      "allow me to take control with scanFrom:"Player subclass: Player23 instanceVariableNames: 'foo' classVariableNames: '' 	poolDictionaries: nil category: 'Instance Specific'!!	"I prescan this and (self rename: #Player23 toBe: #Player30)"!!Player23 methodsFor: 'all' stamp: 'tk 3/9/98 18:58'!!	"actually sent to Player30"foo	^ foo!! !!!!self smartRefStream!!<binary representation of the objects>!!!!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/15/98 20:17'!clear	"remove all old class vars.  They were UniClasses being remapped to aviod a name conflict."	self class classPool keys do: [:key |		self class classPool removeKey: key].	"brute force"! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/10/98 11:07'!initialize	"remove all old class vars that are not instance-specific classes being renamed"	self clear.! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/15/98 20:17'!lookAhead: aChunk	"See if this chunk is a class Definition, and if the new class name already exists and is instance-specific.  Modify the chunk, and record the rename in the SmartRefStream and in me."	| pieces sup oldName existing newName newDefn |	aChunk size < 90 ifTrue: [^ aChunk].		"class defn is big!!"	(aChunk at: 1) == $!! ifTrue: [^ aChunk].	"method def, fast exit"	pieces _ (aChunk copyFrom: 1 to: (300 min: aChunk size)) findTokens: ' #	\' withCRs.	pieces size < 3 ifTrue: [^ aChunk].	"really bigger, but just took front"	(pieces at: 2) = 'subclass:' ifFalse: [^ aChunk].	sup _ Smalltalk at: (pieces at: 1) asSymbol ifAbsent: [^ aChunk].	sup class class == Metaclass ifFalse: [^ aChunk].	((oldName _ pieces at: 3) at: 1) isUppercase ifFalse: [^ aChunk].	oldName _ oldName asSymbol.	(Smalltalk includesKey: oldName) ifFalse: [^ aChunk].	"no conflict"	existing _ Smalltalk at: oldName.	existing isSystemDefined ifTrue: [^ aChunk].	"Go ahead and redefine it!!"	"Is a UniClass"	newName _ sup chooseUniqueClassName.	newDefn _ aChunk copyReplaceAll: oldName with: newName.	Compiler evaluate: newDefn for: self logged: true.	"Create the new class"	self rename: oldName toBe: newName.	^ newName asString		"to be evaluated"! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/15/98 20:21'!rename: existingName toBe: newName	"See if there is a conflict between what the fileIn wants to call the new UniClass (Player23) and what already exists for another unique instance.  If conflict, make a class variable to intercept the existingName and direct it to class newName."	existingName = newName ifFalse: [		self class ensureClassPool.	"create the dictionary"		"can't use addClassVarName: because it checks for conflicts with Smalltalk"		(self class classPool includesKey: existingName) ifFalse: 			["Pick up any refs in Undeclared"			self class classPool declare: existingName from: Undeclared].		self class classPool at: existingName put: (Smalltalk at: newName).		pvt3SmartRefStrm renamed at: existingName put: newName]! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/15/98 20:22'!scanFrom: aByteStream	"Sieze control of the fileIn.  Put myself in as the context.  If any UniClasses (for just one instance) are defined, they will do it through me, and I will look for conflicting class names.  If so, install the old name as a class var of me, so the compile will work.  Tell my SmartRefStream about renaming the class."	| valWithOddName47 scannerNamed53 chunkNamed117 |	pvt3SmartRefStrm _ SmartRefStream on: aByteStream.	aByteStream ascii.	[aByteStream atEnd] whileFalse:		[aByteStream skipSeparators.		valWithOddName47 _ (aByteStream peekFor: $!!)			ifTrue: [chunkNamed117 _ aByteStream nextChunk.	"debug"					scannerNamed53 _ Compiler evaluate: chunkNamed117							for: self logged: false.					scannerNamed53 class == self class 						ifTrue: ["I already am the scanner for this file"]						ifFalse: [scannerNamed53 scanFrom: aByteStream]]			ifFalse: [chunkNamed117 _ aByteStream nextChunk.					chunkNamed117 _ self lookAhead: chunkNamed117.					Compiler evaluate: chunkNamed117 for: self logged: true].		aByteStream skipStyleChunk].	^ valWithOddName47! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 3/15/98 19:33'!smartRefStream	^ pvt3SmartRefStrm! !nil subclass: #ObjectTracer	instanceVariableNames: 'tracedObject recursionFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!ObjectTracer commentStamp: 'di 5/22/1998 16:36' prior: 0!ObjectTracer class comment:'An ObjectTracer can be wrapped around another object, and then give you a chance to inspect it whenever it receives messages from the outside.  For instance...	(ObjectTracer on: Display) flash: (50@50 extent: 50@50)will give control to a debugger just before the message flash is sent.Obviously this facility can be embellished in many useful ways.See also the even more perverse subclass, ObjectViewer, and its example.'!!ObjectTracer methodsFor: 'very few messages' stamp: 'jm 4/19/1998 20:27'!doesNotUnderstand: aMessage 	"All external messages (those not caused by the re-send) get trapped here"	"Present a dubugger before proceeding to re-send the message"	Debugger openContext: thisContext				label: 'About to perform: ', aMessage selector				contents: thisContext shortStack.	^ aMessage sentTo: tracedObject.! !!ObjectTracer methodsFor: 'very few messages'!xxxUnTrace	tracedObject become: self! !!ObjectTracer methodsFor: 'very few messages'!xxxViewedObject	"This message name must not clash with any other (natch)."	^ tracedObject! !!ObjectTracer methodsFor: 'very few messages'!xxxViewedObject: anObject	"This message name must not clash with any other (natch)."	tracedObject _ anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjectTracer class	instanceVariableNames: ''!!ObjectTracer class methodsFor: 'instance creation'!on: anObject	^ self new xxxViewedObject: anObject! !ObjectTracer subclass: #ObjectViewer	instanceVariableNames: 'valueBlock lastValue changeBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!ObjectViewer commentStamp: 'di 5/22/1998 16:36' prior: 0!ObjectViewer class comment:'ObjectViewers offers the same kind of interception of messages (via doesnotUnderstand:) as ObjectTracers, but instead of just being wrappers, they actually replace the object being viewed.  This makes them a lot more dangerous to use, but one can do amazing things.  For instance, the example below actually intercepts the InputSensor object, and prints the mouse coordinates asynchronously, every time they change:	Sensor evaluate: [Sensor cursorPoint printString displayAt: 0@0]		wheneverChangeIn: [Sensor cursorPoint].To exit from this example, execute:	Sensor xxxUnTrace'!!ObjectViewer methodsFor: 'very few messages'!doesNotUnderstand: aMessage 	"Check for change after sending aMessage"	| returnValue newValue |	recursionFlag ifTrue: [^ aMessage sentTo: tracedObject].	recursionFlag _ true.	returnValue _ aMessage sentTo: tracedObject.	newValue _ valueBlock value.	newValue = lastValue ifFalse:		[changeBlock value.		lastValue _ newValue].	recursionFlag _ false.	^ returnValue! !!ObjectViewer methodsFor: 'very few messages'!xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2	"This message name must not clash with any other (natch)."	tracedObject _ viewedObject.	valueBlock _ block2.	changeBlock _ block1.	recursionFlag _ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ObjectViewer class	instanceVariableNames: ''!!ObjectViewer class methodsFor: 'instance creation'!on: viewedObject evaluate: block1 wheneverChangeIn: block2	^ self new xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2! !Switch subclass: #OneOnSwitch	instanceVariableNames: 'connection '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Menus'!!OneOnSwitch commentStamp: 'di 5/22/1998 16:36' prior: 0!OneOnSwitch comment:'I am a kind of Switch that can be connected to some related object, typically to a collection of my instances. When my instance is created, its connection is set to a particular object. When the object changes because an Switch it refers to is turned on, an update message is broadcasted. All the connected OneOnSwitches, except the changed one, turn off. This allows OneOnSwitches to maintain the constraint that at most one of them will be on at any time. OneOnSwitches can thus be made to act like "car radio" switches.'!!OneOnSwitch methodsFor: 'initialize-release'!release	super release.	self isConnectionSet ifTrue: [connection removeDependent: self]! !!OneOnSwitch methodsFor: 'state'!turnOn	"Does nothing if it is already on. If it is not, it is set to 'on', its	dependents are 	notified of the change, its connection is notified, and	its action is executed."	self isOff		ifTrue: 			[on _ true.			self changed.			self notifyConnection.			self doAction: onAction]! !!OneOnSwitch methodsFor: 'connection'!connection	"Answer the object that connects the receiver to other Switches."	^connection! !!OneOnSwitch methodsFor: 'connection'!connection: anObject 	"Set anObject to be the connection among two or more Switches. Make the 	receiver a dependent of the argument, anObject."	connection _ anObject.	connection addDependent: self! !!OneOnSwitch methodsFor: 'connection'!isConnectionSet	"Answer whether the receiver is connected to an object that coordinates 	updates among switches."	connection == nil		ifTrue: [^false]		ifFalse: [^true]! !!OneOnSwitch methodsFor: 'connection'!notifyConnection	"Send the receiver's connection (if it exists) the message 'changed: self' in 	order for the connection to broadcast the change to other objects 	connected by the connection."		self isConnectionSet ifTrue: [self connection changed: self]! !!OneOnSwitch methodsFor: 'updating'!update: aOneOnSwitch 	"Does nothing if aOneOnSwitch is identical to this object. If it is not, this 	object is turned off. This message is sent by the connection (an Object)	when some related OneOnSwitch (possibly this one) has changed. This	allows a group of related OneOnSwitches to maintain the constraint that	at most one will be on at any time."	self ~~ aOneOnSwitch ifTrue: [self turnOff]! !Color subclass: #OpaqueMaskColor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!OpaqueMaskColor commentStamp: 'di 5/22/1998 16:36' prior: 0!OpaqueMaskColor class comment:'The pixel value of an OpaqueMaskColor is all-ones in any depth. This allows it to be used in combination with the AND mode of BitBlt to create masks that work at any depth. Clients typically use "Color opaqueMask" to get an instance of me.'!!OpaqueMaskColor methodsFor: 'equality' stamp: 'di 10/1/97 20:14'!= aColor	^ aColor isColor and: [aColor isOpaqueMask]! !!OpaqueMaskColor methodsFor: 'equality'!hash	^ 1023! !!OpaqueMaskColor methodsFor: 'queries'!isOpaqueMask	^ true! !!OpaqueMaskColor methodsFor: 'transformations'!* aFactor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!+ aColor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!- aColor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!/ aFactor	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!darker	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!lighter	^ self! !!OpaqueMaskColor methodsFor: 'transformations'!mixed: proportion with: aColor	^ self! !!OpaqueMaskColor methodsFor: 'printing'!shortPrintString	^ 'OpaqueMask'! !!OpaqueMaskColor methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Color opaqueMask)'.! !!OpaqueMaskColor methodsFor: 'conversions'!bitPatternForDepth: depth	^ Bitmap with: (self pixelWordForDepth: depth)! !!OpaqueMaskColor methodsFor: 'conversions'!pixelValueForDepth: depth	^ (1 bitShift: depth) - 1! !!OpaqueMaskColor methodsFor: 'conversions'!pixelWordForDepth: depth	^ 16rFFFFFFFF! !!OpaqueMaskColor methodsFor: 'private'!setRed: r green: g blue: b	"Ignored."! !SequenceableCollection subclass: #OrderedCollection	instanceVariableNames: 'array firstIndex lastIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!OrderedCollection commentStamp: 'di 5/22/1998 16:36' prior: 0!OrderedCollection comment:'I represent a collection of objects ordered by the collector.'!!OrderedCollection methodsFor: 'accessing'!after: oldObject 	"Answer the element after oldObject. If the receiver does not contain 	oldObject or if the receiver contains no elements after oldObject, create 	an error notification."	| index |	index _ self find: oldObject.	index = lastIndex		ifTrue: [^self errorLastObject]		ifFalse: [^array at: index + 1]! !!OrderedCollection methodsFor: 'accessing'!at: anInteger 	"Answer my element at index anInteger. at: is used by a knowledgeable	client to access an existing element"	(anInteger < 1 or: [anInteger + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^ array at: anInteger + firstIndex - 1]! !!OrderedCollection methodsFor: 'accessing'!at: anInteger put: anObject 	"Put anObject at element index anInteger. at:put: cannot be used to	append, front or back, to an ordered collection; it is used by a	knowledgeable client to replace an element."	| index |	index _ anInteger asInteger.	(index < 1 or: [index + firstIndex - 1 > lastIndex])		ifTrue: [self errorNoSuchElement]		ifFalse: [^array at: index + firstIndex - 1 put: anObject]! !!OrderedCollection methodsFor: 'accessing'!atPin: anInteger 	"Answer my element at index anInteger. at: is used by a knowledgeable client to access an existing element.   Return the first or last element if index is out of bounds.  6/18/96 tk"anInteger < 1	ifTrue: [^ self first]	ifFalse: [anInteger + firstIndex - 1 > lastIndex		ifTrue: [^ self last]		ifFalse: [^ array at: anInteger + firstIndex - 1]]! !!OrderedCollection methodsFor: 'accessing'!atWrap: anInteger 	"Answer my element at index anInteger. at: is used by a knowledgeable client to access an existing element.   If index is out of bounds, let it wrap around from the end to the beginning until it is in bounds.  6/18/96 tk"^ self at: (anInteger - 1 \\ self size + 1)! !!OrderedCollection methodsFor: 'accessing'!before: oldObject 	"Answer the element before oldObject. If the receiver does not contain 	oldObject or if the receiver contains no elements before oldObject, create 	an error notification."	| index |	index _ self find: oldObject.	index = firstIndex		ifTrue: [^ self errorFirstObject]		ifFalse: [^ array at: index - 1]! !!OrderedCollection methodsFor: 'accessing'!first	"Answer the first element. If the receiver is empty, create an errror	message. This is a little faster than the implementation in the superclass."	self emptyCheck.	^ array at: firstIndex! !!OrderedCollection methodsFor: 'accessing'!inspect	"Open an OrderedCollectionInspector on the receiver.	Use basicInspect to get a normal type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!OrderedCollection methodsFor: 'accessing'!last	"Answer the last element. If the receiver is empty, create an errror	message. This is a little faster than the implementation in the superclass."	self emptyCheck.	^ array at: lastIndex! !!OrderedCollection methodsFor: 'accessing'!size	^lastIndex - firstIndex + 1! !!OrderedCollection methodsFor: 'copying'!copyEmpty	"Answer a copy of the receiver that contains no elements."	^self species new! !!OrderedCollection methodsFor: 'copying'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	| targetCollection |	endIndex < startIndex ifTrue: [^self species new: 0].	targetCollection _ self species new: endIndex + 1 - startIndex.	startIndex to: endIndex do: [:index | targetCollection add: (self at: index)].	^ targetCollection! !!OrderedCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver with replacementCollection's elements in	place of the receiver's start'th to stop'th elements. This does not expect	a 1-1 map from replacementCollection to the start to stop elements, so it	will do an insert or append."	| newOrderedCollection delta startIndex stopIndex |	"if start is less than 1, ignore stop and assume this is inserting at the front. 	if start greater than self size, ignore stop and assume this is appending. 	otherwise, it is replacing part of me and start and stop have to be within my 	bounds. "	delta _ 0.	startIndex _ start.	stopIndex _ stop.	start < 1		ifTrue: [startIndex _ stopIndex _ 0]		ifFalse: [startIndex > self size				ifTrue: [startIndex _ stopIndex _ self size + 1]				ifFalse: 					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])						ifTrue: [self errorOutOfBounds].					delta _ stopIndex - startIndex + 1]].	newOrderedCollection _ 		self species new: self size + replacementCollection size - delta.	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].	1 to: replacementCollection size do: 		[:index | newOrderedCollection add: (replacementCollection at: index)].	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].	^newOrderedCollection! !!OrderedCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and 	includes the argument, newElement, at the end."	| newCollection |	newCollection _ self copy.	newCollection add: newElement.	^newCollection! !!OrderedCollection methodsFor: 'copying' stamp: 'di 11/4/97 20:11'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any elements equal	to oldElement."	^ self select: [:each | each ~= oldElement]! !!OrderedCollection methodsFor: 'copying' stamp: 'di 11/4/97 20:11'!copyWithoutAll: aList	"Answer a copy of the receiver that does not contain any elements equal	to those in aList."	^ self select: [:each | (aList includes: each) not]! !!OrderedCollection methodsFor: 'copying' stamp: 'sw 1/26/96'!reversed	"Answer a copy of the receiver with element order reversed.  "	| newCol |	newCol _ self species new.	self reverseDo:		[:elem | newCol addLast: elem].	^ newCol"#(2 3 4 'fred') reversed"! !!OrderedCollection methodsFor: 'adding'!add: newObject	^self addLast: newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject after: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just succeeding oldObject. Answer newObject."		| index |	index _ self find: oldObject.	self insert: newObject before: index + 1.	^newObject! !!OrderedCollection methodsFor: 'adding'!add: newObject before: oldObject 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just preceding oldObject. Answer newObject."		| index |	index _ self find: oldObject.	self insert: newObject before: index.	^newObject! !!OrderedCollection methodsFor: 'adding'!addAll: anOrderedCollection 	"Add each element of anOrderedCollection at my end. Answer	anOrderedCollection."	^self addAllLast: anOrderedCollection! !!OrderedCollection methodsFor: 'adding'!addAllFirst: anOrderedCollection 	"Add each element of anOrderedCollection at the beginning of the 	receiver. Answer anOrderedCollection."	anOrderedCollection reverseDo: [:each | self addFirst: each].	^anOrderedCollection! !!OrderedCollection methodsFor: 'adding'!addAllLast: anOrderedCollection 	"Add each element of anOrderedCollection at the end of the receiver. 	Answer anOrderedCollection."	anOrderedCollection do: [:each | self addLast: each].	^anOrderedCollection! !!OrderedCollection methodsFor: 'adding'!addFirst: newObject 	"Add newObject to the beginning of the receiver. Answer newObject."	firstIndex = 1 ifTrue: [self makeRoomAtFirst].	firstIndex _ firstIndex - 1.	array at: firstIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding'!addLast: newObject 	"Add newObject to the end of the receiver. Answer newObject."	lastIndex = array size ifTrue: [self makeRoomAtLast].	lastIndex _ lastIndex + 1.	array at: lastIndex put: newObject.	^ newObject! !!OrderedCollection methodsFor: 'adding'!grow	"Become larger. Typically, a subclass has to override this if the subclass	adds instance variables."	| newArray |	newArray _ Array new: self size + self growSize.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray! !!OrderedCollection methodsFor: 'adding'!growSize	^ array size max: 2! !!OrderedCollection methodsFor: 'removing'!remove: oldObject ifAbsent: absentBlock	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[oldObject = (array at: index)				ifTrue: 					[self removeIndex: index.					^ oldObject]				ifFalse: [index _ index + 1]].	^ absentBlock value! !!OrderedCollection methodsFor: 'removing'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element of the receiver. Remove each element 	for which aBlock evaluates to true. Answer an OrderedCollection of the 	removed elements."	| index element newCollection |	newCollection _ self species new.	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[element _ array at: index.			(aBlock value: element)				ifTrue: 					[newCollection add: element.					self removeIndex: index]				ifFalse: [index _ index + 1]].	^newCollection! !!OrderedCollection methodsFor: 'removing'!removeAt: index	^self removeIndex: index + firstIndex - 1! !!OrderedCollection methodsFor: 'removing'!removeFirst	"Remove the first element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| firstObject |	self emptyCheck.	firstObject _ array at: firstIndex.	array at: firstIndex put: nil.	firstIndex _ firstIndex + 1.	^ firstObject! !!OrderedCollection methodsFor: 'removing'!removeLast	"Remove the last element of the receiver and answer it. If the receiver is 	empty, create an error notification."	| lastObject |	self emptyCheck.	lastObject _ array at: lastIndex.	array at: lastIndex put: nil.	lastIndex _ lastIndex - 1.	^ lastObject! !!OrderedCollection methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into a collection that is like me. Answer the new 	collection. Override superclass in order to use add:, not at:put:."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection! !!OrderedCollection methodsFor: 'enumerating'!do: aBlock 	"Override the superclass for performance reasons."	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[aBlock value: (array at: index).			index _ index + 1]! !!OrderedCollection methodsFor: 'enumerating'!reverseDo: aBlock 	"Override the superclass for performance reasons."	| index |	index _ lastIndex.	[index >= firstIndex]		whileTrue: 			[aBlock value: (array at: index).			index _ index - 1]! !!OrderedCollection methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true. Override the superclass in order to use add:, not at:put:."	| newCollection |	newCollection _ self copyEmpty.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^ newCollection! !!OrderedCollection methodsFor: 'private'!collector  "Private"	^ array! !!OrderedCollection methodsFor: 'private'!errorConditionNotSatisfied	self error: 'no element satisfies condition'! !!OrderedCollection methodsFor: 'private'!errorFirstObject	self error: 'specified object is first object'! !!OrderedCollection methodsFor: 'private'!errorLastObject	self error: 'specified object is last object'! !!OrderedCollection methodsFor: 'private'!errorNoSuchElement	self error: 'attempt to index non-existent element in an ordered collection'! !!OrderedCollection methodsFor: 'private'!errorNotFound	self error: 'element not found'! !!OrderedCollection methodsFor: 'private'!find: oldObject	| index |	index _ firstIndex.	[index <= lastIndex and: [oldObject ~= (array at: index)]]		whileTrue: [index _ index + 1].	index <= lastIndex		ifTrue: [^ index]		ifFalse: [self errorNotFound]! !!OrderedCollection methodsFor: 'private'!insert: anObject before: spot	| index delta spotIndex|	spotIndex _ spot.	delta _ spotIndex - firstIndex.	firstIndex = 1		ifTrue: 			[self makeRoomAtFirst.			spotIndex _ firstIndex + delta].	index _ firstIndex _ firstIndex - 1.	[index < (spotIndex - 1)]		whileTrue: 			[array at: index put: (array at: index + 1).			index _ index + 1].	array at: index put: anObject.	^ anObject! !!OrderedCollection methodsFor: 'private'!makeRoomAtFirst	| delta index |	delta _ array size - self size.	delta = 0 ifTrue: 			[self grow.			delta _ array size - self size].	lastIndex = array size ifTrue: [^ self]. "just in case we got lucky"	index _ array size.	[index > delta]		whileTrue: 			[array at: index put: (array at: index - delta + firstIndex - 1).			array at: index - delta + firstIndex - 1 put: nil.			index _ index - 1].	firstIndex _ delta + 1.	lastIndex _ array size! !!OrderedCollection methodsFor: 'private'!makeRoomAtLast	| newLast delta |	newLast _ self size.	array size - self size = 0 ifTrue: [self grow].	(delta _ firstIndex - 1) = 0 ifTrue: [^ self].	"we might be here under false premises or grow did the job for us"	1 to: newLast do:		[:index |		array at: index put: (array at: index + delta).		array at: index + delta put: nil].	firstIndex _ 1.	lastIndex _ newLast! !!OrderedCollection methodsFor: 'private'!removeIndex: removedIndex	| index |	index _ removedIndex.	[index < lastIndex]		whileTrue: 			[array at: index put: (array at: index + 1).			index _ index + 1].	array at: lastIndex put: nil.	lastIndex _ lastIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!reset	firstIndex _ array size // 3 max: 1.	lastIndex _ firstIndex - 1! !!OrderedCollection methodsFor: 'private' stamp: 'di 11/14/97 12:54'!setCollection: anArray	array _ anArray.	self reset! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OrderedCollection class	instanceVariableNames: ''!!OrderedCollection class methodsFor: 'instance creation'!new	^self new: 10! !!OrderedCollection class methodsFor: 'instance creation'!new: anInteger 	"If a subclass adds fields, then it is necessary for that subclass to	reimplement new:."	^ super new setCollection: (Array new: anInteger)! !!OrderedCollection class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new: aCollection size.	newCollection addAll: aCollection.	^newCollection"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !Inspector subclass: #OrderedCollectionInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Inspector'!!OrderedCollectionInspector methodsFor: 'all' stamp: 'tk 4/13/1998 09:49'!fieldList	^ self baseFieldList ,		(object size <= (self i1 + self i2)			ifTrue: [(1 to: object size)						collect: [:i | i printString]]			ifFalse: [(1 to: self i1) , (object size-(self i2-1) to: object size)						collect: [:i | i printString]])"OrderedCollection new inspect(OrderedCollection newFrom: #(3 5 7 123)) inspect(OrderedCollection newFrom: (1 to: 1000)) inspect"! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:38'!replaceSelectionValue: anObject 	"The receiver has a list of variables of its inspected object. One of these 	is selected. The value of the selected variable is set to the value, anObject."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super replaceSelectionValue: anObject].	object at: self selectedObjectIndex put: anObject! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:28'!selectedObjectIndex	"Answer the index of the inspectee's collection that the current selection refers to."	| basicIndex |	basicIndex _ selectionIndex - 2 - object class instSize.	^ (object size <= (self i1 + self i2)  or: [basicIndex <= self i1])		ifTrue: [basicIndex]		ifFalse: [object size - (self i1 + self i2) + basicIndex]! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:39'!selectedSlotName	"Answer the name of the currently selected slot, for the purpose of putting it into a menu title"	^ (selectionIndex _ self selectionIndex) <= self baseFieldList size		ifTrue:			[super selectedSlotName]		ifFalse:			[ 'element ', self selectedObjectIndex printString, ' ']! !!OrderedCollectionInspector methodsFor: 'all' stamp: 'sw 9/16/97 22:39'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	(selectionIndex - 2) <= object class instSize		ifTrue: [^ super selection].	^ object at: self selectedObjectIndex! !SwikiAction subclass: #PSwikiAction	instanceVariableNames: 'authorizer '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!PSwikiAction commentStamp: 'di 5/22/1998 16:36' prior: 0!A Swiki with the potential for a password on each page.  Requires the special folder 'pswiki' from the swiki web site.!!PSwikiAction methodsFor: 'all' stamp: 'mjg 2/6/98 15:43'!auth	^authorizer! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 2/6/98 15:44'!auth: anAuth	authorizer _ anAuth.! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 2/9/98 13:06'!browse: pageRef from: request	"Check authorization"	(pageRef privs includesSubString: 'read') ifTrue:		[(authorizer user: request userID) = pageRef coreID		ifFalse: [self error: (PWS unauthorizedFor: authorizer realm)]].	request reply: PWS success; reply: PWS contentHTML.	request reply: PWS crlf.	^super browse: pageRef from: request! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 5/1/98 09:58'!edit: pageRef from: request	"Check authorization"	(pageRef privs includesSubString: 'write') ifTrue:		[(authorizer user: request userID) = pageRef coreID		ifFalse: [self error: (PWS unauthorizedFor: authorizer realm)]].	request reply: PWS success; reply: PWS contentHTML.	request reply: PWS crlf.request reply: (HTMLformatter evalEmbedded: 							(self fileContents: source , 'pedit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 2/9/98 12:46'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf, 			(HTMLformatter evalEmbedded: (self fileContents: source, 'results.html')				with: (urlmap searchFor: (request fields at: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(request fields includesKey: 'text') ifTrue: [		"It's a response from an edit, so store the page"		page _ urlmap			storeID: coreRef			username: (request fields at: 'username' ifAbsent: [''])			password: (request fields at: 'password' ifAbsent: [''])			privs: (request fields at: 'privs' ifAbsent: [''])			text: (request fields at: 'text' ifAbsent: ['blank text'])			from: request peerName.		page user: request userID.  "Address is machine, user only if logged in"		^ self].	"return self means do serve the edited page afterwards"	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fields printString; cr.! !!PSwikiAction methodsFor: 'all' stamp: 'tk 5/21/1998 16:47'!mapName: nameString password: pwdString to: aPerson	"Insert/remove the username:password combination into/from the users Dictionary.  *** Use this method to add or delete users!!  If you ask for the authorizer and talk to it, the change will not be recorded on the disk!! ***   We use encoding per RFC1421."	authorizer mapName: nameString password: pwdString to: aPerson.	self authorizer: authorizer.	"force it to be written to the disk"		"*** Authorizer not saved to disk yet for this class ***"! !!PSwikiAction methodsFor: 'all' stamp: 'tk 5/21/1998 13:07'!process: request	"URLs are of the form:		{swikiname} to browse Front Page		{swikiname}.{coreID} to browse the page		{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case) return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter 					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, or Edit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded: 							(self fileContents: source , 'results.html')						with: (urlmap searchFor: pageRef name)).			^ self].		command = 'all' ifTrue: 			[formattedPage _ urlmap allPagesFrom: pageRef for: request.			request reply: (HTMLformatter evalEmbedded: 							(self fileContents: source, 'page.html')						with: formattedPage).			^ self].		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !!PSwikiAction methodsFor: 'all' stamp: 'tk 5/22/1998 10:23'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	super restore: nameOfSwiki.	authorizer _ Authorizer new.	"<- not restored from disk in this implementation"	authorizer realm: name.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PSwikiAction class	instanceVariableNames: ''!!PSwikiAction class methodsFor: 'initialization' stamp: 'tk 5/21/1998 12:53'!mapClass	"The class of my pages"	^ PURLmap! !!PSwikiAction class methodsFor: 'initialization' stamp: 'tk 5/14/1998 18:22'!pageClass	"The class of my pages"	^ PSwikiPage! !!PSwikiAction class methodsFor: 'initialization' stamp: 'tk 5/22/1998 10:03'!setUp: actionName	"Set up a named protected Swiki"	| action auth |	super setUp: actionName.	action _ PWS actions at: actionName.	auth _ Authorizer new.	"*** for now, not restored from the disk***"	auth realm: actionName.	action auth: auth.	^ action! !SwikiPage subclass: #PSwikiPage	instanceVariableNames: 'username password privs '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!PSwikiPage methodsFor: 'all' stamp: 'tk 5/21/1998 13:38'!chunk1		| who |	^ String streamContents: [:ss | 		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  Time now print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].	"must be a string!!!!"		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' authName: '; nextPutAll: username printString.		ss nextPutAll: ' authPW: '; nextPutAll: password printString.		ss nextPutAll: ' privs: '; nextPutAll: privs printString.		ss nextPutAll: ' text: ']! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:59'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	username _ ''. password _ ''. privs _ ''.	self scanFrom: theFile.	"name, date"	(username size > 1) ifTrue: ["Set up the authorization"		aSwikiAction auth mapName: username password: password			to: coreID.].	address _ ''.		"should be page that points at it, but how get that?"! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/6/98 15:21'!name: pageName date: dateString time: timeString by: who authName: aName authPW: thePass privs: thePrivs text: theString back: bytes	"Record the name of this page during startup.  When reading the page in order to serve it, this is NOT executed.  The text is read from the file explicitly."		name _ pageName.	date _ dateString asDate.	username _ aName.	password _ thePass.	privs _ thePrivs.! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:54'!password	^password! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:54'!password: aString	password _ aString! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:48'!privs	^privs! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:52'!privs: aString	"Privilege string should contain 'read' or 'write' for what's protected"	privs _ aString! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:53'!username	^username! !!PSwikiPage methodsFor: 'all' stamp: 'mjg 2/9/98 11:54'!username: aName	username _ aName.! !URLmap subclass: #PURLmap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!PURLmap methodsFor: 'all' stamp: 'mjg 2/9/98 13:18'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse: [peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (HTMLformatter swikify: (pageRef text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: refPages]).	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPage formatted.	refPages do: [:page |		(page privs includesSubString: 'read') ifTrue:			[(action auth user: request userID) = page coreID			ifFalse: [self error: (PWS unauthorizedFor: (page name))]].		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: (OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THE page"	^formattedPage! !!PURLmap methodsFor: 'all' stamp: 'mjg 2/9/98 12:28'!newpage: label from: peer	| newpage newfile |		newpage _ PSwikiPage new. 		self at: label put: newpage. 		newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage file: ((ServerAction serverDirectory), 			directory, (ServerAction pathSeparator), newfile).		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	newpage username: ''.	newpage password: ''.	newpage privs: ''.	^newpage! !!PURLmap methodsFor: 'all' stamp: 'mjg 2/9/98 13:12'!recent	| response sortedPages currentDate |	sortedPages _ pages asSortedCollection: [:a :b | a date > b date].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'. 	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDate printString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(page address).		(page privs includesSubString: 'read') ifTrue: 			[response nextPutAll: '  <b>Read protected</b>'.].		(page privs includesSubString: 'write') ifTrue: 			[response nextPutAll: '  <b>Write protected</b>'.].].	response nextPutAll: '</ul>'. 	^response contents! !!PURLmap methodsFor: 'all' stamp: 'mjg 2/9/98 12:20'!storeID: id  username: theUsername password: thePassword privs: thePrivs text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page text: text.	page address: peer.	(theUsername size > 1) ifTrue: [		page username: theUsername.		page password: thePassword.		page privs: thePrivs.		"Set up the authorization"		action auth mapName: theUsername password: thePassword			to: id.].	^ page! !Object subclass: #PWS	instanceVariableNames: 'peerName userId message fields connection log url header '	classVariableNames: 'ActionTable BackupJobs ClientNameCache ServerLog ServerPort ServerProcess ServerStatus '	poolDictionaries: ''	category: 'PluggableWebServer'!!PWS commentStamp: 'di 5/22/1998 16:36' prior: 0!PWS is the PluggableWebServer.  Documentation for it can be found athttp://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/.The PWS decouples the networking and HTTP translation roles of a Web Serverfrom the URL translation and CGI execution roles. The latter roles areplayed by ServerActions.To record a ServerAction for the PWS, use PWS link: key to: action. Key isa string that will be parsed out of the incoming URL.See PWS class howToStart.PWS (and its associated files) are based on Georg Gollman's WebServer,extended by Mark Guzdial.  Those portions are copyright 1997 Georgia TechResearch Corporation and are used with permission.  Mark Guzdial's work onPWS was funded in part by NSF grant REC-9550458.!]style[(432 20 273)f1,f1LPWS class howToStart;,f1!!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!fields   "Return the value of the instance variable 'fields'."   ^fields! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!log   "Return the value of the instance variable 'log'."   ^log! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!log: aString	"Add to the log."	log nextPutAll: aString! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!message   "Return the value of the instance variable 'message'."   ^message! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!objectsInField: fieldName  "Extract the array of objects denoted by 'fieldName', return an empty array if there are none."  | sel |  sel := fields at: fieldName ifAbsent: [ ^#() ].  (sel isKindOf: Array) ifFalse: [ sel := { sel } ].  ^sel collect: [ :s | self objectFromString: s ]! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:23'!peerName  "Return the requesting ipAddress"  ^peerName! !!PWS methodsFor: 'Accessing' stamp: 'jm 3/10/98 11:00'!reply: aString	"Send back part of the reply. If we are in roll forward mode just do nothing."	((connection ~~ nil) and: [connection isConnected])		ifTrue: [connection sendData: aString].! !!PWS methodsFor: 'Accessing' stamp: 'mjg 10/25/97 14:33'!url	^ url! !!PWS methodsFor: 'Accessing' stamp: 'mjg 11/6/97 16:57'!userID   "Return the value of the instance variable 'userID'."   ^userId! !!PWS methodsFor: 'Initializing' stamp: 'jm 3/13/98 12:56'!clientName: addr	"Return the host name of the client connecting via the given socket. If the host name cannot be found, return a string representing that host's numeric IP address."	"Details: Since querying the domain name server can take many seconds (up to 13 second delays were observed during busy times), the results of this query are cached. This cache is flushed when the server starts up, although it could be flushed, say, hourly."	| addrString name |	addrString _ NetNameResolver stringFromAddress: addr.	(ClientNameCache includesKey: addrString) ifFalse: [		name _ NetNameResolver nameForAddress: addr timeout: 15.		name ifNil: [name _ addrString].  "lookup failed or timed out; use numeric address"		ClientNameCache at: addrString put: name].	^ ClientNameCache at: addrString! !!PWS methodsFor: 'Initializing' stamp: 'jm 3/13/98 12:01'!initializeFrom: aSocket	"Initialize me from aSocket."	| request idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	"sets header"	header _ header substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at: idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ self clientName: connection remoteAddress.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	message := url findTokens: '/.\?:='.	request last notNil ifTrue: [ fields := self decodeFields: request last ]! !!PWS methodsFor: 'Initializing' stamp: 'tk 1/29/98 08:21'!readRequest	"Read the request and return an array of header and query."	| idx request query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf) startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString: 'CONTENT-LENGTH:' startingAt: 1) = 0 			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to: 		  (request indexOf: Character cr startingAt: length ifAbsent: [])) 			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request, connection getData ].		query := (request copyFrom: idx + 3 to: request size) withBlanksTrimmed ]	ifFalse: [		((idx := header indexOf: $?) between: 1 and: (header indexOf: (Character cr))) ifTrue: [			query := header copyFrom: idx + 1 to: header size.			header := header copyFrom: 1 to: idx - 1 ]].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'mjg 10/24/97 17:27'!decodeFields: aString  "Convert the form fields in aString to a query dictionary."  | query dict i key value |  query := aString findTokens: '&'.  dict := Dictionary new.  query do: [ :tag |    i := tag indexOf: $=.    key := tag copyFrom: 1 to: i - 1.    value := i < tag size ifTrue: [ self unEscape: (tag copyFrom: i + 1 to: tag size) ] ifFalse: [ nil ].    (dict includesKey: key)     ifFalse: [ dict at: key put: value ]     ifTrue: [      ((dict at: key) isKindOf: String) 		ifTrue: [ dict at: key put: (OrderedCollection with: (dict at: key)) ].      (dict at: key) add: value     ]  ].  ^dict! !!PWS methodsFor: 'Processing' stamp: 'jm 3/13/98 15:33'!getReply	"Generate a reply based on the action selected by the first word of the URL."	| key |	message size > 0		ifTrue: [key _ (message at: 1) asLowercase]		ifFalse: [key _ 'default'].	(ActionTable includesKey: key) ifFalse: [key _ 'default'].	"Transcript show: ('Request: ' , url printString, ' from: ', peerName, ' action: ', key) ; cr."	(ActionTable at: key) process: self.! !!PWS methodsFor: 'Processing' stamp: 'jm 3/10/98 10:59'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request', self class crlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS methodsFor: 'Processing' stamp: 'mjg 10/24/97 17:29'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut: 			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $% 					ifTrue: [ (Number readFrom: (rs next: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents copyWithout: Character cr! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PWS class	instanceVariableNames: ''!!PWS class methodsFor: 'HTTPcodes' stamp: 'tk 1/31/98 14:34'!content: type	"Can also return image types"	^'Content-Type: ', type, self crlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:18'!contentHTML	^self content: 'text/html'! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:16'!crlf	^String with: Character cr with: Character linefeed! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:16'!crlfcrlf	^self crlf , self crlf.! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 11/17/97 13:01'!notFound	^'HTTP/1.0 404 FILE NOT FOUND',self crlf,'<title>File Not Found</title><h2>File Not Found</h2>'! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:26'!redirectTo: URL	^'HTTP/1.0 302 FOUND', self crlf, 'Location: ',URL, self crlf,'URI: ',URL,	self crlfcrlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 10/25/97 12:17'!success	^'HTTP/1.0 200 OK',self crlf! !!PWS class methodsFor: 'HTTPcodes' stamp: 'mjg 12/4/97 12:05'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body>'! !!PWS class methodsFor: 'Backups' stamp: 'mjg 11/10/97 09:21'!addToBackupJob: block	"Stores blocks to be executed hourly at snapshot time."	BackupJobs add: block.! !!PWS class methodsFor: 'ServerActions' stamp: 'mjg 11/6/97 16:58'!actions	^ActionTable! !!PWS class methodsFor: 'ServerActions' stamp: 'tk 2/3/98 15:17'!link: key to: action	ActionTable at: key asLowercase put: action.! !!PWS class methodsFor: 'Initializing' stamp: 'tk 5/22/1998 07:31'!howToStart	"To set up your new Swiki, you need a copy of the 'Server' folder found at: http://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/Put the 'Server' folder into the folder that your image is in.Modify this method to be a path to your Server folder, select it, and choose fileItIn:!!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!!serverDirectory	^ 'Hard Disk:Squeak1.31:Server:'!! !!Then do:	PWS initializeAll.To enable a new Swiki called OurOwnArea.Make a folder named OurOwnArea in the Server folder.  Then do:	SwikiAction setUp: 'OurOwnArea'.	(its main URL is http://thisMachine:80/OurOwnArea.1)Suppose you already have a Swiki called 'myswiki'.To start up:	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	PWS serveOnPort: 80 loggingTo: 'log.txt'.To stop the server: 	PWS stopServer.-----------------------To purge a particular file of all except the latest version:	((PWS actions at: 'myswiki' asLowercase) urlmap atID: '3') condenseChanges.To roll the entire wiki back to a previous time:	""This does not erase data, it just copies the older page to the end""	(PWS actions at: 'myswiki' asLowercase) rollBack: '1/28/98' asDate 			at: '1:30 am' asTime.The look of a served page is controlled by a template.  Templates live in the 'swiki' folder in the 'Server' folder.  Beware that templates are cached by HTMLformatter.  If you change a template, you will not see the effect until you reload the Swiki.To set up a Swiki with a password (same for all users), see AuthorizedSwikiAction comment.To enable a privledged user to execute code remotely (on a workspace page):	(PWS actions at: 'authorized') mapName: 'JSmith' password: 'hard2guess' to: 'JSmith'.	(URL is http://thisMachine:80/authorized.workspace.html)To backup the user data to the disk, do nothing.  All info is already inside the page files on the disk.To enable a new Swiki that evaluates Squeak code submitted by the user.Make a folder named SqkEval in the Server folder.  Then do:	ActiveSwikiAction setUp: 'SqkEval'.	(this is dangerous, because there are still ways a user could crash your server)To convert from an old pre-Squeak1.3 Swiki to the new page format: 	(In the old image, do a backup:)		| mine | mine _ PWS actions at: 'myswiki'.		mine saveTo: mine path,'backup28JanA'.	(Quit.  Start the new image which has this version of the Swiki code)	(Do not start the server!!!!!!)		PWS initializeAll.		SwikiAction restore: 'myswiki' from: 			(ServerAction serverDirectory), 'myswiki:backup28JanA'.		(PWS actions at: 'myswiki' asLowercase) convert.	(do these steps for each Swiki you have)	(now, start the server)	PWS serveOnPort: 80 loggingTo: 'log.txt'."!]style[(10 1647 21 1162)f1b,f1,f1LAuthorizedSwikiAction Comment;,f1! !!PWS class methodsFor: 'Initializing' stamp: 'jm 3/9/98 17:57'!initialize	"PWS initialize"	BackupJobs _ OrderedCollection new.	ActionTable _ Dictionary new.! !!PWS class methodsFor: 'Initializing' stamp: 'mjg 5/1/98 10:22'!initializeAll	| anAuthorizer |	anAuthorizer _ Authorizer new.	anAuthorizer realm: 'AuthorizedSpace'."	anAuthorizer mapName: 'JSmith' password: 'hard2guess' to: 'JSmith'.  "		"No default account!!  See howToStart to enable remote code execution."	self link: 'authorized' to: (AuthorizedServerAction new authorizer: anAuthorizer).	self link: 'chat' to: ChatPage new.	self link: 'default' to: ServerAction new.	self link: 'embedded' to: EmbeddedServerAction new.	self link: 'smtlk' to: CodeServer new.	self link: 'chunk' to: CodeServer new.	Comment setUpExample.	self link: 'comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).! !!PWS class methodsFor: 'Serving' stamp: 'jm 3/9/98 17:59'!doBackupJobs	"This is just a wrapper so we don't have to restart the server loop when we add/remove jobs."	BackupJobs do: [:block |		[block value] ifError: [:msg :rec | ^'*** ', rec asString, ': ', msg asString ]].	^ 'Backup jobs completed'! !!PWS class methodsFor: 'Serving' stamp: 'jm 3/9/98 19:56'!loopOnPort: portNumber loggingTo: fileName	"Loop forever handling HTTP requests. Run backup jobs periodically."	| secondsBetweenBackups nextBackupTime socket logEntry |	secondsBetweenBackups _ 1 * (60 * 60).	nextBackupTime _ Time totalSeconds + secondsBetweenBackups.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil			ifTrue: [				logEntry _ self serve: socket.				ServerLog nextPutAll: logEntry; cr]			ifFalse: [				Time totalSeconds > nextBackupTime					ifTrue: [  "time to back up!!"						logEntry _ self doBackupJobs.						ServerLog nextPutAll: logEntry; cr.						nextBackupTime _ Time totalSeconds + secondsBetweenBackups]					ifFalse: [						(Delay forMilliseconds: 100) wait]]].! !!PWS class methodsFor: 'Serving' stamp: 'jm 3/9/98 19:35'!serve: aSocket	"Respond to a request arriving on the given socket and return a string to be entered in the log file."	| inst |	inst _ self new.	[inst initializeFrom: aSocket.	 inst getReply]		ifError: [:msg :rec | inst report: msg for: rec].	aSocket closeAndDestroy: 30.	^ inst log contents! !!PWS class methodsFor: 'Serving' stamp: 'jm 3/13/98 11:45'!serveOnPort: portNumber loggingTo: fileName	"Start up the HTTP server loop for the given port number and log file."	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: fileName.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	ServerProcess _ [self loopOnPort: portNumber loggingTo: fileName] newProcess.	ServerProcess priority: Processor lowIOPriority.	ServerProcess resume.! !!PWS class methodsFor: 'Serving' stamp: 'jm 3/13/98 12:21'!stopServer	"Shut down the server."	ServerProcess	ifNotNil: [ServerProcess terminate].	ServerPort		ifNotNil: [ServerPort destroy].	ServerLog		ifNotNil: [ServerLog close].	ServerProcess _ ServerPort _ ServerLog _ ClientNameCache _ nil.! !ImageMorph subclass: #PaintBoxColorPicker	instanceVariableNames: 'currentColor locOfCurrent '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!PaintBoxColorPicker commentStamp: 'di 5/22/1998 16:36' prior: 0!A pop-up, 16-bit color palette used as part of a PaintBoxMorph.!!PaintBoxColorPicker methodsFor: 'initialization' stamp: 'jm 4/29/1998 21:24'!initialize	super initialize.	currentColor _ Color black.	locOfCurrent _ nil.	self initMouseHandlers.! !!PaintBoxColorPicker methodsFor: 'accessing' stamp: 'jm 4/29/1998 20:07'!currentColor	^ currentColor! !!PaintBoxColorPicker methodsFor: 'accessing' stamp: 'jm 4/29/1998 20:18'!currentColor: aColor	"Force me to select the given color."	currentColor _ aColor.	locOfCurrent _ nil.  "remove the marker"! !!PaintBoxColorPicker methodsFor: 'drawing' stamp: 'jm 4/29/1998 20:00'!drawOn: aCanvas	"Image plus circles for currently selected color."	| c |	super drawOn: aCanvas.	locOfCurrent ifNotNil: [		c _ self ringColor.		aCanvas			fillOval: (Rectangle center: locOfCurrent + self topLeft extent: 9@9)			color: Color transparent			borderWidth: 1			borderColor: c].! !!PaintBoxColorPicker methodsFor: 'drawing' stamp: 'jm 4/29/1998 20:00'!ringColor	"Choose a color that contrasts with my current color. If that color isn't redish, return red. Otherwise, return green"	currentColor isTransparent ifTrue: [^ Color red].	currentColor red < 0.5 ifTrue: [^ Color red].	currentColor red > (currentColor green + (currentColor blue * 0.5))		ifTrue: [^ Color green]		ifFalse: [^ Color red].! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'jm 4/29/1998 21:39'!endColorSelection: evt	"Update current color and report it to paint box."	self selectColor: evt.	(owner isKindOf: PaintBoxMorph)		ifTrue: [owner takeColorEvt: evt from: self].	"restore mouseLeave handling"	self on: #mouseLeave send: #delete to: self.	evt hand addMouseOverMorph: self.! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'jm 4/29/1998 21:24'!initMouseHandlers	self on: #mouseDown send: #startColorSelection: to: self.	self on: #mouseStillDown send: #selectColor: to: self.	self on: #mouseUp send: #endColorSelection: to: self.	self on: #mouseLeave send: #delete to: self.! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'jm 4/29/1998 21:16'!selectColor: evt	"Update the receiver from the given event. Constrain locOfCurrent's center to lie within the color selection area. If it is partially in the transparent area, snap it entirely into it vertically."	| r |	locOfCurrent _ evt cursorPoint - self topLeft.	r _ Rectangle center: locOfCurrent extent: 9@9.	locOfCurrent _ locOfCurrent + (r amountToTranslateWithin: (5@11 corner: 140@136)).	locOfCurrent x > 128 ifTrue: [locOfCurrent _ 135@locOfCurrent y].  "snap into grayscale"	locOfCurrent y < 17		ifTrue: [			locOfCurrent _ locOfCurrent x@11.  "snap into transparent"			currentColor _ Color transparent]		ifFalse: [			currentColor _ image colorAt: locOfCurrent].	self changed.! !!PaintBoxColorPicker methodsFor: 'event handling' stamp: 'jm 4/29/1998 21:21'!startColorSelection: evt	"Start color selection. Make me stay up as long as the mouse is down."	self on: #mouseLeave send: nil to: nil.	self selectColor: evt.! !ImageMorph subclass: #PaintBoxMorph	instanceVariableNames: 'action tool currentCursor thumbnail currentColor currentBrush colorMemory colorPatch stampHolder rotationTabForm scaleTabForm colorMemoryThin brushes '	classVariableNames: 'AllOffImage AllOnImage AllPressedImage OriginalBounds Prototype '	poolDictionaries: ''	category: 'Morphic-Support'!!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 7/16/97 18:53'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button nib |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		button actionSelector: #tool:action:cursor:; arguments: (Array with: button with: sel with: nil).		button actWhen: #buttonUp; target: self.		]].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |	(self findButton: sel) ifNil: [		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ ThreePhaseButtonMorph new.		button onImage: nil; bounds: rect.		self addMorph: button.		nib _ Form dotOfSize: (#(1 2 3 6 11 26) at: ind).		button actionSelector: #brush:action:nib:; 				arguments: (Array with: button with: sel with: nib).		button actWhen: #buttonUp; target: self.		]]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 10/15/97 22:59'!init3	"Just a record of how we loaded in the latest paintbox button images"| bb rect lay pic16Bit aa blt on thin |self loadoffImage: 'etoy_default.gif'.self allMorphsDo: [:button |	(button isKindOf: ThreePhaseButtonMorph) 		ifTrue: [button offImage: nil]		ifFalse: [button position: button position + (100@0)]].(bb _ self findButton: #keep:) position: bb position + (100@0).(bb _ self findButton: #toss:) position: bb position + (100@0).(bb _ self findButton: #undo:) position: bb position + (100@0)."Transparent is (Color r: 1.0 g: 0 b: 1.0)"self moveButtons.self loadOnImage: 'etoy_in.gif'.AllOnImage _ nil.	'save space'.	self loadPressedImage: 'etoy_in.gif'.AllPressedImage _ nil.	'save space'.self loadCursors."position the stamp buttons"stampHolder stampButtons owner last delete.stampHolder pickupButtons last delete.stampHolder stampButtons: (stampHolder stampButtons copyFrom: 1 to: 3).stampHolder pickupButtons: (stampHolder pickupButtons copyFrom: 1 to: 3)."| rect |"stampHolder pickupButtons do: [:button |		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button bounds: rect.	"image is nil"		]."| rect lay |"stampHolder clear.stampHolder stampButtons do: [:button |		button offImage: nil; pressedImage: nil.		lay _ button owner.		"PopUpMenu notify: 'Rectangle for ',sel."		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button image: (Form fromDisplay: (rect insetBy: 2)).		lay borderWidth: 2.		lay bounds: rect.	"image is nil"		]."| pic16Bit blt aa on |"	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: 'etoy_in.gif'.	aa _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	"Collect all the images for the buttons in the on state"	stampHolder pickupButtons do: [:button |			on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button image: on; pressedImage: on; offImage: nil.			].	self invalidRect: bounds.((self findButton: #erase:) arguments at: 3) offset: (12@35).((self findButton: #eyedropper:) arguments at: 3) offset: (0@0).((self findButton: #fill:) arguments at: 3) offset: (10@44).((self findButton: #paint:) arguments at: 3) offset: (3@3). "unused"((self findButton: #rect:) arguments at: 3) offset: (6@17).((self findButton: #ellipse:) arguments at: 3) offset: (5@4).((self findButton: #polygon:) arguments at: 3) offset: (5@4).((self findButton: #line:) arguments at: 3) offset: (5@17).((self findButton: #star:) arguments at: 3) offset: (2@5).thumbnail delete.thumbnail _ nil.(submorphs select: [:e | e class == RectangleMorph]) first bounds: 	(Rectangle fromUser translateBy: self world viewBox origin negated).(submorphs select: [:e | e class == RectangleMorph]) first borderWidth: 1; borderColor: Color black."| thin |"	submorphs do: [:ss | ss class == ImageMorph ifTrue: [thin _ ss "first"]].colorMemoryThin _ thin.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 5/6/1998 21:08'!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"| bb im pp newImage pic24Bit picNewBit blt |"self loadoffImage: 'roundedPalette3.bmp'."pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.OriginalBounds _ picNewBit boundingBox.AllOffImage _ Form extent: OriginalBounds extent depth: 16.blt _ BitBlt toForm: AllOffImage.blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.AllOffImage removeZeroPixelsFromForm.self image: AllOffImage.self invalidRect: bounds.self submorphsDo: [:button | button position: button position + (10@10)].(im _ submorphs at: 28) class == ImageMorph ifTrue: [	im position: im position + (2@0)].	"color picker""exercise it once"(bb _ self findButton: #keep:) position: bb position + (0@25).(bb _ self findButton: #toss:) position: bb position + (0@25).(bb _ self findButton: #undo:) position: bb position + (0@-25).(bb _ self findButton: #clear:) position: bb position + (0@-25).(bb _ self findButton: #undo:) position: bb position + (0@-69).(bb _ self findButton: #clear:) position: bb position + (0@-69).self submorphsDo: [:button | 	button class == AlignmentMorph ifTrue: [		button position: button position + (0@25)].	(button printString includesSubString: 'stamp:') ifTrue: [		button position: button position + (0@25)]].(bb _ self findButton: #prevStamp:) position: bb position + (0@25).(bb _ self findButton: #nextStamp:) position: bb position + (0@25).bb _ self findButton: #keep:.newImage _ bb pressedImage copy: (0@4 corner: (bb pressedImage boundingBox extent)).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (4@1).pp _ (bb _ self findButton: #toss:) pressedImage.newImage _ pp copy: (0@4 corner: (bb pressedImage extent - (3@0))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@1).pp _ (bb _ self findButton: #undo:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (3@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pp _ (bb _ self findButton: #clear:) pressedImage.newImage _ pp copy: (0@0 corner: (bb pressedImage extent - (0@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pic24Bit _ GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.picNewBit _ Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.newImage _ picNewBit as8BitColorForm.newImage transparentColor: (Color r: 0 g: 0 b: 0).(bb _ self findButton: #erase:) pressedImage: newImage; onImage: newImage;	extent: newImage extent.bb position: bb position + (-11@-1).! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'sw 4/30/1998 23:19'!initialize	super initialize.	self flag: #noteToTed.	"self on: #mouseDown send: #yourself to: self."	colorMemory ifNotNil: [colorMemory on: #mouseDown send: #takeColorEvt:from: to: self].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 4/29/1998 21:43'!loadColorChooser	"Load Forms for ColorMemoryMorph."	| doc closedForm openForm |	doc _ Utilities objectStrmFromUpdates: 'colorPalClosed.obj'.	closedForm _ doc fileInObjectAndCode removeZeroPixelsFromForm.	doc _ Utilities objectStrmFromUpdates: 'colorPalOpen.obj'.	openForm _ doc fileInObjectAndCode removeZeroPixelsFromForm.	colorMemoryThin image: closedForm.	colorMemoryThin position: self position + (0@140).	colorMemory delete.	"delete old one"	colorMemory _ PaintBoxColorPicker new image: openForm.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 18:49'!loadCursors	"Display the form containing the cursors.  Transparent is (Color r: 1.0 g: 0 b: 1.0).  Grab the forms one at a time, and they are stored away.	self loadCursors.	"| button transp cursor map |transp _ Color r: 1.0 g: 0 b: 1.0.map _ Color indexedColors copy.	"just in case"1 to: 256 do: [:ind | (map at: ind) = transp ifTrue: [			map at: ind put: Color transparent]].#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: ) do: [:sel |	PopUpMenu notify: 'Rectangle for ',sel.	cursor _ ColorForm fromUser.	cursor colors: map.	"share it"	button _ self findButton: sel.	button arguments at: 3 put: cursor.	].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 2/23/98 13:10'!loadoffImage: fileName	"Read in and convert the background image for the paintBox.  Allbuttons off.  A .bmp 24-bit image."	"	Prototype loadoffImage: 'roundedPalette3.bmp'	"	| pic16Bit blt type getBounds |	type _ 'bmp'.  " gif or bmp  "	getBounds _ 'fromPic'.	"fromUser = draw out rect of paintbox on image"		"fromOB = just read in new bits, keep same size and place as last time."		"fromPic = picture is just the PaintBox, use its bounds"type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].	getBounds = 'fromPic' ifTrue: [OriginalBounds _ pic16Bit boundingBox].	].		"Use OriginalBounds as it was last time".type = 'bmp' ifTrue: [	pic16Bit _ Form fromBMPFileNamed: fileName depth: 16.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds _ Rectangle fromUser].		"Use OriginalBounds as it was last time".	(getBounds = 'fromPic') ifTrue: [OriginalBounds _ pic16Bit boundingBox].	AllOffImage _ Form extent: OriginalBounds extent depth: 16.	].type = 'gif' ifTrue: [	AllOffImage _ ColorForm extent: OriginalBounds extent depth: 8.	AllOffImage colors: pic16Bit colors].	blt _ BitBlt toForm: AllOffImage.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.type = 'bmp' ifTrue: [AllOffImage removeZeroPixelsFromForm].	self image: AllOffImage.	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 17:50'!loadOnImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadOnImage: 'NoSh_on.bmp'.		AllOnImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ Form fromBMPFileNamed: fileName depth: 16.	pic16Bit display.	aa _ AllOnImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button onImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 18:02'!loadPressedImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadPressedImage: 'NoSh_on.bmp'.		AllPressedImage _ nil.	'save space'.	"	| pic16Bit blt aa on type |	type _ 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" _ GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 8.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit _ Form fromBMPFileNamed: fileName depth: 16.	pic16Bit display.	aa _ AllPressedImage _ Form extent: OriginalBounds extent depth: 16.	blt _ BitBlt toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa removeZeroPixelsFromForm.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on _ ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on _ Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button pressedImage: on]].	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 7/17/97 16:34'!loadRotScalePics	"Load up class vars with .bmp files for the images of the Rotation control button and the Scale control button.  File names do not change."	"	self loadRotScalePics		"	rotationTabForm _ Form fromBMPFileNamed: 'Rotaball.bmp' depth: 16.	scaleTabForm _ Form fromBMPFileNamed: 'Scalball.bmp' depth: 16.		! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'di 10/13/97 17:20'!moveButtons	"Move buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"| rect button |#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: "pickup: pickup: pickup: pickup:" "stamp: stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		].#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |		PopUpMenu notify: 'Rectangle for ',sel.		rect _ Rectangle fromUser translateBy: self world viewBox origin negated.		button _ self findButton: sel.		button bounds: rect.	"image is nil"		]."stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."""! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/97 15:57'!noVeneer	"For a palette with a background (off) image, clear that image.But first, for each button, cut that chunk out and save it in the offImagepart."	"	self noVeneer.		AllOffImage _ nil.	'save space.  irreversible'.	"	| aa on |	AllOffImage ifNil: [AllOffImage _ image].	aa _ AllOffImage.	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			on _ Form extent: button extent depth: 16.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in:aa rule: Form over.			button offImage: on]].	self image: (Form extent: AllOffImage extent depth: 1).	self invalidRect: bounds.	! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 10/31/97 13:38'!colorMemory	^ colorMemory! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 10:15'!colorMemory: aMorph	colorMemory _ aMorph! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 10/31/97 13:35'!colorPatch	^ colorPatch! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 13:28'!copyRecordingIn: dict	"Overridden to copy the stamps holder."	| new |	new _ super copyRecordingIn: dict.	new stampHolder: stampHolder copy.	new colorMemory: (colorMemory copyRecordingIn: dict).	^ new! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 7/17/97 16:26'!rotationTabForm	^ rotationTabForm! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 7/17/97 16:26'!scaleTabForm	^ scaleTabForm! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 10:13'!updateReferencesUsing: aDictionary	"Fix up stampHolder which is a ScrollingToolHolder, which is not a Morph"	super updateReferencesUsing: aDictionary.	stampHolder updateReferencesUsing: aDictionary.	colorMemory updateReferencesUsing: aDictionary.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 3/2/98 11:08'!actionCursor	"Return the cursor to use with this painting action/tool. Offset of the form must be set."	| ff c old map width co larger box |	action == #paint: ifTrue: ["Make a cursor from the brush and the color"		old _ self getNib.		ff _ ColorForm extent: old extent depth: 1.		old displayOn: ff at: old offset negated.		c _ self getColor.		c = Color white ifTrue: [c _ Color black].		c isTransparent ifTrue: [c _ Color black].		map _ ff colors.		map at: (Color white indexInMap: map) put: Color transparent.		map at: (Color black indexInMap: map) put: c.		ff colors: map.		ff offset: ff extent // 2.		^ ff].	action == #erase: ifTrue: ["Make a cursor from the cursor and the color"		width _ self getNib width.		co _ (currentCursor offset - (width//2@4)) max: (0@0).		larger _ 0@0 extent: currentCursor extent + (width@width).		ff _ currentCursor copy: larger.		ff fill: (box _ co extent: (width@width)) fillColor: (Color r: 0.5 g: 0.5 b: 1.0).		ff fill: (box insetBy: 1@1) fillColor: Color transparent.		ff offset: co + (width@width //2).		^ ff].	^ currentCursor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/4/97 09:28'!brush: brushButton action: aSelector nib: aMask	"Set the current tool and action for the paintBox.  "	currentBrush ifNotNil: [		currentBrush == brushButton ifFalse: [currentBrush state: #off]].	currentBrush _ brushButton.		"A ThreePhaseButtonMorph"	"currentBrush state: #on.	already done"	"aSelector is like brush3:.  Don't save it.  Can always say (currentBrush arguments at: 2)	aMask is the brush shape.  Don't save it.  Can always say (currentBrush arguments at: 3)"	self brushable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 11:12'!brushable	"Return true if the current tool uses a brush."	^ (#("non-brushable" eyedropper: fill: pickup: stamp:) indexOf: action) = 0! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:22'!clear: clearButton with: clearSelector	| ss |	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss clear]		ifNil: [self notCurrentlyPainting].	clearButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/15/97 13:35'!colorable	"Return true if the current tool uses a color."	^ (#("These use no color" erase: eyedropper: "fill: does" pickup: stamp:) indexOf: action) = 0! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 19:13'!currentColor: aColor	"Accept a color from the outside.  (my colorMemoryMorph must call takeColorEvt: evt from: colorPicker instead)"	currentColor _ aColor.	colorMemory currentColor: aColor.	self showColor.	self colorable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/11/97 17:06'!deleteCurrentStamp	"The trash is telling us to delete the currently selected stamp"	(tool arguments at: 2) == #stamp: ifTrue: [		stampHolder remove: tool.		self setAction: #paint:].	"no use stamping with a blank stamp"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/30/97 21:51'!eyedropper: aButton action: aSelector cursor: aCursor	"Take total control and pick up a color!!!!"	| pt feedbackColor |	aButton state: #on.	tool ifNotNil: [tool state: #off].	currentCursor _ aCursor."	self world hands first showTemporaryCursor: aCursor 		hotSpotOffset: (aCursor ifNil: [0@0] ifNotNil: [aCursor offset])."	feedbackColor _ Display colorAt: Sensor cursorPoint.	self addMorphFront: colorMemory.	"Full color picker"	self world displayWorld.		[Sensor anyButtonPressed] whileFalse: [			pt _ Sensor cursorPoint.			feedbackColor _ Display colorAt: pt.			Display fill: (colorPatch bounds translateBy: self world viewBox origin) 					fillColor: feedbackColor].		Sensor waitNoButton."	self world hands first showTemporaryCursor: nil 		hotSpotOffset: 0@0."	self currentColor: feedbackColor.	colorMemory delete.	tool ifNotNil: [tool state: #on.		currentCursor _ tool arguments at: 3].	aButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'di 5/6/1998 21:08'!findButton: aSelector	"Find this button in me"	submorphs do: [:button |		(button respondsTo: #arguments) 			ifTrue: [(button arguments at: 2) == aSelector ifTrue: [^ button]]			ifFalse: [(button isKindOf: AlignmentMorph) ifTrue: [				button submorphsDo: [:sub |					(sub respondsTo: #arguments) 						ifTrue: [(sub arguments at: 2) == aSelector ifTrue: [^ sub]]]]].			].	^ nil! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:52'!getColor	^ currentColor! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:24'!getNib	^ currentBrush arguments at: 3! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 13:02'!getSpecial	^ action		"a selector like #paint:"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:23'!keep: keepButton with: keepSelector	"Showing of the corrent palette (viewer or noPalette) is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: [^ self].	keepButton ifNotNil: [keepButton state: #off].	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss save]		ifNil:		[keepSelector == #silent ifTrue: [^ self].		self notCurrentlyPainting].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 08:10'!mouseUpBalk: evt	"A button I own got a mouseDown, but the user moved out before letting up.  Prevent this for the current tool.  Some tool must stay selected."	tool state: #on.	"keep current one, even if user balked on it"	currentBrush ifNotNil: [currentBrush state: #on].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:22'!notCurrentlyPainting	self inform: 'You are not currently painting'! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:23'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting				self setAction: #paint:]].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 22:13'!pickupForm: stampForm	"Install the new picture in this stamp"	| stampButton |	stampHolder stampForm: stampForm for: tool.	stampButton _ action == #pickup: 		ifTrue: [stampHolder otherButtonFor: tool]		ifFalse: [tool].	"was a nil stampForm"	stampButton state: #on.	stampButton doButtonAction.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/21/97 11:33'!rememberColorsFrom: aForm	"Tell my colorMemory to show the colors this form has used."	"The new color picker does not remember colors""	colorMemory clear.	aForm colorsUsed do: [:val | colorMemory mark: val].	colorMemory invalidRect: colorMemory bounds."! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/14/97 17:32'!scrollStamps: actionButton action: aSelector	"Move the stamps over"	aSelector == #prevStamp:		ifTrue: [stampHolder scroll: -1]		ifFalse: [stampHolder scroll: 1].	actionButton state: #off.	action == #stamp: ifTrue: ["reselect the stamp and compute the cursor"		self stampForm 			ifNil: [self setAction: #paint:]			ifNotNil: [tool doButtonAction]].		! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/14/97 17:30'!setAction: aSelector	"Find this button and turn it on.  Does not work for stamps or pickups"	| button |	button _ self findButton: aSelector. 	button ifNotNil: [		button state: #on.		button doButtonAction].	"select it!!"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 3/2/98 15:39'!showColor	"Display the current color in all brushes, both on and off."	| offIndex onIndex center |	currentColor ifNil: [^ self].	colorPatch color: currentColor.	"May delete later"	(brushes == nil or: [brushes first owner ~~ self]) ifTrue: [		brushes _ OrderedCollection new.		#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |			brushes addLast: (self findButton: sel)]].	center _ (brushes at: 6) offImage extent // 2.	offIndex _ (brushes at: 6) offImage pixelValueAt: center.	onIndex _ (brushes at: 6) onImage pixelValueAt: center.	brushes do: [:bb |		bb offImage colors at: offIndex+1 put: currentColor.		bb offImage clearColormapCache.		bb onImage colors at: onIndex+1 put: currentColor.		bb onImage clearColormapCache.		bb invalidRect: bb bounds].	self invalidRect: (brushes first topLeft rect: brushes last bottomRight).! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/17/97 14:03'!showColorPalette	"Remove this method later!!"	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/17/97 14:05'!showColorPalette: evt	| pp myEvt |	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.	"Be sure it gets a mouseEnter: and a mouseLeave:, even if mouse leaves on the next cycle." 	pp _ (colorMemory bounds insetBy: 1@1) pointNearestTo: evt cursorPoint.			"so it will be inside"	myEvt _ evt copy setCursorPoint: pp.	evt hand handleMouseOver: myEvt.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/16/97 11:19'!stampCursorBeCursorFor: anAction	"User just chose a stamp.  Take that stamp picture and make it be the cursor for the tool named."	"self stampCursorBeCursorFor: #star:.	currentCursor offset: 9@3.			Has side effect on the saved cursor."	(self findButton: anAction) arguments at: 3 put: currentCursor.		"Already converted to 8 bits and in the right form"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'di 5/6/1998 21:08'!stampDeEmphasize	"Turn off an emphasized stamp.  Was turned on in pickup:action:cursor:"	tool owner class == AlignmentMorph ifTrue: [		tool "actionButton" owner "layoutMorph" color: Color transparent; 					borderColor: Color transparent].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 14:02'!stampForm	"Return the selected stamp"	^ stampHolder stampFormFor: tool.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 11:47'!stampHolder	^ stampHolder! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 11:48'!stampHolder: newOne	stampHolder _ newOne! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 10/19/97 19:13'!takeColorEvt: evt from: colorPicker	"Accept a new color from the colorMemory.  Programs use currentColor: instead.  Do not do this before the picker has a chance to set its own color!!"	currentColor _ colorPicker currentColor.	self showColor.	self colorable ifFalse: [self setAction: #paint:].	"User now thinking of painting"! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/1/97 12:09'!tool	^ tool! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 09:22'!tool: actionButton action: aSelector cursor: aCursor	"Set the current tool and action for the paintBox.  "	tool ifNotNil: [		tool == actionButton ifFalse: [			tool state: #off.			action == #stamp: ifTrue: [self stampDeEmphasize]]].	tool _ actionButton.		"A ThreePhaseButtonMorph"	"tool state: #on.	already done"	action _ aSelector.		"paint:"	currentCursor _ aCursor.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:23'!toss: cancelButton with: cancelSelector	"Reject the painting.  Showing noPalette is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: ["it happens"  ^ self].	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss cancel]		ifNil: [self notCurrentlyPainting].	cancelButton state: #off.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 5/3/1998 18:23'!undo: undoButton with: undoSelector	| ss |	(ss _ self world findA: SketchEditorMorph) 		ifNotNil: [ss undo]		ifNil: [self notCurrentlyPainting].	undoButton state: #off.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PaintBoxMorph class	instanceVariableNames: ''!!PaintBoxMorph class methodsFor: 'all' stamp: 'sw 5/8/1998 13:36'!fixUpPrototype	"PaintBoxMorph fixUpPrototype"	Prototype eventHandler: nil! !!PaintBoxMorph class methodsFor: 'all' stamp: 'jm 11/14/97 17:32'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ FormCanvas on: button onImage.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PaintBoxMorph class methodsFor: 'all' stamp: 'tk 10/12/97 11:01'!prototype	"Later we will be a subclass of Model, and it will have a general version of this"	^ Prototype! !!PaintBoxMorph class methodsFor: 'all' stamp: 'jm 10/23/97 10:40'!releaseTemporaryForms	"Release the temporary Forms used when loading new artwork."	AllOnImage _ AllOffImage _ AllPressedImage _ nil.	OriginalBounds _ nil.! !ImageMorph subclass: #PaintInvokingMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!PaintInvokingMorph commentStamp: 'di 5/22/1998 16:36' prior: 0!PaintInvokingMorph comment:'When this is dropped inside some appropriate place, then painting is invoked for that place.'!!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 5/19/1998 18:52'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PaintInvokingMorph class	instanceVariableNames: ''!!PaintInvokingMorph class methodsFor: 'as yet unclassified' stamp: 'sw 5/13/1998 15:21'!authoringPrototype	^ self new image: (ScriptingSystem formAtKey: 'Painting')! !DisplayText subclass: #Paragraph	instanceVariableNames: 'clippingRectangle compositionRectangle destinationForm rule mask marginTabsLevel lines lastLine '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Display Objects'!!Paragraph commentStamp: 'di 5/22/1998 16:36' prior: 0!Paragraph comment:'I represent displayable text that has been decoraged with margin alignment, line leading, and tab settings.'!!Paragraph methodsFor: 'accessing'!backgroundColor	backColor == nil ifTrue: [^ Color white].	^ backColor! !!Paragraph methodsFor: 'accessing'!clippingRectangle 	"Answer the rectangle, defined in absolute coordinates, whose 	intersection with the destinationForm is the area in which the characters 	are constrained to display."	^clippingRectangle! !!Paragraph methodsFor: 'accessing' stamp: 'di 10/5/97 15:33'!clippingRectangle: clipRect 	clippingRectangle _ clipRect! !!Paragraph methodsFor: 'accessing'!compositionRectangle	"Answer the rectangle whose width is the dimension, modified by 	indents and tabsLevels, against which line wraparound is measured. The 	height of the compositionRectangle is reset each time recomposition is 	required."	^compositionRectangle! !!Paragraph methodsFor: 'accessing'!compositionRectangle: compRectangle 	"Set the rectangle whose width is the dimension, modified by indents and 	tabsLevels, against which line wraparound is measured."	compositionRectangle _ compRectangle.	self composeAll! !!Paragraph methodsFor: 'accessing'!destinationForm 	 "Answer the Form into which the characters are scanned."	^destinationForm! !!Paragraph methodsFor: 'accessing'!fillColor 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!fillColor: maskForm 	"Set the argument, maskForm, to be the form with which each character 	is combined by the scanner before applying the rule for display."	mask _ maskForm! !!Paragraph methodsFor: 'accessing'!height 	"Answer the height of the composition rectangle."	^compositionRectangle height! !!Paragraph methodsFor: 'accessing'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: lastLine) last.	reader _ ReadStream on: text string from: first to: last.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = last | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!Paragraph methodsFor: 'accessing'!mask 	"Answer the Form with which each character is combined by the scanner 	before applying the rule for display."	^mask! !!Paragraph methodsFor: 'accessing'!numberOfLines 	"Answer the number of lines of text in the receiver."	^lastLine! !!Paragraph methodsFor: 'accessing'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new in: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing'!rule 	"Answer the rule according to which character display behaves. For 	example, rule may equal over, under, reverse."	^rule! !!Paragraph methodsFor: 'accessing'!rule: ruleInteger 	"Set the rule according to which character display behaves."	rule _ ruleInteger! !!Paragraph methodsFor: 'accessing'!text: aText 	"Set the argument, aText, to be the text for the receiver."	text _ aText.	self composeAll! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium	"Because Paragraphs cache so much information, computation is avoided	and displayAt: 0@0 is not appropriate here."	self displayOn: aDisplayMedium		at: compositionRectangle topLeft		clippingBox: clippingRectangle		rule: rule		fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint	"Use internal clippingRect; destination cliping is done during actual display."	self displayOn: aDisplayMedium at: aPoint		clippingBox: (clippingRectangle translateBy: aPoint - compositionRectangle topLeft)		rule: rule fillColor: mask! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"Default display message when aDisplayPoint is in absolute screen	coordinates."	rule _ ruleInteger.	mask _ aForm.	clippingRectangle _ clipRectangle.	compositionRectangle _ aDisplayPoint extent: compositionRectangle extent.	(lastLine == nil or: [lastLine < 1]) ifTrue: [self composeAll].	self displayOn: aDisplayMedium lines: (1 to: lastLine)! !!Paragraph methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle align: alignmentPoint with: relativePoint rule: ruleInteger fillColor: aForm 	self				"Assumes offset has been set!!!!!!!!!!"	  displayOn: aDisplayMedium	  at: (offset 			+ (displayTransformation applyTo: relativePoint) 			- alignmentPoint) rounded	  clippingBox: clipRectangle	  rule: ruleInteger	  fillColor: aForm.	! !!Paragraph methodsFor: 'display box access'!boundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'display box access'!computeBoundingBox	^offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'composition'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new in: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'composition'!wrappingBox: compositionRect clippingBox: clippingRect 	"Set the composition rectangle for the receiver so that the lines wrap 	within the rectangle, compositionRect, and the display of the text is 	clipped by the rectangle, clippingRect."	self compositionRectangle: compositionRect copy				text: text				style: textStyle				offset: offset.	clippingRectangle _ clippingRect copy! !!Paragraph methodsFor: 'character location'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for characters in the text at point aPoint. It is 	assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockAtPoint: aPoint in: self! !!Paragraph methodsFor: 'character location'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!Paragraph methodsFor: 'character location' stamp: 'di 11/30/97 10:10'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'selecting'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box _ CaretForm boundingBox.	f _ Form extent: box extent depth: depth.	map _ (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb _ BitBlt toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'di 1/14/98 09:48'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []						ifSucceed: [							aController controlTerminate.							(att actOnClickFor: model) ifTrue: [action _ true].							aController controlInitialize].				]].	^ action! !!Paragraph methodsFor: 'selecting'!extendSelectionAt: beginBlock endBlock: endBlock 	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes."		(self characterBlockAtPoint: Sensor cursorPoint) <= beginBlock		ifTrue: [^self mouseMovedFrom: beginBlock 					pivotBlock: endBlock					showingCaret: (beginBlock = endBlock)]		ifFalse: [^self mouseMovedFrom: endBlock 					pivotBlock: beginBlock					showingCaret: (beginBlock = endBlock)]! !!Paragraph methodsFor: 'selecting' stamp: 'di 6/23/97 23:14'!hiliteRect: rect	(rect ~~ nil) ifTrue:		[ destinationForm			fill: rect			rule: Form reverse			fillColor: destinationForm highLight.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: destinationForm highLight" ].! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/8/97 12:25'!mouseMovedFrom: beginBlock pivotBlock: pivotBlock showingCaret: caretOn 	| startBlock stopBlock showingCaret |	stopBlock _ startBlock _ beginBlock.	showingCaret _ caretOn.	[Sensor redButtonPressed]		whileTrue: 			[stopBlock _ self characterBlockAtPoint: Sensor cursorPoint.			stopBlock = startBlock				ifFalse: 					[showingCaret						ifTrue: 							[showingCaret _ false.							self reverseFrom: pivotBlock to: pivotBlock].			((startBlock >= pivotBlock and: [stopBlock >= pivotBlock])				or: [startBlock <= pivotBlock and: [stopBlock <= pivotBlock]])				ifTrue: 					[self reverseFrom: startBlock to: stopBlock.					startBlock _ stopBlock]				ifFalse: 					[self reverseFrom: startBlock to: pivotBlock.					self reverseFrom: pivotBlock to: stopBlock.					startBlock _ stopBlock].			(clippingRectangle containsRect: stopBlock) ifFalse:				[stopBlock top < clippingRectangle top				ifTrue: [self scrollBy: stopBlock top - clippingRectangle top						withSelectionFrom: pivotBlock to: stopBlock]				ifFalse: [self scrollBy: stopBlock bottom + textStyle lineGrid - clippingRectangle bottom						withSelectionFrom: pivotBlock to: stopBlock]]]].	pivotBlock = stopBlock ifTrue:		[showingCaret ifFalse:  "restore caret"			[self reverseFrom: pivotBlock to: pivotBlock]].	^ Array with: pivotBlock with: stopBlock! !!Paragraph methodsFor: 'selecting'!mouseSelect	"Answer with an Array of two CharacterBlocks that represent the text 	selection that the user makes.  Return quickly if the button is noticed up	to make double-click more responsive."	| pivotBlock startBlock stopBlock origPoint stillDown |	stillDown _ Sensor redButtonPressed.	pivotBlock _ startBlock _ stopBlock _		self characterBlockAtPoint: (origPoint _ Sensor cursorPoint).	stillDown _ stillDown and: [Sensor redButtonPressed].	self reverseFrom: startBlock to: startBlock.	[stillDown and: [Sensor cursorPoint = origPoint]] whileTrue:		[stillDown _ Sensor redButtonPressed].	(stillDown and: [clippingRectangle containsPoint: Sensor cursorPoint])		ifFalse: [^Array with: pivotBlock with: stopBlock].	^ self mouseMovedFrom: startBlock 		pivotBlock: pivotBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!mouseSelect: clickPoint 	"Track text selection and answer with an Array of two CharacterBlocks."	| startBlock |	startBlock _ self characterBlockAtPoint: clickPoint.	self reverseFrom: startBlock to: startBlock.	^ self mouseMovedFrom: startBlock 		pivotBlock: startBlock		showingCaret: true! !!Paragraph methodsFor: 'selecting'!reverseFrom: characterBlock1 to: characterBlock2 	"Reverse area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline caret |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		caret _ self caretFormForDepth: Display depth.		^ caret  "Use a caret to indicate null selection"				displayOn: destinationForm				at: characterBlock1 topLeft + (-3 @ baseline)				clippingBox: clippingRectangle				rule: (false "Display depth>8" ifTrue: [9 "not-reverse"]									ifFalse: [Form reverse])				fillColor: nil].	visibleRectangle _ 		(clippingRectangle intersect: compositionRectangle)			"intersect: destinationForm boundingBox" "not necessary".	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	self hiliteRect: initialRectangle.	self hiliteRect: interiorRectangle.	self hiliteRect: finalRectangle.! !!Paragraph methodsFor: 'selecting' stamp: 'di 12/1/97 04:43'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| visibleRectangle initialRectangle interiorRectangle finalRectangle lineNo baseline |	characterBlock1 = characterBlock2 ifTrue:		[lineNo _ self lineIndexOfCharacterIndex: characterBlock1 stringIndex.		baseline _ lineNo = 0 ifTrue: [textStyle baseline]							ifFalse: [(lines at: lineNo) baseline].		^ Array with: (characterBlock1 topLeft extent: 1 @ baseline)].	visibleRectangle _ clippingRectangle intersect: compositionRectangle.	characterBlock1 top = characterBlock2 top		ifTrue: [characterBlock1 left < characterBlock2 left					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft corner: characterBlock2 bottomLeft)								intersect: visibleRectangle]					ifFalse: 						[initialRectangle _ 							(characterBlock2 topLeft corner: characterBlock1 bottomLeft)								intersect: visibleRectangle]]		ifFalse: [characterBlock1 top < characterBlock2 top					ifTrue: 						[initialRectangle _ 							(characterBlock1 topLeft 								corner: visibleRectangle right @ characterBlock1 bottom)								intersect: visibleRectangle.						characterBlock1 bottom = characterBlock2 top							ifTrue: 								[finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]							ifFalse: 								[interiorRectangle _ 									(visibleRectangle left @ characterBlock1 bottom										corner: visibleRectangle right 														@ characterBlock2 top)										intersect: visibleRectangle.								finalRectangle _ 									(visibleRectangle left @ characterBlock2 top 										corner: characterBlock2 bottomLeft)										intersect: visibleRectangle]]				ifFalse: 					[initialRectangle _ 						(visibleRectangle left @ characterBlock1 top 							corner: characterBlock1 bottomLeft)							intersect: visibleRectangle.					characterBlock1 top = characterBlock2 bottom						ifTrue: 							[finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]						ifFalse: 							[interiorRectangle _ 								(visibleRectangle left @ characterBlock2 bottom 									corner: visibleRectangle right @ characterBlock1 top)									intersect: visibleRectangle.							finalRectangle _ 								(characterBlock2 topLeft 									corner: visibleRectangle right 												@ characterBlock2 bottom)									intersect: visibleRectangle]]].	^ (Array with: initialRectangle with: interiorRectangle with: finalRectangle)			select: [:rect | rect notNil]! !!Paragraph methodsFor: 'scrolling'!scrollBy: heightToMove 	^ self scrollBy: heightToMove withSelectionFrom: nil to: nil! !!Paragraph methodsFor: 'scrolling'!scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Translate the composition rectangle up (dy<0) by heightToMove.	Repainting text as necessary, and selection if blocks not nil.	Return true unless scrolling limits have been reached."	| max min amount |	max _ 0 max: "cant scroll up more than dist to (top of) bottom line"		compositionRectangle bottom - textStyle lineGrid - clippingRectangle top.	min _ 0 min: "cant scroll down more than top is above clipRect"		compositionRectangle top - clippingRectangle top.	amount _ ((heightToMove truncateTo: textStyle lineGrid) min: max) max: min.	amount ~= 0		ifTrue: [self scrollUncheckedBy: amount					withSelectionFrom: startBlock to: stopBlock.				^ true]		ifFalse: [^ false]! !!Paragraph methodsFor: 'scrolling'!scrollDelta	"By comparing this before and after, you know if scrolling happened"	^ clippingRectangle top - compositionRectangle top! !!Paragraph methodsFor: 'scrolling'!scrollUncheckedBy: heightToMove withSelectionFrom: startBlock to: stopBlock 	"Scroll by the given amount.  Copy bits where possible, display the rest.	If selection blocks are not nil, then select the newly visible text as well."	| savedClippingRectangle delta |	delta _ 0 @ (0 - heightToMove).	compositionRectangle _ compositionRectangle translateBy: delta.	startBlock == nil ifFalse:		[startBlock moveBy: delta.		stopBlock moveBy: delta].	savedClippingRectangle _ clippingRectangle.	clippingRectangle _ clippingRectangle intersect: Display boundingBox.	heightToMove abs >= clippingRectangle height	  ifTrue: 		["Entire visible region must be repainted"		self displayLines: (1 to: lastLine) affectedRectangle: clippingRectangle]	  ifFalse:		["Copy bits where possible / display the rest"		destinationForm			copyBits: clippingRectangle from: destinationForm			at: clippingRectangle topLeft + delta			clippingBox: clippingRectangle			rule: Form over fillColor: nil.		"Set clippingRectangle to 'vacated' area for lines 'pulled' into view."		clippingRectangle _ heightToMove < 0			ifTrue:  "On the top"				[clippingRectangle topLeft corner: clippingRectangle topRight + delta]			ifFalse:  "At the bottom"				[clippingRectangle bottomLeft + delta corner: clippingRectangle bottomRight].		self displayLines: (1 to: lastLine)   "Refresh vacated region"			affectedRectangle: clippingRectangle].	startBlock == nil ifFalse:		[self reverseFrom: startBlock to: stopBlock].	"And restore the clippingRectangle to its original value. "	clippingRectangle _ savedClippingRectangle! !!Paragraph methodsFor: 'alignment'!centered 	"Set the alignment for the style with which the receiver displays its text 	so that text is centered in the composition rectangle."	textStyle alignment: Centered! !!Paragraph methodsFor: 'alignment'!justified 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle."	textStyle alignment: Justified! !!Paragraph methodsFor: 'alignment'!leftFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text begin on an even border in the 	composition rectangle. This is also known as ragged-right."	textStyle alignment: LeftFlush! !!Paragraph methodsFor: 'alignment'!rightFlush 	"Set the alignment for the style with which the receiver displays its text 	so that the characters in each of text end on an even border in the 	composition rectangle but the beginning of each line does not. This is 	also known as ragged-left."	textStyle alignment: RightFlush! !!Paragraph methodsFor: 'alignment'!toggleAlignment 	"Set the alignment for the style with which the receiver displays its text 	so that it moves from centered to justified to leftFlush to rightFlush and 	back to centered again."	textStyle alignment: textStyle alignment + 1! !!Paragraph methodsFor: 'indicating'!flash 	"Complement twice the visible area in which the receiver displays."	Display flash: clippingRectangle! !!Paragraph methodsFor: 'indicating'!outline 	"Display a border around the visible area in which the receiver presents 	its text."	clippingRectangle bottom <= compositionRectangle bottom	  ifTrue: [Display 				border: (clippingRectangle intersect: compositionRectangle) 				width: 2]	  ifFalse: [Display 				border: (clippingRectangle intersect: destinationForm boundingBox)				width: 2].	! !!Paragraph methodsFor: 'utilities'!clearVisibleRectangle 	"Display the area in which the receiver presents its text so that the area 	is all one tone--in this case, all white."	destinationForm	  fill: clippingRectangle	  rule: rule	  fillColor: self backgroundColor! !!Paragraph methodsFor: 'utilities'!deepCopy	"Don't want to copy the destForm (Display) or fonts in the TextStyle.  9/13/96 tk"	| new |	new _ self copy.	new textStyle: textStyle copy.	new destinationForm: destinationForm.	new lines: lines copy.	new text: text deepCopy.	^ new! !!Paragraph methodsFor: 'utilities'!destinationForm: destForm	destinationForm _ destForm! !!Paragraph methodsFor: 'utilities'!fit	"Make the bounding rectangle of the receiver contain all the text without 	changing the width of the receiver's composition rectangle."	[(self lineIndexOfTop: clippingRectangle top) = 1]		whileFalse: [self scrollBy: (0-1)*textStyle lineGrid].	self updateCompositionHeight.	clippingRectangle _ clippingRectangle withBottom: compositionRectangle bottom! !!Paragraph methodsFor: 'utilities'!lines: lineArray	lines _ lineArray! !!Paragraph methodsFor: 'utilities'!visibleRectangle 	"May be less than the clippingRectangle if text ends part way down.	Also some fearful history includes Display intersection;	it shouldn't be necessary"	^ (clippingRectangle intersect: compositionRectangle)		intersect: destinationForm boundingBox! !!Paragraph methodsFor: 'converting'!asForm	"Answer a Form made up of the bits that represent the receiver's displayable text."	| theForm oldBackColor oldForeColor |	theForm _ (ColorForm extent: compositionRectangle extent)		offset: offset;		colors: (Array			with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])			with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).	oldBackColor _ backColor.	oldForeColor _ foreColor.	backColor _ Color white.	foreColor _ Color black.	self displayOn: theForm		at: 0@0		clippingBox: theForm boundingBox		rule: Form over		fillColor: nil.	backColor _ oldBackColor.	foreColor _ oldForeColor.	^ theForm"Example:| p |p _ 'Abc' asParagraph.p foregroundColor: Color red backgroundColor: Color black.p asForm displayOn: Display at: 30@30 rule: Form over"! !!Paragraph methodsFor: 'converting'!asString	"Answer the string of characters of the receiver's text."	^text string! !!Paragraph methodsFor: 'converting'!asText	"Answer the receiver's text."	^text! !!Paragraph methodsFor: 'private'!bottomAtLineIndex: lineIndex 	"Answer the bottom y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [^ y + textStyle lineGrid].	1 to: (lineIndex min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private' stamp: 'tk 9/30/96'!compositionRectangle: compositionRect text: aText style: aTextStyle offset: aPoint	compositionRectangle _ compositionRect copy.	text _ aText.	textStyle _ aTextStyle.	rule _ DefaultRule.	mask _ nil.		"was DefaultMask "	marginTabsLevel _ 0.	destinationForm _ Display.	offset _ aPoint.	^self composeAll! !!Paragraph methodsFor: 'private'!compositionRectangleDelta	"A handy number -- mostly for scrolling."	^compositionRectangle top - clippingRectangle top! !!Paragraph methodsFor: 'private'!displayLines: linesInterval 	^ self displayLines: linesInterval		affectedRectangle: self visibleRectangle! !!Paragraph methodsFor: 'private'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !!Paragraph methodsFor: 'private'!displayOn: aDisplayMedium lines: lineInterval	| saveDestinationForm |	saveDestinationForm _ destinationForm.	destinationForm _ aDisplayMedium.	self displayLines: lineInterval.	destinationForm _ saveDestinationForm! !!Paragraph methodsFor: 'private'!leftMarginForCompositionForLine: lineIndex 	"Build the left margin for composition of a line. Depends upon	marginTabsLevel and the indent."	| indent |	lineIndex = 1		ifTrue: [indent _ textStyle firstIndent]		ifFalse: [indent _ textStyle restIndent].	^indent + (textStyle leftMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private'!leftMarginForDisplayForLine: lineIndex 	"Build the left margin for display of a line. Depends upon	leftMarginForComposition, compositionRectangle left and the alignment."	| pad |	(textStyle alignment = LeftFlush or: [textStyle alignment = Justified])		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex)].	"When called from character location code and entire string has been cut,	there are no valid lines, hence following nil check."	(lineIndex <= lines size and: [(lines at: lineIndex) notNil])		ifTrue: 			[pad _ (lines at: lineIndex) paddingWidth]		ifFalse: 			[pad _ 				compositionRectangle width - textStyle firstIndent - textStyle rightIndent].	textStyle alignment = Centered 		ifTrue: 			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + (pad // 2)].	textStyle alignment = RightFlush 		ifTrue:			[^compositionRectangle left 				+ (self leftMarginForCompositionForLine: lineIndex) + pad].	self error: ['no such alignment']! !!Paragraph methodsFor: 'private'!lineAt: indexInteger put: aTextLineInterval 	"Store a line, track last, and grow lines if necessary."	indexInteger > lastLine ifTrue: [lastLine _ indexInteger].	lastLine > lines size ifTrue: [lines _ lines , (Array new: lines size)].	^lines at: indexInteger put: aTextLineInterval! !!Paragraph methodsFor: 'private'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	1 to: lastLine do: 		[:lineIndex | 		(lines at: lineIndex) last >= characterIndex ifTrue: [^lineIndex]].	^lastLine! !!Paragraph methodsFor: 'private'!lineIndexOfTop: top 	"Answer the line index at a given top y."	| y line |	lastLine = 0 ifTrue: [^ 1].	y _ compositionRectangle top.	1 to: lastLine do:		[:i | line _ lines at: i.		(y _ y + line lineHeight) > top ifTrue: [^ i]].	^ lastLine! !!Paragraph methodsFor: 'private'!lines	^lines! !!Paragraph methodsFor: 'private'!moveBy: delta	compositionRectangle _ compositionRectangle translateBy: delta.	clippingRectangle _ clippingRectangle translateBy: delta.! !!Paragraph methodsFor: 'private'!rightMarginForComposition	"Build the right margin for a line. Depends upon compositionRectangle	width, marginTabsLevel, and right indent."	^compositionRectangle width 		- (textStyle rightMarginTabAt: marginTabsLevel) 		- textStyle rightIndent! !!Paragraph methodsFor: 'private'!rightMarginForDisplay 	"Build the right margin for a line. Depends upon compositionRectangle	rightSide, marginTabsLevel, and right indent."	^compositionRectangle right - 		textStyle rightIndent - (textStyle rightMarginTabAt: marginTabsLevel)! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle 	"Set text and adjust bounding rectangles to fit."	| shrink compositionWidth unbounded |	unbounded _ Rectangle origin: 0 @ 0 extent: 9999@9999.	compositionWidth _ self		setWithText: aText style: aTextStyle compositionRectangle: unbounded clippingRectangle: unbounded.	compositionRectangle _ compositionRectangle withWidth: compositionWidth.	clippingRectangle _ compositionRectangle copy.	shrink _ unbounded width - compositionWidth.	"Shrink padding widths accordingly"	1 to: lastLine do:		[:i | (lines at: i) paddingWidth: (lines at: i) paddingWidth - shrink]! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect 	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle _ clipRect copy.	^self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!setWithText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: cf backColor: cb	"Set text and using supplied parameters. Answer max composition width."	clippingRectangle _ clipRect copy.	self foregroundColor: cf backgroundColor: cb.	^ self		compositionRectangle: compRect		text: aText		style: aTextStyle		offset: 0 @ 0! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex 	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	lastLine = 0 ifTrue: [lineIndex > 0 ifTrue: [^ y + textStyle lineGrid]. ^ y].	1 to: (lineIndex-1 min: lastLine) do:		[:i | y _ y + (lines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!topAtLineIndex: lineIndex using: otherLines and: otherLastLine	"Answer the top y of given line."	| y |	y _ compositionRectangle top.	otherLastLine = 0 ifTrue: [^ y].	1 to: (lineIndex-1 min: otherLastLine) do:		[:i | y _ y + (otherLines at: i) lineHeight].	^ y! !!Paragraph methodsFor: 'private'!trimLinesTo: lastLineInteger	(lastLineInteger + 1 to: lastLine) do: [:i | lines at: i put: nil].	(lastLine _ lastLineInteger) < (lines size // 2) 		ifTrue: [lines _ lines copyFrom: 1 to: lines size - (lines size // 2)]! !!Paragraph methodsFor: 'private'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle _ compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR])		ifTrue: [compositionRectangle _ compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!Paragraph methodsFor: 'private' stamp: 'di 8/30/97 11:14'!withClippingRectangle: clipRect do: aBlock	| saveClip |	saveClip _ clippingRectangle.	clippingRectangle _ clipRect.		aBlock value.	clippingRectangle _ saveClip! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Paragraph class	instanceVariableNames: ''!!Paragraph class methodsFor: 'instance creation'!new	"Do not allow an uninitialized view. Create with text that has no	characters."	^self withText: '' asText! !!Paragraph class methodsFor: 'instance creation'!withText: aText 	"Answer an instance of me with text set to aText and style set to the 	system's default text style."	^self withText: aText style: DefaultTextStyle copy! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle 	"Answer an instance of me with text set to aText and style set to 	aTextStyle."	^super new setWithText: aText style: aTextStyle! !!Paragraph class methodsFor: 'instance creation'!withText: aText style: aTextStyle compositionRectangle: compRect clippingRectangle: clipRect foreColor: c1 backColor: c2	"Answer an instance of me with text set to aText and style set to 	aTextStyle, composition rectangle is compRect and the clipping rectangle 	is clipRect."	| para |	para _ super new.	para setWithText: aText		style: aTextStyle		compositionRectangle: compRect		clippingRectangle: clipRect		foreColor: c1 backColor: c2.	^para! !!Paragraph class methodsFor: 'examples' stamp: 'tk 9/30/96'!example	"This simple example illustrates how to display a few lines of text on the screen at the current cursor point.  	Fixed. "	| para point |	point _ Sensor waitButton.	para _ 'This is the first line of charactersand this is the second line.' asParagraph.	para displayOn: Display at: point.	"Paragraph example"! !ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval '	classVariableNames: 'ChangeText CmdActions CurrentSelection FindText Keyboard ShiftCmdActions TextEditorYellowButtonMenu TextEditorYellowButtonMessages UndoInterval UndoMessage UndoParagraph UndoSelection Undone '	poolDictionaries: 'TextConstants '	category: 'Graphics-Editors'!!ParagraphEditor commentStamp: 'di 5/22/1998 16:36' prior: 0!ParagraphEditor comment:'I am a Controller for editing a Paragraph. I am a kind of ScrollController, so that more text can be created for the Paragraph than can be viewed on the screen. Editing messages are sent by issuing commands from a yellow button menu or from keys on the keyboard. My instances keep control as long as the cursor is within the view when the red or yellow mouse button is pressed; they give up control if the blue button is pressed.'!!ParagraphEditor methodsFor: 'initialize-release'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph _ nil].	paragraph _ aParagraph.	self resetState! !!ParagraphEditor methodsFor: 'initialize-release'!initialize	"Initialize a new ParagraphEditor.  It is initially not in control, so its	 would-be-instance variables, UndoInterval and PriorInterval, are stashed in	 beginTypeInBlock."	super initialize.	self initializeYellowButtonMenu.	beginTypeInBlock _ Array with: (1 to: 0) with: (1 to: 0)! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'accessing' stamp: 'tk 4/21/1998 09:55'!initialText	^ initialText! !!ParagraphEditor methodsFor: 'accessing'!replace: oldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval _ self selectionInterval.	undoInterval = oldInterval ifFalse: [self selectInterval: oldInterval].	UndoSelection _ self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval _ self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!ParagraphEditor methodsFor: 'accessing'!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection _ self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!ParagraphEditor methodsFor: 'accessing'!selection	"Answer the text in the paragraph that is currently selected."	^paragraph text copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadWriteStream		on: paragraph string		from: startBlock stringIndex		to: stopBlock stringIndex - 1! !!ParagraphEditor methodsFor: 'accessing'!selectionInterval	"Answer the interval that is currently selected."	^startBlock stringIndex to: stopBlock stringIndex - 1 ! !!ParagraphEditor methodsFor: 'accessing'!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText _ ChangeText _ aString asText]! !!ParagraphEditor methodsFor: 'accessing'!text	"Answer the text of the paragraph being edited."	^paragraph text! !!ParagraphEditor methodsFor: 'accessing' stamp: 'jm 3/18/98 20:38'!userHasEdited	"Note that the user has edited my text. Here it is just a noop so that the Character Recognizer won't fail when used with a vanilla ParagrahEditor."! !!ParagraphEditor methodsFor: 'accessing'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'controlling'!controlActivity	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self processKeyboard.				self processMouseButtons]! !!ParagraphEditor methodsFor: 'controlling'!controlInitialize	super controlInitialize.	self recomputeInterval.	self initializeSelection.	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'controlling'!controlTerminate	self closeTypeIn.  "Must call to establish UndoInterval"	super controlTerminate.	self deselect! !!ParagraphEditor methodsFor: 'controlling'!isControlActive	^super isControlActive & sensor blueButtonPressed not! !!ParagraphEditor methodsFor: 'scrolling'!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor methodsFor: 'scrolling'!markerDelta	^marker top - scrollBar top - ((paragraph clippingRectangle top -		paragraph compositionRectangle top) asFloat /			(self scrollRectangleHeight max: 1) asFloat *				scrollBar height asFloat) rounded! !!ParagraphEditor methodsFor: 'scrolling'!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar top! !!ParagraphEditor methodsFor: 'scrolling'!scrollBar	^ scrollBar! !!ParagraphEditor methodsFor: 'scrolling'!scrollBy: heightToMove	"Move the paragraph by heightToMove, and reset the text selection."	^ paragraph scrollBy: heightToMove withSelectionFrom: startBlock to: stopBlock! !!ParagraphEditor methodsFor: 'scrolling'!scrollRectangleHeight	^paragraph compositionRectangle height 		+ paragraph lineGrid! !!ParagraphEditor methodsFor: 'scrolling'!scrollToBottom	"Scroll so that the tail end of the text is visible in the view.  5/6/96 sw"	self scrollView: (paragraph clippingRectangle bottom 		- paragraph compositionRectangle bottom)! !!ParagraphEditor methodsFor: 'scrolling'!scrollToTop	"Scroll so that the paragraph is at the top of the view."	self scrollView: (paragraph clippingRectangle top 		- paragraph compositionRectangle top)! !!ParagraphEditor methodsFor: 'scrolling'!scrollView: anInteger 	"Paragraph scrolling uses opposite polarity"	^ self scrollBy: anInteger negated! !!ParagraphEditor methodsFor: 'scrolling'!updateMarker	"A variation of computeMarkerRegion--only redisplay the marker in the scrollbar if an actual change has occurred in the positioning of the paragraph."	self moveMarkerTo: self computeMarkerRegion! !!ParagraphEditor methodsFor: 'scrolling'!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	^paragraph clippingRectangle top 		- paragraph compositionRectangle top 		- ((marker top - scrollBar inside top) asFloat 				/ scrollBar inside height asFloat * self scrollRectangleHeight asFloat)			roundTo: paragraph lineGrid! !!ParagraphEditor methodsFor: 'sensor access'!processBlueButton	"The user pressed the blue button on the mouse. Determine what action 	to take."	^self! !!ParagraphEditor methodsFor: 'sensor access'!processKeyboard	"Determine whether the user pressed the keyboard. If so, read the keys."	sensor keyboardPressed ifTrue: [self readKeyboard]! !!ParagraphEditor methodsFor: 'sensor access'!processMouseButtons	"Determine whether the user pressed any mouse button. For each possible 	button, determine what actions to take."	sensor redButtonPressed ifTrue: [self processRedButton].	sensor yellowButtonPressed ifTrue: [self processYellowButton].	sensor blueButtonPressed ifTrue: [self processBlueButton]! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'tk 1/7/98 12:03'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	| previousStartBlock previousStopBlock selectionBlocks tempBlock clickPoint oldDelta oldInterval |	clickPoint _ sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	previousStartBlock _ startBlock.	previousStopBlock _ stopBlock.	oldDelta _ paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks _ paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks _ paragraph extendSelectionAt: startBlock endBlock: stopBlock.			self closeTypeIn].	selectionShowing _ true.	startBlock _ selectionBlocks at: 1.	stopBlock _ selectionBlocks at: 2.	startBlock > stopBlock		ifTrue: 			[tempBlock _ startBlock.			startBlock _ stopBlock.			stopBlock _ tempBlock].	(startBlock = stopBlock 		and: [previousStartBlock = startBlock and: [previousStopBlock = stopBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval]! !!ParagraphEditor methodsFor: 'sensor access'!processYellowButton	"User pressed the yellow button on the mouse. Determine what actions to 	take."	self yellowButtonActivity! !!ParagraphEditor methodsFor: 'displaying'!display	"Redisplay the paragraph."	| selectionState |	selectionState _ selectionShowing.	self deselect.	paragraph foregroundColor: view foregroundColor			backgroundColor: view backgroundColor;			displayOn: Display.	selectionState ifTrue: [self select]! !!ParagraphEditor methodsFor: 'displaying'!flash	"Causes the view of the paragraph to complement twice in succession."	paragraph flash! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 19:19'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText _ paragraph text copy.! !!ParagraphEditor methodsFor: 'menu messages'!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made.	Undoer & Redoer: #undoAgain:andReselect:typedKey:."	"If last command was also 'again', use same keys as before"	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:)! !!ParagraphEditor methodsFor: 'menu messages'!align	"Align text according to the next greater alignment value--cycling among 	left flush, right flush, center, justified.  No effect on the undoability of the pre	preceding command."	paragraph toggleAlignment.	paragraph displayOn: Display.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'tk 4/10/1998 11:56'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk at: aSymbol ifAbsent: [nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifTrue:						[brow _ Browser new.						brow setClass: anEntry selector: nil.						Browser openBrowserView: (brow openEditString: nil)							label: 'System Browser']					ifFalse:						[anEntry inspect]]			ifFalse:				[Smalltalk browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'tk 4/9/98 11:37'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ view topView model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectLine.	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection _ paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph _ paragraph.	otherInterval _ UndoInterval _ 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:36'!changeAlignment	| aList reply  |	aList _ #(leftFlush centered justified rightFlush).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[paragraph perform: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:39'!changeEmphasis	| aList reply  |	aList _ #(plain bold italic narrow underlined struckOut).	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/20/97 20:11'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList _ (TextConstants select: [:thang | thang isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ Smalltalk clipboardText.	(s isEmpty or: [s = CurrentSelection string])		ifTrue: [^ CurrentSelection]		ifFalse: [^ s asText]! !!ParagraphEditor methodsFor: 'menu messages'!clipboardTextPut: text	"Set text currently on the clipboard.  Also export to Mac"	CurrentSelection _ text.	Smalltalk clipboardText: CurrentSelection string! !!ParagraphEditor methodsFor: 'menu messages'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user.  4/29/96 sw"	| count s |	s _ self clipboardText string.	count _ paragraph text string charactersExactlyMatching: s.	count == (paragraph text string size max: s size) 		ifTrue:			[^ self inform: 'Exact match'].	self selectFrom: 1 to: count! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection _ self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval _ self selectionInterval.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:33'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages'!exchange	"See comment in exchangeWith:"	self exchangeWith: otherInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 5/12/1998 10:16'!experimentalCommand	"Use for experimental command-key implementation.  using this, you can try things out without forever needing to reinitialize the ParagraphEditor. "	sensor keyboard.	self inform: 'Cmd-t is not currently used.To get "ifTrue: [" inserted, use Cmd-SHIFT-t'.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:11'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply |Cursor execute showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a single token, construct, or special character.'.			sorry _ sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:symbol | symbol])						ifTrue: [cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [										selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'menu messages'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| aStream selection |	self controlTerminate.	selection _ self selection.	(ReadWriteStream on: selection string from: 1 to: selection size) fileIn.	self controlInitialize! !!ParagraphEditor methodsFor: 'menu messages'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages'!findAgain	"Find the text-to-find again.  1/24/96 sw"	self againOrSame: true! !!ParagraphEditor methodsFor: 'menu messages'!fit	"Make the bounding rectangle of the paragraph contain all the text while 	 not changing the width of the view of the paragraph.  No effect on undoability	 of the preceding command."	paragraph clearVisibleRectangle.	paragraph fit.	paragraph displayOn: Display; outline.	self recomputeInterval! !!ParagraphEditor methodsFor: 'menu messages'!format	"Put here as a backstop for situations where the menu command is available but a method context is not extablished.  1/24/96 sw"	view flash! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:07'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllImplementorsOf: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:34'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	startBlock = stopBlock ifTrue: [view flash.  ^ self]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:26'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[self terminateAndInitializeAround: [Smalltalk browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed]].	Cursor normal show! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:10'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	self lineSelectAndEmptyCheck: [^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/15/97 13:26'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [Smalltalk browseMethodsWithString: self selection string]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:34'!mvcRedisplay	"Overridable by subclasses that do their own display"	Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"	self display! !!ParagraphEditor methodsFor: 'menu messages'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: stopBlock stringIndex]! !!ParagraphEditor methodsFor: 'menu messages'!performMenuMessage: aSelector	"If a menu command is invoked, typeIn must be closed first, the selection	 must be unhighlighted before and rehighlighted after, and the marker	 must be updated."	self closeTypeIn.	self deselect.	super performMenuMessage: aSelector.	self selectAndScroll.	self updateMarker! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/29/98 13:08'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	| reply items |	self terminateAndInitializeAround:		[reply _ (PopUpMenu labelArray: (items _ self specialMenuItems) lines: #()) startUp.		reply = 0 ifTrue: [^ self].		Utilities evaluate: (items at: reply) in: [] to: self]	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:39'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self lineSelectAndEmptyCheck: [^ self].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages'!selectedSelector	"Try to make a selector out of the current text selection.	6/18/96 sw: incorporated Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, and will not handle parentheses correctly, for example, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel |	sel _  self selection string withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel _ String streamContents:			[:s | ((sel findTokens: Character separators)						select: [:tok | tok last = $:])					do: [:key | s nextPutAll: key]]].	sel size == 0 ifTrue: [^ nil].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!ParagraphEditor methodsFor: 'menu messages'!selectedSymbol	"Return the currently selected symbol, or nil if none.  If the selection involves a method send, return the relevent selector.  If the selection is a class name, return that. 1/15/96 sw.	2/29/96 sw: strip crs before lookup"	| aString |	startBlock = stopBlock ifTrue: [^ nil].	aString _ self selection string copyWithout: Character cr.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:11'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: aSelector]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:12'!setSearchString	"Make the current selection, if any, be the current search string."	startBlock = stopBlock ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/9/97 16:42'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down. 3/13/96 sw	 5/27/96 sw: added font menu"	^ PopUpMenu labels: 'set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with it (E)method source with itspecial menu...more...' 		lines: #(2 7 14).! !!ParagraphEditor methodsFor: 'menu messages'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  Inconvenient to have it here in this separate method; when/if we consolidate via a class variable, as for unshifted, the problem will go away.  1/17/96 sw	 3/7/96 sw: added methodSourceContainingIt	 3/13/96 sw: merged ParagraphEditor and StringHolderController versions into ParagraphEditor, and deleted the StringHolderController versions	 5/27/96 sw: added offerFontMenu	 8/20/96 sw: makeover"	^ #(offerFontMenu changeStyle explain format fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu unshiftedYellowButtonActivity)"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 5/20/1998 22:41'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code _ paragraph text string.	self cancel.	model spawn: code.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 20:00'!spawnWorkspace	| toUse |	self selectLine.	toUse _ self selection asString.	toUse size > 0 ifFalse:		[toUse _ paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self controlTerminate.	Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse.	self controlInitialize.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/29/96'!specialMenuItems	"Refer to comment under #presentSpecialMenu.  .	 : added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'menu messages'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	[sensor keyboardPressed] whileTrue: [sensor keyboard]. "a way to flush stuck keys"	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage _ Message selector: #undoReplace.		UndoInterval _ 1 to: 0.		Undone _ true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph _ Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph _ paragraph! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 11:01'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list _ Smalltalk allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply _ ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'Smalltalk browseAllImplementorsOf: #' , symbol! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 11:02'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:13'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass) ifFalse: [^ nil].	(class _ model selectedClassOrMetaClass) ifNil: [^nil].	  "no class is selected"	(class isKindOf: Metaclass) ifTrue: [class _ class soleInstance].	classes _ (Array with: class) , class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames			detect: [:name | symbol = name] ifNone: [])			~~ nil] ifNone: [].	reply == nil ifFalse: [^'"is a class variable; defined in class ' , reply printString, '"\' withCRs,		'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]			ifNone: []) ~~ nil].	reply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].	reply == nil		ifFalse: 			[classes _ WriteStream on: Array new.			Smalltalk allBehaviorsDo: [:each |					(each sharedPools detect: [:pool | pool == reply] ifNone: [])					~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^'"is a pool variable from the pool ' , (Smalltalk keyAtValue: reply),			', which is used by the following classes ' , classes contents printString , '"\' withCRs,			'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtValue: reply) printString,			' associationAt: #', symbol, ').'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'sw 5/3/1998 14:32'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply _ '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply _ '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply _ '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply _ '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes _ cls withAllSubclasses.			classes size > 12				ifTrue: [text _ cls printString , ' or a subclass']				ifFalse: 					[classes _ classes printString.					text _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply _ '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply _ '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 10:58'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str _ string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 10:57'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	reply class == Dictionary		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  ' , symbol , ' is a Dictionary.  It is a pool which is used by the following classes' , (classes copyFrom: 4 to: classes size) , '"'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:14'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes _ (Array with: cls)				, cls allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' browseAllAccessesTo: ''' , string , '''.'! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:16'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ Smalltalk allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''."']		ifFalse: 			[lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''."'].! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 11:03'!explainNumber: string 	"Is string a Number?"	| strm c |	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1])			ifFalse: [^nil]].	strm _ ReadStream on: string.	c _ Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:17'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane and use yellowbug to select ''implementors''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane and use yellowbug to select ''messages''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'explain'!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg _ 1.	end _ string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c _ string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg _ beg + 1].		[c _ string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end _ end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:19'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass _ model selectedClassOrMetaClass.	tempNames _ selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method _ selectedClass compiledMethodAt: msg.	(i _ tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode _ selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames _ methodNode tempNames]			ifFalse: [^nil]].	(i _ tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply _ '"is a temporary variable in this method"']			ifFalse: [reply _ '"is an argument to this method"']].	^reply! !!ParagraphEditor methodsFor: 'editing keys'!align: characterStream 	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	sensor keyboard.		"flush character"	self align.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw	 1/22/96 sw: put in control terminate/init"	self controlTerminate.	sensor keyboard.	self cancel.	self controlInitialize.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 1/14/98 09:44'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	| keyCode attribute oldAttributes index thisSel colors |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	thisSel _ self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[colors _ #(black magenta red yellow green blue cyan white).		index _ (PopUpMenu labelArray: colors , #('Do it' 'Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' 'URL' 'Copy hidden info')							lines: (Array with: colors size)) startUp.		index = 0 ifTrue: [^ true].		index <= colors size		ifTrue:			[attribute _ TextColor color: (Color perform: (colors at: index))]		ifFalse:			[index _ index - colors size.			index = 1 ifTrue: [attribute _ TextDoIt new.				thisSel _ attribute analyze: self selection asString].			index = 2 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Comment'].			index = 3 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Definition'].			index = 4 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Hierarchy'].			index = 5 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString].			index = 6 ifTrue: [attribute _ TextURL new. 				thisSel _ attribute analyze: self selection asString].			index = 7 ifTrue: ["Copy hidden info"				self copyHiddenInfo.  ^ true].	"no other action"		thisSel ifNil: [^ true]].	"Could not figure out what to link to"		].	(keyCode between: 7 and: 11) ifTrue:		[sensor leftShiftDown		ifTrue:			[keyCode = 10 ifTrue: [attribute _ TextKern kern: -1].			keyCode = 11 ifTrue: [attribute _ TextKern kern: 1]]		ifFalse:			[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self compareToClipboard.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 12/30/97 10:43'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Copy that to the clipboard.  You can paste it and see what it is.  Usually enclosed in <>."	| attrList |	attrList _ paragraph text attributesAt: (startBlock stringIndex + stopBlock stringIndex)//2.	attrList do: [:attr |		attr class == TextLink ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		attr class == TextURL ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		attr class == TextAction ifTrue: [			^ self clipboardTextPut: ('<', attr info, '>') asText].		].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue: [			^ self clipboardTextPut: attr color printString asText]].	^ self clipboardTextPut: '[No hidden info]' asText! !!ParagraphEditor methodsFor: 'editing keys'!copySelection: characterStream 	"Copy the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self copySelection.	^true! !!ParagraphEditor methodsFor: 'editing keys'!cut: characterStream 	"Cut out the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self cut.	^true! !!ParagraphEditor methodsFor: 'editing keys'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self doIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(startBlock ~= stopBlock and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: stopBlock stringIndex]]		ifFalse:			[view flash].	^true! !!ParagraphEditor methodsFor: 'editing keys'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	self closeTypeIn.	startIndex _ startBlock stringIndex.	stopIndex _ stopBlock stringIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys'!exchange: characterStream	"Exchange the current and prior selections.  Keeps typeahead."	sensor keyboard.	 "Flush character"	self closeTypeIn: characterStream.	self exchange.	^true! !!ParagraphEditor methodsFor: 'editing keys'!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr tab realStart realStop lines startLine stopLine start stop adjustStart indentation size origSize numLines inStream newString outStream |	sensor keyboard.  "Flush typeahead"	cr _ Character cr.	tab _ Character tab.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ startBlock stringIndex.	realStop _ stopBlock stringIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexOfCharacterIndex: realStart.	stopLine _ paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into:		[:m :l |		m _ m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size _ origSize _ stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: paragraph string from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'editing keys'!indent: characterStream	"Add a tab at the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: characterStream delta: 1! !!ParagraphEditor methodsFor: 'editing keys'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self inspectIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 15:18'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 9/9/97 16:44'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!noop: characterStream 	"Unimplemented keyboard command; just ignore it."	sensor keyboard.	  "flush character"	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 5/27/96'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNames.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys'!offerFontMenu: characterStream 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw	 Keeps typeahead.  (?? should flush?)"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self offerFontMenu.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!outdent: characterStream	"Remove a tab from the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: characterStream delta: -1! !!ParagraphEditor methodsFor: 'editing keys'!paste: characterStream 	"Replace the current text selection by the text in the shared buffer.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self paste.	^true! !!ParagraphEditor methodsFor: 'editing keys'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: stopBlock stringIndex].	^ true! !!ParagraphEditor methodsFor: 'editing keys'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self printIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!recognizer: characterStream 	"Invoke Alan's character recognizer from cmd-r 2/2/96 sw"	sensor keyboard.	self recognizeCharacters.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 4/4/98 21:42'!save: characterStream 	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self controlTerminate.	self accept.	self controlInitialize.	^ true! !!ParagraphEditor methodsFor: 'editing keys'!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/12/97 22:15'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: startBlock stringIndex.	(emphasisSymbol == #plain) 		ifTrue:			[attribute _ TextEmphasis normal]		ifFalse:			[attribute _ TextEmphasis perform: emphasisSymbol.			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	char = $9 ifTrue: [ char _ $( ].	char = $, ifTrue: [ char _ $< ].	char = $[ ifTrue: [ char _ ${ ].	char = $' ifTrue: [ char _ $" ].	char asciiValue = 27 ifTrue: [ char _ ${ ].	"ctrl-["	self closeTypeIn.	startIndex _ startBlock stringIndex.	stopIndex _ stopBlock stringIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [1].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 4/13/1998 23:26'!spawnIt: characterStream 	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	self controlTerminate.	sensor keyboard.	self spawn.	self controlInitialize.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/18/96'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size == 0		ifTrue:			[currentSelection _ startBlock stringIndex]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection _ startBlock stringIndex + 1]].	self selectFrom: currentSelection - 1 to: currentSelection.	aString _ self selection string.	self replaceSelectionWith: (Text fromString: aString reversed).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 5/12/1998 10:16'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!ParagraphEditor methodsFor: 'editing keys'!undo: characterStream 	"Undo the last edit.  Keeps typeahead, so undo twice is a full redo."	sensor keyboard. 	"flush character"	self closeTypeIn: characterStream.	self undo.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start _ paragraph text findString: ': ' startingAt: stopBlock stringIndex.	start = 0 ifTrue: [start _ paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[startBlock = stopBlock				ifTrue: "a caret, delete at least one character"					[startIndex _ 1 max: startBlock stringIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex _ startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex _ startBlock stringIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	characterStream isEmpty		ifTrue:			[startIndex _ startBlock stringIndex +				(startBlock = stopBlock ifTrue: [0] ifFalse: [1]).			[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex _ 1 max: startIndex - 1.			].			self backTo: startIndex]		ifFalse:			[sensor keyboard.			characterStream skip: -1].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!changeStyle: characterStream 	"Put up the style-change menu"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self changeStyle.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ stopBlock stringIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [(s at: i+1) ~= $[]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorDown: characterStream "Private - Move cursor from position in current line to same position innext line. If next line too short, put at end. If shift key down,select."	| shift string right left start position textSize|	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ stopBlock stringIndex - left.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	right _ start _ right + 1.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	shift		ifTrue: 			[			start + position > right				ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]				ifFalse: [self selectFrom: startBlock stringIndex to: start +position - 1]			]		ifFalse: 			[			start + position > right				ifTrue: [self selectFrom: right to: right - 1]				ifFalse: [self selectFrom: start + position to: start + position -1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorEnd: characterStream "Private - Move cursor end of current line. If cursor already at end ofline, put cursor at end of text"	| string right stringSize |	sensor keyboard.	string _ paragraph text string.	stringSize _ string size.	right _ stopBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]whileTrue: [right _ right + 1].	stopBlock stringIndex == right		ifTrue: [self selectAt: string size + 1]		ifFalse: [self selectAt: right].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorHome: characterStream "Private - Move cursor from position in current line to beginning ofcurrent line. If cursor already at beginning of line, put cursor atbeginning of text"	| string left |	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	startBlock stringIndex == left		ifTrue: [self selectAt: 1]		ifFalse: [self selectAt: left].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorLeft: characterStream "Private - Move cursor left one character if nothing selected, otherwisemove cursor to beginning of selection. If the shift key is down, startselecting or extending current selection. Don't allow cursor pastbeginning of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: 			[			startBlock stringIndex > 1				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: stopBlockstringIndex - 1]			]		ifFalse: 			[			(startBlock stringIndex == stopBlock stringIndex and: [startBlockstringIndex > 1])				ifTrue: [self selectFrom: startBlock stringIndex - 1 to: startBlockstringIndex - 2]				ifFalse: [self selectFrom: startBlock stringIndex to: startBlockstringIndex - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorRight: characterStream "Private - Move cursor right one character if nothing selected,otherwise move cursor to end of selection. If the shift key is down,start selecting characters or extending already selected characters.Don't allow cursor past end of text"	| shift |	shift := sensor leftShiftDown.	sensor keyboard.	shift		ifTrue: [self selectFrom: startBlock stringIndex to: stopBlockstringIndex]		ifFalse: 			[			startBlock stringIndex == stopBlock stringIndex				ifTrue: [self selectFrom: stopBlock stringIndex + 1 to: stopBlockstringIndex]				ifFalse: [self selectFrom: stopBlock stringIndex to: stopBlockstringIndex - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	| shift string left position start |	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ startBlock stringIndex - left.	start _ left.	left _ left - 1.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	left < 1 ifTrue: [left _ 1].	start = 1 ifTrue: [position _ 0].	shift		ifTrue: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: stopBlock stringIndex - 1]				ifFalse: [self selectFrom: left + position to: stopBlock stringIndex- 1]			]		ifFalse: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: start - 2]				ifFalse: [self selectFrom: left + position to: left + position - 1]			].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainMany: characterStream 	"Do the previous thing again repeatedly. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!find: characterStream	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self find.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!findAgain: characterStream 	"Find the desired text again.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self findAgain.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'tk 11/4/96'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char."	| startIndex usel upara uinterval ind |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		"Just like regular Backspace -- delete the selection"		^ self backspace: characterStream].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	sensor keyboard.	self selectFrom: startIndex to: startIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!normalCharacter: characterStream 	"A nonspecial character is to be added to the stream of characters."	characterStream nextPut: sensor keyboard.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	startBlock = stopBlock		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[view flash].	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!search: characterStream	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: true. "true means use same keys"	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!selectAll: characterStream 	"select everything, invoked by cmd-a.  1/17/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectFrom: 1 to: paragraph text string size.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	prior _ otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval _ prior.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 8/1/97 16:13'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex _ startBlock stringIndex + (startBlock = stopBlock ifTrue: [0] ifFalse: [1]).	startIndex _ 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 11/7/97 14:00'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [beginTypeInBlock stringIndex].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ beginTypeInBlock stringIndex - startIndex.		beginTypeInBlock _ startBlock copy.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin start stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ beginTypeInBlock stringIndex.			start _ startBlock stringIndex.			stop _ stopBlock stringIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support'!closeTypeIn: characterStream	"Call instead of closeTypeIn when you want typeahead to be inserted before the	 control character is executed, e.g., from Ctrl-V."	self insertTypeAhead: characterStream.	self closeTypeIn! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 1/15/98 12:57'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	char = Character enter		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"enter, backspace, and escape keys (ascii 3, 8, and 27) are command keys"	(sensor commandKeyPressed or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	sensor controlKeyPressed ifTrue:		[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'typing support' stamp: 'tk 4/4/98 21:42'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self controlTerminate.			self accept.			self controlInitialize].	^ true! !!ParagraphEditor methodsFor: 'typing support'!insertTypeAhead: typeAhead	typeAhead isEmpty ifFalse:		[self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy]! !!ParagraphEditor methodsFor: 'typing support'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ startBlock copy]! !!ParagraphEditor methodsFor: 'typing support'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[beginTypeInBlock _ nil.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support'!recognizeCharacters	"Recognize hand-written characters and put them into the receiving pane.  Invokes Alan's character recognizer.  2/5/96 sw"	self recognizeCharactersWhileMouseIn: view insetDisplayBox! !!ParagraphEditor methodsFor: 'typing support'!recognizeCharactersWhileMouseIn: box	"Recognize hand-written characters and put them into the receiving pane.  Invokes Alan's character recognizer.  2/5/96 sw"	| aRecognizer |	Cursor marker showWhile:		[aRecognizer _ CharRecog new.		aRecognizer recognizeAndDispatch:			[:char | char == BS				ifTrue:					[self simulatedBackspace]				ifFalse:					[self simulatedKeystroke: char]]		until:			[(box containsPoint: sensor cursorPoint) not]].	view display! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 11/10/97 14:10'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (startBlock stringIndex-1 max: 1))					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'jm 3/18/98 20:47'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard. This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits.  1/31/96 sw"	self deselect.	self openTypeIn.	startBlock = stopBlock ifFalse: [UndoSelection _ self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	startBlock _ stopBlock copy.	self selectAndScroll.	self updateMarker.	view topView uncacheBits.! !!ParagraphEditor methodsFor: 'undoers'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText index subject |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize _ (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText _ self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		index _ indices at: i.		(subject _ index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoAndReselect: undoHighlight redoAndReselect: redoHighlight	"Undo typing, cancel, paste, and other operations that are like replaces	 but the selection is not the whole restored text after undo, redo, or both.	 undoHighlight is selected after this phase and redoHighlight after the next phase.	Redoer: itself."	self replace: self selectionInterval with: UndoSelection and:		[self selectInterval: undoHighlight].	self undoMessage: (UndoMessage argument: redoHighlight) forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'undoers'!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut _ self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!ParagraphEditor methodsFor: 'undoers'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: stopBlock stringIndex! !!ParagraphEditor methodsFor: 'undoers'!undoReplace	"Undo of any command that replaced a selection by other text that it left	 highlighted, and that is undone and redone by simple reversal of the	 operation.  This is the most common Undoer; call replaceSelectionWith:	 to get this setup.  Redoer: itself, so never isRedoing."	self replaceSelectionWith: UndoSelection! !!ParagraphEditor methodsFor: 'undo support'!isDoing	"Call from a doer/undoer/redoer any time to see which it is."	^(self isUndoing | self isRedoing) not! !!ParagraphEditor methodsFor: 'undo support'!isRedoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #redoing! !!ParagraphEditor methodsFor: 'undo support'!isUndoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #undoing! !!ParagraphEditor methodsFor: 'undo support'!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage _ Message selector: #noUndoer! !!ParagraphEditor methodsFor: 'undo support'!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph _ paragraph].	UndoMessage _ aMessage.	Undone _ aBoolean! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector	"See comment in undoMessage:.  Use this version when aSelector has no arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1	"See comment in undoMessage:.  Use this version when aSelector has one argument, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector argument: arg1) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2	"See comment in undoMessage:.  Use this version when aSelector has two arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2)) forRedo: false! !!ParagraphEditor methodsFor: 'undo support'!undoer: aSelector with: arg1 with: arg2 with: arg3	"See comment in undoMessage:.  Use this version when aSelector has three arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2 with: arg3)) forRedo: false! !!ParagraphEditor methodsFor: 'current selection'!deselect	"If the text selection is visible on the screen, reverse its highlight."	selectionShowing ifTrue: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection'!initializeSelection	"Do the initial activity when starting up the receiver. For example, in the 	ParagraphEditor highlight the current selection."	self select! !!ParagraphEditor methodsFor: 'current selection'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self computeIntervalFrom: startBlock stringIndex to: stopBlock stringIndex - 1! !!ParagraphEditor methodsFor: 'current selection'!recomputeSelection	"Redetermine the selection according to the start and stop block indices; 	do not highlight."	self deselect; recomputeInterval! !!ParagraphEditor methodsFor: 'current selection'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	paragraph reverseFrom: startBlock to: stopBlock! !!ParagraphEditor methodsFor: 'current selection'!select	"If the text selection is visible on the screen, highlight it."	selectionShowing ifFalse: [self reverseSelection]! !!ParagraphEditor methodsFor: 'current selection'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ stopBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY _ stopBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/10/1998 22:00'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: stopBlock stringIndex ! !!ParagraphEditor methodsFor: 'new selection'!computeIntervalFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	startBlock _ paragraph characterBlockForIndex: start.	stopBlock _ start > stop		ifTrue: [startBlock copy]		ifFalse: [paragraph characterBlockForIndex: stop + 1]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:21'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc _ start.		[(loc _ loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing _ selectionShowing) ifTrue: [ self reverseSelection ].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta _ aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/10/1998 22:24'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (' ' , aString) asText		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:25'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/20/1998 08:31'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	self insertAndSelect: aString at: (anInteger max: 1)! !!ParagraphEditor methodsFor: 'new selection'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!ParagraphEditor methodsFor: 'new selection'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = startBlock stringIndex and: [stop + 1 = stopBlock stringIndex]) ifFalse:		[self deselect.		self selectInvisiblyFrom: start to: stop].	self selectAndScroll! !!ParagraphEditor methodsFor: 'new selection'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: anInterval first to: anInterval last! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/9/1998 20:59'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: start to: stop! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/10/1998 21:01'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	| string left right |	string _ paragraph text string.	left _ startBlock stringIndex.	right _ stopBlock stringIndex - 1.	left > right ifFalse: [^ self].	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:		[left _ left - 1].	[right < string size and: [(string at: (right + 1)) ~= Character cr]] whileTrue:		[right _ right + 1].	self selectFrom: left to: (right min: string size)! !!ParagraphEditor methodsFor: 'new selection'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph text string.	stop _ stopBlock stringIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!ParagraphEditor methodsFor: 'new selection'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string _ paragraph text string.	here _ startBlock stringIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: 			[openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [direction < 0								ifTrue: 									[start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'private'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	 Append the start index of the occurrence to the stream indices, and, if	 ChangeText is not the same object as FindText, replace the occurrence by it."	| where |	where _ paragraph text findString: FindText startingAt: stopBlock stringIndex.	where = 0 ifTrue: [^false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^true! !!ParagraphEditor methodsFor: 'private'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	^ self againOrSame: useOldKeys many: sensor leftShiftDown! !!ParagraphEditor methodsFor: 'private'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [startBlock ~= stopBlock])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: "just inserted at a caret"			[home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home _ startBlock stringIndex to:			startBlock stringIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!ParagraphEditor methodsFor: 'private'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds blockNode outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ startBlock stringIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym _ Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart _ startBlock stringIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection _ self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			view flash].	self selectAt: caret! !!ParagraphEditor methodsFor: 'private'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ startBlock stringIndex.	stop _ stopBlock stringIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before _ prior last < start.			selection _ self selection.			priorSelection _ paragraph text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!ParagraphEditor methodsFor: 'private'!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr _ Character cr.	tab _ Character tab.	delta > 0		ifTrue: "shift right"			[prev _ cr.			 [ch _ (atEnd _ inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev _ ch]]		ifFalse: "shift left"			[skip _ delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch _ inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip _ ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!ParagraphEditor methodsFor: 'private'!initializeYellowButtonMenu	self yellowButtonMenu: TextEditorYellowButtonMenu 		yellowButtonMessages: TextEditorYellowButtonMessages ! !!ParagraphEditor methodsFor: 'private'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge _ anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < startBlock stringIndex or:			[anInterval first - fudge >= stopBlock stringIndex])! !!ParagraphEditor methodsFor: 'private'!nullText	^Text string: '' emphasis: emphasisHere! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:38'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection.! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 23:08'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model isKindOf: Model)		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ rcvr class evaluatorClass new evaluate: self selectionAsStream				in: ctxt to: rcvr notifying: self				ifFail: [FakeClassPool adopt: nil.						^ #failedDoit].	FakeClassPool adopt: nil.	Smalltalk logChange: self selection string.	^ result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:45'!inspectIt	"1/13/96 sw: minor fixup"	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].	self controlInitialize! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:46'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [Smalltalk					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	self controlInitialize! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:52'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParagraphEditor class	instanceVariableNames: ''!!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 6/18/96'!initialize	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	: call initializeTextEditorMenus	other times: marked change to trigger reinit" 	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'class initialization'!initializeTextEditorMenus	"Initialize the yellow button pop-up menu and corresponding messages.	6/1/96 sw moved here from StringHolderController initialize so it can be shared by vanilla ParagraphEditors."	TextEditorYellowButtonMenu _ 		PopUpMenu 			labels: 'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)do it (d)print it (p)inspect it (i)accept (s)cancel (l)more...' 		lines: #(3 5  8 11 13).	TextEditorYellowButtonMessages _ 		#(find findAgain setSearchString again undo copySelection cut paste doIt printIt inspectIt accept cancel shiftedYellowButtonActivity)	"ParagraphEditor initializeTextEditorMenus"! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'tk 3/31/98 16:25'!yellowButtonMenu	^ TextEditorYellowButtonMenu! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'tk 3/31/98 16:25'!yellowButtonMessages	^ TextEditorYellowButtonMessages! !!ParagraphEditor class methodsFor: 'instance creation'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'instance creation'!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor _ super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 10/29/97 20:22'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<'         do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$r	recognizer:		$s	save:		$t	tempCommand:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 10/29/97 20:27'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$w	methodNamesContainingIt:		$v	pasteInitials:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParagraphEditor class methodsFor: 'clipboard access'!clipboardContents	"Answer a copy of the text last cut or copied.  5/29/96 sw"	^ CurrentSelection deepCopy! !Object subclass: #ParseNode	instanceVariableNames: 'comment '	classVariableNames: 'Bfp BtpLong CodeBases CodeLimits DblExtDoAll Dup EndMethod EndRemote Jmp JmpLimit JmpLong LdFalse LdInstLong LdInstType LdLitIndType LdLitType LdMinus1 LdNil LdSelf LdSuper LdTempType LdThisContext LdTrue LoadLong LongLongDoAll NodeFalse NodeNil NodeSelf NodeSuper NodeThisContext NodeTrue Pop Send SendLimit SendLong SendLong2 SendPlus SendType ShortStoP StdLiterals StdSelectors StdVariables Store StorePop '	poolDictionaries: ''	category: 'System-Compiler'!!ParseNode commentStamp: 'di 5/22/1998 16:36' prior: 0!ParseNode comment:'This superclass of most compiler/decompiler classes declares common class variables, default messages, and the code emitters for jumps. Some of the class variables are initialized here; the rest are initialized in class VariableNode.'!!ParseNode methodsFor: 'testing'!assignmentCheck: encoder at: location	"For messageNodes masquerading as variables for the debugger.	For now we let this through - ie we allow stores ev	into args.  Should check against numArgs, though."	^ -1! !!ParseNode methodsFor: 'testing'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^false! !!ParseNode methodsFor: 'testing'!canCascade	^false! !!ParseNode methodsFor: 'testing'!isArg	^false! !!ParseNode methodsFor: 'testing'!isComplex	"Used for pretty printing to determine whether to start a new line"	^false! !!ParseNode methodsFor: 'testing'!isConstantNumber  "Overridden in LiteralNode"	^false! !!ParseNode methodsFor: 'testing'!isMessage: selSymbol receiver: rcvrPred arguments: argsPred	"See comment in MessageNode."	^false! !!ParseNode methodsFor: 'testing'!isReturningIf	^false! !!ParseNode methodsFor: 'testing'!isReturnSelf	^false! !!ParseNode methodsFor: 'testing'!isSelfPsuedoVariable	"Overridden in VariableNode."	^false! !!ParseNode methodsFor: 'testing'!isSpecialConstant	^ false! !!ParseNode methodsFor: 'testing'!isUndefTemp	^ false! !!ParseNode methodsFor: 'testing'!isUnusedTemp	^ false! !!ParseNode methodsFor: 'testing'!isVariableReference	^false! !!ParseNode methodsFor: 'testing'!nowHasDef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'testing'!nowHasRef  "Ignored in all but VariableNode"! !!ParseNode methodsFor: 'testing'!prefersValue	"return true of this node generates shorter code when it leaves a value	on the stack"	^ true! !!ParseNode methodsFor: 'testing'!toDoIncrement: ignored	"Only meant for Messages or Assignments - else return nil"	^ nil! !!ParseNode methodsFor: 'code generation'!emitBranchOn:condition dist: dist pop: stack on: strm	stack pop: 1.	dist = 0 ifTrue: [^ strm nextPut: Pop].	condition		ifTrue: [self emitLong: dist code: BtpLong on: strm]		ifFalse: [self emitShortOrLong: dist code: Bfp on: strm]! !!ParseNode methodsFor: 'code generation'!emitForEffect: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: Pop.	stack pop: 1! !!ParseNode methodsFor: 'code generation'!emitForReturn: stack on: strm	self emitForValue: stack on: strm.	strm nextPut: EndMethod! !!ParseNode methodsFor: 'code generation'!emitJump: dist on: strm	dist = 0 ifFalse: [self emitShortOrLong: dist code: Jmp on: strm]! !!ParseNode methodsFor: 'code generation'!emitLong: dist code: longCode on: aStream 	"Force a two-byte jump."	| code distance |	code _ longCode.	distance _ dist.	distance < 0		ifTrue: 			[distance _ distance + 1024.			code _ code - 4]		ifFalse: 			[distance > 1023 ifTrue: [distance _ -1]].	distance < 0		ifTrue: 			[self error: 'A block compiles more than 1K bytes of code']		ifFalse: 			[aStream nextPut: distance // 256 + code.			aStream nextPut: distance \\ 256]! !!ParseNode methodsFor: 'code generation'!emitShortOrLong: dist code: shortCode on: strm	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [strm nextPut: shortCode + dist - 1]		ifFalse: [self emitLong: dist code: shortCode + (JmpLong-Jmp) on: strm]! !!ParseNode methodsFor: 'code generation'!sizeBranchOn: condition dist: dist	dist = 0 ifTrue: [^1].	^ condition		ifTrue: [2]  "Branch on true is always 2 bytes"		ifFalse: [self sizeShortOrLong: dist]! !!ParseNode methodsFor: 'code generation'!sizeForEffect: encoder	^(self sizeForValue: encoder) + 1! !!ParseNode methodsFor: 'code generation'!sizeForReturn: encoder	^(self sizeForValue: encoder) + 1! !!ParseNode methodsFor: 'code generation'!sizeJump: dist	dist = 0 ifTrue: [^0].	^self sizeShortOrLong: dist! !!ParseNode methodsFor: 'code generation'!sizeShortOrLong: dist	(1 <= dist and: [dist <= JmpLimit])		ifTrue: [^1].	^2! !!ParseNode methodsFor: 'encoding'!encodeSelector: selector	^nil! !!ParseNode methodsFor: 'comment'!comment	^comment! !!ParseNode methodsFor: 'comment'!comment: newComment	comment _ newComment! !!ParseNode methodsFor: 'converting'!asReturnNode	^ReturnNode new expr: self! !!ParseNode methodsFor: 'printing'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^self].	"Show comments in green"	aStream withAttribute: (TextColor color: Color blue) do: 	[1 to: comment size do: 		[:index | 		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment _ comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: '{'.	self printOn: aStream indent: 0.	aStream nextPutAll: '}'! !!ParseNode methodsFor: 'printing'!printOn: aStream indent: anInteger 	"If control gets here, avoid recursion loop."	super printOn: aStream! !!ParseNode methodsFor: 'printing'!printOn: aStream indent: level precedence: p	self printOn: aStream indent: level! !!ParseNode methodsFor: 'private'!nextWordFrom: aStream setCharacter: aBlock	| outStream char |	outStream _ WriteStream on: (String new: 16).	[aStream atEnd		or: 			[char _ aStream next.			char = Character cr or: [char = Character space]]]		whileFalse: [outStream nextPut: char].	aBlock value: char.	^outStream contents! !!ParseNode methodsFor: 'private'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.   	Break the string at word breaks, given the widths in the default font, at 	450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lastChar | lastChar].			wordWidth _ 0.			word do: [:char | wordWidth _ wordWidth + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					aStream nextPutAll: word; space]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParseNode class	instanceVariableNames: ''!!ParseNode class methodsFor: 'class initialization'!initialize	"ParseNode initialize. VariableNode initialize"	LdInstType _ 1.	LdTempType _ 2.	LdLitType _ 3.	LdLitIndType _ 4.	SendType _ 5.	CodeBases _ #(0 16 32 64 208 ).	CodeLimits _ #(16 16 32 32 16 ).	LdSelf _ 112.	LdTrue _ 113.	LdFalse _ 114.	LdNil _ 115.	LdMinus1 _ 116.	LoadLong _ 128.	Store _ 129.	StorePop _ 130.	ShortStoP _ 96.	SendLong _ 131.	DblExtDoAll _ 132.	SendLong2 _ 134.	LdSuper _ 133.	Pop _ 135.	Dup _ 136.	LdThisContext _ 137.	EndMethod _ 124.	EndRemote _ 125.	Jmp _ 144.	Bfp _ 152.	JmpLimit _ 8.	JmpLong _ 164.  "code for jmp 0"	BtpLong _ 168.	SendPlus _ 176.	Send _ 208.	SendLimit _ 16! !Object subclass: #ParseStack	instanceVariableNames: 'position length '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!ParseStack commentStamp: 'di 5/22/1998 16:36' prior: 0!ParseStack comment:'I keep track of the current and high position of the stack that will be needed by code being compiled.'!!ParseStack methodsFor: 'initialize-release'!init	length _ position _ 0! !!ParseStack methodsFor: 'accessing'!pop: n	(position _ position - n) < 0 		ifTrue: [self error: 'Parse stack underflow']! !!ParseStack methodsFor: 'accessing'!push: n	(position _ position + n) > length 		ifTrue: [length _ position]! !!ParseStack methodsFor: 'accessing'!size	^length! !!ParseStack methodsFor: 'results'!position	^position! !!ParseStack methodsFor: 'printing'!printOn: aStream		super printOn: aStream.	aStream nextPutAll: ' at '; print: position; nextPutAll: ' of '; print: length! !Scanner subclass: #Parser	instanceVariableNames: 'here hereType hereMark prevToken prevMark encoder requestor parseNode failBlock requestorOffset tempsMark '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!Parser commentStamp: 'di 5/22/1998 16:36' prior: 0!Parser comment:'I parse Smalltalk syntax and create a MethodNode that is the root of the parse tree. I look one token ahead.'!!Parser methodsFor: 'public access'!encoder	^ encoder! !!Parser methodsFor: 'public access'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth |	self init: sourceStream notifying: req failBlock: [^aBlock value].	encoder _ Encoder new init: class context: ctxt notifying: self.	failBlock_ aBlock.	meth _ self method: noPattern context: ctxt.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^meth! !!Parser methodsFor: 'public access'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	aString == nil ifTrue: [^#()].	^self		initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!Parser methodsFor: 'public access'!parseMethodComment: aString setPattern: aBlock	"Answer the method comment for the argument, aString. Evaluate aBlock 	with the message pattern in the form #(selector, arguments, precedence)."	self		initPattern: aString		notifying: nil		return: aBlock.	currentComment==nil		ifTrue:	[^OrderedCollection new]		ifFalse:	[^currentComment]! !!Parser methodsFor: 'public access'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should 	parse successfully up to the temporary declaration or the end of the 	method header."	^self		initPattern: aString		notifying: nil		return: [:pattern | pattern at: 1]! !!Parser methodsFor: 'expression types'!argumentName	hereType == #word		ifFalse: [^self expected: 'Argument name'].	^self advance! !!Parser methodsFor: 'expression types'!assignment: varNode	" var '_' expression => AssignmentNode."	| loc |	(loc _ varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode _ AssignmentNode new				variable: varNode				value: parseNode				from: encoder.	^true! !!Parser methodsFor: 'expression types'!blockExpression	" [ {:var} ( | statements) ] => BlockNode."	| argNodes |	argNodes _ OrderedCollection new.	[self match: #colon	"gather any arguments"]		whileTrue: 			[argNodes addLast: (encoder autoBind: self argumentName)].	(argNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not])		ifTrue: [^self expected: 'Vertical bar'].	self statements: argNodes innerBlock: true.	(self match: #rightBracket)		ifFalse: [^self expected: 'Period or right bracket'].	argNodes do: [:arg | arg scope: -1] "Scope no longer active"! !!Parser methodsFor: 'expression types'!braceExpression	" { elements } => BraceNode."	| elements locations loc more |	elements _ OrderedCollection new.	locations _ OrderedCollection new.	self advance.	more _ hereType ~~ #rightBrace.	[more]		whileTrue: 			[loc _ hereMark + requestorOffset.			self expression				ifTrue: 					[elements addLast: parseNode.					locations addLast: loc]				ifFalse:					[^self expected: 'Variable or expression'].			more _ self match: #period].	parseNode _ BraceNode new elements: elements sourceLocations: locations.	(self match: #rightBrace)		ifFalse: [^self expected: 'Period or right brace'].	^true! !!Parser methodsFor: 'expression types'!cascade	" {; message} => CascadeNode."	| rcvr msgs |	parseNode canCascade		ifFalse: [^self expected: 'Cascading not'].	rcvr _ parseNode cascadeReceiver.	msgs _ OrderedCollection with: parseNode.	[self match: #semicolon]		whileTrue: 			[parseNode _ rcvr.			(self messagePart: 3 repeat: false)				ifFalse: [^self expected: 'Cascade'].			parseNode canCascade				ifFalse: [^self expected: '<- No special messages'].			parseNode cascadeReceiver.			msgs addLast: parseNode].	parseNode _ CascadeNode new receiver: rcvr messages: msgs! !!Parser methodsFor: 'expression types'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression.				hereType == #leftArrow					ifTrue:						[^self assignment: parseNode]]		ifFalse: [self primaryExpression					ifFalse: [^false]].	(self messagePart: 3 repeat: true)		ifTrue:			[hereType == #semicolon ifTrue: [self cascade]].	^true! !!Parser methodsFor: 'expression types'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver _ parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start _ self startOfNextToken.			selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			words _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart _ self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector _ sym])				ifFalse: [ selector _ self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence _ 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start _ self startOfNextToken.					selector _ self advance asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args _ Array with: parseNode.					precedence _ 2]				ifFalse: [hereType == #word						ifTrue: 							[start _ self startOfNextToken.							selector _ self advance.							args _ #().							words _ OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector _ sym])								ifFalse: [ selector _ self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence _ 1]						ifFalse: [^args notNil]]].	parseNode _ MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!Parser methodsFor: 'expression types'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap _ self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	(sap at: 2) do: [:argNode | argNode isArg: true].	temps _ self temporaries.	messageComment _ currentComment.	currentComment _ nil.	prim _ doit ifTrue: [0] ifFalse: [self primitive].	self statements: #() innerBlock: doit.	blk _ parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode _ MethodNode new comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim! !!Parser methodsFor: 'expression types'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} => 	{selector, arguments, precedence}."	| args selector |	fromDoit 		ifTrue: 			[ctxt == nil				ifTrue: [^Array with: #DoIt with: #() with: 1]				ifFalse: [^Array 							with: #DoItIn: 							with: (Array 									with: (encoder encodeVariable: 'homeContext')) 									with: 3]].	hereType == #word 		ifTrue: [^Array with: self advance asSymbol with: #() with: 1].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^Array with: selector with: args with: 2].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^Array with: selector contents asSymbol with: args with: 3].	^self expected: 'Message pattern'! !!Parser methodsFor: 'expression types'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode _ self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode _ encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode _ encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'expression types'!statements: argNodes innerBlock: inner	| stmts returns start more blockComment |	stmts _ OrderedCollection new.	"give initial comment to block, since others trail statements"	blockComment _ currentComment.	currentComment _ nil.	returns _ false.	more _ hereType ~~ #rightBracket.	[more]		whileTrue: 		[start _ self startOfNextToken.		(returns _ self match: #upArrow)			ifTrue: 				[self expression					ifFalse: [^self expected: 'Expression to return'].				self addComment.				stmts addLast: (parseNode isReturningIf					ifTrue: [parseNode]					ifFalse: [ReturnNode new							expr: parseNode							encoder: encoder							sourceRange: (start to: self endOfLastToken)])]			ifFalse: 				[self expression					ifTrue: 						[self addComment.						stmts addLast: parseNode]					ifFalse: 						[self addComment.						stmts size = 0							ifTrue: 								[stmts addLast: 									(encoder encodeVariable:										(inner ifTrue: ['nil'] ifFalse: ['self']))]]].		returns 			ifTrue: 				[self match: #period.				(hereType == #rightBracket or: [hereType == #doIt])					ifFalse: [^self expected: 'End of block']].		more _ returns not and: [self match: #period]].	parseNode _ BlockNode new				arguments: argNodes				statements: stmts				returns: returns				from: encoder.	parseNode comment: blockComment.	^ true! !!Parser methodsFor: 'expression types'!temporaries	" [ '|' (variable)* '|' ] "	| vars |	(self match: #verticalBar) ifFalse:	"no temps"		[tempsMark _ hereMark.		^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue:		[tempsMark _ prevMark.		^ vars].	^self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types'!variable	| varName varStart varEnd |	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	^encoder encodeVariable: varName ifUnknown:		[self correctVariable: varName interval: (varStart to: varEnd)]! !!Parser methodsFor: 'scanning'!advance	| this |	prevMark _ hereMark.	prevToken _ "Now means prev size"		hereType == #number			ifTrue: [mark - prevMark]			ifFalse: [here size].	this _ here.	here _ token.	hereType _ tokenType.	hereMark _ mark.	self scanToken.	^this! !!Parser methodsFor: 'scanning'!endOfLastToken	"hereType == #doIt ifTrue: [^prevMark + prevToken + 1]."	"tokenType == #doIt ifTrue: [^prevMark + prevToken]."	^prevMark + prevToken - 1! !!Parser methodsFor: 'scanning'!match: type 	"Answer with true if next tokens type matches."	hereType == type		ifTrue: 			[self advance.			^true].	^false! !!Parser methodsFor: 'scanning'!matchToken: thing 	"Matches the token, not its type."	here = thing ifTrue: [self advance. ^true].	^false! !!Parser methodsFor: 'scanning'!startOfNextToken	"Return starting position in source of next token."	hereType == #doIt ifTrue: [^source position + 1].	^hereMark! !!Parser methodsFor: 'temps'!bindArg: name	^ self bindTemp: name! !!Parser methodsFor: 'temps'!bindTemp: name	^name! !!Parser methodsFor: 'error handling'!expected: aString 	"Notify a problem at token 'here'."	tokenType == #doIt ifTrue: [hereMark _ hereMark + 1].	hereType == #doIt ifTrue: [hereMark _ hereMark + 1].	^self notify: aString , ' expected' at: hereMark + requestorOffset! !!Parser methodsFor: 'error handling'!fail	| exitBlock |	encoder == nil		ifFalse: [encoder release. encoder _ nil]. "break cycle"	exitBlock _ failBlock.	failBlock _ nil.	^exitBlock value! !!Parser methodsFor: 'error handling'!interactive	^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!Parser methodsFor: 'error handling'!notify: aString 	"Notify problem at token before 'here'."	^self notify: aString at: prevMark + requestorOffset! !!Parser methodsFor: 'error handling'!notify: string at: location	requestor isNil		ifTrue: [SyntaxError 					errorInClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser methodsFor: 'error handling'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^self notify: aString at: 1]		ifFalse: [^self notify: aString at: mark + requestorOffset]! !!Parser methodsFor: 'error correction'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	^ self correctSelector: proposedKeyword			wordIntervals: spots			exprInterval: expInt			ifAbort: abortAction			fullSearch: false! !!Parser methodsFor: 'error correction'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^ correctSelector.! !!Parser methodsFor: 'error correction'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection temp binding globalToo |	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [ ^ encoder undeclared: proposedVariable ].	temp _ proposedVariable first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: proposedVariable) notNil])		ifTrue: [^encoder global: binding name: proposedVariable].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleVariablesFor: proposedVariable.	aStream _ WriteStream on: (String new: 200).	globalToo _ 0.	aStream nextPutAll: 'declare ' ,		(temp ifTrue: ['temp']			ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: ['Global']					ifFalse: [globalToo _ 1.  'Class Variable']]); cr.	globalToo = 1 ifTrue: [aStream nextPutAll: 'Global'; cr].	alternatives do:		[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: 1 with: alternatives size+1) )		startUpWithCaption:(('Unknown variable: ' , proposedVariable , 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19+proposedVariable size).	(choice = 0) | (choice > (alternatives size+1))		ifTrue: [ ^ self fail ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice =1 ifTrue:			[temp ifTrue: [^ self declareTempAndPaste: proposedVariable]				ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: [^ self declareGlobal: proposedVariable]					ifFalse: [^ self declareClassVar: proposedVariable]]].	(choice = 2) & (globalToo = 1) ifTrue: [^ self declareGlobal: proposedVariable].	"Spelling correction"	self substituteWord: (alternatives at: choice-1-globalToo)			wordInterval: spot			offset: 0.	^ encoder encodeVariable: (alternatives at: choice-1-globalToo)! !!Parser methodsFor: 'error correction'!declareClassVar: name	| sym class |	sym _ name asSymbol.	class _ encoder classEncoding.	class _ class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction'!declareGlobal: name	| sym |	sym _ name asSymbol.	Smalltalk at: sym put: nil.	^ encoder global: (Smalltalk associationAt: sym) name: sym! !!Parser methodsFor: 'error correction'!declareTempAndPaste: name	| insertion tabbed |	(requestor text string at: tempsMark) = $|				ifTrue:  "Paste it before the second vertical bar"					[tempsMark _ tempsMark +						(self substituteWord: name , ' '							wordInterval: (tempsMark to: tempsMark-1)							offset: 0)]				ifFalse:  "No bars - insert some with CR, tab"					[insertion _ '| ' , name , ' |'.					tabbed _ tempsMark > 1						and: [(requestor text string at: tempsMark-1) = Character tab].					tabbed						ifTrue: [insertion _ insertion , (String with: Character tab)].					tempsMark _ tempsMark +						(self substituteWord: insertion							wordInterval: (tempsMark to: tempsMark-1)							offset: 0)						- (tabbed ifTrue: [3] ifFalse: [2])].			^ encoder reallyBind: name! !!Parser methodsFor: 'error correction'!queryUndefined	| varStart varName | 	varName _ parseNode key.	varStart _ self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!Parser methodsFor: 'error correction' stamp: 'di 2/11/98 20:59'!removeUnusedTemps 	| str end start | 	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[PopUpMenu notify:'You''ll first have to remove thestatement where it''s stored into']]]! !!Parser methodsFor: 'error correction'!substituteSelector: selectorParts wordIntervals: spots	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset |	offset _ 0.	selectorParts with: spots do:		[ :word :interval |		offset _ self substituteWord: word wordInterval: interval offset: offset ]! !!Parser methodsFor: 'error correction'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor correctFrom: (spot first + o)					to: (spot last + o)					with: correctWord.	requestorOffset _ requestorOffset + correctWord size - spot size.	^ o + correctWord size - spot size! !!Parser methodsFor: 'private'!addComment	parseNode ~~ nil		ifTrue: 			[parseNode comment: currentComment.			currentComment _ nil]! !!Parser methodsFor: 'private'!init: sourceStream notifying: req failBlock: aBlock	requestor _ req.	failBlock _ aBlock.	super scan: sourceStream.	prevMark _ hereMark _ mark.	requestorOffset _ 0.	self advance! !!Parser methodsFor: 'private'!initPattern: aString notifying: req return: aBlock	| result |	self		init: (ReadStream on: aString asString)		notifying: req		failBlock: [^nil].	encoder _ self.	result _ aBlock value: (self pattern: false inContext: nil).	encoder _ failBlock _ nil.  "break cycles"	^result! !!Parser methodsFor: 'primitives'!allocateLiteral: lit	encoder litIndex: lit! !!Parser methodsFor: 'primitives'!primitive	| n |	(self matchToken: #<) ifFalse: [^ 0].	n _ self primitiveDeclarations.	(self matchToken: #>) ifFalse: [^ self expected: '>'].	^ n! !!Parser methodsFor: 'primitives'!primitiveDeclarations	| prim |	(self matchToken: 'primitive:') ifTrue:		[prim _ here.		(self match: #number) ifFalse: [^self expected: 'Integer']].	^ prim! !AlignmentMorph subclass: #PartsBinMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 8/12/97 14:16'!isPartsBin	^ true! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 5/6/1998 18:13'!repelsMorph: aMorph event: ev	^ (aMorph isKindOf: PhraseTileMorph) or: [aMorph hasProperty: #newAnonymousScript]! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'sw 10/18/97 18:19'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy removeProperty: #partsDonor]].		root _ root owner].	^ super rootForGrabOf: aMorph! !AlignmentMorph subclass: #PartsViewer	instanceVariableNames: 'scriptedPlayer partsBank scriptsBank '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!PartsViewer commentStamp: 'di 5/22/1998 16:36' prior: 0!The so-called Viewer -- a kind of browser and inspector for a singleton object.scriptedPlayer - the player whom I am viewingpartsBank - a number representing which of several possible banks of parts is showingscriptsBank - a number representing which of several possible banks of scripts is showing.!!PartsViewer methodsFor: 'initialization' stamp: 'sw 5/7/1998 09:08'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/22/1998 16:00'!addTilesForPlayerParts	(scriptedPlayer slotNamesAndTypesForViewerBank: partsBank) do:		[:quint | self addMorphBack:  (self 			aRowForPart: 	quint first 			type:			quint second			readOnly:		(quint third == #readOnly)			getSelector:		quint fourth			putSelector:		quint fifth)]! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 5/2/1998 15:02'!initialize	super initialize.	color _ ScriptingSystem colorBehindTiles.	borderWidth _ 1.	orientation _ #vertical.	hResizing _ #spaceFill.	vResizing _ #shrinkWrap.	inset _ 1.	partsBank _ 1.	scriptsBank _ 1! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/15/1998 16:32'!invisiblySetPlayer: aPlayer	scriptedPlayer _ aPlayer! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/27/1998 16:48'!noteDeletionOf: aMorph	| pal |	aMorph == self morph ifTrue:		[(pal _ self standardPalette)			ifNotNil: [pal showNoPalette]			ifNil:	[self delete]]   "Viewer on a discarded player"! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/26/1998 02:07'!readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	| readout | 	(partType == #player) ifTrue:		[readout _ PlayerReferenceReadout new objectToView: scriptedPlayer viewSelector: getSelector putSelector: putSelector].	(partType == #color) ifTrue:		[readout _ UpdatingRectangleMorph new		target: self morph;		getSelector: (Utilities getterSelectorFor: partName);		borderWidth: 1;		extent:  30@25.		putSelector == #unused ifFalse: [readout putSelector: (Utilities setterSelectorFor: partName)]].	readout ifNil: [readout _ self morph updatingTileForArgType: partType partName: partName getSelector: getSelector putSelector: putSelector].	readout step.	^ readout! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/27/1998 00:19'!repelsMorph: aMorph event: ev	^ aMorph isKindOf: PhraseTileMorph! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 4/15/1998 16:33'!setPlayer: aPlayer	| topRight |	topRight _ bounds topRight.	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self  addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self extent: 174@342.  "try to match size of BookMorphs"	self position: (topRight x - self fullBounds width) @ topRight y.	self beRepelling! !!PartsViewer methodsFor: 'banks' stamp: 'sw 5/6/1998 16:42'!maxPartsBankNumber	^ scriptedPlayer maxPartsBankNumber! !!PartsViewer methodsFor: 'banks' stamp: 'sw 5/6/1998 16:43'!maxScriptsBankNumber	^ scriptedPlayer maxScriptsBankNumber! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 16:22'!nextPartsBank	partsBank _ self partsBank + 1.	partsBank > self maxPartsBankNumber ifTrue: [partsBank _ 1].	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 16:37'!nextScriptsBank	scriptsBank _ self scriptsBank + 1.	scriptsBank > self maxScriptsBankNumber ifTrue: [scriptsBank _ 1].	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 16:20'!obtainBankInfoFrom: aPartsViewer	partsBank _ aPartsViewer partsBank.	scriptsBank _ aPartsViewer scriptsBank! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 15:39'!partsBank	^ partsBank! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 16:03'!previousPartsBank	partsBank _ self partsBank - 1.	partsBank < 1 ifTrue: [partsBank _ self maxPartsBankNumber].	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 16:37'!previousScriptsBank	scriptsBank _ self scriptsBank - 1.	scriptsBank < 1 ifTrue: [scriptsBank _ self maxScriptsBankNumber].	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'banks' stamp: 'sw 4/22/1998 15:39'!scriptsBank	^ scriptsBank! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 10/31/97 13:55'!getterButtonFor: partName type: partType	| m |	m _ TileMorph new setOperator: partName.	m typeColor: (TilePadMorph colorForType: partType).	m on: #mouseDown send: #makeGetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 4/22/1998 16:42'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType |	(aType _ args last) == #unknown ifTrue: [^ self beep].	args first == #colorSees 		ifFalse: [m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol			type: aType]		ifTrue: [m _ self colorSeesPhrase].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	self presenter coloredTilesEnabled ifFalse:		[m makeAllTilesGreen].	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 4/20/1998 17:35'!makeSetter: evt from: aMorph forPart: args	| argType m argTile selfTile |	argType _ args last.	m _ PhraseTileMorph new setAssignmentRoot: args first asSymbol		type: #command		rcvrType: #player		argType: argType.	argTile _ self tileForArgType: argType.	argTile position: m lastSubmorph position.	m lastSubmorph addMorph: argTile.	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	self presenter coloredTilesEnabled ifFalse:		[m makeAllTilesGreen].	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'misc' stamp: 'sw 1/29/98 21:38'!morph	^ scriptedPlayer costume! !!PartsViewer methodsFor: 'misc' stamp: 'sw 2/3/98 23:50'!scriptedPlayer	^ scriptedPlayer! !!PartsViewer methodsFor: 'misc' stamp: 'sw 4/28/1998 00:25'!tileForPlayer: aPlayer	"Return a tile representing aPlayer"	^ TileMorph new		setObjectRef: nil "disused parm" actualObject: aPlayer;		typeColor: (TilePadMorph colorForType: #player)! !!PartsViewer methodsFor: 'misc' stamp: 'sw 4/8/98 13:30'!wantsHaloFor: aSubmoph	^ false! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/2/1998 15:02'!arrowSetterButtonFor: partName type: partType	| m |	m _ RectangleMorph new		color: (TilePadMorph colorForType: #command);		extent: 24@TileMorph defaultH;		borderWidth: 1.	m addMorphCentered: (ImageMorph new image: (ScriptingSystem formAtKey: 'Gets')).	m on: #mouseDown send: #makeSetter:from:forPart:		to: self		withValue: (Array with: partName with: partType).	^ m! !!PartsViewer methodsFor: 'private' stamp: 'sw 2/25/98 00:43'!caretColor	^ Color green muchLighter! !!PartsViewer methodsFor: 'private' stamp: 'sw 2/12/98 10:12'!colorSeesPhrase	| outerPhrase |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	outerPhrase addMorphBack: ColorSeerTile new.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(TilePadMorph colorForType: #color)).	^ outerPhrase! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/2/1998 15:02'!commandTiles	"Return a list of tiles for my scriptedPlayer's commands."	| resultType cmd m argType argTile selfTile aRow names bank  |	names _ scriptedPlayer class namedTileScriptSelectors.	bank _ self scriptsBank.	^ (scriptedPlayer typedCommandsForBank: bank) collect: [:entry |		aRow _ PartsBinMorph newRow borderWidth: 0;			color: self color.		resultType _ (entry at: 1).		cmd _ (entry at: 2).		entry size = 2			ifTrue:				[m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player.				(names includes: cmd) ifTrue: [m userScriptSelector: cmd]]			ifFalse: 				[argType _ entry at: 3.				m _ PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #player					argType: argType.				argTile _ self tileForArgType: argType.				argTile position: m lastSubmorph position.				m lastSubmorph addMorph: argTile.				m markAsPartsDonor].		selfTile _ self tileForSelf.		selfTile position: m firstSubmorph position.		m firstSubmorph addMorph: selfTile.			aRow addMorph: (ScriptingSystem tryButtonFor: m).		aRow addMorphBack: (Morph new extent: 4@2; color: self color).		aRow addMorphBack: m.		aRow beSticky; openToDragNDrop: false.		aRow]	"	m addMorphFront: (Morph new color: self color; extent: 2@10). "! !!PartsViewer methodsFor: 'private' stamp: 'sw 1/29/98 21:25'!commandTilesPartsBin	| bin |	bin _ PartsBinMorph new		color: self color;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: self commandTiles.	^ bin! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/21/1998 14:09'!infoButtonFor: aSlotName	| aButton isUserSlot |	isUserSlot _ scriptedPlayer slotInfo includesKey: aSlotName asSymbol.	aButton _ SimpleButtonMorph new.	aButton target: scriptedPlayer;		actionSelector: #infoFor:;		arguments: (Array with: aSlotName);		label: '?' font: (StrikeFont familyName: #ComicBold size: 16);		color: Color transparent;		borderWidth: 0;		actWhen: #buttonDown.	aButton balloonTextSelector: (isUserSlot		ifFalse:	[aSlotName]		ifTrue:	[#userSlot]).	^ aButton! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/6/1998 16:31'!newEmptyScript	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/21/1998 15:19'!nextCostume	"The receiver's player is currently being viewed via a particular costume.  Now switch to a plausible different costume."	| ind acn c |	ind _ (acn _ scriptedPlayer availableCostumeNamesForArrows) indexOf: scriptedPlayer costume renderedMorph class name.	ind _ ind + 1.	ind > acn size ifTrue: [ind _ 1].	scriptedPlayer costume:		(c _ scriptedPlayer costumeNamed: (acn at: ind)) fullCopy.	c isInWorld ifTrue: [self presenter updatePartsViewer: self]! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/21/1998 15:19'!previousCostume	"The receiver's player is currently being viewed via a particular costume.  Now switch to a plausible different costume."	| ind acn c |	ind _ (acn _ scriptedPlayer availableCostumeNamesForArrows) indexOf: scriptedPlayer costume renderedMorph class name.	ind _ ind - 1.	ind < 1 ifTrue: [ind _ acn size].	scriptedPlayer costume:		(c _ scriptedPlayer costumeNamed: (acn at: ind)) fullCopy.	c isInWorld ifTrue: [self presenter updatePartsViewer: self]! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/22/1998 13:58'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #newCostume to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to specify new costume.'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 5/22/1998 13:33'!rowBeforeScripts	| r aButton aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'add script' font: (aFont _ StrikeFont familyName: #ComicBold size: 16); color: self caretColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'add inst var' font: aFont; color: self caretColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	r addMorphBack: aButton.	^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 4/17/1998 23:33'!tileForArgType: typeSymbol	| aColor |	aColor _ TilePadMorph colorForType: typeSymbol.	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	#(number string) with:	#(5  'chars')  do:		[:sym :lit | typeSymbol == sym ifTrue: [^ lit newTileMorphRepresentative typeColor: aColor]].	typeSymbol == #boolean ifTrue:		[^ true newTileMorphRepresentative].	typeSymbol == #sound ifTrue:		[^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue:		[^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue:		[^ Color blue newTileMorphRepresentative].	typeSymbol == #boolean ifTrue:		[^ true newTileMorphRepresentative typeColor: aColor].	self halt: 'Unrecognized type'! !!PartsViewer methodsFor: 'private' stamp: 'sw 2/7/98 21:48'!tileForSelf	"Return a tile representing the target morph itself."	^ self tileForPlayer: scriptedPlayer! !!PartsViewer methodsFor: 'type coercion' stamp: 'sw 3/24/98 17:58'!booleanPhraseForRetrieverOfType: retrieverType retrieverOp: retrieverOp player: aPlayer	| outerPhrase getterPhrase receiverTile  rel finalTile |	rel _ (retrieverType == #number)		ifTrue:		[#<]		ifFalse:		[#=].	outerPhrase _ PhraseTileMorph new setOperator: rel type: #boolean rcvrType: retrieverType argType: retrieverType.	getterPhrase _  PhraseTileMorph new setOperator: retrieverOp type: retrieverType rcvrType: #player.	getterPhrase submorphs last setSlotRefOperator: (Utilities inherentSelectorForGetter: retrieverOp).	receiverTile _ (self tileForPlayer: aPlayer) bePossessive.	receiverTile position: getterPhrase firstSubmorph position.	getterPhrase firstSubmorph addMorph: receiverTile.	outerPhrase firstSubmorph addMorph: getterPhrase.	finalTile _ self tileForArgType: retrieverType.	retrieverType == #number ifTrue: [finalTile addArrows].	outerPhrase submorphs last addMorph: finalTile.	^ outerPhrase! !!PartsViewer methodsFor: 'type coercion' stamp: 'sw 3/23/98 08:53'!booleanPhraseFromPhrase: phrase	|  retrieverOp retrieverTile |	phrase isBoolean ifTrue: [^ phrase].	self morph isInWorld ifFalse: [^ Array new].	((retrieverTile _ phrase submorphs last) isKindOf: TileMorph) ifFalse: [^ phrase].	retrieverOp _ retrieverTile operatorOrExpression.	(#(color number player) includes: phrase resultType) ifTrue:		[^ self booleanPhraseForRetrieverOfType: phrase resultType retrieverOp: retrieverOp player: phrase actualObject].	^ phrase! !Object subclass: #Password	instanceVariableNames: 'cache sequence '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!Password methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 21:08'!decode: string	"Xor with secret number -- just so file won't have raw password in it"	| kk rand |	rand _ Random new seed: 234237.	kk _ (ByteArray new: string size) collect: [:bb | (rand next * 255) asInteger].	1 to: kk size do: [:ii |		kk at: ii put: ((kk at: ii) bitXor: (string at: ii) asciiValue)].	^ kk asString! !!Password methodsFor: 'as yet unclassified' stamp: 'jm 5/6/1998 19:46'!serverPasswords	"Get the server passwords off the disk.  Decode them.  File 'sqk.info' must be in the same folder with the version of the Squeak application (VM) that is running this image now."	| raw dir |	dir _ (SourceFiles at: 1) directory.	(dir fileExists: 'sqk.info') ifFalse: [^ nil].	"Caller will ask user for password"	raw _ (dir oldFileNamed: 'sqk.info') contentsOfEntireFile.		"If you don't have this file, and you really do want to release 		an update, contact Ted Kaehler."	^ (self decode: raw) findTokens: String cr.! !!Password methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!cache: anObject	cache _ anObject! !!Password methodsFor: 'accessing' stamp: 'tk 1/7/98 10:28'!passwordFor: serverDir	"Returned the password from one of many sources.  OK if send in a nil arg."	| sp msg |	cache ifNotNil: [^ cache].	sequence ifNotNil: [		(sp _ self serverPasswords) ifNotNil: [			sequence <= sp size ifTrue: [^ sp at: sequence]]].	msg _ (serverDir isKindOf: ServerDirectory)		ifTrue: [serverDir moniker]		ifFalse: ['this directory'].	^ cache _ FillInTheBlank request: 'Password for ', msg, ':'.		"Diff between empty string and abort?"! !!Password methodsFor: 'accessing' stamp: 'tk 1/5/98 21:14'!sequence: anNumber	sequence _ anNumber! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Password class	instanceVariableNames: ''!!Password class methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 21:26'!shutDown	"Forget all cached passwords, so they won't stay in the image"	self withAllSubclasses do: [:cls |		cls allInstancesDo: [:each | each cache: nil]].! !GradientFillMorph subclass: #PasteUpMorph	instanceVariableNames: 'presenter model cursor padding backgroundMorph turtleTrailsForm turtlePen lastTurtlePositions openToDragNDrop isPartsBin autoLineLayout indicateCursor resizeToFit fileName isStackLike dataInstances currentDataInstance userFrameRectangle '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!PasteUpMorph commentStamp: 'di 5/22/1998 16:36' prior: 0!A morph whose submorphs comprise a paste-up of rectangular subparts which "show through".Facilities commonly needed on pages of graphical presentations and on simulation playfields, such as the painting of new objects, turtle trails, gradient fills, background paintings, parts-bin behavior, collision-detection, etc., are (or will be) provided.This class is young and still under construction, and a number of its (many) instance variables are not yet fully deployed.!!PasteUpMorph methodsFor: 'initialization' stamp: 'sw 5/3/1998 12:27'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	gradientDirection _ #vertical.	color _ Color r: 0.8 g: 1.0 b: 0.6.	fillColor2 _ color.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	openToDragNDrop _ true.	lastTurtlePositions _ IdentityDictionary new.	self isWorldMorph ifFalse: [self setProperty: #suppressPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 4/21/1998 16:05'!cursor	^ cursor! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 12:54'!cursor: aNumber	"Set the cursor to the given number, modulo the number of items I contain. Fractional cursor values are allowed."	| truncP |	cursor ~= aNumber ifTrue: 		[cursor _ self asNumber: aNumber.		truncP _ cursor truncated.		truncP > submorphs size ifTrue:			[submorphs size > 0				ifTrue: [cursor _ cursor \\ submorphs size]				ifFalse: [cursor _ 1]].		truncP < 0 ifTrue: [cursor _ 1].		self changed]! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 4/21/1998 16:05'!cursorAtEnd	^ cursor truncated >= submorphs size! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 10:55'!rectifyCursor	cursor _ ((cursor truncated max: 1) min: submorphs size)! !!PasteUpMorph methodsFor: 'cursor'!selectedRect	"Return a rectangle enclosing the morph at the current cursor. Note that the cursor may be a float and may be out of range, so pick the nearest morph. Assume there is at least one submorph."	| p |	p _ cursor asInteger.	p > submorphs size ifTrue: [p _ submorphs size].	p < 1 ifTrue: [p _ 1].	^ (submorphs at: p) fullBounds expandBy: 2.! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 4/21/1998 16:06'!valueAtCursor	submorphs isEmpty ifTrue: [^ 0].	^ submorphs at: ((cursor truncated max: 1) min: submorphs size)! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 10:55'!valueAtCursor: aMorph	submorphs isEmpty ifTrue: [^ self].	self rectifyCursor.	self replaceSubmorph: self valueAtCursor by: aMorph! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 4/1/98 16:59'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	(lastTurtlePositions ~~ nil and:	 [lastTurtlePositions size > 0]) ifTrue:		["Note: trails form is created when first pen goes down"		self createOrResizeTrailsForm.		self updateTrailsForm].	turtleTrailsForm ifNotNil:		[aCanvas image: turtleTrailsForm at: self position].	self recordTurtlePositions.	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 12/30/97 16:40'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas  |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self borderWidth. "assure it's set, before it's blithely used by display code.  This is needed somewhere like here for transition from WeekTwo image only, I believe"	clippingCanvas _ aCanvas copyClipRect: bounds.	self drawOn: clippingCanvas.	submorphs isEmpty ifFalse:		[submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/27/1998 00:43'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredCostumee.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ costumee addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		costumee updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/21/1998 16:06'!allowSubmorphExtraction	^ openToDragNDrop == true and: [isPartsBin ~~ true]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/19/1998 15:06'!morphToDropFrom: aMorph	"Presently only in service for features in the tile-scripting system that allow a different object from the one being carried to be dropped"	| itsSelector aScriptor adjustment anEditor actualObject aUserScript |	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/2/1998 11:31'!positionNear: aPoint forExtent: anExtent adjustmentSuggestion: adjustmentPoint	"Compute a plausible positioning for adding a subpart of size anExtent, somewhere near aPoint, using adjustmentPoint as the unit of adjustment"	| adjustedPosition |	adjustedPosition _ aPoint.	[((self morphsAt: (adjustedPosition + (anExtent // 2))) size > 1) and:  "that 1 is self here"		[bounds containsPoint: adjustedPosition]]	whileTrue:		[adjustedPosition _ adjustedPosition + adjustmentPoint].	^ adjustedPosition! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/14/1998 00:08'!repelsMorph: aMorph event: ev	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/4/1998 10:29'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[^ root usableDuplicate].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/22/1998 17:24'!wantsDroppedMorph: aMorph event: evt	^ self openToDragNDrop and: [self isPartsBin not]! !!PasteUpMorph methodsFor: 'layout'!fixLayout	"Pack my submorphs into rows that fit within my width."	| nextY i morphsForThisRow |	nextY _ bounds top + borderWidth.	i _ 1.	[i <= submorphs size] whileTrue: [		morphsForThisRow _ self rowMorphsStartingAt: i.		nextY _ self layoutRow: morphsForThisRow lastRowBase: nextY.		i _ i + morphsForThisRow size].! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 4/16/1998 13:47'!insertionIndexFor: aMorph	"Find the right place to put the given dropped morph."	| p rowBase i morphsForThisRow |	aMorph mustBeBackmost ifTrue: [^ submorphs size + 1].	self autoLineLayout ifFalse: [^ 1].	p _ aMorph center.	rowBase _ bounds top + borderWidth.	i _ 1.	[i <= submorphs size] whileTrue:		[morphsForThisRow _ self rowMorphsStartingAt: i.		rowBase _ self rowBaseFor: morphsForThisRow lastRowBase: rowBase.		rowBase > p y ifTrue: [  "found row"			morphsForThisRow do: [:m |				m center x > p x ifTrue: [^ i].  "found index in row"				i _ i + 1].			^ i].		i _ i + morphsForThisRow size].	^ submorphs size + 1  "insert at end"! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 4/23/1998 18:31'!laySubpartsOutInOneRow	| aPosition |	aPosition _ padding @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition _ aMorph topRight]! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 5/2/1998 01:22'!layoutRow: mList lastRowBase: lastRowBase	| rowBase nextX |	rowBase _ self rowBaseFor: mList lastRowBase: lastRowBase.	nextX _ bounds left + borderWidth + padding.	mList do: [:m |		m position: nextX @ ((lastRowBase + rowBase - m fullBounds height) // 2).		nextX _ nextX + m fullBounds width + padding].	^ rowBase! !!PasteUpMorph methodsFor: 'layout' stamp: 'jm 11/17/97 15:45'!rowBaseFor: mList lastRowBase: lastRowBase	| maxH |	maxH _ 0.	mList do: [:m | maxH _ maxH max: m fullBounds height].	^ lastRowBase + maxH + padding! !!PasteUpMorph methodsFor: 'layout'!rowMorphsStartingAt: startIndex	"Return a collection of morphs for a row starting at the given index. Put at least one morph into the row, even if it sticks out."	| mList nextX lastIndex m |	mList _ OrderedCollection new.	nextX _ bounds left + borderWidth + padding.	lastIndex _ submorphs size.	startIndex to: lastIndex do: [:i |		m _ submorphs at: i.		nextX _ nextX + m fullBounds width + padding.		nextX > bounds right ifTrue: [			mList isEmpty ifTrue: [mList add: m].			^ mList].		mList add: m].	^ mList! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 5/2/1998 00:33'!addCustomMenuItems: menu hand: aHandMorph	| subMenu |	super addCustomMenuItems: menu hand: aHandMorph.	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack].		subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	self autoLineLayout		ifTrue:			[subMenu add: 'stop auto layout' action: #toggleAutoLineLayout]		ifFalse:			[subMenu add: 'start auto layout' action: #toggleAutoLineLayout].	self resizeToFit		ifTrue:			[subMenu add: 'stop resize-to-fit' action: #toggleResizeToFit]		ifFalse:			[subMenu add: 'start resize-to-fit' action: #toggleResizeToFit].	self indicateCursor		ifTrue:			[subMenu add: 'stop showing cursor' action: #toggleIndicateCursor]		ifFalse:			[subMenu add: 'start showing cursor' action: #toggleIndicateCursor].	self isPartsBin		ifTrue:			[subMenu add: 'stop being a parts bin' action: #toggleIsPartsBin]		ifFalse:			[subMenu add: 'start being a parts bin' action: #toggleIsPartsBin].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	menu add: 'playfield options...' subMenu: subMenu.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 5/3/1998 18:01'!addOptionalHandlesTo: aHalo box: box	| aHandle |	aHandle _ aHalo addHandleAt: box rightCenter color: Color lightGray.	aHandle on: #mouseDown send: #paintBackground to: self."	aHandle _ aHalo addHandleAt: box leftCenter color: Color veryVeryLightGray.	aHandle on: #mouseDown send: #makeNewDrawingWithin to: self."! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 4/14/1998 00:07'!wantsHaloFor: aSubMorph	^ isPartsBin ~~ true and: [openToDragNDrop ~~ false]! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 5/13/1998 00:21'!createCustomModel	"Create a model object for this world if it does not yet have one. A model object is an initially empty subclass of MorphicModel. As the user names parts and adds behavior, instance variables and methods are added to this class."	model == nil ifFalse: [^ self].	model _ MorphicModel newSubclass new.! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 4/1/98 21:18'!model	"Return the model object for this world. If the world has no model, then create one."	self createCustomModel.	^ model! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 4/1/98 21:18'!modelOrNil	"Return the model object for this world, or nil if it doesn't have one."	^ model! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 4/1/98 21:17'!setModel: aModelMorph	"Set the model for this world. Methods for sensitized morphs will be compiled into the class for this model."	model _ aModelMorph! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 16:57'!autoLineLayout	^ autoLineLayout == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 16:57'!autoLineLayout: aBoolean	autoLineLayout _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/21/1998 15:47'!behaveLikeHolder	self resizeToFit: true; autoLineLayout: true; indicateCursor: true;		fixLayout; layoutChanged	! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 16:58'!indicateCursor	^ indicateCursor == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 16:59'!indicateCursor: aBoolean	indicateCursor _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/13/1998 18:15'!isPartsBin	^ isPartsBin == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/23/1998 16:49'!isPartsBin: aBoolean	isPartsBin _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/21/1998 16:06'!openToDragNDrop	^ openToDragNDrop! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/21/1998 16:06'!openToDragNDrop: aBoolean	openToDragNDrop _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'di 5/4/1998 12:42'!resizeToFit	resizeToFit ifNil: [^true].	^ resizeToFit! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 17:42'!resizeToFit: aBoolean	resizeToFit _ aBoolean! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/13/1998 17:29'!toggleAutoLineLayout	autoLineLayout _ self autoLineLayout not.	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/13/1998 18:13'!toggleIndicateCursor	indicateCursor _ self indicateCursor not.	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 5/13/1998 11:51'!toggleIsPartsBin	isPartsBin _ self isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m setProperty: #partsDonor toValue: true.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m removeProperty: #partsDonor.					m restoreSuspendedEventHandler]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/13/1998 18:13'!toggleResizeToFit	resizeToFit _ self resizeToFit not.	self fixLayout.	self layoutChanged! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 4/1/98 16:37'!backgroundSketch	backgroundMorph ifNil: [^ nil].	backgroundMorph owner ifNil:		[backgroundMorph _ nil].	"has been deleted"	^ backgroundMorph! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 4/1/98 16:37'!backgroundSketch: aSketchMorphOrNil	backgroundMorph ifNotNil: [backgroundMorph delete].  "replacing old background"	aSketchMorphOrNil ifNil: [backgroundMorph _ nil.  ^ self].	backgroundMorph _ StickySketchMorph new form: aSketchMorphOrNil form.	backgroundMorph position: aSketchMorphOrNil position.	self addMorphBack: backgroundMorph.	aSketchMorphOrNil delete.	backgroundMorph lock.	^ backgroundMorph! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 5/19/1998 18:50'!makeNewDrawingWithin	self primaryHand makeNewDrawingInBounds: self paintingBounds pasteUpMorph: self! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 4/22/1998 17:31'!paintBackground	| pic rect |	self world abandonAllHalos.	self world stopRunningAll.	pic _ self backgroundSketch.	pic ifNotNil: [pic editDrawingIn: self forBackground: true]		"need to resubmit it? (tck comment)"		ifNil: [rect _ self bounds.			pic _ self world hands first drawingClass new form: 				(Form extent: rect extent depth: Display depth).			pic bounds: rect.			"self world addMorphBack: pic.  done below"			pic _ self backgroundSketch: pic.	"returns a different guy"			pic ifNotNil: [pic editDrawingIn: self forBackground: true]]! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 5/19/1998 18:51'!paintingBounds	^ self paintingBoundsAround: self bounds center! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 5/19/1998 18:51'!paintingBoundsAround: dropPoint	| anExtent possibleBounds |	^ (self bounds area > ScriptingSystem maxPaintArea)		ifTrue:			[anExtent _ ScriptingSystem reasonablePaintingExtent.			possibleBounds _ (dropPoint - (anExtent // 2)) extent: anExtent.			possibleBounds intersect: self bounds]		ifFalse:			[self bounds]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/1/98 16:38'!clearTurtleTrails	turtleTrailsForm _ nil.	turtlePen _ nil.	self changed.! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/1/98 16:38'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds. On return, turtleTrailsForm exists and is the correct size."	| newForm |	turtleTrailsForm ifNil: [		"create new turtleTrailsForm if needed"		turtleTrailsForm _ Form extent: self extent depth: 8.		turtlePen _ nil.		^ self].	turtleTrailsForm extent = self extent ifFalse: [		"resize turtleTrailsForm if my size has changed"		newForm _ Form extent: self extent depth: 8.		newForm			copy: self bounds			from: turtleTrailsForm			to: 0@0			rule: Form paint.		turtleTrailsForm _ newForm.		turtlePen _ nil].! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/1/98 17:26'!liftAllPens	submorphs do: [:m | m assuredCostumee liftPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/1/98 17:26'!lowerAllPens	submorphs do: [:m | m assuredCostumee lowerPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 4/29/1998 11:16'!recordTurtlePositions	"Record the current positions of all turtles (Actors) whose pens are down."	| player |	lastTurtlePositions _ IdentityDictionary new: submorphs size * 4.	submorphs do: [:m |		player _ m costumee.		player ifNotNil: [			player getPenDown ifTrue: [				lastTurtlePositions at: player put: m referencePosition]]].! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 4/29/1998 11:21'!updateTrailsForm	"Update the turtle-trails form using the current positions of all turtles."	"Details: The positions of all turtles with their pens down are recorded each time the draw method is called. If the list from the previous display cycle isn't empty, then trails are drawn from the old to the new positions of those morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin m oldPoint newPoint mPenSize offset |	origin _ self topLeft.	turtlePen ifNil: [turtlePen _ Pen newOnForm: turtleTrailsForm].	lastTurtlePositions associationsDo: [:assoc |		m _ assoc key costume.		oldPoint _ assoc value.		newPoint _ m referencePosition.		((m owner == self) and:		 [m getPenDown and:		 [newPoint ~= oldPoint]]) ifTrue:			[mPenSize _ m getPenSize.			turtlePen sourceForm width ~= mPenSize				ifTrue: [turtlePen squareNib: mPenSize].			offset _ (mPenSize // 2)@(mPenSize // 2).			turtlePen color: m getPenColor.			turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint.			self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)]]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 5/6/1998 16:28'!emptyAnonymousScriptorFrom: aPlaceHoldingMorph	| aScriptor |	aScriptor _  (aPlaceHoldingMorph valueOfProperty: #player) anonymousScriptEditorFor: nil.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 5/3/1998 12:11'!expandPhrasesToScripts	^ (self hasProperty: #suppressPhraseExpansion) not! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 5/19/1998 15:03'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/4/1998 21:44'!becomeStack	currentDataInstance _ self assuredCostumee.	dataInstances _ OrderedCollection with: currentDataInstance.	isStackLike _ true.	self borderWidth: (self borderWidth + 1).	submorphs do:		[:aMorph | aMorph holdsDataForEachInstance			ifTrue:				[aMorph becomeField]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/8/1998 13:39'!doWrap	"Determine whether a 'next' request at the end of my list should wrap around to the beginning, etc."	self flag: #deferred.  "Hang this maybe on a property"	^ true! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/4/1998 01:46'!goToNextCard	| index totalInstances originalIndex |	self isStackLike ifFalse: [^ self].	originalIndex _ (dataInstances indexOf: currentDataInstance).	index _ originalIndex + 1.	((totalInstances _ dataInstances size) >= index) ifFalse: 		[(self doWrap and: [totalInstances > 1]) ifFalse: [^ self beep] ifTrue: [index _ 1]].	self installAsCurrent: (dataInstances at: index)! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/2/1998 22:47'!goToPreviousCard	| index totalInstances originalIndex |	self isStackLike ifFalse: [^ self].	originalIndex _ (dataInstances indexOf: currentDataInstance).	index _ originalIndex - 1.	(index > 0) ifFalse: 		[totalInstances _ dataInstances size.		(self doWrap and: [totalInstances > 1]) ifFalse: [^ self beep] ifTrue: [index _ totalInstances]].	self installAsCurrent: (dataInstances at: index)! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/8/1998 13:40'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	costumee _ anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 4/27/1998 17:56'!isStackLike	^ isStackLike == true! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 4/27/1998 21:54'!morphsForInstanceData	"Answer a list of the receiver's submorphs whose formal data are held in instances of the receiver's costumee.  At present, these are only the DataFieldMorphs; more to follow"	^ self submorphs select: [:m | m holdsDataForEachInstance]! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 5/2/1998 22:12'!newCard	| aNewInstance |	self isStackLike ifFalse: [^ self beep].	aNewInstance _ currentDataInstance class new.	dataInstances add: aNewInstance after: currentDataInstance.	self installAsCurrent: aNewInstance.	self changed! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 4/27/1998 22:01'!scriptPerformer	^ self isStackLike		ifTrue:			[currentDataInstance]		ifFalse:			[super scriptPerformer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/1/98 21:20'!color: aColor	super color: aColor.	fillColor2 _ aColor! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/1/98 17:36'!demandsBoolean	"Sent by some scripting objects to their container"	^ false! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/21/1998 15:50'!fullBounds	"This is the hook that triggers lazy re-layout. See the comment in LayoutMorph."	| result |	(fullBounds == nil and: [self autoLineLayout]) ifTrue:		[self fixLayout.		"compute fullBounds before calling changed to avoid infinite recursion!!"		result _ super fullBounds.  "updates cache"		self changed.		^ result].	self resizeToFit ifFalse: [^ bounds].	^ super fullBounds! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 1/29/98 21:50'!isPlayfieldLike	^ true! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/27/1998 22:24'!newPlayerInstance	^ Player newUserInstance! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/23/1998 18:50'!padding: aNumber	padding _ aNumber! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/1/98 16:40'!prepareToBeSaved	super prepareToBeSaved.	self world ifNotNil:		[self setProperty: #worldSize toValue: self world extent].	turtlePen _ nil.	lastTurtlePositions _ IdentityDictionary new.! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/4/1998 00:18'!presenter	"Normally only the world will have a presenter, but the architecture supports individual localized presenters as well"	^ presenter ifNil: [super presenter] ifNotNil: [presenter]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/16/1998 20:24'!presenter: aPresenter	presenter _ aPresenter! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/22/1998 14:39'!residesInPartsBin	"Answer true if the receiver is, or has some ancestor owner who is, a parts bin"	^ self isPartsBin ifTrue: [true] ifFalse: [super residesInPartsBin]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/21/1998 15:21'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:"		"(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused)")].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/6/1998 17:07'!wantsKeyboardFocusFor: aSubmorph	aSubmorph inPartsBin ifTrue: [^ false].	aSubmorph wouldAcceptKeyboardFocus ifTrue: [ ^ true].	^ super wantsKeyboardFocusFor: aSubmorph! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 5/22/1998 16:02'!convertbosfcep0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	lastTurtlePositions _ IdentityDictionary new.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 5/21/1998 06:39'!convertbosfcepc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	lastTurtlePositions _ IdentityDictionary new.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 5/21/1998 06:45'!convertbosfcepcbbfgcc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from BookPageMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	lastTurtlePositions _ IdentityDictionary new.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PasteUpMorph class	instanceVariableNames: ''!!PasteUpMorph class methodsFor: 'all' stamp: 'sw 4/27/1998 22:32'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter; borderWidth: 2; 		borderColor: Color green; extent: 100@80.	^ proto! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 5/3/1998 14:25'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'playfield'! !DisplayObject subclass: #Path	instanceVariableNames: 'form collectionOfPoints '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!Path commentStamp: 'di 5/22/1998 16:36' prior: 0!Path comment:'I am the abstract superclass of the Graphic spatial primitives. I represent an ordered sequence of Points. Spatial primitives are used to generate "trajectories" such as lines and circles.'!!Path methodsFor: 'accessing'!at: index 	"Answer the point on the receiver's path at position index."	^collectionOfPoints at: index! !!Path methodsFor: 'accessing'!at: index put: aPoint 	"Store the argument, aPoint, as the point on the receiver's path at position	index."	^collectionOfPoints at: index put: aPoint! !!Path methodsFor: 'accessing'!atPin: index 	"Answer the point on the receiver's path at position index."	^collectionOfPoints atPin: index! !!Path methodsFor: 'accessing'!atWrap: index 	"Answer the point on the receiver's path at position index."	^collectionOfPoints atWrap: index! !!Path methodsFor: 'accessing'!first	"Answer the first point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint	"Answer the first point on the receiver's path."	^collectionOfPoints first! !!Path methodsFor: 'accessing'!firstPoint: aPoint 	"Replace the first element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 1 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!form	"Answer the receiver's form, or, if form is nil, then answer a 1 x 1 black 	form (a black dot)."	| aForm |	form == nil		ifTrue: 			[aForm _ Form extent: 1 @ 1.			aForm fillBlack.			^aForm]		ifFalse: 			[^form]! !!Path methodsFor: 'accessing'!form: aForm 	"Make the argument, aForm, be the receiver's form."	form _ aForm! !!Path methodsFor: 'accessing'!last	"Answer the last point on the receiver's path; included to correspond to 	OrderedCollection protocol."	^collectionOfPoints last! !!Path methodsFor: 'accessing'!offset	"There are basically two kinds of display objects in the system: those	that, when asked to transform themselves, create a new object; and those	that side effect themselves by maintaining a record of the transformation	request (typically an offset). Path, like Rectangle and Point, is a display	object of the first kind."	self shouldNotImplement! !!Path methodsFor: 'accessing'!secondPoint	"Answer the second element of the receiver."	^collectionOfPoints at: 2! !!Path methodsFor: 'accessing'!secondPoint: aPoint 	"Replace the second element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 2 put: aPoint.	^aPoint! !!Path methodsFor: 'accessing'!size	"Answer the length of the receiver."	^collectionOfPoints size! !!Path methodsFor: 'accessing'!thirdPoint	"Answer the third element of the receiver."	^collectionOfPoints at: 3! !!Path methodsFor: 'accessing'!thirdPoint: aPoint 	"Replace the third element of the receiver with the new value aPoint. 	Answer the argument aPoint."	collectionOfPoints at: 3 put: aPoint.	^aPoint! !!Path methodsFor: 'testing'!isEmpty	^collectionOfPoints isEmpty! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Display this Path--offset by aPoint, clipped by clipRect and the form 	associated with this Path will be displayedr according to one of the sixteen 	functions of two logical variables (rule). Also the source form will be first 	anded with aForm as a mask. Does not effect the state of the Path"	collectionOfPoints do: 		[:element | 		self form			displayOn: aDisplayMedium			at: element + aDisplayPoint			clippingBox: clipRectangle			rule: ruleInteger			fillColor: aForm]! !!Path methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: displayTransformation clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Displays this path, translated and scaled by aTransformation. Get the	scaled and translated Path."	| newPath transformedPath |	transformedPath _ displayTransformation applyTo: self.	newPath _ Path new.	transformedPath do: [:point | newPath add: point].	newPath form: self form.	newPath		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRectangle		rule: ruleInteger		fillColor: aForm! !!Path methodsFor: 'display box access'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	| box |	box _ Rectangle origin: (self at: 1) extent: 0 @ 0.	collectionOfPoints do: 		[:aPoint | box _ box merge: (Rectangle origin: aPoint extent: 0 @ 0)].	^box! !!Path methodsFor: 'transforming'!scaleBy: aPoint 	"Answers a new Path scaled by aPoint. Does not affect the current data in 	this Path."	| newPath |	newPath _ Path new: self size.	newPath form: self form.	collectionOfPoints do: 		[:element | 		newPath add: 				(aPoint x * element x) asInteger @ (aPoint y * element y) asInteger].	^newPath! !!Path methodsFor: 'transforming'!translateBy: aPoint 	"Answers a new Path whose elements are translated by aPoint. Does not	affect the elements of this Path."	| newPath |	newPath _ Path new: self size.	newPath form: self form.	collectionOfPoints do: 		[:element | 		newPath add: 			(element x + aPoint x) asInteger @ (element y + aPoint y) asInteger].	^newPath! !!Path methodsFor: 'adding'!add: aPoint 	"Include aPoint as one of the receiver's elements."	collectionOfPoints add: aPoint! !!Path methodsFor: 'removing'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element of the receiver. Remove each element 	for which aBlock evaluates to true."	| newCollection |	newCollection _ collectionOfPoints removeAllSuchThat: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect the resulting values into a path that is like the receiver. Answer 	the new path."	| newCollection |	newCollection _ collectionOfPoints collect: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'enumerating'!select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new path like the receiver only those elements for which 	aBlock evaluates to true. Answer the new path."	| newCollection |	newCollection _ collectionOfPoints select: aBlock.	newCollection form: self form.	^newCollection! !!Path methodsFor: 'private'!initializeCollectionOfPoints	collectionOfPoints _ OrderedCollection new! !!Path methodsFor: 'private'!initializeCollectionOfPoints: anInteger	collectionOfPoints _ OrderedCollection new: anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Path class	instanceVariableNames: ''!!Path class methodsFor: 'instance creation'!new	^self basicNew initializeCollectionOfPoints! !!Path class methodsFor: 'instance creation'!new: anInteger	^self basicNew initializeCollectionOfPoints: anInteger! !!Path class methodsFor: 'examples'!example	"Creates a Path from mousePoints and displays it several ways on the display screen. Messes up the display. For learning about class Path, just select the code below and execute it to create a path and see it redisplayed in another place on the screen. Each path displays using a different form. A path is indicated by pressing the red mouse button in a sequence; press any other mouse button to terminate. "	| aPath aForm pl fl flag |	aForm _ Form extent: 2 @ 40.		"creates a form one inch long"	aForm fillBlack.							"turns it black"	aPath _ Path new.	aPath form: aForm.						"use the long black form for displaying"	flag _ true.	[flag]		whileTrue: 			[Sensor waitButton.			Sensor redButtonPressed				ifTrue: 					[aPath add: Sensor waitButton.					Sensor waitNoButton.					aForm displayOn: Display at: aPath last]				ifFalse: [flag _ false]].	Display fillWhite.	aPath displayOn: Display.			"the original path"	pl _ aPath translateBy: 0 @ 100.	fl _ Form extent: 40 @ 40.	fl fillGray.	pl form: fl.	pl displayOn: Display.				"the translated path"	Sensor waitNoButton	"Path example"! !BitBlt subclass: #Pen	instanceVariableNames: 'location direction penDown '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Pen commentStamp: 'di 5/22/1998 16:36' prior: 0!My instances can scribble on the screen or some other Form, drawing and printing at any angle. Since I am a BitBlt, the drawing can be done with an arbitary source Form.!!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:02'!defaultNib: widthInteger 	"Nib is the tip of a pen. This sets up the pen, with a nib of width widthInteger. You can also set the shape of the pen nib using:		roundNib: widthInteger, or		squareNib: widthInteger, or		sourceForm: aForm""Example:	| bic |	bic _ Pen new sourceForm: Cursor normal.	bic combinationRule: Form paint; turn: 90.	10 timesRepeat: [bic down; go: 3; up; go: 10]."	self color: Color black.	self squareNib: widthInteger.! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:03'!roundNib: diameter	"Makes this pen draw with a round dot of the given diameter."	self sourceForm: (Form dotOfSize: diameter).	combinationRule _ Form paint.! !!Pen methodsFor: 'initialize-release' stamp: 'jm 4/28/1998 04:03'!squareNib: widthInteger 	"Makes this pen draw with a square nib of the given width."	self sourceForm: (Form extent: widthInteger @widthInteger) fillBlack.	self combinationRule: Form over.  "a bit faster than paint mode"! !!Pen methodsFor: 'accessing'!direction	"Answer the receiver's current direction. 0 is towards the top of the	screen."	^direction! !!Pen methodsFor: 'accessing'!location	"Answer where the receiver is currently located."	^location! !!Pen methodsFor: 'operations' stamp: 'jm 4/28/1998 03:40'!color: aColorOrInteger	"Set the pen to the given color or to a color chosen from a fixed set of colors."	| count c |	aColorOrInteger isInteger		ifTrue: [			destForm depth = 1 ifTrue: [^ self fillColor: Color black].			count _ 19.  "number of colors in color wheel"			c _ (Color red wheel: count) at: ((aColorOrInteger * 7) \\ count) + 1]		ifFalse: [c _ aColorOrInteger].  "assume aColorOrInteger is a Color"	self fillColor: c.! !!Pen methodsFor: 'operations'!down	"Set the state of the receiver's pen to down (drawing)."	penDown _ true! !!Pen methodsFor: 'operations'!go: distance 	"Move the pen in its current direction a number of bits equal to the 	argument, distance. If the pen is down, a line will be drawn using the 	receiver's form source as the shape of the drawing brush."	self goto: (direction degreeCos @ direction degreeSin) * distance + location! !!Pen methodsFor: 'operations' stamp: 'di 11/4/97 20:11'!goto: aPoint 	"Move the receiver to position aPoint. If the pen is down, a line will be 	drawn from the current position to the new one using the receiver's 	form source as the shape of the drawing brush. The receiver's set 	direction does not change."	| old |	old _ location.	location _ aPoint.	penDown ifTrue: [self drawFrom: old rounded								to: location rounded]	"NOTE:  This should be changed so it does NOT draw the first point, so as	not to overstrike at line junctions.  At the same time, place should draw	a single dot if the pen is down, as should down (put-pen-down) if it	was not down before."! !!Pen methodsFor: 'operations'!home	"Place the receiver at the center of its frame."	location _ destForm boundingBox center! !!Pen methodsFor: 'operations'!north	"Set the receiver's direction to facing toward the top of the display screen."	direction _ 270! !!Pen methodsFor: 'operations'!place: aPoint 	"Set the receiver at position aPoint. No lines are drawn."	location _ aPoint! !!Pen methodsFor: 'operations'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale _ sourceForm width.	wasDown _ penDown.	lineStart _ location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form _ font characterFormAt: char.			charStart _ location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart _ location.				bb _ BitBlt bitPeekerFromForm: form.				pix _ RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: (TextStyle default fontAt: 1)]"! !!Pen methodsFor: 'operations'!turn: degrees 	"Change the direction that the receiver faces by an amount equal to the 	argument, degrees."	direction _ direction + degrees! !!Pen methodsFor: 'operations'!up	"Set the state of the receiver's pen to up (no drawing)."	penDown _ false! !!Pen methodsFor: 'geometric designs'!dragon: n  "Display restoreAfter: [Display fillWhite. 1 to: 4 do:	[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'jm 4/28/1998 03:51'!filberts: n side: s 	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self color: i - 1 * 40.		self hilbert: n side: s.		self go: s.		self hilbert: n side: s.		self go: s.		self up.		self go: n2 - 1 * s.		self turn: -90.		self go: n2 * s.		self turn: 180.		self down]! !!Pen methodsFor: 'geometric designs'!hilbert: n side: s 	"Draw an nth level Hilbert curve with side length s in the center of the 	screen. Write directly into the display's bitmap only. A Hilbert curve is 	a space-filling curve."	| a m |	n = 0 ifTrue: [^self turn: 180].	n > 0		ifTrue: 			[a _ 90.			m _ n - 1]		ifFalse: 			[a _ -90.			m _ n + 1].	self turn: a.	self hilbert: 0 - m side: s.	self turn: a; go: s.	self hilbert: m side: s.	self turn: 0 - a; go: s; turn: 0 - a.	self hilbert: m side: s.	self go: s; turn: a.	self hilbert: 0 - m side: s.	self turn: a	" 	(Pen new) hilbert: 3 side: 8. 	(Pen new sourceForm: Cursor wait) combinationRule: Form under; 	hilbert: 3 side: 25.	"! !!Pen methodsFor: 'geometric designs'!hilberts: n   "Display restoreAfter: [Display fillWhite.  Pen new hilberts: 5]"	"Draws n levels of nested Hilbert curves"	| s |	self up; turn: 90; go: 128; down.	1 to: n do: 		[:i | 		s _ 256 bitShift: 0 - i.		self defaultNib: n - i * 2 + 1.		self color: i+1.		self up; go: 0 - s / 2; turn: -90; go: s / 2; turn: 90; down.		self hilbert: i side: s.		self go: s.		self hilbert: i side: s.		self go: s]! !!Pen methodsFor: 'geometric designs'!mandala: npoints	"Display restoreAfter: [Pen new mandala: 30]"	"On a circle of diameter d, place npoints number of points. Draw all 	possible connecting lines between the circumferential points."	| l points d |	Display fillWhite.	d _ Display height-50.	l _ 3.14 * d / npoints.	self home; up; turn: -90; go: d // 2; turn: 90; go: 0 - l / 2; down.	points _ Array new: npoints.	1 to: npoints do: 		[:i | 		points at: i put: location rounded.		self go: l; turn: 360.0 / npoints].	npoints // 2		to: 1		by: -1		do: 			[:i | 			self color: i.			1 to: npoints do: 				[:j | 				self place: (points at: j).				self goto: (points at: j + i - 1 \\ npoints + 1)]]! !!Pen methodsFor: 'geometric designs' stamp: 'jm 5/6/1998 22:26'!spiral: n angle: a 	"Draw a double squiral (see Papert, MindStorms), where each design is made	by moving the receiver a distance of n after turning the amount + or -a."	1 to: n do: 		[:i | 		self color: i * 2.		self go: i; turn: a]"	Display restoreAfter: [		Display fillWhite. Pen new spiral: 200 angle: 89; home; spiral: 200 angle: -89]."! !!Pen methodsFor: 'geometric designs' stamp: 'jm 8/1/97 11:42'!web   "Display restoreAfter: [Pen new web]"	"Draw pretty web-like patterns from the mouse movement on the screen.	Press the mouse button to draw, option-click to exit.	By Dan Ingalls and Mark Lentczner. "	| history newPoint ancientPoint lastPoint filter color |	"self erase."	color _ 1.	[ true ] whileTrue:		[ history _ OrderedCollection new.		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ lastPoint _ Sensor mousePoint.		20 timesRepeat: [ history addLast: lastPoint ].		self color: (color _ color + 1).		[ Sensor redButtonPressed ] whileTrue: 			[ newPoint _ Sensor mousePoint.			(newPoint = lastPoint) ifFalse:				[ ancientPoint _ history removeFirst.				filter _ filter * 4 + newPoint // 5.				self place: filter.				self goto: ancientPoint.				lastPoint _ newPoint.				history addLast: filter ] ] ]! !!Pen methodsFor: 'private'!sourceForm: aForm	(aForm depth = 1 and: [destForm depth > 1])		ifTrue: ["Map 1-bit source to all ones for color mask"				colorMap _ Bitmap with: 0 with: 16rFFFFFFFF]		ifFalse: [colorMap _ nil].	^ super sourceForm: aForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pen class	instanceVariableNames: ''!!Pen class methodsFor: 'instance creation'!new	^ self newOnForm: Display! !!Pen class methodsFor: 'instance creation'!newOnForm: aForm	| pen |	pen _ super new.	pen setDestForm: aForm.	pen sourceOrigin: 0@0.	pen home.	pen defaultNib: 1.	pen north.	pen down.	^ pen! !!Pen class methodsFor: 'examples' stamp: 'jm 5/6/1998 22:28'!example	"Draw a spiral with a pen that is 2 pixels wide."	"Display restoreAfter: [Pen example]"	| bic |	bic _ self new.	bic defaultNib: 2.	bic color: Color blue.	bic combinationRule: Form over.	1 to: 100 do: [:i | bic go: i*4. bic turn: 89].! !RecordingControlsMorph subclass: #PermanentRecordingControlsMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!PermanentRecordingControlsMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:09'!addButtonRows	"Spun off to allow subclasses to customize the buttons but still benefit from super intialize"	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Tile' action: #makeTile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Show' action: #show).	self addMorphBack: r.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: self makeStatusLight..	self addMorphBack: r! !!PermanentRecordingControlsMorph methodsFor: 'all' stamp: 'sw 11/5/97 13:53'!initialize	super initialize.	hResizing _ #shrinkWrap! !AlignmentMorph subclass: #PhraseTileMorph	instanceVariableNames: 'resultType brightenedOnEnter userScriptSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!PhraseTileMorph commentStamp: 'di 5/22/1998 16:36' prior: 0!PhraseTileMorph comment:'Phrase Tile World: A single smalltalk expression in tiles.  Like (car forwardBy: number), having 3 tiles.  type = commandrcvrType = #actorIn the Old Single tile world:  Holder for a phrase of tiles as it came from the viewer and while it is being dragged by the hand. '!!PhraseTileMorph methodsFor: 'all' stamp: 'sw 5/3/1998 22:34'!acceptDroppingMorph: aMorph event: evt	| m |	m _ self owner.	[m == nil] whileFalse: [		((m respondsTo: #orientation) and: [m orientation == #vertical]) ifTrue: [^ m acceptDroppingMorph: aMorph event: evt].		m _ m owner].	"| o |	self prepareToUndoDropOf: aMorph.	o _ owner.	self delete.	aMorph position: o position.	o addMorph: aMorph."! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/12/98 10:14'!actualObject	"Answer the player that's the object of my attention"	^ self player! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/3/97 16:59'!booleanOperator	| op |	"If the receiver represents a boolean value, return the associated operator; if not, return nil"	submorphs size < 2 ifTrue: [^ nil].	(op _ submorphs second) type == #operator ifFalse: [^ nil].	^ (#(< <= = == ~= > >= ~~) includes: op operatorOrExpression)		ifTrue:			[op operatorOrExpression]		ifFalse:			[nil]! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 21:56'!brightenTiles	brightenedOnEnter _ true.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue: [			m color: (TilePadMorph brightColorFor: m color)]].! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 4/22/1998 14:59'!bringUpToDate	"Nothing here to do in the current architecture"! !!PhraseTileMorph methodsFor: 'all' stamp: 'tk 10/10/97 15:10'!canAccept: aMorph	"((aMorph isKindOf: PhraseTileMorph) or:	 [aMorph isKindOf: TileMorph])"  "not allow dropping to replace now"	(aMorph isKindOf: TileMorph) ifTrue: [			^ aMorph resultType == resultType]. "This is never used????"	^ false! !!PhraseTileMorph methodsFor: 'all' stamp: 'tk 11/3/97 17:20'!catchDivideByZero: aStream	"See if I am have divide as my operator.  If so, insert a test in the argument to divide."	(submorphs at: 2) type = #operator ifFalse: [^ false].		"not me"	(submorphs at: 2) operatorOrExpression == #/ ifFalse: [^ false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs at: 3) storeCodeOn: aStream.	aStream nextPut: $).	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/3/97 14:08'!codeString	| aStream |	aStream _ ReadWriteStream on: ''.	self storeCodeOn: aStream.	^ aStream contents! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 10/17/97 23:41'!enclosingEditor	"Return the next scriptor outward in the containment hierarchy"	| current |	current _ owner.	[current == nil] whileFalse:		[((current isKindOf: ScriptEditorMorph)				or: [current isKindOf: CompoundTileMorph])			ifTrue: [^ current].		current _ current owner].	^ nil! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/11/98 23:29'!handlesMouseDown: evt	| editor |	^ (editor _ self topEditor)		ifNil:			[false]		ifNotNil:			[editor openToDragNDrop]! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 19:53'!handlesMouseOver: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 20:07'!initialize	super initialize.	resultType = #unknown.	brightenedOnEnter _ false.	centering _ #center.	hResizing _ #shrinkWrap.	borderWidth _ 0.	inset _ 0.	self extent: 5@5.  "will grow to fit"! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 11:22'!inPartsBin	| o |	o _ self owner.	[o == nil] whileFalse: [		(o isKindOf: PartsBinMorph) ifTrue: [^ true].		o _ o owner].	^ false! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/3/97 17:00'!isBoolean	^ self booleanOperator ~~ nil! !!PhraseTileMorph methodsFor: 'all' stamp: 'tk 10/1/97 18:25'!isTileLike	"Can be dropped into a script"	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 4/21/1998 21:35'!isTileScriptingElement	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 10/19/97 17:42'!mouseDown: evt	"Pretend we picked up the tile and then put it down for a trial positioning."	"The essence of ScriptEditor mouseEnter:"	| ed ss |	owner class == TilePadMorph 		ifTrue: ["picking me out of another phrase"			(ss _ submorphs first) class == TilePadMorph ifTrue: [					ss _ ss submorphs first].			owner addMorph: (ss fullCopy)].	(ed _ self enclosingEditor) ifNotNil:		[evt hand grabMorph: self.		ed startStepping].! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 21:58'!mouseEnter: evt	"Show drag/drop feedback."	| h m |	h _ evt hand.	h submorphCount ~= 1 ifTrue: [^ self].	m _ h firstSubmorph.	(self canAccept: m) ifFalse: [^ self].	"don't give feedback if I'm not the inner-most phrase that could be replaced"	(self morphsAt: evt cursorPoint) do: [:subM |		((subM isKindOf: PhraseTileMorph) and: [subM ~~ self]) ifTrue: [^ self].		(subM isKindOf: TilePadMorph) ifTrue: [^ self]].	self brightenTiles.! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/12/98 10:14'!player	"Answer the player that's the object of my attention"	^ self firstSubmorph firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 22:20'!prepareToUndoDropOf: aMorph	| m |	self mouseLeave: MorphicEvent new.	m _ self owner.	[m == nil] whileFalse: [		(m isKindOf: ScriptEditorMorph) ifTrue: [^ m prepareToUndoDropOf: aMorph].		m _ m owner].! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/25/97 16:56'!resultType	^ resultType! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/4/98 21:05'!rootForGrabOf: aMorph	"Allow submorph to be extracted."	| m outerPhrase tt |	self inPartsBin ifTrue: [^ super rootForGrabOf: aMorph].	self isSticky ifTrue: [^ nil].	outerPhrase _ self.	m _ self owner.	[m == nil] whileFalse:		[(m isKindOf: PhraseTileMorph) ifTrue: [outerPhrase _ m].		m _ m owner].	(tt _ self topEditor) ifNotNil: [tt markEdited].	^ outerPhrase! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 4/16/1998 20:32'!rowOfRightTypeFor: aLayoutMorph forActor: aPlayer	| aPartsViewer aPhrase |	aLayoutMorph demandsBoolean ifTrue:		[self isBoolean ifTrue: [^ self].		aPartsViewer _ PartsViewer new invisiblySetPlayer: aPlayer.		aPhrase _ aPartsViewer booleanPhraseFromPhrase: self.		aLayoutMorph presenter coloredTilesEnabled ifFalse: [aPhrase makeAllTilesGreen].		^ aPhrase].	^ self! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/16/98 01:13'!setAssignmentRoot: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (TilePadMorph colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((AssignmentTileMorph new setRoot: opSymbol asString dataType: argType) typeColor: color).	self addMorphBack: (TilePadMorph new setType: argType)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/11/98 23:33'!setOperator: opSymbol type: opType rcvrType: rcvrType	opSymbol numArgs <= 0 ifFalse:		["Obscure:  numArgs comes back -1 for upper-case symbol, such as OnTicks"		self error: 'you must specify the type of the operand'].	self setOperator: opSymbol type: opType rcvrType: rcvrType argType: nil.! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 10/31/97 14:17'!setOperator: opSymbol type: opType rcvrType: rcvrType argType: argType	resultType _ opType.	self color: (TilePadMorph colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: rcvrType).	self addMorphBack: ((TileMorph new setOperator: opSymbol asString) typeColor: color).	opSymbol numArgs = 1 ifTrue: [		self addMorphBack: (TilePadMorph new setType: argType)].! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/12/98 10:14'!setSlotRefOperator: opSymbol type: opType	resultType _ opType.	self color: (TilePadMorph colorForType: opType).	self removeAllMorphs.	self addMorph: (TilePadMorph new setType: #player).	self addMorphBack: ((TileMorph new setSlotRefOperator: opSymbol asString) typeColor: color)! !!PhraseTileMorph methodsFor: 'all' stamp: 'tk 11/3/97 17:21'!storeCodeOn: aStream	"Add in some smarts for division by zero."	aStream nextPut: $(.	(submorphs at: 1) storeCodeOn: aStream.	aStream space.	(submorphs at: 2) storeCodeOn: aStream.	submorphs size > 2 ifTrue: [		(self catchDivideByZero: aStream) ifFalse: [			aStream space.			(submorphs at: 3) storeCodeOn: aStream]].	aStream nextPut: $).! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 16:27'!tileRows	^ Array with: (Array with: self fullCopy)! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 5/13/1998 16:42'!topEditor	^ self outermostMorphThat: [:m | (m isKindOf: ScriptEditorMorph) or:		 [m isKindOf: CompoundTileMorph]]! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 2/12/98 10:15'!try	| aPlayer |	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed costumee.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self player				logged: false].	(Delay forMilliseconds: 200) wait! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 10/19/97 14:35'!unbrightenTiles	brightenedOnEnter ifFalse: [^ self].	brightenedOnEnter _ false.	self allMorphsDo: [:m |		(m isKindOf: TileMorph) ifTrue: [			m color: (TilePadMorph unbrightColorFor: m color)]].! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 1/29/98 01:49'!userScriptSelector	^ userScriptSelector! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 1/29/98 01:49'!userScriptSelector: s	userScriptSelector _ s! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 6/26/97 20:57'!wantsDroppedMorph: aMorph event: evt	^ self canAccept: aMorph! !ImageMorph subclass: #PinMorph	instanceVariableNames: 'component pinForm pinSpec wires '	classVariableNames: 'InputPinForm IoPinForm OutputPinForm '	poolDictionaries: ''	category: 'Morphic-Components'!!PinMorph methodsFor: 'initialization' stamp: 'di 5/4/1998 09:13'!component: aComponent pinSpec: spec	component _ aComponent.	pinSpec _ spec.	pinSpec isInput ifTrue: [pinForm _ InputPinForm].	pinSpec isOutput ifTrue: [pinForm _ OutputPinForm].	pinSpec isInputOutput ifTrue: [pinForm _ IoPinForm].	self image: pinForm! !!PinMorph methodsFor: 'initialization' stamp: 'di 5/2/1998 15:37'!delete	self unwire.	^ super delete! !!PinMorph methodsFor: 'initialization' stamp: 'di 5/4/1998 09:13'!initialize	super initialize.	wires _ OrderedCollection new! !!PinMorph methodsFor: 'accessing' stamp: 'di 5/1/1998 15:51'!pinSpec	^ pinSpec! !!PinMorph methodsFor: 'geometry' stamp: 'di 5/4/1998 00:35'!placeFromSpec	| side corners c1 c2 pos |	side _ pinSpec pinLoc asInteger.  "1..4 ccw from left"	corners _ owner bounds corners.	c1 _ corners at: side.	c2 _ corners atWrap: side+1.	pos _ c1 + (c2 - c1 * pinSpec pinLoc fractionPart) grid: 4@4.	side = 1 ifTrue: [super position: pos - (8@0)].	(side = 2) | (side = 3) ifTrue: [super position: pos].	side = 4 ifTrue: [super position: pos - (0@8)].	self updateImage.! !!PinMorph methodsFor: 'geometry' stamp: 'di 5/6/1998 14:24'!position: p	| r side p1 corners c1 c2 sideIndex |	"Adhere to owner bounds, and apply gridding"	r _ owner bounds.	side _ r sideNearestTo: p.	p1 _ r pointNearestTo: p.  "a point on the border"	p1 _ p1 grid: 4@4.	"Update pin spec(5) = side index + fraction along side"	corners _ r corners.	sideIndex _ #(left bottom right top) indexOf: side.	c1 _ corners at: sideIndex.	c2 _ corners atWrap: sideIndex+1.	pinSpec pinLoc: sideIndex + ((p1 dist: c1) / (c2 dist: c1) min: 0.99999).	"Set new position with appropriate offset."	side = #top ifTrue: [super position: p1 - (0@8)].	side = #left ifTrue: [super position: p1 - (8@0)].	side = #bottom ifTrue: [super position: p1].	side = #right ifTrue: [super position: p1].	wires do: [:w | w pinMoved]! !!PinMorph methodsFor: 'geometry' stamp: 'di 5/6/1998 14:22'!privateMoveBy: delta	super privateMoveBy: delta.! !!PinMorph methodsFor: 'geometry' stamp: 'di 5/4/1998 09:10'!updateImage	"pinForm was made for right side.  Rotate/flip for other sides"	bounds left < owner bounds left ifTrue:  "left side"		[^ self image: (pinForm flipBy: #horizontal centerAt: 0@0)].	bounds bottom > owner bounds bottom ifTrue:  "bottom"		[^ self image: ((pinForm rotateBy: #left centerAt: 0@0)								flipBy: #vertical centerAt: 0@0)].	bounds right > owner bounds right ifTrue:  "right side"		[^ self image: pinForm].	bounds top < owner bounds top ifTrue:  "top"		[^ self image: (pinForm rotateBy: #left centerAt: 0@0)].self halt: 'uncaught pin geometry case'! !!PinMorph methodsFor: 'geometry' stamp: 'di 4/30/1998 12:12'!wiringEndPoint	| side |	side _ owner bounds sideNearestTo: bounds center.	side = #left ifTrue: [^ self position + (0@4)].	side = #bottom ifTrue: [^ self position + (4@7)].	side = #right ifTrue: [^ self position + (7@4)].	side = #top ifTrue: [^ self position + (4@0)]! !!PinMorph methodsFor: 'events' stamp: 'di 4/30/1998 22:33'!handlesMouseDown: evt	^ (evt optionKeyPressed | evt commandKeyPressed) not! !!PinMorph methodsFor: 'events' stamp: 'di 4/30/1998 22:34'!mouseDown: event	"Unshifted action is to move the pin (see mouseMove:)"	event shiftPressed ifTrue: [self startWiring: event].! !!PinMorph methodsFor: 'events' stamp: 'di 4/30/1998 12:30'!mouseMove: evt	evt shiftPressed ifTrue: [^ self].	self position: evt targetPoint.	self updateImage! !!PinMorph methodsFor: 'wires' stamp: 'di 4/30/1998 13:25'!addWire: aWireMorph	wires add: aWireMorph! !!PinMorph methodsFor: 'wires' stamp: 'di 5/1/1998 22:25'!canDockWith: otherPin	"Later include data type compatibility and circularity as well"	(pinSpec isInputOnly and: [otherPin pinSpec isInputOnly]) ifTrue: [^ false].	(pinSpec isOutputOnly and: [otherPin pinSpec isOutputOnly]) ifTrue: [^ false].	^ true! !!PinMorph methodsFor: 'wires' stamp: 'di 5/2/1998 17:23'!connectedPins	^ wires collect: [:w | w otherPinFrom: self]! !!PinMorph methodsFor: 'wires' stamp: 'di 5/2/1998 17:24'!isIsolated	^ wires isEmpty! !!PinMorph methodsFor: 'wires' stamp: 'di 4/30/1998 13:25'!removeWire: aWireMorph	wires remove: aWireMorph! !!PinMorph methodsFor: 'wires' stamp: 'di 5/6/1998 14:12'!startWiring: event	"Start wiring from this pin"	| origin handle candidates candidate wiringColor wire |	origin _ self wiringEndPoint.	candidates _ OrderedCollection new.	"Later this could be much faster if we define pinMorphsDo:		so that it doesn't go too deep and bypasses non-widgets."	self pasteUpMorph allMorphsDo:		[:m | ((m isMemberOf: PinMorph) and: [m canDockWith: self])				 ifTrue: [candidates add: m]].	handle _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:newPoint |			candidate _ candidates detect: [:m | m containsPoint: newPoint] ifNone: [nil].			wiringColor _ candidate == nil ifTrue: [Color black] ifFalse: [Color red].			handle removeAllMorphs;				 addMorph: (PolygonMorph vertices: (Array with: origin with: newPoint)						color: Color black borderWidth: 1 borderColor: wiringColor)]		lastPointDo:			[:lastPoint | (self wireTo: candidate) ifTrue:				[wire _ (WireMorph vertices: (Array with: origin with: lastPoint)						color: Color black borderWidth: 1 borderColor: Color black)						fromPin: self toPin: candidate.				self pasteUpMorph addMorph: wire.				self addWire: wire.				candidate addWire: wire]].	event hand world addMorph: handle.	handle startStepping! !!PinMorph methodsFor: 'wires' stamp: 'di 5/4/1998 00:15'!unwire	"Remove wires one by one.  Not fastest, but by far simplest"	wires do: [:w | w delete].  "This is where all the work is done"! !!PinMorph methodsFor: 'wires' stamp: 'di 5/3/1998 23:55'!wireTo: otherPin	"Note must return true or false indicating success"	(otherPin == nil or: [otherPin == self]) ifTrue: [^ false].	self hasVariable	ifTrue: [otherPin hasVariable			ifTrue: [self mergeVariableWith: otherPin]			ifFalse: [otherPin shareVariableOf: self]]	ifFalse: [otherPin hasVariable			ifTrue: [self shareVariableOf: otherPin]			ifFalse: [self addModelVariable.					otherPin shareVariableOf: self]].	component model changed: pinSpec modelReadSelector.	^ true! !!PinMorph methodsFor: 'variables' stamp: 'di 5/4/1998 00:11'!addModelVariable	| accessors |	accessors _ component model addVariableNamed: component knownName , pinSpec pinName.	pinSpec modelReadSelector: accessors first modelWriteSelector: accessors second.	component initFromPinSpecs.	self connectedPins do: [:connectee | connectee shareVariableOf: self]! !!PinMorph methodsFor: 'variables' stamp: 'di 5/1/1998 13:21'!hasVariable	^ pinSpec hasVariable! !!PinMorph methodsFor: 'variables' stamp: 'di 5/4/1998 00:01'!mergeVariableWith: otherPin	"Change all pins with otherPin's selectors to these selectors,	and then remove the slot and accessors for the old selectors"	self removeModelVariable.	self connectedPins do:		[:connectee | connectee shareVariableOf: otherPin].	self shareVariableOf: otherPin! !!PinMorph methodsFor: 'variables' stamp: 'di 5/3/1998 23:58'!removeModelVariable	component model removeVariableNamed: pinSpec variableName.	self removeVariableAccess! !!PinMorph methodsFor: 'variables' stamp: 'di 5/4/1998 00:18'!removeVariableAccess	pinSpec modelReadSelector: nil modelWriteSelector: nil.	component initFromPinSpecs! !!PinMorph methodsFor: 'variables' stamp: 'di 5/2/1998 15:55'!shareVariableOf: otherPin	pinSpec modelReadSelector: otherPin pinSpec modelReadSelector			modelWriteSelector: otherPin pinSpec modelWriteSelector.	component initFromPinSpecs! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PinMorph class	instanceVariableNames: ''!!PinMorph class methodsFor: 'as yet unclassified' stamp: 'di 5/3/1998 10:09'!includeInNewMorphMenu	^ false! !!PinMorph class methodsFor: 'as yet unclassified' stamp: 'di 4/28/1998 10:58'!initialize  "PinMorph initialize"	OutputPinForm _ Form extent: 8@8 depth: 1 fromArray:			#( 0 3221225472 4026531840 4227858432 4278190080 4227858432 4026531840 3221225472)		offset: 0@0.	IoPinForm _ Form extent: 8@8 depth: 1 fromArray:			#( 0 402653184 1006632960 2113929216 4278190080 2113929216 1006632960 402653184)		offset: 0@0.	InputPinForm _ OutputPinForm flipBy: #horizontal centerAt: 0@0.! !Object subclass: #PinSpec	instanceVariableNames: 'pinName direction localReadSelector localWriteSelector modelReadSelector modelWriteSelector defaultValue pinLoc '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!PinSpec methodsFor: 'initialization' stamp: 'di 5/1/1998 13:38'!pinName: a direction: b localReadSelector: c localWriteSelector: d modelReadSelector: e modelWriteSelector: f defaultValue: g pinLoc: h	pinName _ a.	direction _ b.	localReadSelector _ c.	localWriteSelector _ d.	modelReadSelector _ e.	modelWriteSelector _ f.	defaultValue _ g.	pinLoc _ h! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 09:59'!defaultValue	^ defaultValue! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 16:38'!isInput	direction = #input ifTrue: [^ true].	direction = #inputOutput ifTrue: [^ true].	direction = #ioAsInput ifTrue: [^ true].	^ false! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 22:25'!isInputOnly	direction = #input ifTrue: [^ true].	direction = #ioAsInput ifTrue: [^ true].	^ false! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 16:42'!isInputOutput	^ direction = #inputOutput! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 16:39'!isOutput	direction = #output ifTrue: [^ true].	direction = #inputOutput ifTrue: [^ true].	direction = #ioAsOutput ifTrue: [^ true].	^ false! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 22:26'!isOutputOnly	direction = #output ifTrue: [^ true].	direction = #ioAsOutput ifTrue: [^ true].	^ false! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 09:58'!localReadSelector	^ localReadSelector! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 09:58'!localWriteSelector	^ localWriteSelector! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 09:59'!modelReadSelector	^ modelReadSelector! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 13:36'!modelReadSelector: a modelWriteSelector: b	modelReadSelector _ a.	modelWriteSelector _ b! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 09:59'!modelWriteSelector	^ modelWriteSelector! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 10:00'!pinLoc	^ pinLoc! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 10:14'!pinLoc: x	pinLoc _ x! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 13:39'!pinName	^ pinName! !!PinSpec methodsFor: 'variables' stamp: 'di 5/1/1998 13:26'!hasVariable	^ modelReadSelector ~~ nil or: [modelWriteSelector ~~ nil]! !!PinSpec methodsFor: 'variables' stamp: 'di 5/2/1998 15:47'!variableName	^ modelReadSelector! !Envelope subclass: #PitchEnvelope	instanceVariableNames: 'centerPitch '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!PitchEnvelope methodsFor: 'all' stamp: 'jm 1/31/98 14:46'!centerPitch	^ centerPitch! !!PitchEnvelope methodsFor: 'all' stamp: 'jm 1/31/98 14:49'!centerPitch: aNumber	centerPitch _ aNumber.! !!PitchEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 07:30'!updateSelector	"Needed by the envelope editor."	^ #pitch:! !!PitchEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 21:11'!updateTargetAt: mSecs	"Update the pitch for my target. Answer true if the value changed."	"Details: Assume envelope range is 0.0..2.0, with 1 being the center pitch. Subtracting one yields the range -1.0..1.0. Raising two to this power yields pitches between half and double the center pitch; i.e. from an octave below to an octave about the center pitch."	| newValue |	newValue _ self valueAtMSecs: mSecs.	newValue ~= lastValue ifTrue: [		target pitch: (2.0 raisedTo: newValue - (scale / 2.0)) * centerPitch.		lastValue _ newValue.		^ true].	^ false! !MorphicModel subclass: #PlayWithMe1	instanceVariableNames: 'slider1 valuePrinter scrollBar1 listPane1 listPane2 '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!!PlayWithMe1 methodsFor: 'public access'!slider1Value: x	valuePrinter contents: x printString.	scrollBar1 value: x! !!PlayWithMe1 methodsFor: 'input events'!listPane1MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!listPane1NewSelection: t1 	valuePrinter contents: (t1 = 0			ifTrue: ['-']			ifFalse: [(listPane1 instVarNamed: 'list')					at: t1]).	listPane1 selectionIndex: t1.	listPane2 selectionIndex: t1! !!PlayWithMe1 methodsFor: 'input events'!listPane2MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!listPane2NewSelection: t1 	valuePrinter contents: (t1 = 0			ifTrue: ['-']			ifFalse: [(listPane2 instVarNamed: 'list')					at: t1]).	listPane2 selectionIndex: t1.	listPane1 selectionIndex: t1! !!PlayWithMe1 methodsFor: 'input events'!scrollBar1MenuButtonPressed: arg1	self confirm: 'Do you like menu buttons?'! !!PlayWithMe1 methodsFor: 'input events'!scrollBar1Value: arg1	valuePrinter contents: arg1 printString.	slider1 value: arg1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PlayWithMe1 class	instanceVariableNames: ''!!PlayWithMe1 class methodsFor: 'all' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !MorphicModel subclass: #PlayWithMe2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!MorphicModel subclass: #PlayWithMe3	instanceVariableNames: 'slantedList1 '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!!PlayWithMe3 methodsFor: 'public access'!slantedList1	^slantedList1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PlayWithMe3 class	instanceVariableNames: ''!!PlayWithMe3 class methodsFor: 'all' stamp: 'di 6/22/97 09:14'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !Model subclass: #Player	instanceVariableNames: 'costume '	classVariableNames: 'TimeOfError '	poolDictionaries: ''	category: 'Morphic-Scripting'!!Player commentStamp: 'di 5/22/1998 16:36' prior: 0!The fundamental user-scriptable entity.  Always represented by a user-specific subclass of Player; instance vars and methods relate to user-defined structures.costume  is a Morph, the primary morph I am currently wearing for graphical display.!!Player methodsFor: 'card/stack commands' stamp: 'sw 5/5/1998 00:01'!createNewCard	self costume createNewCard! !!Player methodsFor: 'card/stack commands' stamp: 'sw 5/21/1998 12:54'!deleteCard	"Still underway"	true ifTrue: [^ self beep].	costume deleteCard! !!Player methodsFor: 'card/stack commands' stamp: 'sw 5/2/1998 22:38'!goToNextCard	self costume goToNextCard! !!Player methodsFor: 'card/stack commands' stamp: 'sw 5/2/1998 22:44'!goToPreviousCard	self costume goToPreviousCard! !!Player methodsFor: 'card/stack commands' stamp: 'sw 5/5/1998 00:05'!newCard	self costume newCard! !!Player methodsFor: 'clone' stamp: 'sw 5/8/1998 13:40'!copyStateFrom: aPlayer	"Just a place-holder for the present: clear out scripts; until we also clear out the method dictionary, this is an inconsistency.  Also, need attention to inst vars"	self class copyStateFrom: aPlayer class.	self copyAddedStateFrom: aPlayer.  "the inst vars added by him"	self flag: #deferred.  "Doesn't yet deal with stuff stored on the morph side"! !!Player methodsFor: 'clone' stamp: 'sw 5/6/1998 17:40'!duplicatedPlayerForCostume: aCostume	"Answer a new Player that starts out life with the same set of methods as the receiver has.  You'll need to get its costume set up properly."	| anInstance |	anInstance _ self class officialClass instanceOfUniqueClassWithInstVarString: self class instanceVariablesString andClassInstVarString: self class class instanceVariablesString.	anInstance costume: aCostume.	anInstance copyStateFrom: self.	anInstance class copyMethodDictionaryFrom: self class.	^ anInstance! !!Player methodsFor: 'clone' stamp: 'sw 2/4/98 15:42'!justClonedFrom: donorActor	"Convert all references to actor1 to actor2, who now owns the script"	| lastAcceptedScript lastScriptEditor |	self flag: #noteToTed.   "Code to get all the scripts right in the clone needs to be considered here, esp making the right donorActor:ownActor: calls"	false ifTrue: [lastAcceptedScript ifNotNil:		[lastAcceptedScript myMorph == self ifFalse: [self error: 'dup should have done it'].		"All subMorphs including targets and arguments are fixed up by veryDeepCopy"		lastAcceptedScript donorActor: donorActor ownActor: self.		lastAcceptedScript bringUpToDate.			"Note that both of above two lines rewrite tile's line1 with new external name"			"Fix this?"		lastAcceptedScript install].	lastScriptEditor _ lastAcceptedScript.]	! !!Player methodsFor: 'clone' stamp: 'sw 5/13/1998 16:43'!justDuplicatedFrom: donorActor	"Convert all references to actor1 to actor2, who now owns the script"	"This is the case of true duplication, where the receiver and the donorPlayer are of distinct classes"	self class userScriptsDo:		[:aScript | aScript donorActor: donorActor ownActor: self; bringUpToDate]! !!Player methodsFor: 'costume' stamp: 'sw 5/13/1998 14:07'!availableCostumeNames	"Answer a list of class names (minus trailing ...Morph) to be offered in the thumbnail 'new-Costume' menu in the Viewer" 	^ #(Book BouncingAtoms Curve Ellipse  Flasher Image Joystick  PasteUp Polygon Rectangle Ruler Sketch Star String Text  )"  ScrollBar  SimpleButton SimpleSlider SimpleSwitch  UserFrame  "! !!Player methodsFor: 'costume' stamp: 'sw 2/15/98 13:55'!availableCostumeNamesForArrows	"Answer the names of costumes to be moved among via the costume-arrows next the thumbnail in the viewer"	^ self instantiatedCostumeNames asSortedArray! !!Player methodsFor: 'costume' stamp: 'sw 12/16/97 11:00'!costume	^ costume! !!Player methodsFor: 'costume' stamp: 'sw 5/21/1998 15:15'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	((costume isKindOf: SketchMorph) and: [(aMorph isKindOf: SketchMorph)])		ifTrue:			[^ costume wearCostume: aMorph].	self costumeDictionary		at: aMorph formalCostumeName		put: (aMorph fullCopy costumee: nil).	costume ifNotNil:		[itsBounds _ costume bounds.		costume pasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph costumee: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'sw 4/8/98 12:07'!costumeAt: aCostumeName ifAbsent: aBlock	^ self class costumeAt: aCostumeName ifAbsent: aBlock! !!Player methodsFor: 'costume' stamp: 'sw 4/8/98 12:07'!costumeDictionary	^ self class costumeDictionary! !!Player methodsFor: 'costume' stamp: 'sw 2/15/98 14:00'!costumeNamed: aCostumeName	"Answer a costume of the given name for the receiver.  If none found, create one"	| found |	found _ self costumeAt: aCostumeName ifAbsent: [nil].	found ifNil:		[found _ (Smalltalk at: aCostumeName asSymbol) new setNameTo: self externalName.		self costumeDictionary at: aCostumeName put: found].	^ found! !!Player methodsFor: 'costume' stamp: 'sw 4/8/98 12:06'!costumesDo: aBlock	self class costumesDo: aBlock! !!Player methodsFor: 'costume' stamp: 'sw 2/15/98 00:00'!instantiatedCostumeNames	^ self costumeDictionary keys asArray! !!Player methodsFor: 'costume' stamp: 'sw 2/14/98 18:29'!newCostume	| aMenu reply |	aMenu _ SelectionMenu selections: self availableCostumeNames.	(reply _ aMenu startUpWithCaption: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply! !!Player methodsFor: 'costume' stamp: 'jm 4/25/1998 03:38'!rawCostume: aMorph	costume _ aMorph.! !!Player methodsFor: 'costume' stamp: 'sw 5/20/1998 02:32'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	self costume: anotherPlayer costume fullCopy! !!Player methodsFor: 'costume' stamp: 'jm 5/20/1998 14:36'!wearCostumeOfClass: aClass	self costume:		(self costumeNamed: aClass formalCostumeName) fullCopy! !!Player methodsFor: 'costume' stamp: 'sw 2/20/98 00:32'!wearCostumeOfName: aName	| classToUse |	classToUse _ Smalltalk at: (aName, 'Morph') asSymbol ifAbsent: 		[Smalltalk at: aName asSymbol].	self wearCostumeOfClass: classToUse! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headDown	| radians |	radians _ (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headLeft	| radians |	radians _ (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs negated @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headRight	| radians |	radians _ (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos abs @ radians sin) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'heading' stamp: 'jm 4/24/1998 22:30'!headUp	| radians |	radians _ (self getHeadingUnrounded - 90.0) degreesToRadians.	self setHeading:		((radians cos @ radians sin abs negated) theta radiansToDegrees			roundTo: 0.001) + 90.0.! !!Player methodsFor: 'name' stamp: 'sw 5/19/1998 13:20'!assureExternalName	costume knownName ifNil:		[costume setNameTo: costume externalName]! !!Player methodsFor: 'name' stamp: 'sw 5/12/1998 16:46'!externalName	^ self costume externalName! !!Player methodsFor: 'name' stamp: 'sw 5/12/1998 23:56'!renameTo: aName	costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'pen' stamp: 'sw 5/2/1998 15:14'!addPlayerMenuItemsTo: aMenu hand: aHandMorph	| subMenu |	"Note that all these items are now available in another way in an object's Viewer"	(self slotInfo size > 0) ifTrue:		[aMenu add: 'change variable type...' target: self action: #changeVariableType].	subMenu _ MenuMorph new defaultTarget: self.	self getPenDown		ifTrue: [subMenu add: 'lift pen' action: #liftPen]		ifFalse: [subMenu add: 'lower pen' action: #lowerPen].	subMenu add: 'choose pen size...' action: #choosePenSize.	subMenu add: 'choose pen color...' action: #choosePenColor:.	aMenu add: 'pen...' subMenu: subMenu! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:49'!choosePenColor: evt	evt hand changeColorTarget: costume selector: #penColor:! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:25'!choosePenSize	^ self actorState choosePenSize! !!Player methodsFor: 'pen' stamp: 'di 3/1/98 12:13'!colorUnder	^ costume colorUnder! !!Player methodsFor: 'pen' stamp: 'sw 2/4/98 15:16'!defaultPenColor	^ Color blue! !!Player methodsFor: 'pen' stamp: 'sw 2/4/98 15:03'!defaultPenSize	^ 1! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:35'!getPenColor	^ self actorState getPenColor! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:41'!getPenDown	^ self actorState getPenDown! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:26'!getPenSize	^ self actorState getPenSize! !!Player methodsFor: 'pen' stamp: 'sw 4/13/1998 22:38'!liftPen	self actorState liftPen! !!Player methodsFor: 'pen' stamp: 'sw 4/13/1998 22:38'!lowerPen	self actorState lowerPen! !!Player methodsFor: 'pen' stamp: 'sw 4/13/1998 22:38'!penColor: aColor	self actorState penColor: aColor! !!Player methodsFor: 'pen' stamp: 'sw 4/22/1998 13:51'!setPenColor: aColor	self actorState setPenColor: aColor! !!Player methodsFor: 'slots-kernel' stamp: 'sw 4/8/98 11:56'!slotInfo	^ self class slotInfo! !!Player methodsFor: 'slots-kernel' stamp: 'sw 2/15/98 13:08'!slotNames	^ self class instVarNames  "Could also get it from the slotInfo dictionary"			! !!Player methodsFor: 'slots-kernel' stamp: 'sw 4/22/1998 16:20'!slotNamesAndTypesForViewerBank: aBank	^ (self standardSlotsForBank: aBank), (self personalSlotNamesAndTypesForBank: aBank), (self costumeSlotNamesAndTypesForBank: aBank)! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/5/1998 01:26'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(colorSees	boolean		readOnly	dummy				unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-kernel' stamp: 'sw 5/6/1998 13:42'!typeForSlot: aSlotName	| infoDict |	infoDict _ self slotInfo.	(infoDict includesKey: aSlotName) ifTrue: [^ infoDict at: aSlotName].	^ ScriptingSystem typeForSystemSlotNamed: aSlotName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:30'!getAmount	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #amount) ifTrue: [^ renderedMorph amount].	^ (self costumeNamed: #JoystickMorph) amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:30'!getAngle	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #angle) ifTrue: [^ renderedMorph angle].	^ (self costumeNamed: #JoystickMorph) angle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:30'!getBorderColor	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #borderColor) ifTrue: [^ renderedMorph borderColor].	self costumesDo: [:aCostume | (aCostume respondsTo: #borderColor) ifTrue: [^ aCostume borderColor]].	"No instantiated costume bears a border color.  Very unlikely"	^ (self costumeNamed: #RectangleMorph) borderColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:23'!getBorderWidth	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #borderWidth) ifTrue: [^ renderedMorph borderWidth].	self costumesDo: [:aCostume | (aCostume respondsTo: #borderWidth) ifTrue: [^ aCostume borderWidth]].	"No instantiated costume bears a border width.  Very unlikely"	^ (self costumeNamed: #RectangleMorph) borderWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getBottom	^ self costume bottom! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:38'!getColor	^ costume renderedMorph color! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 1/28/98 17:37'!getColorUnder	^ costume colorUnder! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/12/1998 12:55'!getCursor	| aMorph |	((aMorph _ costume renderedMorph) respondsTo: #cursor) ifTrue: [^ aMorph cursor].	^ (self costumeNamed: #PasteUpMorph) cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'jm 4/17/1998 00:50'!getHeading	^ self getHeadingUnrounded rounded! !!Player methodsFor: 'slots-standard-get/set' stamp: 'jm 4/24/1998 21:46'!getHeadingUnrounded 	costume isFlexMorph		ifTrue: [^ costume rotationDegrees asSmallAngleDegrees]		ifFalse: [^ 0.0].! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 00:50'!getHeight	^ self costume height! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getLeft	^ self costume left! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:31'!getLeftRight	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #leftRight) ifTrue: [^ renderedMorph leftRight].	^ (self costumeNamed: #JoystickMorph) leftRight! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/1/1998 23:28'!getMouseX	^ costume mouseX! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/1/1998 23:28'!getMouseY	^ costume mouseY! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 2/3/98 23:36'!getName	^ self externalName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getRight	^ self costume right! !!Player methodsFor: 'slots-standard-get/set' stamp: 'jm 4/17/1998 05:20'!getScaleFactor	costume isFlexMorph		ifTrue: [^ costume scale]		ifFalse: [^ 1.0].! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 2/21/98 23:23'!getSpeed	"If user defines a speed slot, it will override this.  This provides a backstop value for use with moveToward:, etc"	^ 5 ! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:15'!getTop	^ self costume top! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:31'!getUpDown	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #upDown) ifTrue: [^ renderedMorph upDown].	^ (self costumeNamed: #JoystickMorph) upDown! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:33'!getValueAtCursor	| costumeToUse anObject renderedMorph |	costumeToUse _ ((renderedMorph _ costume renderedMorph) respondsTo: #valueAtCursor) 		ifTrue:			[renderedMorph]		ifFalse:			[self costumeNamed: #PasteUpMorph].	anObject _ costumeToUse valueAtCursor.	^ anObject == 0  "weird return from Holder & Graph"		ifTrue:			[nil]		ifFalse:			[anObject assuredCostumee]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 00:49'!getWidth	^ self costume width! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 15:36'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	costume isInWorld ifFalse: [^ 100].	^ costume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 1/28/98 17:34'!getY	^ costume y! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 15:08'!setBorderColor: aColor	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #borderColor:) ifTrue: [^ renderedMorph borderColor: aColor].	"If doing invisibly, do it equally to any hidden costume that cares"	self costumesDo: [:aCostume | ((renderedMorph _ aCostume renderedMorph) respondsTo: #borderColor:) ifTrue: [renderedMorph borderColor: aColor]].	"No instantiated costume bears a border color.  Very unlikely"	^ (self costumeNamed: #RectangleMorph) borderColor: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 15:08'!setBorderWidth: aWidth	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #borderWidth:) ifTrue: [^ renderedMorph borderWidth: aWidth].	"If doing invisibly, do it equally to any hidden costume that cares"	self costumesDo: [:aCostume | (aCostume renderedMorph respondsTo: #borderWidth) ifTrue: [aCostume renderedMorph borderWidth: aWidth]].	"No instantiated costume bears a border width.  Very unlikely"	^ (self costumeNamed: #RectangleMorph) borderWidth: aWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:25'!setBottom: w	^ self costume bottom: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:37'!setColor: aColor	costume renderedMorph color: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 2/12/98 00:28'!setCostume: someOtherMorph	^ costume wearCostume: someOtherMorph! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/12/1998 12:53'!setCursor: aNumber	| aMorph |	((aMorph _ costume renderedMorph) respondsTo: #cursor:) ifTrue: [^ aMorph cursor: aNumber].	^ (self costumeNamed: #PasteUpMorph) cursor: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'jm 4/25/1998 04:05'!setHeading: aNumber	0.0 = aNumber		ifTrue: [			1.0 = self getScaleFactor ifTrue: [				costume isFlexMorph ifTrue: [costume removeFlexShell].				^ self]]		ifFalse: [			costume isFlexMorph ifFalse: [costume addFlexShell]].	costume rotationDegrees: aNumber.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 00:49'!setHeight: w	^ self costume height: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:24'!setLeft: w	^ self costume left: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 1/28/98 17:30'!setName: aName	^ costume renameTo: aName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:24'!setRight: w	^ self costume right: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'jm 4/25/1998 04:04'!setScaleFactor: aNumber	1.0 = aNumber		ifTrue: [			0.0 = self getHeading ifTrue: [				costume isFlexMorph ifTrue: [costume removeFlexShell].				^ self]]		ifFalse: [			costume isFlexMorph ifFalse: [costume addFlexShell]].	costume scale: (aNumber asFloat max: 0.125).! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 01:25'!setTop: w	^ self costume top: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/21/1998 14:36'!setValueAtCursor: aPlayer	| renderedMorph |	((renderedMorph _ costume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(costume respondsTo: #valueAtCursor:) ifTrue: [costume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 5/5/1998 00:49'!setWidth: w	^ self costume width: w! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 1/29/98 00:42'!setX: val	^ costume x: val! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 1/29/98 00:42'!setY: val	^ costume y: val! !!Player methodsFor: 'slots-user' stamp: 'sw 5/13/1998 19:18'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: typeChosen.	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 4/26/1998 10:59'!addSlotNamedLike: suggestedName withValue: aValue	| otherNames numericSuffix nameToUse  stem |	stem _ suggestedName first asLowercase asString , suggestedName allButFirst.	stem _ stem stemAndNumericSuffix first.	nameToUse _ stem.	otherNames _ self class allInstVarNames.	numericSuffix _ 1.	[otherNames includes: nameToUse]		whileTrue: [numericSuffix _ numericSuffix + 1. (nameToUse _ stem, numericSuffix printString)].	self class addInstVarName: nameToUse.	self instVarAt: self class instSize put: aValue.  "Assumes added as last field"	self compileAccessorsFor: nameToUse.	self slotInfo at: nameToUse asSymbol put: aValue basicType.	^ nameToUse! !!Player methodsFor: 'slots-user' stamp: 'sw 3/24/98 22:59'!changeVariableType	| slotName |	(slotName _ self chooseUserSlot) ifNil: [^ self].	self chooseSlotTypeFor: slotName asSymbol! !!Player methodsFor: 'slots-user' stamp: 'sw 5/13/1998 19:32'!chooseSlotTypeFor: slotName	| typeChoices typeChosen |	typeChoices _ #(number player boolean color point string costume).	typeChosen _ (SelectionMenu selections: typeChoices lines: #()) startUpWithCaption: 'Choose the TYPEfor ', slotName.	(typeChosen size == 0) ifTrue: [^ self].	(self typeForSlot: slotName) = typeChosen ifTrue: [^ self].	self slotInfo at: slotName put: typeChosen.	self class allInstancesDo:		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName)).		anInst updateAllViewers]! !!Player methodsFor: 'slots-user' stamp: 'sw 3/24/98 23:01'!chooseUserSlot	| names aMenu result |	(names _ self slotNames) size == 1		ifTrue: [^ names first].	aMenu _ SelectionMenu selections: names.	result _ aMenu startUpWithCaption: 'Please choose a variable'.	result size == 0 ifTrue: [^ nil].	^ result! !!Player methodsFor: 'slots-user' stamp: 'sw 2/15/98 12:55'!compileInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self class compile: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self class compile: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil.! !!Player methodsFor: 'slots-user' stamp: 'sw 2/15/98 03:21'!costumeSlotNamesAndTypesForBank: aBank	"Return an array of slot names and slot info to be added by the receiver's various costumes for use in a viewer on the receiver"	| names aList |	names _ OrderedCollection new.	aList _ OrderedCollection new.	self costumesDo:		[:aCostume |			(aCostume slotNamesAndTypesForBank: aBank) do:				[:aPair | (names includes: aPair first)					ifFalse:						[aList add: aPair.						names add: aPair first]]].	^ aList! !!Player methodsFor: 'slots-user' stamp: 'sw 3/24/98 22:21'!initialTypeForSlotNamed: aName	^ #number! !!Player methodsFor: 'slots-user' stamp: 'sw 4/17/1998 23:33'!initialValueForSlotOfType: aType	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color red]! !!Player methodsFor: 'slots-user' stamp: 'sw 2/16/98 01:06'!personalSlotNamesAndTypesForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver"	| nameString |	aBank ~~ 1 ifTrue: [^ Array new].	^ self slotNames collect: [:aName |		nameString _ aName asString capitalized.		Array			with: 	aName 								"name"			with: 	(self typeForSlot: aName asSymbol)	"type"			with:	#readWrite							"r/w"			with:	('get', nameString) asSymbol		"get selector"			with:	('set', nameString, ':') asSymbol]	"set selector"! !!Player methodsFor: 'slots-user' stamp: 'sw 5/20/1998 01:40'!removeSlotNamed: aSlotName	(self okayToRemoveSlotNamed: aSlotName) ifFalse:		[^ self inform: 'Sorry, ', aSlotName, ' is inuse in a script.'].	self notYetImplemented! !!Player methodsFor: 'slots-user' stamp: 'sw 5/2/1998 01:50'!renameSlot: aSlotName	self notYetImplemented! !!Player methodsFor: 'slots-user' stamp: 'sw 3/26/98 10:05'!valueOfType: aType from: oldValue	"The user has changed a slot's type to aType; convert its former value, oldValue, to something of the appropriate type.  For now, does not take oldvalue into account"	^ self initialValueForSlotOfType: aType! !!Player methodsFor: 'slots-assignment' stamp: 'sw 1/31/98 00:06'!assignDecrGetter: getterSelector setter: setterSelector amt: aDecrement	self perform: setterSelector with:		((self perform: getterSelector) - aDecrement)! !!Player methodsFor: 'slots-assignment' stamp: 'sw 1/31/98 00:07'!assignGetter: getterSelector setter: setterSelector amt: amt	self perform: setterSelector with: amt! !!Player methodsFor: 'slots-assignment' stamp: 'sw 1/31/98 00:07'!assignIncrGetter: getterSelector setter: setterSelector amt: anIncrement	self perform: setterSelector with:		((self perform: getterSelector) + anIncrement)! !!Player methodsFor: 'slots-assignment' stamp: 'sw 1/31/98 00:06'!assignMultGetter: getterSelector setter: setterSelector amt: aMultiplier	self perform: setterSelector with:		((self perform: getterSelector) * aMultiplier)! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 4/9/98 22:02'!acceptScript: aScriptEditorMorph for: aSelector	| classif |	classif _ aScriptEditorMorph isAnonymous ifTrue: ['anonymous scripts'] ifFalse: ['named scripts'].	self class		compile: aScriptEditorMorph methodString		classified: classif		notifying: nil.	self class atSelector: aSelector putScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 4/9/98 21:56'!allScriptEditors	"Used presently only an one-shot efforts to update all tile scripts to new styles"	^ self class tileScriptNames collect: [:n | self scriptEditorFor: n]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/8/1998 13:40'!anonymousScriptEditorFor: aPhraseTileMorph	| aScriptEditor aUserScript |	self isFlagshipForClass ifFalse:		[self flag: #deferred.		self inform: 'sorry, for the moment you cannot tearoff a new anonymous script forany instance of a uniclass otherthan the flagship instance.  If thismakes no sense to you,  yousurely got here in error'.		self error: 'Please close this window'].	aUserScript _ self class anonymousUserScriptFor: self unusedScriptName player: self.	aScriptEditor _ aUserScript instantiatedScriptEditor.	aPhraseTileMorph		ifNotNil:			[aScriptEditor scriptName: aUserScript selector phrase: aPhraseTileMorph]		ifNil:			[aScriptEditor startOutEmptyForScriptName: aUserScript selector].	^ aScriptEditor! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/15/98 12:54'!compileAccessorsFor: varName	^ self compileInstVarAccessorsFor: varName	"code below is the implementation where we use a slots dictionary rather than true inst vars	nameString _ varName asString capitalized.	self class compile: ('get', nameString, '	^ self atSlot: #', varName)		classified: 'access' notifying: nil.	self class compile: ('set', nameString, ': val		self atSlot: #', varName, ' put: val')		classified: 'access' notifying: nil"! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/21/98 23:32'!hasScriptInvoking: scriptName ofPlayer: aPlayer	"Answer whether the receiver bears any script that invokes a script of the given name for  the given player"	self allScriptEditors do:		[:anEditor | (anEditor hasScriptInvoking: scriptName ofPlayer: aPlayer) ifTrue: [^ true]].	^ false! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/21/1998 14:12'!hasScriptReferencing: scriptName ofPlayer: aPlayer	"Answer whether the receiver bears any script that references a slot of the given name for  the given player"	self allScriptEditors do:		[:anEditor | (anEditor hasScriptReferencing: scriptName ofPlayer: aPlayer) ifTrue: [^ true]].	^ false! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/3/1998 14:34'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aString aMenu reply |	aString _ aSlotName asString, ' (', (self typeForSlot: aSlotName asSymbol), ')'.	(self slotInfo includesKey: aSlotName asSymbol)		ifTrue:  "User slot"			[aMenu _ SelectionMenu labelList: 				#('change data type'					'remove this instance variable'					'rename this instance variable')			selections: #(chooseSlotType removeSlot renameSlot).			reply _ aMenu startUpWithCaption: aString.			reply == nil ifTrue: [^ self].			reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: aSlotName asSymbol].			reply == #removeSlot ifTrue: [^ self removeSlotNamed:  aSlotName asSymbol].			reply == #renameSlot ifTrue: [^ self renameSlot: aSlotName asSymbol]].	aString _ aString, (String with: Character cr), (ScriptingSystem helpStringFor: aSlotName).	self inform: aString! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/1/1998 15:05'!instantiatedUserScriptsDo: aBlock	self costume instantiatedUserScriptsDo: aBlock! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/13/1998 16:17'!maxPartsBankNumber	^ 5! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/13/1998 10:51'!maxScriptsBankNumber	"later make sensitive to number of user scripts, and more general."	^ self  class namedTileScriptSelectors size > 11		ifTrue:			[5]		ifFalse:			[4]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/11/1998 17:21'!okayToDestroyScriptNamed: scriptName	costume world allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/11/1998 17:20'!okayToRemoveSlotNamed: aSlotName	costume world allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 4/30/1998 13:45'!scriptEditorFor: aSelector	^ (self class userScriptForPlayer: self selector: aSelector) instantiatedScriptEditor bringUpToDate! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/5/1998 00:18'!scriptEvaluatorFor: aSelector phrase: aPhrase	| anEvaluator |	anEvaluator _ ScriptEvaluatorMorph new playerScripted: self.	anEvaluator initializeFor: aPhrase.	^ anEvaluator bringUpToDate! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/1/1998 21:34'!scriptInstantiationForSelector: aSelector	|  entry scriptDict classEntry |	scriptDict _ self actorState instantiatedUserScriptsDictionary.	entry _ scriptDict at: aSelector ifAbsent: [nil].	entry ifNil:		[classEntry _ self class userScriptForPlayer: self selector: aSelector.		entry _ ScriptInstantiation new player: self selector: aSelector status: classEntry status.		entry anonymous: classEntry isAnonymous.		scriptDict at: aSelector put: entry].	^ entry! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 5/6/1998 16:55'!tileScriptCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>	Currently, put up to five on the first bank, the rest on the second"	| sortedNames aList scriptCount |	sortedNames _ self class namedTileScriptSelectors asSortedArray.  "perhaps too jarring"	scriptCount _ sortedNames size.	aBank == 1		ifTrue:			[aList _ (1 to: (scriptCount min: 3)) collect:				[:i | Array with: #command with: (sortedNames at: i)]].	aBank == 2		ifTrue:			[aList _ (4 to: (scriptCount  min: 6)) collect:				[:i | Array with: #command with: (sortedNames at: i)]].	aBank == 3		ifTrue:			[aList _ (7 to: (scriptCount min: 11)) collect:				[:i | Array with: #command with: (sortedNames at: i)]].	aBank == 4		ifTrue:			[aList _ (12 to: scriptCount) collect:				[:i | Array with: #command with: (sortedNames at: i)]].	^ aList asArray! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 2/1/98 00:31'!typedCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>"	^ (self standardCommandsForBank: aBank), (self tileScriptCommandsForBank: aBank)! !!Player methodsFor: 'scripts-execution' stamp: 'sw 5/13/1998 13:10'!assureEventHandlerRepresentsStatus	self instantiatedUserScriptsDo:			[:aScriptInst | aScriptInst assureEventHandlerRepresentsStatus]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 4/30/1998 13:58'!runAllTickingScripts	self instantiatedUserScriptsDo: [:aScriptInstantiation | aScriptInstantiation runIfTicking]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 1/31/98 01:50'!scriptPerformer	^ self! !!Player methodsFor: 'scripts-execution' stamp: 'sw 5/13/1998 16:04'!startRunning	costume startStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 5/2/1998 13:48'!startRunningScripts	self startRunning.	costume startStepping.  "emergency patch, if not going already"	costume presenter startRunningScripts! !!Player methodsFor: 'scripts-execution' stamp: 'sw 2/12/98 13:46'!step	self runAllTickingScripts! !!Player methodsFor: 'scripts-execution' stamp: 'sw 2/12/98 13:48'!stopProgramatically	"stop running my ticking scripts -- called from running code"	self instantiatedUserScriptsDo:		[:aUserScript | aUserScript stopTicking]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 2/12/98 14:51'!stopRunning	self stopProgramatically! !!Player methodsFor: 'scripts-standard' stamp: 'jm 5/20/1998 21:01'!beep: soundName	self playSoundNamed: soundName.! !!Player methodsFor: 'scripts-standard' stamp: 'jm 4/24/1998 22:49'!bounce: soundName	| box bounced |	costume ifNil: [^ self].	(costume owner == nil or: [costume owner isHandMorph]) ifTrue: [^ self].	box _ costume owner bounds.	bounced _ false.	(costume left < box left)			ifTrue: [self headRight. bounced _ true].	(costume right > box right)		ifTrue: [self headLeft. bounced _ true].	(costume top < box top)			ifTrue: [self headDown. bounced _ true].	(costume bottom > box bottom)	ifTrue: [self headUp. bounced _ true].	bounced ifTrue: [^ self makeBounceSound: soundName].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 4/29/1998 16:03'!forward: dist	| rho radians delta didStray p fractionalP newP |	costume isInWorld ifFalse: [^ self].	costume isWorldOrHandMorph ifTrue: [^ self].	rho _ (costume asNumber: dist) asFloat.	radians _ (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta _ (radians cos @ radians sin) * rho.	((costume owner isHandMorph not) and:	 [costume presenter fenceEnabled]) ifTrue:		[(costume owner bounds containsRect: costume bounds) ifFalse:			["If I stray out of the bounds of my owner, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray _ false.			((costume left < costume owner left and: [delta x < 0]) or:			 [costume right > costume owner right and: [delta x > 0]]) ifTrue: [				delta _ delta x negated @ delta y.				didStray _ true].			((costume top < costume owner top and: [delta y < 0]) or:			 [costume bottom > costume owner bottom and: [delta y > 0]]) ifTrue: [				delta _ delta x @ delta y negated.				didStray _ true].			didStray ifTrue: [costume makeFenceSound]]].	"use and record the fractional position"	p _ costume referencePosition asFloatPoint.	fractionalP _ costume actorState fractionalPosition.	(fractionalP == nil or: [(fractionalP - p) abs >= (1@1)])		ifTrue: [newP _ p + delta]		ifFalse: [newP _ p + (fractionalP - p) + delta].	costume actorState fractionalPosition: newP.	costume referencePosition: newP rounded.! !!Player methodsFor: 'scripts-standard' stamp: 'sw 5/3/1998 18:42'!goToRightOf: aPlayer	| hisCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(hisCostume _ aPlayer costume) isInWorld ifFalse: [^ self].	(costume owner == hisCostume owner) ifFalse:		[hisCostume owner addMorphFront: costume].	costume position:		(hisCostume bounds rightCenter - (0 @ (costume height // 2)))! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/14/98 23:35'!hide	costume hide! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/21/98 23:23'!moveToward: aPlayer	| angle |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(costume bounds intersects: aPlayer costume bounds) ifTrue: [^ self].	angle _ costume referencePosition bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'sw 4/22/1998 13:47'!setPenDown: aBoolean	self actorState setPenDown: aBoolean! !!Player methodsFor: 'scripts-standard' stamp: 'sw 4/22/1998 13:45'!setPenSize: aSize	self actorState setPenSize: aSize! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/14/98 23:35'!show	costume show! !!Player methodsFor: 'scripts-standard' stamp: 'sw 5/5/1998 00:06'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)			(command stopProgramatically))].	(aBank == 3 and: [costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 5/13/1998 19:13'!turn: degrees	degrees ifNotNil:		[self setHeading: (self getHeading + degrees asFloat) \\ 360.0]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 2/4/98 20:53'!wrap	costume wrap! !!Player methodsFor: 'misc' stamp: 'sw 4/13/1998 22:36'!actorState	^ costume actorState! !!Player methodsFor: 'misc' stamp: 'sw 4/25/1998 12:51'!basicType	"number string boolean player collection sound color etc"	^ #player! !!Player methodsFor: 'misc' stamp: 'sw 2/1/98 01:29'!beNotZero: aNumber	"This is a runtime check if the arg to divide in a script is zero.  If it is, put up a message from M. Mouse.  Return 0.001 instead of 0.  Note the time.  If fails again within 1 min., don't tell the user again."	aNumber = 0 ifFalse: [^ aNumber].	"normal case"	"We have a problem"	TimeOfError 		ifNil: [TimeOfError _ Time totalSeconds]		ifNotNil: [(Time totalSeconds - TimeOfError) > 45 ifTrue: [			TimeOfError _ Time totalSeconds.	"in case user interrupt and reenter"			PopUpMenu inform: 'Dividing by zero makes a number too large for even a Sorcerer to handle.  Please change your script.  					-- M. Mouse'.			TimeOfError _ Time totalSeconds]].	^ 0.001! !!Player methodsFor: 'misc' stamp: 'sw 2/1/98 02:36'!color	^ self costume color! !!Player methodsFor: 'misc' stamp: 'sw 2/10/98 12:40'!color: myColor sees: externalColor	^ costume color: myColor sees: externalColor! !!Player methodsFor: 'misc' stamp: 'sw 4/13/1998 19:43'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self externalName ifNil: ['An unaffiliated Player'] ifNotNil: [self externalName]! !!Player methodsFor: 'misc' stamp: 'sw 1/29/98 21:53'!dummy! !!Player methodsFor: 'misc' stamp: 'sw 5/6/1998 12:27'!isFlagshipForClass	^ self class flagshipInstance == self! !!Player methodsFor: 'misc' stamp: 'sw 5/4/1998 00:16'!lastEvent	"A convenience for user scripts written in Squeak to call"	^ costume primaryHand lastEvent! !!Player methodsFor: 'misc' stamp: 'jm 5/16/1998 10:38'!makeBounceSound: soundName	costume world soundsEnabled		ifTrue: [self playSoundNamed: soundName].! !!Player methodsFor: 'misc' stamp: 'sw 4/27/1998 00:14'!noteDeletionOf: aMorph fromWorld: aWorld	"aMorph, while pointing to me as its costumee, has been deleted"	"This may be too aggressive because deletion of a morph may not really mean deletion of its associated player -- in light of hoped-for multiple viewing"	| viewers scriptors |	viewers _ OrderedCollection new.	scriptors _ OrderedCollection new.	aWorld allMorphs do:		[:m | (m isKindOf: PartsViewer) ifTrue: [viewers add: m].			((m isKindOf: ScriptEditorMorph) and: [m myMorph == aMorph])				ifTrue: [scriptors add: m]].	viewers do: [:v |  v noteDeletionOf: aMorph].	scriptors do: [:s | s privateDelete] ! !!Player methodsFor: 'misc' stamp: 'sw 2/15/98 12:54'!owner	"Answer the player who wears my costume's owner as its costume"	| itsOwner |	costume ifNotNil:		[(itsOwner _ costume owner) ifNotNil:			[^ itsOwner costumee]].	^ nil! !!Player methodsFor: 'misc' stamp: 'sw 5/4/1998 00:18'!presenter	"Convenience for calling from user scripts"	^ costume presenter! !!Player methodsFor: 'misc' stamp: 'sw 5/4/1998 01:43'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' (', self asOop printString, ')').	costume ifNil: [aStream nextPutAll: ' (with nil costume)'.  ^ self].	aStream nextPutAll: ' named ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 5/21/1998 14:26'!renderedCostumeRespondsTo: aSelector	^ costume renderedMorph respondsTo: aSelector! !!Player methodsFor: 'misc' stamp: 'sw 4/23/1998 12:37'!standardHolder	^ costume ifNil: [nil] ifNotNil:		[costume presenter ifNil: [nil] ifNotNil: [costume presenter standardHolder]]! !!Player methodsFor: 'misc' stamp: 'sw 2/14/98 18:32'!tearOffTileForSelf	costume world primaryHand attachMorph: self tileReferringToSelf! !!Player methodsFor: 'misc' stamp: 'sw 4/28/1998 00:25'!tileReferringToSelf	| aTile |	aTile _ TileMorph new		setObjectRef: nil "disused parm" actualObject: self;		typeColor: (TilePadMorph colorForType: #player).	self costume presenter coloredTilesEnabled ifFalse: [aTile useUniformTileColor].	^ aTile! !!Player methodsFor: 'misc' stamp: 'sw 4/9/98 21:56'!unusedScriptName	"answer a name of the form 'sssScriptN', where N is one higher than the highest-numbered similarly-named script"	| highestThus aPair |	highestThus _ 0.	self class tileScriptNames do:		[:aName |			aPair _ aName stemAndNumericSuffix.			aPair first = 'xxxScript' ifTrue: [highestThus _ highestThus max: aPair last]].	^ ('xxxScript', (highestThus + 1) printString) asSymbol! !!Player methodsFor: 'misc' stamp: 'sw 4/26/1998 11:22'!updateAllViewers	"The receiver's structure has changed, so viewers on it need to be reconstituted."	| aPresenter viewers |	(aPresenter _ self costume presenter) ifNil: [^ self].	viewers _ self costume world allMorphs select:		[:m | (m isKindOf: PartsViewer) and: [m scriptedPlayer == self]].	viewers do: [:m | aPresenter updatePartsViewer: m]	"overkill, removes player from viewer cache repeatedly"! !!Player methodsFor: 'misc' stamp: 'sw 2/1/98 02:36'!width	^ self costume width! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Player class	instanceVariableNames: 'scripts slotInfo costumeDictionary '!!Player class methodsFor: 'initialization' stamp: 'sw 5/6/1998 12:29'!copyStateFrom: anotherClass	| dupScript |	self copyAddedStateFrom: anotherClass.  "being the reference table stored in inst vars of the class"	scripts _ IdentityDictionary new.	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]].	slotInfo _ anotherClass slotInfo deepCopy! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 5/6/1998 12:27'!flagshipInstance	^ self someInstance  "The first one created is the real deal"! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 5/6/1998 12:16'!initialInstance	self == Player ifTrue: [self error: 'must not instantiate naked Player'].	^ super initialInstance! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 4/9/98 21:49'!tileScriptNames	scripts ifNil: [^ OrderedCollection new].	^ scripts collect: [:aScript | aScript selector]! !!Player class methodsFor: 'slots' stamp: 'sw 4/8/98 11:58'!slotInfo	slotInfo ifNil: [slotInfo _ IdentityDictionary new].	^ slotInfo! !!Player class methodsFor: 'other' stamp: 'sw 2/4/98 00:06'!acceptsLoggingOfCompilation	"Dont log sources for my automatically-generated subclasses.  Can easily switch this back when it comes to deal with Versions, etc."	^ self == Player! !!Player class methodsFor: 'other' stamp: 'jm 5/20/1998 20:54'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are otherwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have not references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c |		((c name asString beginsWith: 'Player') and:		 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0])			ifTrue: [Smalltalk removeKey: c name ifAbsent: []. false]			ifFalse: [true]].	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not]) ifTrue: [			newSubclasses add: c.			Smalltalk at: c name put: c]].	subclasses _ newSubclasses.	SystemOrganization removeMissingClasses.! !!Player class methodsFor: 'other' stamp: 'tk 3/15/98 20:23'!officialClass	"We want to make a new instance of the receiver, which is a subclass of Player.  Answer who to make a new subclass of.  Also used to tell if a given class is a UniClass, existing only for its single instance."	^ Player! !!Player class methodsFor: 'other' stamp: 'sw 3/23/98 12:37'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval _ candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystem].	^ Smalltalk garbageCollect - oldFree! !!Player class methodsFor: 'other' stamp: 'sw 2/13/98 23:33'!wantsChangeSetLogging	"Log changes for Player itself, but not for automatically-created subclasses like Player1, Player2"	^ self == Player or:		[(self class name beginsWith: 'Player') not]! !!Player class methodsFor: 'costume' stamp: 'sw 4/8/98 12:06'!costumeAt: aCostumeName ifAbsent: aBlock	costumeDictionary ifNil: [^ aBlock value].	^ costumeDictionary at: aCostumeName ifAbsent: [aBlock value]! !!Player class methodsFor: 'costume' stamp: 'sw 4/8/98 12:05'!costumeDictionary	costumeDictionary ifNil: [costumeDictionary _ Dictionary new].	^ costumeDictionary! !!Player class methodsFor: 'costume' stamp: 'sw 4/8/98 12:06'!costumesDo: aBlock	self costumeDictionary size > 0 ifTrue: [costumeDictionary do: aBlock]! !!Player class methodsFor: 'scripts' stamp: 'sw 5/8/1998 13:40'!anonymousUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializeAnonymousScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 5/6/1998 12:27'!atSelector: aSelector putScriptEditor: aScriptEditor	| selSym  aUserScript |	selSym _ aSelector asSymbol.	scripts ifNil: [scripts _ IdentityDictionary new].	aUserScript _ scripts at: selSym ifAbsent: [nil].	aUserScript ifNil:		[aUserScript _ UserScript new player: self flagshipInstance selector: selSym.		scripts at: selSym put: aUserScript].	aUserScript currentScriptEditor: aScriptEditor! !!Player class methodsFor: 'scripts' stamp: 'sw 4/9/98 21:55'!jettisonScripts	scripts _ IdentityDictionary new! !!Player class methodsFor: 'scripts' stamp: 'sw 4/9/98 21:58'!namedTileScriptSelectors	scripts ifNil: [^ OrderedCollection new].	^ scripts select: [:aScript | (aScript isAnonymous not) & (aScript selector ~~ nil)] 		thenCollect: [:aScript | aScript selector]! !!Player class methodsFor: 'scripts' stamp: 'sw 4/9/98 21:52'!removeScriptNamed: aScriptName	aScriptName ifNotNil:		[scripts removeKey: aScriptName.		self removeSelector: aScriptName]! !!Player class methodsFor: 'scripts' stamp: 'sw 5/19/1998 09:44'!scripts	scripts ifNil: [scripts _ IdentityDictionary new].	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'sw 5/1/1998 21:51'!userScriptForPlayer: aPlayer selector: aSelector	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ scripts at: aSelector ifAbsent: [nil].	entry ifNil:		[entry _ UserScript new player: aPlayer selector: aSelector.		scripts at: aSelector put: entry].	^ entry! !!Player class methodsFor: 'scripts' stamp: 'sw 4/14/1998 01:16'!userScriptsDo: aBlock	self scripts do:		[:aUserScript | aBlock value: aUserScript]! !!Player class methodsFor: 'namespace' stamp: 'sw 4/27/1998 23:39'!compileReferenceAccessorFor: varName	self class compile: ((self referenceAccessorSelectorFor: varName), '	^ ', varName)		classified: 'reference' notifying: nil! !!Player class methodsFor: 'namespace' stamp: 'sw 4/27/1998 23:42'!makeReferenceFor: anObject	| stem otherNames i partName |	stem _ anObject class name.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem _ stem copyFrom: 1 to: stem size - 5].	stem _ stem first asLowercase asString, stem allButFirst.	otherNames _ self class allInstVarNames.	i _ 1.	[otherNames includes: (partName _ stem, i printString)]		whileTrue: [i _ i + 1].	self class addInstVarName: partName.	self instVarAt: self class instSize put: anObject.  "assumes added as last field"	self compileReferenceAccessorFor: partName.	^ self referenceAccessorSelectorFor: partName! !!Player class methodsFor: 'namespace' stamp: 'sw 4/27/1998 23:38'!referenceAccessorSelectorFor: varName	^ 'ref', (varName asString capitalized)! !!Player class methodsFor: 'namespace' stamp: 'sw 4/28/1998 00:03'!referenceSelectorFor: anObject	self class instVarNames do:  "Just those added in the unique subclass"		[:aName | (self instVarNamed: aName) == anObject			ifTrue:				[^ self referenceAccessorSelectorFor: aName]].	^ self makeReferenceFor: anObject! !ThumbnailMorph subclass: #PlayerReferenceReadout	instanceVariableNames: 'putSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Support'!!PlayerReferenceReadout commentStamp: 'di 5/22/1998 16:37' prior: 0!A thumbnail that serves as the value readout for a player-valued slot in a Viewer.  Clicking on it allows the user to select a new object for the slot to point to. !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 4/26/1998 02:02'!handlesMouseDown: evt	"Allow the user to respecify this by direct clicking"	^ true! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 5/13/1998 18:27'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredCostumee.	self changed! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 4/26/1998 02:07'!objectToView: objectOrNil viewSelector: aSelector putSelector: aPutSelector	self objectToView: objectOrNil viewSelector: aSelector.	putSelector _ aPutSelector! !AbstractSound subclass: #PluckedSound	instanceVariableNames: 'initialCount count ring scaledIndex scaledIndexIncr scaledIndexLimit '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!PluckedSound commentStamp: 'di 5/22/1998 16:37' prior: 0!The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string. Fractional indexing is used to allow precise tuning; without this, the pitch would be rounded to the pitch corresponding to the nearest buffer size.!!PluckedSound methodsFor: 'initialization' stamp: 'jm 1/31/98 15:07'!setPitch: p dur: d loudness: vol	| sz |	super setPitch: p dur: d loudness: vol.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 1/5/98 18:29'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 12/17/97 21:35'!reset	"Fill the ring with random noise."	| seed n |	super reset.	seed _ 17.	n _ ring monoSampleCount.	1 to: n do: [:i |		seed _ ((seed * 1309) + 13849) bitAnd: 65535.		ring at: i put: seed - 32768].	count _ initialCount.	scaledIndex _ ScaleFactor.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 11/26/97 10:51'!samplesRemaining	^ count! !!PluckedSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	^ super copy copyRing! !!PluckedSound methodsFor: 'copying' stamp: 'jm 11/4/97 08:25'!copyRing	"Private!! Support for copying"	ring _ ring copy.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluckedSound class	instanceVariableNames: ''!!PluckedSound class methodsFor: 'instruments' stamp: 'jm 1/31/98 16:32'!default	"PluckedSound default play"	"(AbstractSound majorScaleOn: PluckedSound default) play"	| snd p env |	snd _ PluckedSound new.	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 20@0.0.	env _ VolumeEnvelope points: p loopStart: 2 loopEnd: 2.	env target: snd; scale: 0.3.	^ snd		addEnvelope: env;		setPitch: 220 dur: 3.0 loudness: 0.3! !Controller subclass: #PluggableButtonController	instanceVariableNames: 'selector arguments '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableButtonController commentStamp: 'di 5/22/1998 16:37' prior: 0!The controller for Buttons.  Not meant to be used with buttons that have mouseOver feeback when the button is not pressed.  Use mouseEnter/mouseLeave for that. !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'tk 4/29/1998 11:45'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback].! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'jm 4/5/98 12:52'!controlTerminate 	"Reverse the feedback displayed by controlInitialize, if any. Perform the button action if necessary."	view triggerOnMouseDown ifFalse: [		view toggleMouseOverFeedback.		self viewHasCursor ifTrue: [view performAction]].! !!PluggableButtonController methodsFor: 'control defaults'!controlActivity 	^ self! !!PluggableButtonController methodsFor: 'control defaults'!isControlActive 	^ sensor anyButtonPressed & self viewHasCursor! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'tk 4/29/1998 10:47'!isControlWanted	"sensor flushKeyboard."	self viewHasCursor & sensor anyButtonPressed ifFalse: [^ false].	view askBeforeChanging		ifTrue: [^ model okToChange]  "ask before changing"		ifFalse: [^ true].! !!PluggableButtonController methodsFor: 'button activity' stamp: 'tk 4/29/1998 11:30'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !AlignmentMorph subclass: #PluggableButtonMorph	instanceVariableNames: 'model label getStateSelector actionSelector getLabelSelector getMenuSelector shortcutCharacter askBeforeChanging triggerOnMouseDown offColor onColor feedbackColor showSelectionFeedback allButtons '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableButtonMorph commentStamp: 'di 5/22/1998 16:37' prior: 0!A PluggableButtonMorph is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the model		getLabelSelector		fetch this button's lable from the model		getMenuSelector		fetch a pop-up menu for this button from the modelAny of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs its view(s) of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.Options:	askBeforeChanging		have model ask user before allowing a change that could lose edits	triggerOnMouseDown	do this button's action on mouse down (vs. up) transition	shortcutCharacter		a place to record an optional shortcut key!!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'jm 5/4/1998 22:49'!initialize 	super initialize.	orientation _ #vertical.	hResizing _ vResizing _ #spaceFill.	centering _ #center.	borderWidth _ 1.	model _ nil.	label _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	color _ Color lightGreen.	onColor _ color darker.	offColor _ color.	feedbackColor _ Color red.	showSelectionFeedback _ false.	allButtons _ nil.	self extent: 20@15.! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'jm 5/4/1998 17:53'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	getLabelSelector _ labelSel.	getMenuSelector _ menuSel.	self update: labelSel.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 18:53'!askBeforeChanging	^ askBeforeChanging! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging _ aBoolean.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 17:47'!feedbackColor: aColor	"Set the color of this button's selection feedback border."	feedbackColor _ aColor.	self changed.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 17:38'!label	"Answer the DisplayObject used as this button's label."	^ label! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'di 5/6/1998 21:10'!label: aStringOrTextOrMorph	"Label this button with the given string or morph."	| r |	self removeAllMorphs.	"nest label in a row for centering"	r _ AlignmentMorph newRow		borderWidth: 0;		inset: 0;		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		centering: #center.	aStringOrTextOrMorph isMorph		ifTrue: [			label _ aStringOrTextOrMorph.			r addMorph: aStringOrTextOrMorph]		ifFalse: [			label _ aStringOrTextOrMorph asString.			r addMorph: (StringMorph contents: label)].	self addMorph: r.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 16:52'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 16:29'!onColor: colorWhenOn offColor: colorWhenOff	"Set the fill colors to be used when this button is on/off."	onColor _ colorWhenOn.	offColor _ colorWhenOff.	self update: nil.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter	"Return the Character to be used as a shortcut to turn on this switch, or nil if this switch doesn't have a keyboard shortcut."	^ shortcutCharacter! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter _ aCharacter.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 19:26'!triggerOnMouseDown	^ triggerOnMouseDown! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown _ aBoolean.! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jm 5/4/1998 17:46'!drawOn: aCanvas 	super drawOn: aCanvas.	showSelectionFeedback ifTrue: [		aCanvas frameRectangle: self innerBounds width: 2 color: feedbackColor].! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/4/1998 16:57'!handlesMouseDown: evt	^ true! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/20/1998 11:49'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	allButtons _ nil.	evt yellowButtonPressed ifTrue: [^ self invokeMenu: evt].	triggerOnMouseDown		ifTrue: [self performAction]		ifFalse: [			allButtons _ owner submorphs select: [:m | m class = self class].			self updateFeedbackForEvt: evt].! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/4/1998 17:30'!mouseMove: evt	allButtons ifNil: [^ self].	allButtons do: [:m | m updateFeedbackForEvt: evt].! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/4/1998 17:33'!mouseUp: evt	showSelectionFeedback _ false.	allButtons ifNil: [^ self].	allButtons do: [:m |		(m containsPoint: evt cursorPoint) ifTrue: [m performAction]].	allButtons _ nil.	self changed.! !!PluggableButtonMorph methodsFor: 'events' stamp: 'jm 5/4/1998 17:22'!updateFeedbackForEvt: evt	| newState |	newState _ self containsPoint: evt cursorPoint.	newState = showSelectionFeedback ifFalse: [		showSelectionFeedback _ newState.		self changed].! !!PluggableButtonMorph methodsFor: 'updating' stamp: 'jm 5/4/1998 17:53'!update: aParameter 	getLabelSelector ifNotNil: [		aParameter == getLabelSelector ifTrue: [			self label: (model perform: getLabelSelector)]].	self getModelState		ifTrue: [self color: onColor]		ifFalse: [self color: offColor].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:34'!getMenu: evt	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: evt shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 4/4/98 20:50'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	getStateSelector == nil		ifTrue: [^ false]		ifFalse: [^ model perform: getStateSelector].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 5/20/1998 11:51'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt.	menu ifNotNil: [		menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jm 4/2/98 19:50'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."	actionSelector ifNotNil: [model perform: actionSelector].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableButtonMorph class	instanceVariableNames: ''!!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/4/1998 15:28'!on: anObject getState: getStateSel action: actionSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: nil		menu: nil! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/4/1998 15:28'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/4/1998 15:29'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: menuSel! !!PluggableButtonMorph class methodsFor: 'example' stamp: 'jm 5/7/1998 13:21'!example	"PluggableButtonMorph example"	| s1 s2 s3 b1 b2 b3 row |	s1 _ Switch new.	s2 _ Switch new turnOn.	s3 _ Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 _ (PluggableButtonMorph on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 _ (PluggableButtonMorph on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 _ (PluggableButtonMorph on: s3 getState: #isOn action: #turnOn) label: 'S3'.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		addAllMorphs: (Array with: b1 with: b2 with: b3);		extent: 120@35.	^ row! !View subclass: #PluggableButtonView	instanceVariableNames: 'label getStateSelector actionSelector getLabelSelector getMenuSelector shortcutCharacter askBeforeChanging triggerOnMouseDown complemented '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableButtonView commentStamp: 'di 5/22/1998 16:37' prior: 0!A PluggableButtonView is a combination of an indicator for a boolean value stored in its model and an action button. The action of a button is often, but not always, to toggle the boolean value that it shows. Its pluggable selectors are:		getStateSelector		fetch a boolean value from the model		actionSelector		invoke this button's action on the modelEither of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if getStateSelector is nil, then this button shows the state of a read-only boolean that is always false.The model informs a pluggable view of changes by sending #changed: to itself with getStateSelector as a parameter. The view tells the model when the button is pressed by sending actionSelector.Options:	askBeforeChanging		have model ask user before allowing change that could lose edits	triggerOnMouseDown	do button action on mouse down (vs. up) transition	shortcutCharacter		a place to record an optional shortcut key!!PluggableButtonView methodsFor: 'initialize-release' stamp: 'jm 5/2/1998 15:20'!initialize 	super initialize.	label _ nil.	getStateSelector _ nil.	actionSelector _ nil.	getLabelSelector _ nil.	getMenuSelector _ nil.	shortcutCharacter _ nil.	askBeforeChanging _ false.	triggerOnMouseDown _ false.	complemented _ false.! !!PluggableButtonView methodsFor: 'initialize-release' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self initialize.	self model: anObject.	getStateSelector _ getStateSel.	actionSelector _ actionSel.	getLabelSelector _ labelSel.	getMenuSelector _ menuSel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 18:53'!askBeforeChanging	^ askBeforeChanging! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging _ aBoolean.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:38'!label	"Answer the DisplayObject used as this button's label."	^ label! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/4/98 20:28'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	(aStringOrDisplayObject isKindOf: String)		ifTrue: [label _ aStringOrDisplayObject asParagraph]		ifFalse: [label _ aStringOrDisplayObject].	self centerLabel.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter	"Return the Character to be used as a shortcut to turn on this switch, or nil if this switch doesn't have a keyboard shortcut."	^ shortcutCharacter! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter _ aCharacter.! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/2/98 19:26'!triggerOnMouseDown	^ triggerOnMouseDown! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown _ aBoolean.! !!PluggableButtonView methodsFor: 'controller access' stamp: 'jm 4/2/98 17:39'!defaultControllerClass 	^ PluggableButtonController! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:49'!deEmphasizeView 	self getModelState ifTrue: [self displayNormal].! !!PluggableButtonView methodsFor: 'displaying'!display	"Sets the PluggableButtonView mode to 'normal', displays the border, displays the inside and, if its model is 'on', complements the inside."	self displayBorder.	self displayView.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:49'!displayComplemented	"Complement the receiver if it isn't already."	complemented ifFalse: [		complemented _ true.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:43'!displayNormal	"Complement the receiver if its mode is 'complemented'."	complemented ifTrue: [		complemented _ false.		Display reverse: self insetDisplayBox].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/2/98 18:27'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display			transformation: self displayTransformation			clippingBox: self insetDisplayBox			fixedPoint: label boundingBox center].	complemented _ false.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/4/98 20:41'!emphasizeView 	self getModelState ifTrue: [self displayComplemented].! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 4/5/98 12:54'!toggleMouseOverFeedback	"Complement the label (or a portion of the displayBox if no label is defined) to show that the mouse is over this button. This feedback can be removed by a second call to this method."	Display reverse: self insetDisplayBox fillColor: Color gray.	Display reverse: (self insetDisplayBox insetBy: 2) fillColor: Color gray.! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!defaultWindow	"Return a rectangle large enough to contain this button's label. If this button is label-less, just return the standard View default window."	label == nil		ifTrue: [^ super defaultWindow]		ifFalse: [^ label boundingBox expandBy: 6].! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/2/98 19:50'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."	actionSelector ifNotNil: [model perform: actionSelector].! !!PluggableButtonView methodsFor: 'other' stamp: 'tk 4/27/1998 21:23'!update: aParameter 	aParameter == getLabelSelector ifTrue: [		getLabelSelector ifNotNil: [			self label: (model perform: getLabelSelector).			self displayView]].	self getModelState 		ifTrue: [self displayComplemented]		ifFalse: [self displayNormal].! !!PluggableButtonView methodsFor: 'other' stamp: 'jm 4/7/98 19:12'!window: aWindow	"Center my label when my window changes."	super window: aWindow.	self centerLabel.! !!PluggableButtonView methodsFor: 'private' stamp: 'jm 4/2/98 17:42'!centerLabel	"Align the center of the label with the center of the receiver's window."	| alignPt |	label ifNotNil: [		alignPt _ label boundingBox center.		(label isKindOf: Paragraph) ifTrue: [			alignPt _ alignPt + (0@1)].  "compensate for leading in default style"		label align: alignPt with: self getWindow center].! !!PluggableButtonView methodsFor: 'private' stamp: 'jm 5/2/1998 14:40'!getMenu	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: Sensor leftShiftDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'jm 4/4/98 20:50'!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	getStateSelector == nil		ifTrue: [^ false]		ifFalse: [^ model perform: getStateSelector].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableButtonView class	instanceVariableNames: ''!!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: nil		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:19'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'tk 4/29/1998 11:18'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: menuSel! !!PluggableButtonView class methodsFor: 'example' stamp: 'jm 4/7/98 19:55'!example	"PluggableButtonView example"	| s1 s2 s3 b1 b2 b3 topView |	s1 _ Switch new.	s2 _ Switch new turnOn.	s3 _ Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 _ (PluggableButtonView on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 _ (PluggableButtonView on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 _ (PluggableButtonView on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1 borderWidth: 1.	b2 borderWidth: 1.	b3 borderWidth: 1.	topView _ StandardSystemView new		label: 'Switch Test';		addSubView: b1;		addSubView: b2 toRightOf: b1;		addSubView: b3 toRightOf: b2.	topView controller open.! !ListController subclass: #PluggableListController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableListController methodsFor: 'all'!changeModelSelection: anInteger	"Let the view handle this."	view changeModelSelection: anInteger.! !!PluggableListController methodsFor: 'all'!controlActivity	"Overridden to handle keystrokes."	sensor keyboardPressed ifTrue: [view handleKeystroke: sensor keyboard].	super controlActivity.! !!PluggableListController methodsFor: 'all' stamp: 'tk 4/1/98 09:40'!redButtonActivity	model okToChange   "Don't change selection if model refuses to unlock"		ifTrue: [^ super redButtonActivity]! !!PluggableListController methodsFor: 'all' stamp: 'tk 4/4/98 21:06'!yellowButtonActivity	"Invoke the model's menu."	| menu |	menu _ view getMenu.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !PluggableListController subclass: #PluggableListControllerOfMany	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableListControllerOfMany methodsFor: 'as yet unclassified' stamp: 'tk 4/8/98 11:08'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit _ true.	scrollFlag _ false.	lastSelection _ 0.	[sensor redButtonPressed] whileTrue: 		[selection _ view findSelection: (pt _ sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag _ true.				selection _ view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag _ true.				selection _ view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit _ false.				turningOn _ (model listSelectionAt: selection) not].			view selection: selection.			(model listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				model listSelectionAt: selection put: turningOn].			lastSelection _ selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		model listSelectionAt: selection put: (model listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !!PluggableListControllerOfMany methodsFor: 'as yet unclassified' stamp: 'tk 4/8/98 11:09'!scrollView: anInteger 	"Need to minimize the selections which get recomputed"	| oldLimit |	oldLimit _ anInteger > 0		ifTrue: [view firstShown]		ifFalse: [view lastShown].	(view scrollBy: anInteger)		ifTrue: [anInteger > 0  "Highlight selections brought into view"					ifTrue: [view highlightFrom: view firstShown								to: (oldLimit-1 min: view lastShown)]					ifFalse: [view highlightFrom: (oldLimit+1 max: view firstShown)								to: view lastShown].				^ true]		ifFalse: [^ false]! !ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list selectedMorph selection getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableListMorph methodsFor: 'initialization' stamp: 'di 4/10/98 16:20'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!PluggableListMorph methodsFor: 'initialization'!extent: newExtent	super extent: newExtent.	self setScrollDeltas ! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 5/6/1998 21:19'!installModelIn: aWorld	"No special inits for new components"	^ self! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 5/6/1998 21:19'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: (index = 0 ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 5/22/1998 00:32'!listItemHeight	"This should be cleaned up.  The list should get spaced by this parameter."	^ 12! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 5/6/1998 21:20'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.! !!PluggableListMorph methodsFor: 'initialization'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	scrollBar scrollDelta: (scroller firstSubmorph height / range) asFloat 			pageDelta: (self innerBounds height / range) asFloat ! !!PluggableListMorph methodsFor: 'drawing'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) invertRect: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableListMorph methodsFor: 'drawing'!highlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color red]! !!PluggableListMorph methodsFor: 'drawing'!unhighlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color black]! !!PluggableListMorph methodsFor: 'events' stamp: 'di 5/7/1998 12:09'!mouseDown: event onItem: aMorph	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph]! !!PluggableListMorph methodsFor: 'events' stamp: 'di 5/22/1998 00:02'!mouseEnter: event	super mouseEnter: event.	event hand newKeyboardFocus: self! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:21'!maximumSelection	^ list size! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:20'!minimumSelection	^ 1! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:32'!numSelectionsInView	^ self height // self listItemHeight! !!PluggableListMorph methodsFor: 'selection'!selectedMorph: aMorph	self unhighlightSelection.	selectedMorph _ aMorph.	selection _ aMorph ifNil: [nil] ifNotNil: [aMorph contents].	self highlightSelection! !!PluggableListMorph methodsFor: 'selection'!selection 	^ selection! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/6/1998 11:03'!selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list.	Note: won't work right if list includes repeated items"	self selectionIndex: (scroller submorphs findFirst: [:m | m contents = item])! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/6/1998 11:02'!selectionIndex: index	"Called internally to select the index-th item."	| theMorph range |	index ifNil: [^ self].	(theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index])		ifNotNil:		[((theMorph bounds top - scroller offset y) >= 0			and: [(theMorph bounds bottom - scroller offset y) <= bounds height]) ifFalse:			["Scroll into view -- should be elsewhere"			range _ self totalScrollRange.			scrollBar value: (range > 0				ifTrue: [((index-1 * theMorph height) / self totalScrollRange)									truncateTo: scrollBar scrollDelta]				ifFalse: [0]).			scroller offset: -3 @ (range * scrollBar value)]].	self selectedMorph: theMorph! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/6/1998 21:20'!setSelectedMorph: aMorph	self changeModelSelection: (scroller submorphs indexOf: aMorph)! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/6/1998 21:18'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[model perform: setIndexSelector with: anInteger].! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/6/1998 21:18'!getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector == nil ifTrue: [^ 0].	^ model perform: getIndexSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/6/1998 21:19'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/22/1998 00:34'!keyStroke: event	"Process potential command keys"	| args aCharacter |	keystrokeActionSelector == nil ifTrue: [^ nil].	aCharacter _ event keyCharacter.	(args _ keystrokeActionSelector numArgs) = 1		ifTrue: [^ model perform: keystrokeActionSelector with: aCharacter].	args = 2		ifTrue: [^ model perform: keystrokeActionSelector with: aCharacter with: self].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph methodsFor: 'updating' stamp: 'di 5/6/1998 21:21'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue: 		[self list: self getList.		^ self].	aSymbol == getIndexSelector ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableListMorph class	instanceVariableNames: ''!!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/22/1998 00:17'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:		"default"! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/22/1998 00:17'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/6/1998 21:45'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !PluggableListMorph subclass: #PluggableListMorphByItem	instanceVariableNames: 'itemList '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'tk 5/12/1998 10:01'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'tk 5/12/1998 10:01'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector == nil ifTrue: [^ 0].	item _ model perform: getIndexSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'tk 5/12/1998 11:34'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	^ super list: arrayOfStrings! !ListView subclass: #PluggableListView	instanceVariableNames: 'getListSelector getSelectionSelector setSelectionSelector getMenuSelector keystrokeActionSelector autoDeselect '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableListView commentStamp: 'di 5/22/1998 16:37' prior: 0!A pluggable list view gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. Selector usage is:		getListSel		fetch the list of items (strings) to be displayed		getSelectionSel	get the currently selected item		setSelectionSel	set the currently selected item (takes an argument)		getMenuSel		get the pane-specific, 'yellow-button' menu		keyActionSel	process a keystroke typed in this pane (takes an argument)	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. However, if getListSel is nil, the default behavior just provides an empty list, which makes for a rather dull list view!!	The model informs a pluggable view of changes by sending #changed: to itself with getListSel or getSelectionSel as a parameter. The view informs the model of selection changes by sending setSelectionSel to it with the newly selected item as a parameter, and invokes menu and keyboard actions on the model via getMenuSel and keyActionSel.	Pluggability allows a single model object to have pluggable list views on multiple aspects of itself. For example, an object representing one personal music library might be organized as a three-level hierarchy: the types of music, the titles within a given type, and the songs on a given title. Pluggability allows one to easily build a multipane browser for this object with separate list views for the music type, title, and song.	AutoDeselect is a feature, normally set to true, that will tell the model that there is no selection if you click on an item that is currently selected.  If autoDeselect is false, then the model will simply be told to select the same item again.!!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:56'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!PluggableListView methodsFor: 'initialization' stamp: 'di 5/7/1998 00:47'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph withArray: (Array streamContents:		[:s | s nextPut: topDelimiter.		arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].		s nextPut: bottomDelimiter]).	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'tk 4/12/1998 08:25'!menu: getMenuSel	getMenuSelector _ getMenuSel! !!PluggableListView methodsFor: 'initialization' stamp: 'di 4/10/98 09:55'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	| newIndex |	newIndex _ anInteger.	(autoDeselect == nil or: [autoDeselect]) ifTrue:		[getSelectionSelector ifNotNil:			[(model perform: getSelectionSelector) = anInteger ifTrue:				["Click on existing selection deselects"				newIndex _ 0]]].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: newIndex].! !!PluggableListView methodsFor: 'model access' stamp: 'di 5/6/1998 20:52'!getCurrentSelectionIndex	"Answer the index of the current selection."	getSelectionSelector == nil ifTrue: [^ 0].	^ model perform: getSelectionSelector! !!PluggableListView methodsFor: 'model access'!getList 	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListView methodsFor: 'model access' stamp: 'tk 4/2/98 13:36'!getListSelector	^ getListSelector! !!PluggableListView methodsFor: 'model access' stamp: 'di 4/10/98 10:03'!getMenu	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: Sensor leftShiftDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'tk 4/21/1998 08:26'!handleKeystroke: aCharacter	"Answer the menu for this list view."	| args |	keystrokeActionSelector == nil ifTrue: [^ nil].	controller controlTerminate.	(args _ keystrokeActionSelector numArgs) = 1		ifTrue: [model perform: keystrokeActionSelector with: aCharacter.				^ controller controlInitialize].	args = 2		ifTrue: [model perform: keystrokeActionSelector with: aCharacter with: self.				^ controller controlInitialize].	^ self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'controller access' stamp: 'jm 3/11/98 17:17'!defaultControllerClass 	^ PluggableListController! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/17/1998 13:58'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].	aSymbol == #closeScrollBar ifTrue:		[^ controller controlTerminate].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableListView class	instanceVariableNames: ''!!PluggableListView class methodsFor: 'instance creation' stamp: 'tk 4/17/1998 20:41'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation' stamp: 'tk 4/17/1998 20:41'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListView class methodsFor: 'instance creation'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !PluggableListView subclass: #PluggableListViewByItem	instanceVariableNames: 'itemList '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableListViewByItem methodsFor: 'all' stamp: 'di 5/6/1998 16:28'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setSelectionSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setSelectionSelector with: item].! !!PluggableListViewByItem methodsFor: 'all' stamp: 'di 5/6/1998 16:27'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getSelectionSelector == nil ifTrue: [^ 0].	item _ model perform: getSelectionSelector.	^ itemList findFirst: [ :x | x = item]! !!PluggableListViewByItem methodsFor: 'all' stamp: 'di 5/6/1998 16:26'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph withArray: (Array streamContents:		[:s | s nextPut: topDelimiter.		arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].		s nextPut: bottomDelimiter]).	selection _ self getCurrentSelectionIndex.	self positionList.! !PluggableListView subclass: #PluggableListViewOfMany	instanceVariableNames: 'selections '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 15:42'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	selection _ 0.	1 to: self maximumSelection do:		[:i | selection _ i.		(model listSelectionAt: i) ifTrue: [self deEmphasizeSelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 15:42'!highlightFrom: start to: stop	(start == nil or: [stop == nil]) ifTrue: [^ self displayView].	start to: stop do:		[:i | selection _ i.		(model listSelectionAt: selection) ifTrue: [self displaySelectionBox]].	selection _ 0! !!PluggableListViewOfMany methodsFor: 'displaying' stamp: 'tk 4/6/98 20:42'!scrollBy: anInteger	"This is a possible way to intercept what ListOfManyController did to get multiple selections to show.  Feel to replace this."	| ans |	ans _ super scrollBy: anInteger."	self displaySelectionBox."	^ ans! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!moveSelectionBox: anInteger 	"Presumably the selection has changed to be anInteger. Deselect the 	previous selection and display the new one, highlighted."	selection ~= anInteger		ifTrue: 			[selection _ anInteger.			self displaySelectionBox]! !!PluggableListViewOfMany methodsFor: 'selecting' stamp: 'tk 4/6/98 15:43'!selection	"Have to override normal controller smarts about deselection"	^ 0! !!PluggableListViewOfMany methodsFor: 'updating' stamp: 'tk 4/8/98 13:12'!update: aSymbol 	aSymbol == getListSelector		ifTrue: [self list: self getList.			^ self displayView; emphasizeView].	aSymbol == getSelectionSelector		ifTrue: [^ self displayView; emphasizeView].	aSymbol == #allSelections		ifTrue: [^ self displayView; emphasizeView].	^ super update: aSymbol! !!PluggableListViewOfMany methodsFor: 'controller access' stamp: 'di 5/17/1998 22:48'!defaultControllerClass 	^ PluggableListControllerOfMany! !ServerAction subclass: #PluggableServerAction	instanceVariableNames: 'processBlock returnBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!PluggableServerAction commentStamp: 'di 5/22/1998 16:37' prior: 0!A PluggableServerAction instance has two blocks in instance variables. The processBlock is executed with the web request to do any input processing that is needed. The returnBlock is executed with the web request, and its return value is sent as the output of the CGI processing.!!PluggableServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 08:58'!processBlock: aBlock	processBlock := aBlock.! !!PluggableServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 08:59'!returnBlock: aBlock	returnBlock := aBlock.! !!PluggableServerAction methodsFor: 'URL processing' stamp: 'tk 1/31/98 14:40'!process: request	processBlock value: request.	request reply: PWS success; reply: PWS contentHTML, PWS crlf.	request reply: (returnBlock value: request).! !Object subclass: #PluggableTest	instanceVariableNames: 'musicTypeList musicTypeIndex artistList artistIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableTest commentStamp: 'di 5/22/1998 16:37' prior: 0!This class demonstrates how to use PluggableListViews.!!PluggableTest methodsFor: 'initialization' stamp: 'jm 5/3/1998 16:20'!initialize	musicTypeList _ #('reggae' 'classical' 'early').	artistList _ #(		('alpha blondy' 'black uhuru' 'bob marley' 'burning spear')		('bach' 'beethoven' 'josquin' 'morley' 'mozart' 'telemann')		('josquin' 'morley' 'telemann')).	musicTypeIndex _ 0.	artistIndex _ 0.! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist	^ artistIndex! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artist: anInteger	artistIndex _ anInteger.	self changed: #artist.! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:14'!artistKeystroke: aCharacter	self artistList doWithIndex: [:artist :i |		(artist first asLowercase = aCharacter asLowercase) ifTrue: [			self artist: i]].! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:21'!artistList	((musicTypeIndex ~= nil) and:	 [musicTypeIndex between: 1 and: artistList size])		ifTrue: [^ artistList at: musicTypeIndex]		ifFalse: [^ #()].! !!PluggableTest methodsFor: 'artist pane' stamp: 'jm 5/3/1998 16:20'!artistName	"Answer the name of the currently selected artist, or nil if no artist is selected."	| artistsForCurrentType |	artistsForCurrentType _ self artistList.	(artistIndex between: 1 and: artistsForCurrentType size)		ifTrue: [^ artistsForCurrentType at: artistIndex]		ifFalse: [^ nil].! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType	^ musicTypeIndex! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicType: anInteger	| oldArtist |	oldArtist _ self artistName.	musicTypeIndex _ anInteger.  "this changes artists list"	artistIndex _ self artistList indexOf: oldArtist.	self changed: #musicType.	self changed: #artistList.! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/2/1998 15:18'!musicTypeKeystroke: aCharacter	musicTypeList doWithIndex: [:type :i |		(type first asLowercase = aCharacter asLowercase)			ifTrue: [self musicType: i]].! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:11'!musicTypeList	^ musicTypeList! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:00'!musicTypeMenu: aMenu	^ aMenu addList: #(		(reggae reggaeCmd)		(early earlyCmd)		(grunge grungeCmd)		-		(flash flashCmd))! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 5/3/1998 16:21'!musicTypeName	"Answer the name of the currently selected music type, or nil if no music type is selected."	(musicTypeIndex between: 1 and: musicTypeList size)		ifTrue: [^ musicTypeList at: musicTypeIndex]		ifFalse: [^ nil].! !!PluggableTest methodsFor: 'menu commands' stamp: 'jm 5/3/1998 16:00'!earlyCmd	self musicType: (musicTypeList indexOf: 'early').! !!PluggableTest methodsFor: 'menu commands'!flashCmd	Display reverse; reverse.! !!PluggableTest methodsFor: 'menu commands'!grungeCmd	SelectionMenu confirm:		'You mean, like those strange bands from Seattle?'! !!PluggableTest methodsFor: 'menu commands' stamp: 'jm 5/3/1998 15:59'!reggaeCmd	self musicType: (musicTypeList indexOf: 'reggae').! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTest class	instanceVariableNames: ''!!PluggableTest class methodsFor: 'example' stamp: 'di 5/6/1998 20:58'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	listView2 _		PluggableListView on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open.! !StringHolderController subclass: #PluggableTextController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableTextController methodsFor: 'all' stamp: 'di 5/7/1998 13:43'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	(view setText: paragraph text from: self) ifTrue:		[initialText _ paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!PluggableTextController methodsFor: 'all' stamp: 'tk 4/6/98 10:41'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = startBlock stringIndex and: [stop + 1 = stopBlock stringIndex]) ifFalse:		[view superView ifNotNil: [self deselect].		self selectInvisiblyFrom: start to: stop].	view superView ifNotNil: [self selectAndScroll]! !!PluggableTextController methodsFor: 'all' stamp: 'tk 3/31/98 17:19'!shiftedYellowButtonActivity	"Invoke the model's menu."	| menu sel |	menu _ view getMenuShifted.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			model doMenuItem: sel paneID: view getTextSelector from: self].! !!PluggableTextController methodsFor: 'all' stamp: 'tk 3/31/98 20:49'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!PluggableTextController methodsFor: 'all' stamp: 'tk 3/31/98 20:49'!userHasNotEdited	"Note that my text is free of user edits."	view hasUnacceptedEdits: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 4/11/98 11:41'!yellowButtonActivity	"Invoke the model's menu."	| menu sel |	menu _ view getMenu.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/13/1998 14:27'!appendEntry	"Append the text in the model's writeStream to the editable text. "	view topView isCollapsed ifTrue:		[^ paragraph text replaceFrom: 1 to: paragraph text size				with: model contents asText].	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/13/1998 14:16'!changeText: aText	"The paragraph to be edited is changed to aText."	paragraph text: aText.	self resetState.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self selectAndScroll.	self deselect! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:22'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	view topView isCollapsed ifTrue: [^ actionBlock value].	paneRect _ paragraph clippingRectangle.	rectSet _ self visibleAreas.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:26'!scrollIn: scrollRect	"Altered from selectAndScroll so can use with null clipRect"	"Scroll until the selection is in the view and then highlight it."	| deltaY |	deltaY _ stopBlock top - scrollRect top.	deltaY >= 0 		ifTrue: [deltaY _ stopBlock bottom - scrollRect bottom max: 0].						"check if stopIndex below bottom of scrollRect"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + paragraph lineGrid - 1) * deltaY sign]! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 5/7/1998 22:23'!visibleAreas	"Transcript dependents last controller visibleAreas"	| visibleAreas rect remnants myTopController |	myTopController _ self view topView controller.	visibleAreas _ Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | c == myTopController ifTrue: [^ visibleAreas].		rect _ c view windowBox.		remnants _ OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas _ remnants].	^ visibleAreas! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTextController class	instanceVariableNames: ''!!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 17:08'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down. 3/13/96 sw	 5/27/96 sw: added font menu"	^ PopUpMenu labels: 'set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with it (E)method source with itspecial menu...more...' 		lines: #(2 7 14).! !!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'tk 3/31/98 17:06'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  "	^ #(offerFontMenu changeStyle explain format fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu yellowButtonActivity "<-note change")"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !ScrollPane subclass: #PluggableTextMorph	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 5/4/1998 15:55'!editString: aString 	"Jam some text in.  This is treated as clean text by default."	self setText: aString asText! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 4/14/98 11:58'!extent: newExtent	super extent: (newExtent max: 36@16).	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height]! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 4/20/1998 18:48'!initialize	super initialize.	hasUnacceptedEdits _ false.	askBeforeDiscardingEdits _ true! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 5/3/1998 12:45'!installModelIn: aWorld	"No special inits for new components"	^ self! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 4/9/98 16:25'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	getMenuSelector _ getMenuSel.	self borderWidth: 1.	self setText: self getText.	self setSelection: self getSelection.! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 4/7/98 16:15'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ model perform: getSelectionSelector! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 4/27/1998 11:39'!getText 	"Retrieve the current model text"	getTextSelector == nil ifTrue: [^ Text new].	^ (model perform: getTextSelector) ifNil: [Text new]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 5/22/1998 00:01'!setSelection: sel	selectionInterval _ sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 4/22/1998 11:06'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ TextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 4/20/1998 07:59'!text	^ textMorph contents! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/20/1998 21:12'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept ok |	self canDiscardEdits ifTrue: [^ self flash].	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:41'!again	self handleEdit: [textMorph editor again]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:43'!browseIt	textMorph editor browseIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 4/22/1998 11:04'!cancel	self setText: self getText.	self setSelection: self getSelection.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:41'!changeStyle	self handleEdit: [textMorph editor changeStyle]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 4/11/98 16:33'!copySelection	textMorph editor copySelection! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:41'!cut	self handleEdit: [textMorph editor cut]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 22:04'!doIt	self handleEdit: [textMorph editor evaluateSelection]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:41'!explain	self handleEdit: [textMorph editor explain]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:43'!fileItIn	textMorph editor fileItIn! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:42'!find	self handleEdit: [textMorph editor find]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:42'!findAgain	self handleEdit: [textMorph editor findAgain]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:42'!format	self handleEdit: [textMorph editor format]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:42'!implementorsOfIt	textMorph editor implementorsOfIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 22:07'!inspectIt	| result |	self handleEdit:		[result _ textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [result inspect]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:43'!methodNamesContainingIt	textMorph editor methodNamesContainingIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:43'!methodSourceContainingIt	textMorph editor methodSourceContainingIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:44'!methodStringsContainingit	textMorph editor methodStringsContainingit! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:44'!offerFontMenu	self handleEdit: [textMorph editor offerFontMenu]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:44'!paste	self handleEdit: [textMorph editor paste]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:44'!presentSpecialMenu	self handleEdit: [textMorph editor presentSpecialMenu]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 22:02'!printIt	| result |	self handleEdit:		[result _ textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [textMorph editor afterSelectionInsertAndSelect: result printString]]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:45'!recognizeCharacters	self handleEdit: [textMorph editor recognizeCharacters]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:45'!referencesToIt	textMorph editor referencesToIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 4/21/1998 13:51'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:45'!sendersOfIt	textMorph editor sendersOfIt! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 4/11/98 16:32'!setSearchString	textMorph editor setSearchString! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/20/1998 23:11'!spawn	self handleEdit: [textMorph editor spawn].	self cancel! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 12:45'!undo	textMorph editor undo! !!PluggableTextMorph methodsFor: 'updating' stamp: 'di 5/12/1998 21:05'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #autoSelect ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self world displayWorld].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self world displayWorld].! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'di 4/22/1998 09:55'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits"	super drawOn: aCanvas.	self hasUnacceptedEdits ifTrue:		[aCanvas frameRectangle: self innerBounds width: 1 color: Color red]! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/20/1998 18:53'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/20/1998 18:52'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/20/1998 18:56'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/22/1998 09:51'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	aBoolean == hasUnacceptedEdits ifFalse:		[hasUnacceptedEdits _ aBoolean.		self changed]! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/21/1998 14:00'!promptForCancel	"Ask if it is OK to cancel changes to text"	(self confirm:'Changes have not been saved.Is it OK to cancel those changes?')		ifTrue: [model clearUserEditFlag].! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 15:19'!correctFrom: start to: stop with: aString	^ textMorph editor correctFrom: start to: stop with: aString! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 15:16'!deselect	^ textMorph editor deselect! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 15:26'!nextTokenFrom: start direction: dir	^ textMorph editor nextTokenFrom: start direction: dir! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/20/1998 08:32'!notify: aString at: anInteger in: aStream	^ textMorph editor notify: aString at: anInteger in: aStream! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 14:59'!select	^ textMorph editor select! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 14:58'!selectFrom: start to: stop	^ textMorph editor selectFrom: start to: stop! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 15:18'!selectInvisiblyFrom: start to: stop	^ textMorph editor selectInvisiblyFrom: start to: stop! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 5/6/1998 14:56'!selectionInterval	^ textMorph editor selectionInterval! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 5/10/1998 22:33'!handleEdit: editBlock	textMorph editor model: model.  "For evaluateSelection"	textMorph handleEdit: editBlock.   "Update selection after edit"	self scrollSelectionIntoView! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 5/22/1998 12:35'!scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 5/22/1998 15:27'!scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest |	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[event cursorPoint y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2].		event cursorPoint y >= self bottom			ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2].		selectionInterval _ textMorph editor selectionInterval].	selRect _ (scroller transformFrom: self) invertRect: rectToTest.	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'di 5/13/1998 14:29'!appendEntry	"Append the text in the model's writeStream to the editable text. "	textMorph asText size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: textMorph asText size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: textMorph asText size + 1 to: textMorph asText size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: textMorph asText size + 1 to: textMorph asText size! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'di 5/8/1998 21:22'!changeText: aText	"The paragraph to be edited is changed to aText."	self setText: aText! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'di 5/9/1998 21:40'!replaceSelectionWith: aText	^ textMorph editor replaceSelectionWith: aText! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'di 5/22/1998 11:27'!mouseEnter: event	super mouseEnter: event.	selectionInterval ifNotNil:		[textMorph handleEdit: [textMorph editor selectInterval: selectionInterval]].	event hand newKeyboardFocus: textMorph! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'di 5/22/1998 00:05'!mouseLeave: event	selectionInterval _ textMorph editor selectionInterval.	super mouseLeave: event! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTextMorph class	instanceVariableNames: ''!!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'di 4/7/98 16:03'!on: anObject text: getTextSel accept: setTextSel	^ self on: anObject		text: getTextSel		accept: setTextSel		readSelection: nil		menu: nil! !!PluggableTextMorph class methodsFor: 'as yet unclassified' stamp: 'di 4/7/98 16:03'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	^ self new on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !StringHolderView subclass: #PluggableTextView	instanceVariableNames: 'getTextSelector setTextSelector getSelectionSelector getMenuSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!PluggableTextView commentStamp: 'di 5/22/1998 16:37' prior: 0!A PluggableTextView gets its content from the model. This allows the same kind of view to be used in different situations, thus avoiding a proliferation of gratuitous view and controller classes. See the class comment for PluggableListView.Selectors are:		getTextSel		fetch the original text from the model		setTextSel		submit new text to the model when user "accepts"		getSelectionSel	get the current text selection range		getMenuSel		get the pane-specific, 'yellow-button' menu	Any of the above selectors can be nil, meaning that the model does not supply behavior for the given action, and the default behavior should be used. For example, if setTextSel is nil then this view is consider read-only.	The model informs a pluggable view of changes by sending #changed: to itself with getTextSel as a parameter. The view informs the model of selection changes by sending setTextSel to it with the newly selected item as a parameter, and invokes menu actions on the model via getMenuSel.!!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:24'!defaultControllerClass 	^ PluggableTextController! !!PluggableTextView methodsFor: 'initialization' stamp: 'tk 4/6/98 10:51'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector _ getTextSel.	setTextSelector _ setTextSel.	getSelectionSelector _ getSelectionSel.	getMenuSelector _ getMenuSel.	self borderWidth: 1.	self editString: self getText.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'initialization' stamp: 'jm 3/29/98 07:25'!setSelection: sel	controller selectFrom: sel first to: sel last.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 4/9/98 16:15'!getMenu	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: Sensor leftShiftDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 3/31/98 17:14'!getMenuShifted	"Answer the other menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ nil].	"Need the other menu"	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: true].	^ nil! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 3/29/98 07:26'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ model perform: getSelectionSelector! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 4/1/98 08:32'!getText 	"Answer the list to be displayed."	| txt |	getTextSelector == nil ifTrue: [^ Text new].	txt _ model perform: getTextSelector.	txt == nil ifTrue: [^ Text new].	self hasUnacceptedEdits: false.	"clean now"	^ txt! !!PluggableTextView methodsFor: 'model access' stamp: 'tk 3/31/98 15:58'!getTextSelector	"This is sent to the model to find out what text to display"	^ getTextSelector! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 5/3/1998 19:29'!isReadOnlyView	^ setTextSelector == nil! !!PluggableTextView methodsFor: 'model access' stamp: 'di 3/10/98 13:51'!setText: textToAccept from: ctlr	"Inform the model of text to be accepted, and return true if OK.	Any errors should be reported to the controller, ctlr."	setTextSelector == nil ifTrue: [^ true].	setTextSelector numArgs = 2		ifTrue: [^ model perform: setTextSelector with: textToAccept with: ctlr]		ifFalse: [^ model perform: setTextSelector with: textToAccept]! !!PluggableTextView methodsFor: 'model access' stamp: 'di 4/27/1998 12:46'!updateDisplayContents	self editString: self getText.	self displayView.	self setSelection: self getSelection.! !!PluggableTextView methodsFor: 'updating' stamp: 'di 5/7/1998 22:32'!update: aSymbol	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action."	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [self promptForCancel].  ^ self].	aSymbol == #flash ifTrue: [^ controller flash].	aSymbol == getTextSelector ifTrue: [^ self updateDisplayContents].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #autoSelect ifTrue:			[^ controller setSearch: model autoSelectString;					againOrSame: true].	aSymbol == #appendEntry ifTrue:			[^ controller doOccluded: [controller appendEntry]].	aSymbol == #clearText ifTrue:			[^ controller doOccluded:				[controller changeText: Text new]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableTextView class	instanceVariableNames: ''!!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel	^ self on: anObject		text: getTextSel		accept: setTextSel		readSelection: nil		menu: nil! !!PluggableTextView class methodsFor: 'instance creation' stamp: 'jm 3/29/98 07:24'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	^ self new on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !Object subclass: #Point	instanceVariableNames: 'x y '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Point commentStamp: 'di 5/22/1998 16:37' prior: 0!Point comment:'I represent an x-y pair of numbers usually designating a location on the screen.'!!Point methodsFor: 'accessing'!x	"Answer the x coordinate."	^x! !!Point methodsFor: 'accessing'!y	"Answer the y coordinate."	^y! !!Point methodsFor: 'comparing'!< aPoint 	"Answer whether the receiver is above and to the left of aPoint."	^x < aPoint x and: [y < aPoint y]! !!Point methodsFor: 'comparing'!<= aPoint 	"Answer whether the receiver is neither below nor to the right of aPoint."	^x <= aPoint x and: [y <= aPoint y]! !!Point methodsFor: 'comparing'!= aPoint	self species = aPoint species		ifTrue: [^x = aPoint 	"Refer to the comment in Object|=." x and: [y = aPoint y]]		ifFalse: [^false]! !!Point methodsFor: 'comparing'!> aPoint 	"Answer whether the receiver is below and to the right of aPoint."	^x > aPoint x and: [y > aPoint y]! !!Point methodsFor: 'comparing'!>= aPoint 	"Answer whether the receiver is neither above nor to the left of aPoint."	^x >= aPoint x and: [y >= aPoint y]! !!Point methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^(x hash bitShift: 2) bitXor: y hash! !!Point methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Point methodsFor: 'comparing'!max: aPoint 	"Answer the lower right corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x max: aPoint x) @ (y max: aPoint y)! !!Point methodsFor: 'comparing'!min: aPoint 	"Answer the upper left corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x min: aPoint x) @ (y min: aPoint y)! !!Point methodsFor: 'comparing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !!Point methodsFor: 'arithmetic'!* scale 	"Answer a Point that is the product of the receiver and scale (which is a 	Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^x * scalePoint x @ (y * scalePoint y)! !!Point methodsFor: 'arithmetic'!+ delta 	"Answer a Point that is the sum of the receiver and delta (which is a 	Point or Number)."	| deltaPoint |	deltaPoint _ delta asPoint.	^x + deltaPoint x @ (y + deltaPoint y)! !!Point methodsFor: 'arithmetic'!- delta 	"Answer a Point that is the difference of the receiver and delta (which is 	a Point or Number)."	| deltaPoint |	deltaPoint _ delta asPoint.	^x - deltaPoint x @ (y - deltaPoint y)! !!Point methodsFor: 'arithmetic'!/ scale 	"Answer a Point that is the quotient of the receiver and scale (which is a 	Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^x / scalePoint x @ (y / scalePoint y)! !!Point methodsFor: 'arithmetic'!// scale 	"Answer a Point that is the quotient of the receiver and scale (which is a 	Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^x // scalePoint x @ (y // scalePoint y)! !!Point methodsFor: 'arithmetic'!abs	"Answer a Point whose x and y are the absolute values of the receiver's x 	and y."	^ x abs @ y abs! !!Point methodsFor: 'arithmetic'!\\ scale 	"Answer a Point that is the mod of the receiver and scale (which is a  Point or Number)."	| scalePoint |	scalePoint _ scale asPoint.	^ x \\ scalePoint x @ (y \\ scalePoint y)! !!Point methodsFor: 'truncation and round off'!rounded	"Answer a Point that is the receiver's x and y rounded."	^x rounded @ y rounded! !!Point methodsFor: 'truncation and round off'!truncated	"Answer a Point that is the receiver's x and y truncated by removing the fractional part."	^(x truncated) @ (y truncated)! !!Point methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Point that is the receiver's x and y truncated to grid x and 	grid y."	| gridPoint |	gridPoint _ grid asPoint.	^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !!Point methodsFor: 'polar coordinates' stamp: 'di 6/12/97 12:18'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 90.0]				ifFalse: [^ 270.0]]		ifFalse: 			[tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^ theta radiansToDegrees]						ifFalse: [^ 360.0 + theta radiansToDegrees]]				ifFalse: [^ 180.0 + theta radiansToDegrees]]! !!Point methodsFor: 'polar coordinates'!r	"Answer the receiver's radius in polar coordinate system."	^(self dotProduct: self) sqrt! !!Point methodsFor: 'polar coordinates'!theta	"Answer the angle the receiver makes with origin in radians. right is 0; 	down is 90."	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^1.5708"90.0 degreesToRadians"]				ifFalse: [^4.71239"270.0 degreesToRadians"]]		ifFalse: 			[tan _ y asFloat / x asFloat.			theta _ tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^theta]						ifFalse: [^360.0 degreesToRadians + theta]]				ifFalse: [^180.0 degreesToRadians + theta]]! !!Point methodsFor: 'point functions' stamp: 'sw 2/15/98 02:27'!bearingToPoint: anotherPoint    "Return the bearing, in degrees, from the receiver to anotherPoint.     Adapted from Playground, where the ultimate provenance of the algorithm was a wild earlier method of Jay Fenton's which I never checked carefully, but the thing has always seemed to work"    | deltaX deltaY  |    deltaX := anotherPoint x -  x.    deltaY := anotherPoint y - y.    deltaX abs < 0.001        ifTrue:            [^ deltaY > 0 ifTrue: [180] ifFalse: [0]].    ^ ((deltaX >= 0 ifTrue: [90] ifFalse: [270])            - ((deltaY / deltaX) arcTan negated * 57.2957795131)) rounded! !!Point methodsFor: 'point functions'!dist: aPoint 	"Answer the distance between aPoint and the receiver."	^(aPoint - self) r! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:11'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	| temp |	temp _ self * aPoint.	^temp x abs + temp y abs! !!Point methodsFor: 'point functions'!eightNeighbors	^ (Array with: self + (1@0)		with: self + (1@1)		with: self + (0@1)		with: self + (-1@1)) ,	(Array with: self + (-1@0)		with: self + (-1@-1)		with: self + (0@-1)		with: self + (1@-1))! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 16:08'!flipBy: direction centerAt: c	"Answer a Point which is flipped according to the direction about the point c.	Direction must be #vertical or #horizontal."	direction == #vertical ifTrue: [^ x @ (c y * 2 - y)].	direction == #horizontal ifTrue: [^ (c x * 2 - x) @ y].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions'!fourNeighbors	^ Array with: self + (1@0)		with: self + (0@1)		with: self + (-1@0)		with: self + (0@-1)! !!Point methodsFor: 'point functions'!grid: aPoint 	"Answer a Point to the nearest rounded grid modules specified by aPoint."	| newX newY |	newX _ x + (aPoint x // 2) truncateTo: aPoint x.	newY _ y + (aPoint y // 2) truncateTo: aPoint y.	^newX @ newY! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:37'!nearestPointAlongLineFrom: p1 to: p2	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [^ p1 x @ y].	p1 y = p2 y ifTrue: [^ x @ p1 y].	x1 _ p1 x asFloat.	y1 _ p1 y asFloat.	x21 _ p2 x asFloat - x1.	y21 _ p2 y asFloat - y1.	t _ ((y asFloat - y1 / x21) + (x asFloat - x1 / y21))			/ ((x21 / y21) + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))"	| old new |	Pen new place: 200@100; goto: (old _ 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new _ (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old _ new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!nearestPointOnLineFrom: p1 to: p2	"This will not give points beyond the endpoints"	^ (self nearestPointAlongLineFrom: p1 to: p2)		adhereTo: (p1 rect: p2)! !!Point methodsFor: 'point functions'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise."	| n |	n _ y negated @ x.	^n / (n x * n x + (n y * n y)) sqrt! !!Point methodsFor: 'point functions'!octantOf: otherPoint	"Return 1..8 indicating relative direction to otherPoint.	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"	| quad moreHoriz |	(x = otherPoint x and: [y > otherPoint y]) ifTrue: [^ 6].	"special case"	(y = otherPoint y and: [x < otherPoint x]) ifTrue: [^ 8].	quad _ self quadrantOf: otherPoint.	moreHoriz _ (x - otherPoint x) abs >= (y - otherPoint y) abs.	(quad even eqv: moreHoriz)		ifTrue: [^ quad*2]		ifFalse: [^ quad*2 - 1]! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!onLineFrom: p1 to: p2	^ self onLineFrom: p1 to: p2 within: 2! !!Point methodsFor: 'point functions' stamp: 'jm 2/24/98 08:34'!onLineFrom: p1 to: p2 within: epsilon	"Answer true if the receiver lies on the given line segment between p1 and p2 within a small epsilon."	"is this point within the box spanning p1 and p2 expanded by epsilon? (optimized)"	p1 x < p2 x		ifTrue: [			((x < (p1 x - epsilon)) or: [x > (p2 x + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((x < (p2 x - epsilon)) or: [x > (p1 x + epsilon)]) ifTrue: [^ false]].	p1 y < p2 y		ifTrue: [			((y < (p1 y - epsilon)) or: [y > (p2 y + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((y < (p2 y - epsilon)) or: [y > (p1 y + epsilon)]) ifTrue: [^ false]].	"it's in the box; is it on the line?"	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsilon! !!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]"! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 15:12'!rotateBy: direction centerAt: c	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset _ self - c.	direction == #right ifTrue: [^ (offset y negated @ offset x) + c].	direction == #left ifTrue: [^ (offset y @ offset x negated) + c].	direction == #pi ifTrue: [^ c - offset].	self error: 'unrecognizable direction'! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:07'!adaptFloat: floatScalar	^ floatScalar @ floatScalar! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:10'!adaptInteger: scalar	^ scalar @ scalar! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:08'!adaptToFloat	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting' stamp: 'di 11/1/97 19:11'!adaptToInteger	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting'!asFloatPoint	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting'!asIntegerPoint	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting'!asPoint	"Answer the receiver itself."	^self! !!Point methodsFor: 'converting'!corner: aPoint 	"Answer a Rectangle whose origin is the receiver and whose corner is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self corner: aPoint! !!Point methodsFor: 'converting'!extent: aPoint 	"Answer a Rectangle whose origin is the receiver and whose extent is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self extent: aPoint! !!Point methodsFor: 'converting' stamp: 'di 12/3/97 19:00'!rect: aPoint 	"Answer a Rectangle that encompasses the receiver and aPoint.	This is the most general infix way to create a rectangle."	^ Rectangle 		origin: (self min: aPoint)		corner: (self max: aPoint)! !!Point methodsFor: 'transforming' stamp: 'di 4/30/1998 11:16'!adhereTo: aRectangle	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."	(aRectangle containsPoint: self) ifTrue: [^ self].	^ ((x max: aRectangle left) min: aRectangle right)		@ ((y max: aRectangle top) min: aRectangle bottom)! !!Point methodsFor: 'transforming'!negated	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"	^ x negated @ y negated! !!Point methodsFor: 'transforming'!rotateBy: angle about: center	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p _ self - center.	r _ p r.	theta _ angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @	  (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming'!scaleBy: factor 	"Answer a Point scaled by factor (an instance of Point)."	^(factor x * x) @ (factor y * y)! !!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)					@ ((y-rect1 top) * rect2 height // rect1 height))! !!Point methodsFor: 'transforming'!translateBy: delta 	"Answer a Point translated by delta (an instance of Point)."	^(delta x + x) @ (delta y + y)! !!Point methodsFor: 'copying'!copy	"Implemented here for better performance."	^ x @ y! !!Point methodsFor: 'copying'!deepCopy	"Implemented here for better performance."	^x deepCopy @ y deepCopy! !!Point methodsFor: 'copying'!shallowCopy	"Implemented here for better performance."	^ x @ y! !!Point methodsFor: 'printing' stamp: 'sw 4/25/1998 12:53'!basicType	^ #point! !!Point methodsFor: 'printing'!printOn: aStream 	"The receiver prints on aStream in terms of infix notation."	x printOn: aStream.	aStream nextPut: $@.	y printOn: aStream! !!Point methodsFor: 'printing'!storeOn: aStream 	"x@y printed form is good for storing too"	self printOn: aStream! !!Point methodsFor: 'private'!setR: rho degrees: theta	| radians |	radians _ theta asFloat degreesToRadians.	x _ (rho asFloat * radians cos) asInteger.	y _ (rho asFloat * radians sin) asInteger.! !!Point methodsFor: 'private'!setX: xPoint setY: yPoint	x _ xPoint.	y _ yPoint! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Point class	instanceVariableNames: ''!!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor cursorPoint"Point fromUser"! !!Point class methodsFor: 'instance creation'!r: rho degrees: theta	"Answer an instance of me with polar coordinates rho and theta."	^self new setR: rho degrees: theta! !!Point class methodsFor: 'instance creation'!x: xInteger y: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self new setX: xInteger setY: yInteger! !BorderedMorph subclass: #PolygonMorph	instanceVariableNames: 'vertices closed filledForm quickFill arrows arrowForms handles '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!PolygonMorph commentStamp: 'di 5/22/1998 16:37' prior: 0!PolygonMorph comment:'Polygons and curves use a 1-bit shape form to make display reasonably fast.  This could be further optimized by going to a 2-bit form and including the border.  It would also be simpleto compute an inner rectangle, as with ellipses. '!!PolygonMorph methodsFor: 'initialization' stamp: 'jm 8/2/97 14:21'!initialize	super initialize.	vertices _ Array with: 20@20 with: 40@30 with: 20@40.	color _ Color orange.	borderWidth _ 2.	borderColor _ Color magenta.	closed _ true.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/26/97 10:33'!installModelIn: aWorld	aWorld isWorldMorph ifTrue: [self addHandles]! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 12/3/97 10:00'!vertices: verts color: c borderWidth: bw borderColor: bc	super initialize.	vertices _ verts.	color _ c.	borderWidth _ bw.	borderColor _ bc.	closed _ vertices size > 2.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'access' stamp: '6/8/97 15:43 di'!borderWidth: anInteger	borderColor ifNil: [borderColor _ Color black].	borderWidth _ anInteger.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'di 12/4/97 09:45'!isCurve	^ false! !!PolygonMorph methodsFor: 'access' stamp: 'jm 11/19/97 18:55'!isOpen	^ closed not! !!PolygonMorph methodsFor: 'access' stamp: '6/9/97 13:22 di'!makeClosed	closed _ true.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: '6/9/97 13:22 di'!makeOpen	closed _ false.	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'sw 9/14/97 18:22'!vertices	^ vertices! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/1/97 12:44'!closestPointTo: aPoint	| curvePoint closestPoint dist minDist |	closestPoint _ minDist _ nil.	self lineSegmentsDo:		[:p1 :p2 | 		curvePoint _ aPoint nearestPointOnLineFrom: p1 to: p2.		dist _ curvePoint dist: aPoint.		(closestPoint == nil or: [dist < minDist])			ifTrue: [closestPoint _ curvePoint.					minDist _ dist]].	^ closestPoint! !!PolygonMorph methodsFor: 'geometry' stamp: 'jm 2/24/98 08:12'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!flipHAroundX: centerX	"Flip me horizontally around the center.  If centerX is nil, compute my center of gravity."	| cent |	cent _ centerX 		ifNil: [bounds center x			"cent _ 0.			vertices do: [:each | cent _ cent + each x].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerX].	self setVertices: (vertices collect: [:vv |			(vv x - cent) * -1 + cent @ vv y]) reversed.! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!flipVAroundY: centerY	"Flip me vertically around the center.  If centerY is nil, compute my center of gravity."	| cent |	cent _ centerY 		ifNil: [bounds center y			"cent _ 0.			vertices do: [:each | cent _ cent + each y].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerY].	self setVertices: (vertices collect: [:vv |			vv x @ ((vv y - cent) * -1 + cent)]) reversed.! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!inset: amt	"Only works if I am made of rectangles (every segment of me is horizontal or vertical).  Inset each vertex by amt.  Uses containsPoint."	| delta four cnt offset |	delta _ amt asPoint.	four _ {delta.  -1@1 * delta.  -1@-1 * delta.  1@-1 * delta}.	self setVertices: (vertices collect: [:vv | 		cnt _ 0.		offset _ four detectSum: [:del | 			(self containsPoint: del+vv) ifTrue: [cnt _ cnt + 1. del] ifFalse: [0@0]].		cnt = 2 ifTrue: [offset _ offset // 2].		vv + offset]).! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!merge: aPolygon	"Expand myself to enclose the other polygon.  (Later merge overlapping or disjoint in a smart way.)  For now, the two polygons must share at least two vertices.  Shared vertices must come one after the other in each polygon.  Polygons must not overlap."	| shared mv vv hv xx |	shared _ vertices select: [:mine | 		(aPolygon vertices includes: mine)].	shared size < 2 ifTrue: [^ nil].	"not sharing a segment"	mv _ vertices asOrderedCollection.	[shared includes: mv first] whileFalse: ["rotate them"		vv _ mv removeFirst.		mv addLast: vv].	hv _ aPolygon vertices asOrderedCollection.	[mv first = hv first] whileFalse: ["rotate him until same shared vertex is first"		vv _ hv removeFirst.		hv addLast: vv].	[shared size > 2] whileTrue: [		shared _ shared asOrderedCollection.		(self mergeDropThird: mv in: hv from: shared) ifNil: [^ nil]].		"works by side effect on the lists"	(mv at: 2) = hv last ifTrue: [mv removeFirst; removeFirst.		^ self setVertices: (hv, mv) asArray].	(hv at: 2) = mv last ifTrue: [hv removeFirst; removeFirst.		^ self setVertices: (mv, hv) asArray].	(mv at: 2) = (hv at: 2) ifTrue: [hv removeFirst.  mv remove: (mv at: 2).		xx _ mv removeFirst.		^ self setVertices: (hv, (Array with: xx), mv reversed) asArray].	mv last = hv last ifTrue: [mv removeLast.  hv removeFirst.		^ self setVertices: (mv, hv reversed) asArray].	^ nil! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!mergeDropThird: mv in: hv from: shared	"We are merging two polygons.  In this case, they have at least three identical shared vertices.  Make sure they are sequential in each, and drop the middle one from vertex lists mv, hv, and shared.  First vertices on lists are identical already."	"know (mv first = hv first)"	| mdrop vv |	(shared includes: (mv at: mv size - 2)) 		ifTrue: [(shared includes: (mv last)) ifTrue: [mdrop _ mv last]]		ifFalse: [(shared includes: (mv last)) ifTrue: [			(shared includes: (mv at: 2)) ifTrue: [mdrop _ mv first]]].	(shared includes: (mv at: 3)) ifTrue: [		(shared includes: (mv at: 2)) ifTrue: [mdrop _ mv at: 2]].	mdrop ifNil: [^ nil].	mv remove: mdrop.	hv remove: mdrop.	shared remove: mdrop.	[shared includes: mv first] whileFalse: ["rotate them"		vv _ mv removeFirst.		mv addLast: vv].	[mv first = hv first] whileFalse: ["rotate him until same shared vertex is first"		vv _ hv removeFirst.		hv addLast: vv].! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!rotate: degrees around: centerPt	"Rotate me around the center.  If center is nil, use the center of my bounds.  Rotation is clockwise on the screen."	| cent |	cent _ centerPt 		ifNil: [bounds center]	"approx the center"		ifNotNil: [centerPt].	degrees \\ 90 = 0 ifTrue: ["make these cases exact"		degrees \\ 360 = 90 ifTrue: ["right"			^ self setVertices: (vertices collect: [:vv |				(vv - cent) y * -1 @ ((vv - cent) x) + cent])].		degrees \\ 360 = 180 ifTrue: [			^ self setVertices: (vertices collect: [:vv |				(vv - cent) negated + cent])].		degrees \\ 360 = 270 ifTrue: ["left"			^ self setVertices: (vertices collect: [:vv |				(vv - cent) y @ ((vv - cent) x * -1) + cent])].		degrees \\ 360 = 0 ifTrue: [^ self].		].	self setVertices: (vertices collect: [:vv |			(Point r: (vv - cent) r degrees: (vv - cent) degrees + degrees) + cent]).! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 12/3/97 19:41'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 11/14/97 11:14'!drawOnFills: aRectangle	^ false  "Could be improved by quick check of inner rectangle"! !!PolygonMorph methodsFor: 'editing' stamp: 'di 12/3/97 14:38'!dragVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ evt cursorPoint.	vertices at: ix put: p.	handle position: p - (handle extent//2).	self computeBounds! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/25/97 16:13'!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 6/11/97 16:03'!extent: newExtent	"Not really advisable, but we can preserve most of the geometry if we don't	shrink things too small."	| safeExtent |	safeExtent _ newExtent max: 20@20.	self setVertices: (vertices collect:		[:p | p - bounds topLeft * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + bounds topLeft])! !!PolygonMorph methodsFor: 'editing' stamp: 'di 9/26/97 10:33'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!!	Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix+1 to: ix with: (Array with: pt)).	evt hand mouseDownRecipient: (handles at: ix+1*2-1)! !!PolygonMorph methodsFor: 'menu' stamp: 'tk 7/28/97 23:04'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'menu' stamp: 'di 1/26/98 23:50'!addHandles	| handle newVert tri |	self removeHandles.	handles _ OrderedCollection new.	tri _ Array with: 0@-4 with: 4@3 with: -3@3.	vertices withIndexDo:		[:vertPt :vertIndex |		handle _ EllipseMorph newBounds: (Rectangle center: vertPt extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		handle on: #mouseUp send: #dropVertex:fromHandle:vertIndex:				to: self withValue: vertIndex.		self addMorph: handle.		handles addLast: handle.		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ PolygonMorph					vertices: (tri collect: [:p | p + (vertPt + (vertices atWrap: vertIndex+1) // 2)])					color: Color green borderWidth: 1 borderColor: Color black.			newVert on: #mouseDown send: #newVertex:fromHandle:afterVert:					to: self withValue: vertIndex.			self addMorph: newVert.			handles addLast: newVert]].	self changed! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBackArrow	arrows _ #back.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBothArrows	arrows _ #both.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeForwardArrow	arrows _ #forward.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeNoArrows	arrows _ #none.	self computeBounds! !!PolygonMorph methodsFor: 'menu' stamp: 'tk 9/2/97 16:04'!removeHandles	"tk 9/2/97 allow it to be called twice (when nil already)"	handles ifNotNil: [		handles do: [:h | h delete].		handles _ nil].! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:09'!arrowForms	"ArrowForms are computed only upon demand"	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ arrowForms _ nil].	arrowForms ifNotNil: [^ arrowForms].	arrowForms _ Array new.	(arrows == #forward or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices last from: self nextToLastPoint)].	(arrows == #back or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices first from: self nextToFirstPoint)].	^ arrowForms! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/13/97 07:21'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ ColorForm extent: box extent asIntegerPoint.	bb _ (BitBlt toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:11'!computeBounds	self changed.	bounds _ self curveBounds.	self releaseCachedState.	self arrowForms ifNotNil:		[self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)]].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'sw 9/14/97 18:22'!copyRecordingIn: dict	"Copy the vertices array.  Give each one its own handles, and in the handles array."	| new hadHandles |	hadHandles _ handles ifNil: [false] ifNotNil: [self removeHandles. true].	new _ super copyRecordingIn: dict.	new setVertices: vertices copy.	hadHandles ifTrue: [self addHandles.  new addHandles].	^ new! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/3/97 19:37'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/29/97 21:00'!filledForm	"Computation of the filled form is done only on demand"	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent.	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: ["Someday put a better fill algorithm here"].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/21/97 21:29'!lineSegments	| lineSegments |	lineSegments _ OrderedCollection new.	self lineSegmentsDo: [:p1 :p2 | lineSegments addLast: (Array with: p1 with: p2)].	^ lineSegments! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/29/97 20:54'!lineSegmentsDo: endPointsBlock	| beginPoint |	beginPoint _ nil.	vertices do:		[:endPoint | beginPoint ifNotNil:			[endPointsBlock value: beginPoint							value: endPoint].		beginPoint _ endPoint].	(closed or: [vertices size = 1])		ifTrue: [endPointsBlock value: beginPoint								value: vertices first]! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:16'!loadCachedState	"Prepare for fast response -- next page of a book?"	self filledForm.	self arrowForms! !!PolygonMorph methodsFor: 'private' stamp: '6/9/97 12:07 di'!nextToFirstPoint  "For arrow direction"	^ vertices at: 2! !!PolygonMorph methodsFor: 'private' stamp: '6/9/97 12:07 di'!nextToLastPoint  "For arrow direction"	^ vertices at: vertices size - 1! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:08'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms ifNotNil: [self arrowForms do: [:f | f offset: f offset + delta]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/13/97 15:05'!releaseCachedState	filledForm _ nil.	arrowForms _ nil! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/11/97 16:00'!setVertices: newVertices	| hadHandles |	hadHandles _ handles ifNil: [false] ifNotNil: [self removeHandles. true].	vertices _ newVertices.	hadHandles ifTrue: [self addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'private' stamp: 'di 1/27/98 00:01'!updateHandles	| newVert oldVert |	vertices withIndexDo:		[:vertPt :vertIndex |		oldVert _ handles at: vertIndex*2-1.		oldVert position: vertPt - (oldVert extent//2).		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: (vertPt + (vertices atWrap: vertIndex+1)								- newVert extent) // 2 + (1@-1)]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PolygonMorph class	instanceVariableNames: ''!!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 9/26/97 10:33'!vertices: verts color: c borderWidth: bw borderColor: bc	^ self basicNew vertices: verts color: c borderWidth: bw borderColor: bc! !StringMorph subclass: #PopUpChoiceMorph	instanceVariableNames: 'target actionSelector arguments getItemsSelector getItemsArgs choiceSelector choiceArgs '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!actionSelector	^ actionSelector! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!arguments	^ arguments! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!arguments: aCollection	arguments _ aCollection asArray copy.! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:33'!getItemsArgs	^ getItemsArgs! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:33'!getItemsArgs: aCollection	getItemsArgs _ aCollection asArray copy.! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:32'!getItemsSelector	^ getItemsSelector! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:32'!getItemsSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ getItemsSelector _ nil].	getItemsSelector _ aSymbolOrString asSymbol.! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:20'!handlesMouseDown: evt	^ true! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:23'!initialize	super initialize.	self contents: 'PopUpChoice of Colors'.	target _ Color.	actionSelector _ nil.	arguments _ EmptyArray.	getItemsSelector _ #colorNames.	getItemsArgs _ EmptyArray.! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'di 2/3/98 19:36'!mouseDown: evt	| items menu selectedItem |	(target == nil or: [getItemsSelector == nil]) ifTrue: [^ self].	items _ target perform: getItemsSelector withArguments: getItemsArgs.	menu _ CustomMenu new.	items do: [:item | menu add: item action: item].	selectedItem _ menu startUp.	selectedItem ifNil: [^ self].	self contentsClipped: selectedItem.  "Client can override this if necess"	actionSelector ifNotNil: [		target			perform: actionSelector			withArguments: (arguments copyWith: selectedItem)].! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!target	^ target! !!PopUpChoiceMorph methodsFor: 'all' stamp: 'jm 2/2/98 00:05'!target: anObject	target _ anObject! !Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection '	classVariableNames: 'CacheMenuForms MenuStyle '	poolDictionaries: ''	category: 'Interface-Menus'!!PopUpMenu commentStamp: 'di 5/22/1998 16:37' prior: 0!PopUpMenu comment:'I represent a list of items. My instances are presented on the display screen in a rectangular area. The user points to an item, pressing a mouse button; the item is highlighted. When the button is released, the highlighted item indicates the selection.'!!PopUpMenu methodsFor: 'basic control sequence'!startUp	"Display and make a selection from the receiver as long as the button 	is pressed. Answer the current selection."		^ self startUpWithCaption: nil! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 5/21/1998 14:33'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	^ self startUpWithCaption: captionOrNil at: Sensor cursorPoint - (frame width//2@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 5/22/1998 15:19'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	nLines _ (frame height - 4) // marker height.	allLabels := labelString findTokens: Character cr asString.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 2.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines) startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 5/21/1998 14:34'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor, so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: Sensor cursorPoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 5/21/1998 22:29'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released, answer the index of the current selection, or zero if the mouse is not released over any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	frame height > maxHeight ifTrue:		[^ self startUpSegmented: maxHeight withCaption: captionOrNil at: location].	World ifNotNil: [		^ (MVCMenuMorph from: self title: captionOrNil)			invokeAt: location in: World].	Cursor normal showWhile:		[self displayAt: location			withCaption: captionOrNil			during: [[Sensor anyButtonPressed] whileFalse: [].					[Sensor anyButtonPressed] whileTrue: [self manageMarker]]].	^ selection! !!PopUpMenu methodsFor: 'displaying'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionView captionSave outerFrame captionText tFrame frameSaveLoc |	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ DisplayText				text: captionOrNil asText				textStyle: TextStyle default copy centered.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionView _ DisplayTextView new model: captionText.		captionView align: captionView boundingBox bottomCenter					with: frame topCenter + (0@2).		captionView insideColor: Color white.		captionView borderWidth: 2.		captionSave _ Form fromDisplay: captionView displayBox.		captionView unlock; display; release].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionView displayBox topLeft]! !!PopUpMenu methodsFor: 'accessing'!center	"Answer the point at the center of the receiver's rectangular area."	^frame center! !!PopUpMenu methodsFor: 'accessing'!labelString	^ labelString! !!PopUpMenu methodsFor: 'accessing'!lineArray	^ lineArray! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifTrue: [CacheMenuForms ifFalse: [form _ nil]]					ifFalse: [form == nil ifTrue: [form _ self computeForm].							pt _ pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment'!markerOff	"No item is selected. Reverse the highlight if any item has been marked 	as selected."	selection ~= 0		ifTrue: 			[Display reverse: marker.			selection _ 0]! !!PopUpMenu methodsFor: 'marker adjustment'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection ~= 0 ifTrue: [Display reverse: marker].						marker _ 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection _ marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'marker adjustment'!markerTop: aPoint 	"Answer aPoint, gridded to lines in the receiver."	^(aPoint y - frame inside top truncateTo: font height) + frame inside top! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!scrollIntoView: cursorLoc	| dy |	dy _ 0.	cursorLoc y < 2 ifTrue: [dy _ font height].	cursorLoc y > (Display height-3) ifTrue: [dy _ font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame _ frame translateBy: 0@dy.	marker _ marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'selecting'!selection	"Answer the current selection."	^selection! !!PopUpMenu methodsFor: 'selecting'!setSelection: index	| lineHeight newSelection |	lineHeight _ font height.	newSelection _ (0 max: index) min: frame height // lineHeight.	marker _ marker translateBy:		 0 @ (lineHeight * (newSelection - selection)).	selection _ newSelection! !!PopUpMenu methodsFor: 'private'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm |	borderInset _ 2@2.	paraForm _ self computeLabelParagraph asForm.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm fillBlack.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse: [		lineArray do: [ :line |			menuForm fillBlack:				(0 @ ((line * font height) + borderInset y) extent: (menuForm width @ 1)).		].	].	^ menuForm! !!PopUpMenu methodsFor: 'private'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PopUpMenu methodsFor: 'private'!labels: aString font: aFont lines: anArray	| style inside |	labelString _ aString.	font _ aFont.	lineArray _ anArray.	frame _ Quadrangle new.	frame region: self menuForm boundingBox.	frame borderWidth: 2.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ self computeLabelParagraph lineGrid).	selection _ 1.! !!PopUpMenu methodsFor: 'private'!menuForm	"Answer a Form to be displayed for this menu."	"Details: On slower systems, cache the menu Form for speed."	form == nil ifFalse: [^ form].	CacheMenuForms		ifTrue: [^ form _ self computeForm]		ifFalse: [^ self computeForm]! !!PopUpMenu methodsFor: 'private'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	form _ nil.	"PopUpMenu withAllSubclasses do: [ :menuClass |		menuClass allInstancesDo: [ :m | m rescan ]]"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PopUpMenu class	instanceVariableNames: ''!!PopUpMenu class methodsFor: 'instance creation'!labelArray: labelArray lines: lineArray	"Answer an instance of me whose items are in anArray, with lines drawn  after each item indexed by anArray.  2/1/96 sw"	| aStream |	labelArray size == 0 ifTrue:		[self error: 'Menu must not be zero size'].	aStream _ WriteStream on: (String new: 40).	labelArray doWithIndex: [:anitem :anIndex | 		aStream nextPutAll: anitem.		anIndex ~~ labelArray size			ifTrue: [aStream cr]].	^ self labels: aStream contents lines: lineArray"(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #()) startUp"! !!PopUpMenu class methodsFor: 'instance creation'!labels: aString	"Answer an instance of me whose items are in aString."	^self labels: aString lines: nil! !!PopUpMenu class methodsFor: 'instance creation'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^self new		labels: aString		font: (MenuStyle fontAt: 1)		lines: anArray! !!PopUpMenu class methodsFor: 'instance creation'!notify: message	^ (self labels: ' OK ') startUpWithCaption: message! !!PopUpMenu class methodsFor: 'class initialization'!initialize  "PopUpMenu initialize"	"Change CacheMenuForms to true to get faster popup menus on slower systems."	"CacheMenuForms _ true"	CacheMenuForms _ false.	(MenuStyle _ TextStyle default copy)		gridForFont: 1 withLead: 0;		centered.	PopUpMenu withAllSubclasses do:		[:menuClass | menuClass allInstancesDo:			[:m | m rescan]]! !Stream subclass: #PositionableStream	instanceVariableNames: 'collection position readLimit '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!PositionableStream commentStamp: 'di 5/22/1998 16:37' prior: 0!PositionableStream comment:'I represent an accessor for a sequence of objects (a collection) that are externally named by indices so that the point of access can be repositioned. I am abstract in that I do not implement the messages next and nextPut: which are inherited from my superclass Stream.'!!PositionableStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	^collection copyFrom: 1 to: readLimit! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!contentsOfEntireFile	"For non-file streams"	^ self contents! !!PositionableStream methodsFor: 'accessing'!last	"Return the final element in the receiver.  Put in at Alan's request.  2/2/96 sw"	^ collection at: (position - 1)! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 3/27/98 08:44'!nextDelimited: terminator	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."	| out ch |	out _ WriteStream on: (String new: 1000).	self atEnd ifTrue: [^ ''].	self next == terminator ifFalse: [self skip: -1].	"absorb initial terminator"	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'accessing' stamp: 'sw 3/10/98 13:55'!nextInto: buffer 	"fill buffer from my collection"	(buffer isMemberOf: Bitmap) ifTrue:		[1 to: buffer size do:			[:index | buffer at: index put: (self nextNumber: 4)].		^ buffer].	1 to: buffer size do:		[:index | buffer at: index put: self next].	^ buffer! !!PositionableStream methodsFor: 'accessing'!originalContents	"Answer the receiver's actual contents collection, NOT a copy.  1/29/96 sw"	^ collection! !!PositionableStream methodsFor: 'accessing'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| nextObject |	self atEnd ifTrue: [^nil].	nextObject _ self next.	position _ position - 1.	^nextObject! !!PositionableStream methodsFor: 'accessing'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject _ self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position _ position - 1.	^false! !!PositionableStream methodsFor: 'accessing'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!PositionableStream methodsFor: 'accessing'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream el |	newStream _ WriteStream on: (collection species new: 100).	[(el _ self next) == nil] whileFalse: [ newStream nextPut: el ].	^ newStream contents! !!PositionableStream methodsFor: 'testing'!atEnd	"Primitive. Answer whether the receiver can access any more objects.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 67>	^position >= readLimit! !!PositionableStream methodsFor: 'testing'!isEmpty	"Answer whether the receiver's contents has no elements."	^position = 0! !!PositionableStream methodsFor: 'positioning' stamp: 'tk 2/3/98 18:02'!match: subCollection	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern _ ReadStream on: subCollection.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch + 1.						startMatch _ nil]]].	^self atEnd! !!PositionableStream methodsFor: 'positioning' stamp: 'di 2/15/98 14:41'!padTo: nBytes put: aCharacter 	"Pad using the argument, aCharacter, to the next boundary of nBytes characters."	| rem |	rem _ nBytes - (self position \\ nBytes).	rem = nBytes ifTrue: [^ 0].	self next: rem put: aCharacter.! !!PositionableStream methodsFor: 'positioning'!position	"Answer the current position of accessing the sequence of objects."	^position! !!PositionableStream methodsFor: 'positioning'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	anInteger >= 0 & (anInteger <= readLimit)		ifTrue: [position _ anInteger]		ifFalse: [self positionError]! !!PositionableStream methodsFor: 'positioning'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position _ 0! !!PositionableStream methodsFor: 'positioning' stamp: 'sw 3/10/98 13:55'!resetContents	"Set the position and limits to 0."	position _ 0.	readLimit _ 0! !!PositionableStream methodsFor: 'positioning'!setToEnd	"Set the position of the receiver to the end of the sequence of objects."	position _ readLimit! !!PositionableStream methodsFor: 'positioning'!skip: anInteger 	"Set the receiver's position to be the current position+anInteger. A 	subclass might choose to be more helpful and select the minimum of the 	receiver's size and position+anInteger, or the maximum of 1 and 	position+anInteger for the repositioning."	self position: position + anInteger! !!PositionableStream methodsFor: 'positioning'!skipTo: anObject 	"Set the access position of the receiver to be past the next occurrence of 	anObject. Answer whether anObject is found."	[self atEnd]		whileFalse: [self next = anObject ifTrue: [^true]].	^false! !!PositionableStream methodsFor: 'fileIn/Out'!command: aString	"Overridden by HtmlFileStream to append commands directly without translation.  4/5/96 tk"	"We ignore any HTML commands.  Do nothing"! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:44'!copyMethodChunkFrom: aStream	"Copy the next chunk from aStream (must be different from the receiver)."	| chunk |	chunk _ aStream nextChunkText.	chunk runs values size = 1 "Optimize for unembellished text"		ifTrue: [self nextChunkPut: chunk asString]		ifFalse: [self nextChunkPutWithStyle: chunk]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 08:49'!copyMethodWithPreamble: preamble from: aStream	| newFilePosition |	"First copy the preamble if any."	self copyPreamble: preamble from: aStream.	"Then copy the method chunk"	newFilePosition _ self position.	self copyMethodChunkFrom: aStream.	self nextChunkPut: ' '.	^ newFilePosition! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 09:16'!copyPreamble: preamble from: aStream	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator methodPos p last50 stamp i |	terminator _ $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	methodPos _ aStream position.	aStream position: (p _ 0 max: methodPos-50).	last50 _ aStream next: methodPos - p.	stamp _ String new.	(i _ last50 findString: 'stamp:' startingAt: 1) > 0 ifTrue:		[stamp _ (last50 copyFrom: i+8 to: last50 size) copyUpTo: $'].	"Write the new preamble, with old stamp if any."	self cr; nextPut: terminator.	self nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: preamble.		stamp size > 0 ifTrue:			[strm nextPutAll: ' stamp: '; print: stamp]]).	self cr! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/13/97 13:36'!decodeStyle: runsObjData version: styleVersion	"Decode the runs array from the ReferenceStream it is stored in."	"Verify that the class mentioned have the same inst vars as we have now"	| structureInfo |	styleVersion = RemoteString currentTextAttVersion ifTrue: [		"Matches our classes, no need for checking"		^ (ReferenceStream on: runsObjData) next].	structureInfo _ RemoteString structureAt: styleVersion.	"or nil"		"See SmartRefStream instVarInfo: for dfn"	^ SmartRefStream read: runsObjData withClasses: structureInfo! !!PositionableStream methodsFor: 'fileIn/Out'!header	"If the stream requires a standard header, override this message.  See HtmlFileStream"! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 2/3/98 14:29'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	| terminator out ch |	terminator _ $!!.	out _ WriteStream on: (String new: 1000).	self skipSeparators.	[(ch _ self next) == nil] whileFalse: [		(ch == terminator) ifTrue: [			self peek == terminator ifTrue: [				self next.  "skip doubled terminator"			] ifFalse: [				^ out contents  "terminator is not doubled; we're done!!"			].		].		out nextPut: ch.	].	^ out contents! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:54'!nextChunkText	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."	| string runsRaw strm runs peek |	"Read the plain text"	string _ self nextChunk.		"Test for ]style[ tag"	peek _ self skipSeparatorsAndPeekNext.	peek = $] ifFalse: [^ string asText].  "no tag"	(self upTo: $[) = ']style' ifFalse: [^ string asText].  "different tag"	"Read and decode the style chunk"	runsRaw _ self nextChunk.	"style encoding"	strm _ ReadStream on: runsRaw from: 1 to: runsRaw size.	runs _ RunArray scanFrom: strm.	^ Text basicNew setString: string setRunsChecking: runs.! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 6/13/97 12:00'!skipSeparators	[self atEnd]		whileFalse:		[self next isSeparator ifFalse: [^ self position: self position-1]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:08'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast"	| peek |	[self atEnd]		whileFalse:		[(peek _ self next) isSeparator			ifFalse: [self position: self position-1. ^ peek]]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'tk 12/29/97 12:37'!skipStyleChunk	"Get to the start of the next chunk that is not a style for the previous chunk"	| pos |	pos _ self position.	self skipSeparators.	self peek == $] 		ifTrue: [(self upTo: $[) = ']text' 	"old -- no longer needed"				"now positioned past the open bracket"			ifFalse: [self nextChunk]]	"absorb ]style[ and its whole chunk"						ifFalse: [self position: pos]	"leave untouched"! !!PositionableStream methodsFor: 'fileIn/Out'!trailer	"If the stream requires a standard trailer, override this message.  See HtmlFileStream"! !!PositionableStream methodsFor: 'fileIn/Out'!unCommand	"If this read stream is at a <, then skip up to just after the next >.  For removing html commands."	| char |	[self peek = $<] whileTrue: ["begin a block"		[self atEnd == false and: [self next ~= $>]] whileTrue.		"absorb characters"		]. ! !!PositionableStream methodsFor: 'fileIn/Out'!verbatim: aString	"Do not attempt to translate the characters.  Use to override nextPutAll:"	^ self nextPutAll: aString! !!PositionableStream methodsFor: 'private'!on: aCollection	collection _ aCollection.	readLimit _ aCollection size.	position _ 0.	self reset! !!PositionableStream methodsFor: 'private'!positionError	"Since I am not necessarily writable, it is up to my subclasses to override 	position: if expanding the collection is preferrable to giving this error."	self error: 'Attempt to set the position of a PositionableStream out of bounds'! !!PositionableStream methodsFor: 'private'!setFrom: newStart to: newStop	position _ newStart - 1.	readLimit _ newStop! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s _ 0.	1 to: 4 do: [:i | s _ (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextInt32Put: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos _ int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextLitteEndianNumber: n put: value	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes |	bytes _ ByteArray new: n.	1 to: n do: [: i | bytes at: i put: (value digitAt: i)].	self nextPutAll: bytes! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'jm 4/9/98 21:36'!nextLittleEndianNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."	| bytes s |	bytes _ self next: n.	s _ 0.	n to: 1 by: -1 do: [:i | s _ (s bitShift: 8) bitOr: (bytes at: i)].	^ s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextNumber: n 	"Answer the next n bytes as a positive Integer or LargePositiveInteger."	| s |	s _ 0.	1 to: n do: 		[:i | s _ (s bitShift: 8) bitOr: self next].	^ s normalize! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextNumber: n put: v 	"Append to the receiver the argument, v, which is a positive 	SmallInteger or a LargePositiveInteger, as the next n bytes.	Possibly pad with leading zeros."	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].	^ v! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextString	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first two bytes 	encode the length."	| aString char length|	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ (length - 192) * 256 + self next].	aString _ String new: length.	1 to: length do: [:i | aString at: i put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextStringPut: s 	"Append the string, s, to the receiver."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length // 256 + 192).			self nextPut: (length \\ 256)].	s do: [:char | self nextPut: char asciiValue].	^s! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWord	"Answer the next two bytes from the receiver as an Integer."	| high low |	high _ self next.		high==nil ifTrue: [^false].	low _ self next.		low==nil ifTrue: [^false].	^(high asInteger bitShift: 8) + low asInteger! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'sw 3/10/98 13:55'!nextWordPut: aWord 	"Append to the receiver an Integer as the next two bytes."	self nextPut: ((aWord bitShift: -8) bitAnd: 255).	self nextPut: (aWord bitAnd: 255).	^aWord! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PositionableStream class	instanceVariableNames: ''!!PositionableStream class methodsFor: 'instance creation'!on: aCollection 	"Answer an instance of me, streaming over the elements of aCollection."	^self basicNew on: aCollection! !!PositionableStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me, streaming over the elements of aCollection 	starting with the element at firstIndex and ending with the one at 	lastIndex."	^self basicNew on: (aCollection copyFrom: firstIndex to: lastIndex)! !Object subclass: #Preferences	instanceVariableNames: ''	classVariableNames: 'DesktopColor FlagDictionary '	poolDictionaries: ''	category: 'System-Support'!!Preferences commentStamp: 'di 5/22/1998 16:37' prior: 0!Preferences comment:'A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  It is also possible to store non-boolean data in the preference table.  sw 8/91'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Preferences class	instanceVariableNames: ''!!Preferences class methodsFor: 'initialization' stamp: 'jm 2/1/98 20:07'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	self setPreference: #reverseWindowStagger toValue: true.	self setPreference: #thoroughSenders toValue: true.	self setPreference: #uniformWindowColors toValue: false.	self setPreference: #warnIfNoChangesFile toValue: true.	self setPreference: #warnIfNoSourcesFile toValue: true.	self setPreference: #disableSounds toValue: false.! !!Preferences class methodsFor: 'initialization' stamp: 'jhm 10/15/97 17:13'!initialize	"Preferences initialize"	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'di 2/2/98 11:22'!confirmFirstUseOfStyle	"Squeak will ask the user if this flag is true and a method is	being accepted for the first time with embellished text.	NOTE: ignoreStyleIfOnlyBold has precedence over this setting."	^ true! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'jhm 10/15/97 17:31'!desktopColor	"Answer the desktop color. Initialize it if necessary."		DesktopColor == nil ifTrue: [DesktopColor _ Color gray].	^ DesktopColor! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'jhm 10/15/97 17:31'!desktopColor: aColor	"Record a new desktop color preference."	DesktopColor _ aColor.! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'sw 4/24/1998 18:10'!fontForScriptorButtons	^ StrikeFont familyName: #ComicBold size: 18! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'di 2/2/98 13:25'!ignoreStyleIfOnlyBold 	"Squeak will ignore source code emphasis that includes only boldface.	NOTE: this setting affects source from fileIns as well."	^ true! !!Preferences class methodsFor: 'hard-coded preferences' stamp: 'sw 5/6/1998 10:09'!noviceMode	^ false! !!Preferences class methodsFor: 'hard-coded preferences'!scrollBarColor	"Answer the preferred color for scroll bar elevators."	^ Color gray! !!Preferences class methodsFor: 'hard-coded preferences'!scrollBarWidth	"Answer the preferred width for scroll bars."	^ 8! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:29'!deletePreference: preferenceNameSymbol	FlagDictionary removeKey: preferenceNameSymbol ifAbsent: [].! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:32'!doesNotUnderstand: aMessage	"Look up the message selector as a flag."	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!openPreferencesInspector	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings."	"Preferences openPreferencesInspector"	FlagDictionary inspectWithLabel: 'Preferences'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!setPreference: preferenceNameSymbol toValue: aBoolean	FlagDictionary at: preferenceNameSymbol put: aBoolean.! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jhm 10/15/97 17:12'!valueOfFlag: aFlagName	^ FlagDictionary at: aFlagName ifAbsent: [false]! !!Preferences class methodsFor: 'ui prefs' stamp: 'di 1/2/98 11:15'!userPlacement	"Answer whether the user prefers to place and size all new windows by hand."	^ false! !Object subclass: #Presenter	instanceVariableNames: 'associatedMorph stopButton stepButton goButton balloonHelpEnabled mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabled viewerCache standardPlayer standardPlayfield standardPalette standardHolder '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!Presenter commentStamp: 'di 5/22/1998 16:37' prior: 0!Optionally associated with a PasteUpMorph, provides presentation services.Holds control buttons:	stopButton stepButton goButton.Holds state flags:	balloonHelpEnabled mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabledHolds a viewerCache Holds, optionally three standard items, idiomatic support of ongoing squeak-team internal work   standardPlayer standardPlayfield standardPalette !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph	^ associatedMorph! !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph: aMorph	associatedMorph _ aMorph! !!Presenter methodsFor: 'access' stamp: 'sw 4/22/1998 20:05'!world	^ associatedMorph world! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/2/1998 11:50'!addLeftHandButtons	| aMorph anExtent aPosition |	aMorph _ self newPaintingButton.	anExtent _ aMorph extent.	aPosition _ associatedMorph topLeft + (5 @ 3).	aPosition _ associatedMorph positionNear: aPosition forExtent: anExtent adjustmentSuggestion: (0 @ (anExtent y)).	associatedMorph addMorph: (aMorph beRepelling position: aPosition).	associatedMorph addMorph:		(self newPlayfieldButton position: (aPosition  + (5 @ 60))).	associatedMorph addMorph:		(self newPartsBinButton position: (aPosition + (9 @ 106))).	associatedMorph addMorph:		(self newControlsButton position: (aPosition + (6 @ 146)))! !!Presenter methodsFor: 'button creation' stamp: 'sw 4/22/1998 14:43'!addLowerLeftButtonsTo: aPasteUpMorph"save button disabled for now""	delta _ 40 @ 0.	aPosition _ aPosition + delta.	aButton _ SimpleButtonMorph new label: 'Save';			setProperty: #eToyControl toValue: true.	aButton target: eToyHolder playfield primaryHand; actionSelector: #saveEToyInFile;		position: aPosition.	aPasteUpMorph addMorphBack: aButton."! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 10:47'!addStandardControls	|  aControl |	self addStopStepGoButtonsTo: associatedMorph.	self addLeftHandButtons. 	self "er, add..." standardPlayer.	self addTrashCan.	"Save button"	aControl _ SimpleButtonMorph newSticky position: (380 @ (associatedMorph height - 30)).	aControl label: 'Save'; setProperty: #scriptingControl toValue: true.	aControl target: self; actionSelector: #saveOnFile.	associatedMorph addMorph: aControl! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/2/1998 18:02'!addStopStepGoButtons	self addStopStepGoButtonsTo: associatedMorph! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:00'!addStopStepGoButtonsTo: aPasteUpMorph	self stopButton.	self stepButton.	self goButton! !!Presenter methodsFor: 'button creation' stamp: 'jm 5/22/1998 11:50'!addTrashCan	| aControl aPosition |	(associatedMorph findA: TrashCanMorph) ifNotNil: [^ self].	aControl _ TrashCanMorph newSticky.	aPosition _ associatedMorph positionNear: (associatedMorph bottomRight - (58@76)) forExtent: aControl extent adjustmentSuggestion:  (-10 @ 0).	aControl position: aPosition.	associatedMorph addMorph: aControl.	aControl startStepping.	aControl setProperty: #scriptingControl toValue: true.! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 10:48'!flushButton	"for debugging only"	| aButton |	aButton _ EllipseMorph new extent: 41@25.	aButton addMorphCentered: (StringMorph new contents: 'Flush') lock;			color: (Color r: 0.548 g: 0.935 b: 0.935);			on: #mouseUp send: #flushUp:with: to: self;			setNameTo: 'Flush';			setProperty: #scriptingControl toValue: true;			setBalloonText: 'Don''t worry, youcan *never* go down the drain.Clears out the Viewer andflushes the viewer cache';			beRepelling.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 10:59'!goButton	| aDict |	goButton == nil  ifTrue:		[aDict _ ScriptingSystem formDictionary.		goButton _ ThreePhaseButtonMorph new.		goButton image:  (aDict at: 'GoPicOn');			offImage: (aDict at: 'GoPic');			pressedImage: (aDict at: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setBalloonText:'Press Go to resume runningall paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:01'!newControlsButton	| aDict aButton aForm |	aDict _ ScriptingSystem formDictionary.	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ aDict at: 'Controls');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createControlPanel; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Controls';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to get a Control panel'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:02'!newPaintingButton	| aDict aButton |	aDict _ ScriptingSystem formDictionary.	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aDict at: 'PaintBrush');		offImage: (aDict at: 'PaintBrush'); pressedImage:  (aDict at: 'PaintBrush').	aButton actionSelector: #dragAndDropToMakeNewDrawing; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'New Painting';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag a paintbrush into any playfieldto start drawing a new player there.'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:02'!newPartsBinButton	| aDict aButton aForm |	aDict _ ScriptingSystem formDictionary.	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ aDict at: 'PartsBin');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #createStandardPartsBin; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Parts Bin';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to create a new Parts Bin'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:02'!newPlayfieldButton	| aDict aButton aForm |	aDict _ ScriptingSystem formDictionary.	aButton _ ThreePhaseButtonMorph new.	aButton image:  (aForm _ aDict at: 'NewPlayfield');		offImage: aForm; pressedImage:  aForm.	aButton actionSelector: #makeNewPlayfield; 		arguments: Array new;		actWhen: #buttonDown; target: self;		setNameTo: 'Make Playfield';		beRepelling;		setProperty: #scriptingControl toValue: true;		setBalloonText: 'Drag from here to create a new Playfield'.	^ aButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/12/1998 01:13'!stepButton	| aDict aPosition |	stepButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (aDict at: 'StepPicOn');			offImage: (aDict at: 'StepPic'); pressedImage:  (aDict at: 'StepPicOn');			actionSelector: #stepStillDown:with:; 			arguments: (Array with: nil with: stepButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Press Step to run every pausedscript exactly once.  Keepthe mouse button down over "Step"and everything will keep runninguntil you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 5/6/1998 11:02'!stopButton	| aDict aPosition anExtent |	stopButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (aDict at: 'StopPic');			offImage: (aDict at: 'StopPic'); pressedImage:  (aDict at: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setBalloonText:'Press Stop to stop allrunning scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ 128 @ (associatedMorph height - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 4/23/1998 20:05'!addPageTwoControlsTo: aLayoutPage	"Return a book with pages containing controls"	| aWorld spacer button |	aWorld _ associatedMorph world.	spacer _ Morph new color: Color transparent; extent: 1@3.	button _ SimpleButtonMorph new target: aWorld; borderColor: Color black.	aLayoutPage color: Color transparent; borderWidth: 0; inset: 0.	aLayoutPage hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5; centering: #center.	"Commands sent to the Hand"		button target: self primaryHand; color: (Color r: 1.0 g: 0.8 b: 0.6) lighter.		#(  			('Import Graphic...'			importImageFromDisk)			('Grab Screen Area'		grabDrawingFromScreen)			('Show Hiders'			showHiders)												)		do:			[:pair |				aLayoutPage addMorphBack: (button fullCopy label: pair first;	actionSelector: pair last).				aLayoutPage addMorphBack: spacer fullCopy]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 5/11/1998 14:09'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		( BookMorph SimpleButtonMorph JoystickMorph)		( RecordingControlsMorph ClockMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 5/21/1998 18:27'!createControlPanel	|  aPanel aSize |	(aPanel _ associatedMorph world allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ associatedMorph primaryHand attachMorph: aPanel].	aSize _ 186 @ 50.	aPanel _ PasteUpMorph new extent: aSize.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	associatedMorph primaryHand attachMorph: aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 4/30/1998 22:10'!createStandardPartsBin	associatedMorph primaryHand attachMorph: self newStandardPartsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 5/7/1998 11:28'!newPageForStandardPartsBin	| aPage |	aPage _ PasteUpMorph new.	aPage color: Color white; padding: 10.	aPage autoLineLayout: true.	aPage isPartsBin: true; openToDragNDrop: false.	^ aPage! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 5/21/1998 18:15'!newStandardPartsBin	| aPartsContainer aPage aSize |	aSize _ 340 @ 160.	aPartsContainer _ BookMorph new color: Color blue veryMuchLighter.	aPartsContainer borderWidth: 2.	aPartsContainer removeEverything.	aPartsContainer openToDragNDrop: false.	aPartsContainer addMorphBack: (aPartsContainer makeMinimalControlsWithColor: Color transparent title: '    Parts Bin    ').	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage fixLayout.			aPartsContainer insertPage: aPage pageSize: aSize]."	aBrowser _ Browser new openAsMorphEditing: nil.	aPage _ self newPageForStandardPartsBin.	aBrowser extent: (200 @ 140); setLabel: 'Browser'.	aPage addMorphBack: aBrowser.	aPage markAsPartsDonor.	aPartsContainer insertPage: aPage pageSize: aSize.""	#(valueTiles booleanTiles arithmeticTiles) do:		[:aSym |			aPage _ self newPageForStandardPartsBin.			(self perform: aSym) do:				[:aTile | aPage addMorphBack: aTile markAsPartsDonor].			aPage fixLayout.			self coloredTilesEnabled ifFalse:				[aPage makeAllTilesGreen].			aPartsContainer insertPage: aPage pageSize: aSize]."	aPartsContainer goToPage: 1.^ aPartsContainer! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 4/21/1998 22:57'!ownStandardPalette	^ standardPalette! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 5/5/1998 00:11'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formDictionary at: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredCostumee renameTo: '�'.	aMorph setBalloonText: 'hrrumph, grr'.	self positionStandardPlayer.	^ standardPlayer	"ScriptingSystem formDictionary at: 'standardPlayer' put: (GIFImports at: 'broom')"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 5/2/1998 15:42'!positionStandardPlayer	| aPosition standardPlayerMorph |	standardPlayerMorph _ standardPlayer costume.	aPosition _ associatedMorph positionNear: (associatedMorph bottomLeft + (4 @ (standardPlayerMorph height negated))) forExtent: standardPlayerMorph extent adjustmentSuggestion: (standardPlayerMorph width @ 0).	standardPlayerMorph position: aPosition! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 4/22/1998 20:29'!standardHolder	^ standardHolder! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 4/22/1998 20:28'!standardHolder: aHolder	standardHolder _ aHolder! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 5/2/1998 15:31'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphFront: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 4/19/1998 01:03'!standardPlayer: aPlayer	standardPlayer _ aPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:35'!goButtonState: newState	goButton ifNotNil:		[newState			ifTrue: [goButton state: #on]			ifFalse: [goButton state: #off]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/2/1998 13:48'!goUp: evt with: aMorph	self startRunningScripts! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 13:12'!startRunningScripts	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	goButton world startRunningAll.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:35'!stepButtonState: newState	stepButton ifNotNil:		[newState			ifTrue: [stepButton state: #on]			ifFalse: [stepButton state: #off]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 10:20'!stepDown: evt with: aMorph	self stopRunningScripts! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 12:47'!stepStillDown: dummy with: theButton	self stepButtonState: true.	self stopButtonState: false.	theButton world stepAll; displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 13:10'!stepUp: evt with: aMorph	stepButton state: #off! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/12/1998 15:34'!stopButtonState: newState	stopButton ifNotNil:		[newState			ifTrue: [stopButton state: #on]			ifFalse: [stopButton state: #off]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 13:10'!stopRunningScripts	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	self stopButton world stopRunningAll! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/22/1998 01:33'!stopUp: dummy with: theButton	associatedMorph world flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 4/17/1998 23:12'!balloonHelpEnabled	^ balloonHelpEnabled == true! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 4/18/1998 01:35'!coloredTilesEnabled	^ coloredTilesEnabled == true! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 4/20/1998 17:54'!fenceEnabled	^ fenceEnabled == true! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 4/17/1998 23:04'!mouseOverHalosEnabled	^ mouseOverHalosEnabled == true! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 4/22/1998 20:03'!soundsEnabled	^ soundsEnabled == true! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 4/22/1998 20:04'!toggleColoredTiles	coloredTilesEnabled _ self coloredTilesEnabled not.	self harmonizeTilesWithColorSetting! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 4/20/1998 17:55'!toggleFence	fenceEnabled _ self fenceEnabled not! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 4/17/1998 23:12'!toggleShowBalloons	balloonHelpEnabled _ self balloonHelpEnabled not! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 4/17/1998 23:04'!toggleShowHalos	mouseOverHalosEnabled _ self mouseOverHalosEnabled not! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 4/22/1998 20:03'!toggleSoundsEnabled	soundsEnabled _ self soundsEnabled not! !!Presenter methodsFor: 'tile support' stamp: 'sw 5/3/1998 22:42'!arithmeticTiles	| list rcvr op arg |		list _ #(		(1 + 1)		(1 - 1)		(2 * 2)		(6 / 2)		(4 max: 3)		(7 min: 2)).	^ list collect: [:entry |		rcvr _ entry first.		op _ (entry at: 2) asSymbol.		arg _ entry last.		self phraseForReceiver: rcvr op: op arg: arg resultType: #number]! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/27/1998 02:56'!booleanTiles	| list rcvr op arg |	list _ #(		(0 < 1)		(0 <= 1)		(0 = 1)		(0 ~= 1)		(0 > 1)		(0 >= 1)).	list _ list asOrderedCollection collect: [:entry |		rcvr _ entry first.		op _ (entry at: 2) asSymbol.		arg _ entry last.		self phraseForReceiver: rcvr op: op arg: arg resultType: #boolean].	list add: (self phraseForReceiver: Color red op: #= arg: Color red resultType: #boolean).	^ list "copyWith: CompoundTileMorph new"! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:30'!constantTile: anObject	(anObject isKindOf: Color) ifTrue:		[^ ColorTileMorph new typeColor: (TilePadMorph colorForType: #color)].	^ anObject newTileMorphRepresentative		typeColor: (TilePadMorph colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:12'!listPaddedWithSpacersFrom: aList padExtent: padExtent	| listWithSpacers spacer |	listWithSpacers _ OrderedCollection new.	spacer _ Morph newSticky extent: padExtent; color: Color transparent.	aList do:		[:aMorph | listWithSpacers add: aMorph.		listWithSpacers add: spacer deepCopy].	listWithSpacers size > 1 ifTrue: [listWithSpacers last delete].	^ listWithSpacers! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/27/1998 22:13'!partsBinFor: morphList	| bin |	bin _ PartsBinMorph new		color: Color white;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: self color; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: (self presenter listPaddedWithSpacersFrom: morphList padExtent: 1@4).	bin openToDragNDrop: false.	^ bin! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/27/1998 22:14'!partsBinFor: morphList color: aColor	| bin |	bin _ PartsBinMorph new		color: Color white;		borderWidth: 0;		orientation: #vertical.	bin addMorphBack:		(Morph new color: aColor; extent: 1@1).  "placeholder for parts bin label"	bin addAllMorphs: (self listPaddedWithSpacersFrom: morphList padExtent: 1@4).	bin openToDragNDrop: false.	^ bin! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:27'!phraseForReceiver: rcvr op: op arg: arg resultType: resultType	| m argTile rcvrTile |	arg == nil		ifTrue:			[m _ PhraseTileMorph new setOperator: op				type: resultType				rcvrType: (self typeForConstant: rcvr)]		ifFalse:			[m _ PhraseTileMorph new setOperator: op				type: resultType				rcvrType: (self typeForConstant: rcvr)				argType: (self typeForConstant: arg).			argTile _ self constantTile: arg.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	rcvrTile _ self constantTile: rcvr."	TilePadMorph makeReceiverColorOfResultType ifTrue: [rcvrTile color: m color]."	rcvrTile position: m firstSubmorph position.	m firstSubmorph addMorph: rcvrTile.	^ m! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:24'!suppliesBook	"Return a book with pages containing bins of parts.  Everything in the supplies book is for drag-n-drop"	| book aColor |	aColor _ Color blue veryMuchLighter.	book _ BookMorph new borderWidth: 2.	book  removeEverything; addKidsDressing.	book		insertPageLabel: 'Values'		morphs: (Array with: (self partsBinFor: self valueTiles color: aColor)).	book		insertPageLabel: 'Comparing and Testing'		morphs: (Array with: (self partsBinFor: self booleanTiles color: aColor)).	book		insertPageLabel: 'Arithmetic'		morphs: (Array with: (self partsBinFor: self arithmeticTiles color: aColor)).	book goToPage: 1.	book openToDragNDrop: false.	^ book! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:28'!typeForConstant: anObject	^ anObject basicType! !!Presenter methodsFor: 'tile support' stamp: 'sw 5/3/1998 22:38'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (TilePadMorph colorForType: #color)).	tiles add: (TileMorph new typeColor: (TilePadMorph colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: ((TileMorph new typeColor: (TilePadMorph colorForType: #number))				setExpression: '(self getMouseX)' label: 'mouseX').	tiles add: ((TileMorph new typeColor: (TilePadMorph colorForType: #number))		setExpression: '(self getMouseY)' label: 'mouseY').	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/17/1998 21:29'!cacheViewer: aViewer forPlayer: aPlayer	self viewerCache at: aPlayer put: aViewer! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/17/1998 20:21'!flushViewerCache	viewerCache _ IdentityDictionary new! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/25/1998 12:32'!nascentPartsViewer	"EToyPlayer creates one that is sticky, here it's movable"	^ PartsViewer new! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/17/1998 21:42'!removeFromViewerCache: aPlayer	viewerCache ifNotNil:		[viewerCache removeKey: aPlayer ifAbsent: []]! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/25/1998 17:33'!updatePartsViewer: aPartsViewer	| aPlayer aPosition aNewPartsViewer oldOwner wasSticky |	aPlayer _ aPartsViewer scriptedPlayer.	aPosition _ aPartsViewer position.	self removeFromViewerCache: aPlayer.	wasSticky _ aPartsViewer isSticky.	aNewPartsViewer _ PartsViewer new.	wasSticky ifTrue: [aNewPartsViewer beSticky].	oldOwner _ aPartsViewer owner.	aPartsViewer delete.	oldOwner ifNotNil: [oldOwner addMorph: aNewPartsViewer].	aNewPartsViewer obtainBankInfoFrom: aPartsViewer.	aNewPartsViewer setPlayer: aPlayer.	aNewPartsViewer position: aPosition.	self coloredTilesEnabled ifFalse:		[aNewPartsViewer makeAllTilesGreen].	self cacheViewer: aNewPartsViewer forPlayer: aPlayer! !!Presenter methodsFor: 'viewer' stamp: 'sw 5/13/1998 00:17'!viewMorph: aMorph	| aPlayer aViewer aPalette |	(aPalette _ aMorph standardPalette) ifNotNil:		[^ aPalette viewMorph: aMorph].	aPlayer _ aMorph assuredCostumee.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!Presenter methodsFor: 'viewer' stamp: 'sw 4/17/1998 21:30'!viewerCache	viewerCache ifNil: [viewerCache _ IdentityDictionary new].	^ viewerCache! !!Presenter methodsFor: 'misc' stamp: 'sw 4/22/1998 15:21'!currentlyViewing: aPlayer	"Hook, for EToyPlayer to reimplement.  Probably can be dispensed with eventually"	^ false! !!Presenter methodsFor: 'misc' stamp: 'sw 4/22/1998 14:31'!dragAndDropToMakeNewDrawing	"Triggered by the user's dragging from the paint-brush; wherever the user drops the paintbrush, a new drawing will be started"	associatedMorph primaryHand attachMorph: PaintInvokingMorph authoringPrototype! !!Presenter methodsFor: 'misc' stamp: 'sw 4/18/1998 01:06'!drawingJustCompleted: aSketchMorph	"Some presenters, such as the original EToyPlayer, wish to pop up a viewer immediately"! !!Presenter methodsFor: 'misc' stamp: 'sw 5/6/1998 11:01'!grabScreenAreaButton  "not sent, momentarily.  A repository for this code"	| button |	button _ SimpleButtonMorph new.	button target: associatedMorph primaryHand; 		borderColor: Color black; 		color: (Color r: 1.0 g: 0.8 b: 0.6) lighter;		setNameTo: 'Grab Screen Area';		label: 'Grab Screen Area';		setProperty: #scriptingControl toValue: true;		actionSelector: #grabDrawingFromScreen.	^ button! !!Presenter methodsFor: 'misc' stamp: 'sw 4/22/1998 20:10'!harmonizeTilesWithColorSetting	self coloredTilesEnabled		ifTrue:			[self world makeAllTilesColored]		ifFalse:			[self world makeAllTilesGreen].	self flushViewerCache! !!Presenter methodsFor: 'misc' stamp: 'sw 4/17/1998 23:04'!initializeToggles 	balloonHelpEnabled _ true.	mouseOverHalosEnabled _ false.	soundsEnabled _ true.	fenceEnabled _ true.	coloredTilesEnabled _ false! !!Presenter methodsFor: 'misc' stamp: 'sw 4/18/1998 02:12'!makeNewPlayfield	| aPlayfield names aKey |	aPlayfield _ PasteUpMorph new.	names _ associatedMorph allSubmorphNames.	aKey _ Utilities keyLike: 'playfield' satisfying:		[:aName | (names includes: aKey) not].	aPlayfield setNameTo: aKey.	aPlayfield color: Color green muchLighter; borderWidth: 2; 		borderColor: Color green;		extent: 250 @ 200.	associatedMorph primaryHand attachMorph: aPlayfield! !!Presenter methodsFor: 'misc' stamp: 'sw 4/17/1998 20:39'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	"self viewMorph: aMorph"! !!Presenter methodsFor: 'misc' stamp: 'sw 4/18/1998 02:06'!mouseUpBalk: evt! !!Presenter methodsFor: 'misc' stamp: 'sw 4/18/1998 00:15'!playfield	| fields |	standardPlayfield ifNotNil: [standardPlayfield isInWorld ifTrue: [^ standardPlayfield]].	fields _ associatedMorph submorphs select: [:m | m isPlayfieldLike].	fields do: [:m | (m externalName beginsWith: 'playfield') ifTrue:		[standardPlayfield _ m.		^ m]].	^ m size > 0 ifTrue: [standardPlayfield _ m first] ifFalse: [associatedMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 4/18/1998 00:32'!returnToFrontPage	self inform: 'This would return youto the front page.'! !!Presenter methodsFor: 'misc' stamp: 'sw 4/23/1998 18:47'!tempCommand	Transcript cr; show: '#tempCommand invoked for Presenter'! !!Presenter methodsFor: 'misc' stamp: 'sw 5/2/1998 15:03'!toggleButtons	| aButton aDict aList |	aDict _ ScriptingSystem formDictionary.	aList _ #(	('Halos' 	'HalosOn'		'HalosOff' 		toggleShowHalos		mouseOverHalosEnabled)	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Show Halos:If green, then when thecursor pauses over an objecton the playfield, the objectwill sprout halos''Balloon Help:If green, then when thecursor pauses over an objectthat has balloon help,that help balloon is shown''Sounds:If green, sounds will be heard when appropriate; ifred, sounds are suppressed''Fence:If green, an invisible "fence"keeps your objects inside ofthe playfield')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (aDict at: q second);				offImage: (aDict at: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown; target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (aDict at: q second) extent.			aButton].	^ aList! !TextComponent subclass: #PrintComponent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!PrintComponent methodsFor: 'as yet unclassified' stamp: 'di 4/27/1998 11:49'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept |	self canDiscardEdits ifTrue: [^ self flash].	setTextSelector == nil ifTrue: [^ self].	textToAccept _ textMorph asText.	model perform: setTextSelector			with: (Compiler evaluate: textToAccept logged: false).	self setText: textToAccept.	self hasUnacceptedEdits: false! !!PrintComponent methodsFor: 'as yet unclassified' stamp: 'di 4/27/1998 11:35'!getText 	"Retrieve the current model text"	getTextSelector == nil ifTrue: [^ Text new].	^ (model perform: getTextSelector) printString asText! !!PrintComponent methodsFor: 'as yet unclassified' stamp: 'di 5/1/1998 13:39'!initPinSpecs 	pinSpecs _ Array		with: (PinSpec new pinName: 'value' direction: #inputOutput				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getTextSelector modelWriteSelector: setTextSelector				defaultValue: nil pinLoc: 1.5)! !Link subclass: #Process	instanceVariableNames: 'suspendedContext priority myList errorHandler '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Process commentStamp: 'di 5/22/1998 16:37' prior: 0!Process comment:'I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.'!!Process methodsFor: 'changing process state'!resume	"Primitive. Allow the process that the receiver represents to continue. Put 	the receiver in line to become the activeProcess. Fail if the receiver is 	already waiting in a queue (in a Semaphore or ProcessScheduler). 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 87>	self primitiveFailed! !!Process methodsFor: 'changing process state'!suspend	"Primitive. Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise fail and the code below will remove the receiver from the list 	of waiting processes. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 88>	Processor activeProcess == self		ifTrue: [self primitiveFailed]		ifFalse: 			[Processor remove: self ifAbsent: [self error: 'This process was not active'].			myList _ nil]! !!Process methodsFor: 'changing process state'!terminate 	"Stop the process that the receiver represents forever."	| context |	Processor activeProcess == self		ifTrue: 			[thisContext sender == nil ifFalse:				[thisContext sender release].			thisContext removeSelf suspend]		ifFalse: 			[myList == nil				ifFalse: 					[myList remove: self ifAbsent: [].					myList _ nil].			context _ suspendedContext.			suspendedContext _ nil.			(context ~~ nil and: [context sender ~~ nil])				ifTrue: [context sender release]]! !!Process methodsFor: 'changing suspended state'!install: aContext 	"Replace the suspendedContext with aContext."	self == Processor activeProcess		ifTrue: [^self error: 'The active process cannot install contexts'].	suspendedContext _ aContext! !!Process methodsFor: 'changing suspended state'!popTo: aContext 	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	self == Processor activeProcess		ifTrue: [^self error: 'The active process cannot pop contexts'].	suspendedContext releaseTo: aContext.	suspendedContext _ aContext! !!Process methodsFor: 'accessing'!offList	"Inform the receiver that it has been taken off a list that it was 	suspended on. This is to break a backpointer."	myList _ nil! !!Process methodsFor: 'accessing'!priority	"Answer the priority of the receiver."	^priority! !!Process methodsFor: 'accessing'!priority: anInteger 	"Set the receiver's priority to anInteger."	anInteger<=Processor highestPriority		ifTrue: [priority _ anInteger]		ifFalse: [self error: 'priority too high']! !!Process methodsFor: 'accessing'!suspendedContext	"Answer the context the receiver has suspended."	^suspendedContext! !!Process methodsFor: 'accessing'!suspendingList	"Answer the list on which the receiver has been suspended."	^myList! !!Process methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' in '.	suspendedContext printOn: aStream! !!Process methodsFor: 'private'!suspendedContext: aContext	suspendedContext _ aContext! !!Process methodsFor: 'error handling'!errorHandler    ^ errorHandler! !!Process methodsFor: 'error handling'!errorHandler: aBlock    errorHandler _ aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Process class	instanceVariableNames: ''!!Process class methodsFor: 'instance creation'!forContext: aContext priority: anInteger 	"Answer an instance of me that has suspended aContext at priority 	anInteger."	| newProcess |	newProcess _ self new.	newProcess suspendedContext: aContext.	newProcess priority: anInteger.	^newProcess! !Object subclass: #ProcessorScheduler	instanceVariableNames: 'quiescentProcessLists activeProcess '	classVariableNames: 'BackgroundProcess HighIOPriority LowIOPriority SystemBackgroundPriority SystemRockBottomPriority TimingPriority UserBackgroundPriority UserInterruptPriority UserSchedulingPriority '	poolDictionaries: ''	category: 'Kernel-Processes'!!ProcessorScheduler commentStamp: 'di 5/22/1998 16:37' prior: 0!ProcessorScheduler comment:'My single instance, named Processor, coordinates the use of the physical processor by all Processes requiring service.'!!ProcessorScheduler methodsFor: 'accessing'!activePriority	"Answer the priority level of the currently running Process."	^activeProcess priority! !!ProcessorScheduler methodsFor: 'accessing'!activeProcess	"Answer the currently running Process."	^activeProcess! !!ProcessorScheduler methodsFor: 'accessing'!highestPriority	"Answer the number of priority levels currently available for use."	^quiescentProcessLists size! !!ProcessorScheduler methodsFor: 'accessing'!highestPriority: newHighestPriority	"Change the number of priority levels currently available for use."	| continue newProcessLists |	(quiescentProcessLists size > newHighestPriority		and: [self anyProcessesAbove: newHighestPriority])			ifTrue: [self error: 'There are processes with priority higher than '													,newHighestPriority printString].	newProcessLists _ Array new: newHighestPriority.	1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do: 		[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].	quiescentProcessLists size to: newProcessLists size do: 		[:priority | newProcessLists at: priority put: LinkedList new].	quiescentProcessLists _ newProcessLists! !!ProcessorScheduler methodsFor: 'removing'!remove: aProcess ifAbsent: aBlock 	"Remove aProcess from the list on which it is waiting for the processor 	and answer aProcess. If it is not waiting, evaluate aBlock."	(quiescentProcessLists at: aProcess priority)		remove: aProcess ifAbsent: aBlock.	^aProcess! !!ProcessorScheduler methodsFor: 'process state change'!suspendFirstAt: aPriority 	"Suspend the first Process that is waiting to run with priority aPriority."	^self suspendFirstAt: aPriority		  ifNone: [self error: 'No Process to suspend']! !!ProcessorScheduler methodsFor: 'process state change'!suspendFirstAt: aPriority ifNone: noneBlock 	"Suspend the first Process that is waiting to run with priority aPriority. If 	no Process is waiting, evaluate the argument, noneBlock."	| aList |	aList _ quiescentProcessLists at: aPriority.	aList isEmpty		ifTrue: [^noneBlock value]		ifFalse: [^aList first suspend]! !!ProcessorScheduler methodsFor: 'process state change'!terminateActive	"Terminate the process that is currently running."	activeProcess terminate! !!ProcessorScheduler methodsFor: 'process state change'!yield	"Give other Processes at the current priority a chance to run."	| semaphore |	semaphore _ Semaphore new.	[semaphore signal] fork.	semaphore wait! !!ProcessorScheduler methodsFor: 'priority names'!highIOPriority	"Answer the priority at which the most time critical input/output 	processes should run. An example is the process handling input from a 	network."	^HighIOPriority! !!ProcessorScheduler methodsFor: 'priority names'!lowIOPriority	"Answer the priority at which most input/output processes should run. 	Examples are the process handling input from the user (keyboard, 	pointing device, etc.) and the process distributing input from a network."	^LowIOPriority! !!ProcessorScheduler methodsFor: 'priority names'!systemBackgroundPriority	"Answer the priority at which system background processes should run. 	Examples are an incremental garbage collector or status checker."	^SystemBackgroundPriority! !!ProcessorScheduler methodsFor: 'priority names'!timingPriority	"Answer the priority at which the system processes keeping track of real 	time should run."	^TimingPriority! !!ProcessorScheduler methodsFor: 'priority names'!userBackgroundPriority	"Answer the priority at which user background processes should run."	^UserBackgroundPriority! !!ProcessorScheduler methodsFor: 'priority names'!userInterruptPriority	"Answer the priority at which user processes desiring immediate service 	should run. Processes run at this level will preempt the window 	scheduler and should, therefore, not consume the processor forever."	^UserInterruptPriority! !!ProcessorScheduler methodsFor: 'priority names'!userSchedulingPriority	"Answer the priority at which the window scheduler should run."	^UserSchedulingPriority! !!ProcessorScheduler methodsFor: 'private'!anyProcessesAbove: highestPriority 	"Do any instances of Process exist with higher priorities?"	^(Process allInstances select: [:aProcess | aProcess priority > highestPriority]) isEmpty! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProcessorScheduler class	instanceVariableNames: ''!!ProcessorScheduler class methodsFor: 'class initialization'!initialize     	SystemRockBottomPriority _ 1.	SystemBackgroundPriority _ 2.	UserBackgroundPriority _ 3.	UserSchedulingPriority _ 4.	UserInterruptPriority _ 5.	LowIOPriority _ 6.	HighIOPriority _ 7.	TimingPriority _ 8	"ProcessorScheduler initialize."! !!ProcessorScheduler class methodsFor: 'instance creation'!new	"New instances of ProcessorScheduler should not be created."	self error:'New ProcessSchedulers should not be created sincethe integrity of the system depends on a unique scheduler'! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:44'!idleProcess	"A default background process which is invisible."	[true] whileTrue:		[self relinquishProcessorForMicroseconds: 1000].! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/3/97 11:17'!relinquishProcessorForMicroseconds: anInteger	"Platform specific. This primitive is used to return processor cycles to the host operating system when Squeak's idle process is running (i.e., when no other Squeak process is runnable). On some platforms, this primitive causes the entire Squeak application to sleep for approximately the given number of microseconds. No Squeak process can run while the Squeak application is sleeping, even if some external event makes it runnable. On the Macintosh, this primitive simply calls GetNextEvent() to give other applications a chance to run. On platforms without a host operating system, it does nothing. This primitive should not be used to add pauses to a Squeak process; use a Delay instead."	<primitive: 230>	"don't fail if primitive is not implemented, just do nothing"! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:42'!startUp	"Install a background process of the lowest possible priority that is always runnable."	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].	BackgroundProcess _ [self idleProcess] newProcess.	BackgroundProcess priority: SystemRockBottomPriority.	BackgroundProcess resume.! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:32'!sweepHandIdleProcess	"A default background process which shows a sweeping circle of XOR-ed bits on the screen."	| sweepHand |	sweepHand _ Pen new.	sweepHand defaultNib: 2.	sweepHand combinationRule: 6.	[true] whileTrue: [		2 timesRepeat: [			sweepHand north.			36 timesRepeat: [				sweepHand place: Display boundingBox topRight + (-25@25).				sweepHand go: 20.				sweepHand turn: 10]].		self relinquishProcessorForMicroseconds: 10000].! !Model subclass: #Project	instanceVariableNames: 'world changeSet transcript parentProject previousProject displayDepth activeProcess exitFlag viewSize thumbnail '	classVariableNames: 'CurrentProject '	poolDictionaries: ''	category: 'Interface-Projects'!!Project commentStamp: 'di 5/22/1998 16:37' prior: 0!Project comment:'A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet, as well as the parent project in which it was created.  When you change projects, whether by entering or exiting, all the global state is saved into the project being exited, and loaded from the one being entered.A project is retained by its view in the parent world.  It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds.  The distinction is based on whether the variable ''world'' contains a WorldMorph or a ControlManager.'!!Project methodsFor: 'initialization'!defaultBackgroundColor	^ #lightOrange! !!Project methodsFor: 'initialization' stamp: 'di 5/8/1998 20:52'!initFromParent:  aProject	"Written so that Morphic can still be removed."	world _ (Smalltalk at: #WorldMorph ifAbsent: [^ nil]) new.	changeSet _ ChangeSet new initialize.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ aProject! !!Project methodsFor: 'initialization'!initialExtent	^ (Display extent // 6) + (0@17)! !!Project methodsFor: 'initialization'!initialProject	self saveState.	parentProject _ self! !!Project methodsFor: 'initialization'!setChangeSet: aChangeSet	changeSet _ aChangeSet! !!Project methodsFor: 'initialization' stamp: 'di 5/8/1998 12:49'!setProjectHolder: aProject	world _ ControlManager new.	changeSet _ ChangeSet new initialize.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ aProject! !!Project methodsFor: 'accessing'!displayDepth: newDepth	displayDepth _ newDepth! !!Project methodsFor: 'accessing'!isTopProject	"Return true only of this is the top project (its own holder)"	^ parentProject == self! !!Project methodsFor: 'accessing'!leaveThisWorld	exitFlag _ true! !!Project methodsFor: 'accessing'!name	^ changeSet name! !!Project methodsFor: 'accessing' stamp: 'di 3/6/98 10:22'!parent	^ parentProject! !!Project methodsFor: 'accessing' stamp: 'jm 5/20/1998 23:31'!previousProject	^ previousProject! !!Project methodsFor: 'accessing'!projectChangeSet	^ changeSet! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:07'!setThumbnail: aForm	thumbnail _ aForm! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:06'!setViewSize: aPoint	viewSize _ aPoint! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:07'!thumbnail	^ thumbnail! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:06'!viewSize	^ viewSize! !!Project methodsFor: 'accessing'!world	^ world! !!Project methodsFor: 'menu messages' stamp: 'jm 5/21/1998 16:00'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom |	self == CurrentProject ifTrue: [^ self].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				vanishingPoint _ Sensor cursorPoint.				(entering ifTrue: [self] ifFalse: [previousProject]) dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [vanishingPoint _ v windowBox center]].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcess]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'jm 5/21/1998 15:44'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	activeProcess _ nil.	parentProject enter: false.! !!Project methodsFor: 'menu messages'!fileOut	changeSet fileOut! !!Project methodsFor: 'menu messages' stamp: 'jm 5/20/1998 23:35'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNotNil: [		thumbnail _ Form extent: viewSize depth: Display depth.		(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize)].! !!Project methodsFor: 'menu messages' stamp: 'di 6/16/97 11:39'!saveState	"Save the current state in me prior to switching projects"	world isMorph ifTrue: [world _ World]				ifFalse: [world _ ScheduledControllers.						ScheduledControllers unCacheWindows].	changeSet _ Smalltalk changes.	transcript _ Transcript.	displayDepth _ Display depth.! !!Project methodsFor: 'release' stamp: 'jm 5/21/1998 08:00'!deletingProject: aProject	"Clear my previousProject link if it points at the given Project, which is being deleted."	previousProject == aProject		ifTrue: [previousProject _ nil].! !!Project methodsFor: 'release' stamp: 'jm 5/21/1998 08:08'!okToChange	| ok |	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'release'!release	world == nil ifFalse:		[world release.		world _ nil].	^ super release! !!Project methodsFor: 'active process' stamp: 'di 5/4/1998 22:08'!cmdDotEnabled	"This should be a project variable -- for now it is a constant"	^ true! !!Project methodsFor: 'active process' stamp: 'di 5/4/1998 22:28'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList |	suspendingList _ activeProcess suspendingList.	suspendingList == nil		ifTrue: [activeProcess == Processor activeProcess					ifTrue: [activeProcess suspend]]		ifFalse: [suspendingList remove: activeProcess.				activeProcess offList].	Debugger openInterrupt: labelString			onProcess: activeProcess! !!Project methodsFor: 'active process' stamp: 'di 5/4/1998 22:18'!maybeForkInterrupt	World ifNil: [ScheduledControllers cmdDotEnabled ifTrue:					[[ScheduledControllers interruptName: 'User Interrupt'] fork]]		ifNotNil: [self cmdDotEnabled ifTrue:					[[self interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 5/4/1998 22:06'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive! !!Project methodsFor: 'printing' stamp: 'jm 5/21/1998 07:40'!printOn: aStream	aStream nextPutAll: 'a Project(', self name, ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Project class	instanceVariableNames: ''!!Project class methodsFor: 'class initialization'!initialize	"This is the Top Project."   	CurrentProject _ super new initialProject	"Project initialize"! !!Project class methodsFor: 'instance creation'!new	^ super new setProjectHolder: CurrentProject! !!Project class methodsFor: 'instance creation' stamp: 'di 11/16/97 09:39'!newMorphic   "ProjectView open: Project newMorphic"	^ super new initFromParent: CurrentProject! !!Project class methodsFor: 'utilities' stamp: 'jm 5/14/1998 17:17'!allNames	| names |	names _ OrderedCollection new.	self allInstancesDo: [:proj |		proj == CurrentProject ifFalse: [names add: proj name]].	^ names! !!Project class methodsFor: 'utilities' stamp: 'jm 5/21/1998 15:48'!jumpToProject	"Present a list of potential projects and enter the one selected."	"Project jumpToProject"	| selection menu |	menu _ CustomMenu new.	CurrentProject previousProject ifNotNil: [		menu add: 'previous project' action: #previous].	CurrentProject isTopProject ifFalse: [		menu add: 'parent project' action: #parent].	menu addLine.	Project allNames do: [:n | menu add: n action: n].	selection _ menu startUp.	selection ifNotNil: [		selection = #previous ifTrue: [^ self returnToPreviousProject].		selection = #parent ifTrue: [CurrentProject parent enter: false. ^ self].		(Project named: selection) enter: false].! !!Project class methodsFor: 'utilities' stamp: 'jm 5/20/1998 23:38'!named: projName	"Answer the project with the given name, or the current project if there is no project of that given name."	"(Project named: 'zork') enter"	^ self allInstances		detect: [:proj | proj name = projName]		ifNone: [self current]! !!Project class methodsFor: 'utilities' stamp: 'jm 5/21/1998 15:46'!returnToPreviousProject	"Return to the project from which this project was entered. Do nothing if the current project has no link to its previous project."	| prevProj |	prevProj _ CurrentProject previousProject.	prevProj ifNotNil: [prevProj enter: true].! !!Project class methodsFor: 'constants'!current	"Answer the project that is currently being used."	^CurrentProject! !StandardSystemController subclass: #ProjectController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Projects'!!ProjectController methodsFor: 'control activity' stamp: 'di 1/21/98 19:03'!controlInitialize  "Overridden to allow single-click entry"	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	self labelHasCursor ifTrue: [sensor waitNoButton].	status _ #active! !!ProjectController methodsFor: 'control activity' stamp: 'jm 5/21/1998 15:44'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index _ (PopUpMenu labelArray: #('enter' 'jump to project...') lines: #()) 		startUpCenteredWithCaption: nil.	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false].	index = 2 ifTrue: [Project jumpToProject. ^ self].! !StandardSystemView subclass: #ProjectView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Projects'!!ProjectView methodsFor: 'initialization'!defaultControllerClass	^ ProjectController! !!ProjectView methodsFor: 'initialization' stamp: 'di 5/6/1998 17:03'!relabel: newLabel	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ self].	model projectChangeSet name: newLabel.	super relabel: newLabel! !!ProjectView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ false! !!ProjectView methodsFor: 'displaying' stamp: 'di 1/21/98 11:50'!displayView	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNotNil:		[model thumbnail displayAt: self insetDisplayBox topLeft]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProjectView class	instanceVariableNames: ''!!ProjectView class methodsFor: 'as yet unclassified'!open: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView controller open! !ImageMorph subclass: #ProjectViewMorph	instanceVariableNames: 'project lastProjectThumbnail '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ProjectViewMorph commentStamp: 'di 5/22/1998 16:37' prior: 0!I am a Morphic view of a project. I display a scaled version of the project's thumbnail, which itself is a scaled-down snapshot of the screen taken when the project was last exited. When I am displayed, I check to see if the project thumbnail has changed and, if so, I update my own view of that thumbnail.!!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/14/1998 15:47'!borderWidth: ignored	"Sent by SystemWindow, but ignored here."! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 5/15/1998 22:49'!drawOn: aCanvas	(project ~~ nil and: [project thumbnail ~~ lastProjectThumbnail]) ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: image)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: image extent).			lastProjectThumbnail _ project thumbnail.			image borderWidth: 1].	super drawOn: aCanvas.! !!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/21/1998 15:44'!enter	"Enter my project."	project setViewSize: self extent.	project enter: false.! !!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/14/1998 16:13'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale fillColor |	((bounds extent = aPoint) and:	 [image depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP x asFloat max: scaleP y asFloat.				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self image: (Form extent: newExtent depth: Display depth).		project world			ifNil: [fillColor _ project world color]			ifNotNil: [fillColor _ Color veryLightGray].		image fill: image boundingBox fillColor: fillColor.		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/4/1998 22:13'!handlesMouseDown: evt	^ true! !!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/21/1998 00:07'!mouseDown: evt	"Quick hack: use old-fashioned menu."	| menu selection |	menu _ CustomMenu new		add: 'enter' action: #enter;		add: 'jump to project...' action: #jumpToProject.	selection _ menu startUp: #enter.	selection = #enter ifTrue: [^ self enter].	selection = #jumpToProject ifTrue: [Project jumpToProject. ^ self].! !!ProjectViewMorph methodsFor: 'all' stamp: 'jm 5/14/1998 17:13'!on: aProject	project _ aProject.	lastProjectThumbnail _ nil.	project thumbnail		ifNil: [self extent: 80@100]		ifNotNil: [self extent: project thumbnail extent].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProjectViewMorph class	instanceVariableNames: ''!!ProjectViewMorph class methodsFor: 'instance creation' stamp: 'jm 5/14/1998 16:19'!on: aProject	^ self new on: aProject! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'jm 5/14/1998 16:19'!newMVCProject	"Create an instance of me on a new MVC project (in a SystemWindow)."	| proj window |	proj _ Project new.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'jm 5/14/1998 16:19'!newMorphicProject	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphic.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !MessageSet subclass: #ProtocolBrowser	instanceVariableNames: 'selectedClass selectedSelector '	classVariableNames: 'TextMenu '	poolDictionaries: ''	category: 'Interface-Browser'!!ProtocolBrowser commentStamp: 'di 5/22/1998 16:37' prior: 0!ProtocolBrowser comment:'An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.'!!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!getList	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!list	"Answer the receiver's message list."	^ messageList! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selectedClass	"Answer the receiver's selected class."	^ selectedClass! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selectedClass: aClass	"Set the receiver's selected class to be the argument."	selectedClass := aClass! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector	"Answer the receiver's selected selector."	^ selectedSelector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString.	self changed: #selector! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!setSelector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:23'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface."	| defClass item |	messageList := OrderedCollection new.	selectorCollection do: 		[:selector |  defClass := aClass whichClassIncludesSelector: selector.		item _ selector, '     (' , defClass name , ')'.		messageList add: (defClass == aClass ifTrue:[item asText allBold] ifFalse:[item])]! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:26'!on: aClass 	"Initialize with the entire protocol for the class, aClass."	self initListFrom: aClass allSelectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:29'!onSubProtocolOf: aClass 	"Initialize with the entire protocol for the class, aClass,		but excluding those inherited from Object."	| selectors |	selectors := Set new.	(aClass withAllSuperclasses copyWithout: Object) do:		[:each | selectors addAll: each selectors].	self initListFrom: selectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser methodsFor: 'private' stamp: 'tk 4/3/98 09:32'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	| tuple cl |	tuple _ messageString asString findTokens: ' '.	cl _ tuple at: 2.	cl _ cl copyWithoutAll: '()'.  "Strip parens"	cl _ tuple size = 2		ifTrue: [Smalltalk at: cl asSymbol]		ifFalse: [(Smalltalk at: cl asSymbol) class].	self selectedClass: cl.	self setSelector: tuple first.	^ csBlock value: cl value: tuple first asSymbol! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:37'!setClassAndSelectorIn: csBlock	"Decode strings of the form <selectorName>   (<className> [class])  "	^ self parse: self selection toClassAndSelector: csBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProtocolBrowser class	instanceVariableNames: ''!!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openFullProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new on: aClass.	label := 'Entire protocol of: ', aClass name.	self open: aPBrowser name: label! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openSubProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.	label := 'Sub-protocol of: ', aClass name.	self open: aPBrowser name: label! !Object variableSubclass: #PseudoContext	instanceVariableNames: 'fixed fields never accessed from smalltalk '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!PseudoContext commentStamp: 'di 5/22/1998 16:37' prior: 0!PseudoContext comment:'I represent cached context state within the virtual machine.  I have the same format as normal method and block contexts, but my fields are never referenced directly from Smalltalk.  Whenever a message is sent to me I will magically transform myself into a real context which will respond to all the usual messages.	I rely on the fact that block and method contexts have exactly the same number of fixed fields.'!!PseudoContext methodsFor: 'testing' stamp: 'ikp 9/26/97 14:45'!isPseudoContext	^true! !!PseudoContext methodsFor: 'system primitives' stamp: 'ikp 10/20/97 15:36'!nextObject	"See Object>>nextObject."	<primitive: 139>	self primitiveFailed.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PseudoContext class	instanceVariableNames: ''!!PseudoContext class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:33'!initialize	"It's tricky to do the necessary stuff with the regular file-in machinery."	PseudoContext superclass = nil		ifFalse: [			(Smalltalk confirm: 'Shall I convert PseudoContext into a compact subclass of nil?("yes" is almost always the correct response)')				ifTrue: [					PseudoContext becomeCompact.					PseudoContext superclass removeSubclass: PseudoContext.					PseudoContext superclass: nil]].	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !!PseudoContext class methodsFor: 'filing out' stamp: 'ikp 9/26/97 14:45'!definition	"Our superclass is really nil, but this causes problems when we try to become compact	after filing in for the first time.  Fake the superclass as Object, and repair the situation	during class initialisation."	| defn |	defn _ super definition.	^(defn beginsWith: 'nil ')		ifTrue: ['Object' , (defn copyFrom: 4 to: defn size)]		ifFalse: [defn].! !!PseudoContext class methodsFor: 'private' stamp: 'ikp 9/26/97 14:45'!contextCacheDepth	"Answer the number of entries in the context cache.  This requires a little insider	knowledge.  Not intended for casual use, which is why it's private protocol."	^self contextCacheDepth: thisContext yourself! !!PseudoContext class methodsFor: 'private' stamp: 'ikp 9/26/97 14:45'!contextCacheDepth: b	^b isPseudoContext		ifTrue: [1 + (self contextCacheDepth: b)]		ifFalse: [1]! !Rectangle subclass: #Quadrangle	instanceVariableNames: 'borderWidth borderColor insideColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Quadrangle commentStamp: 'di 5/22/1998 16:37' prior: 0!Quadrangle comment:'I represent a particular kind of Rectangle that has a border and inside color.'!!Quadrangle methodsFor: 'initialize-release'!initialize	"Initialize the region to a null Rectangle, the borderWidth to 1, the 	borderColor to black, and the insideColor to white."	origin _ 0 @ 0.	corner _ 0 @ 0.	borderWidth _ 1.	borderColor _ Color black.	insideColor _ Color white.! !!Quadrangle methodsFor: 'bordering'!borderColor	"Answer the form that is the borderColor of the receiver."	^borderColor! !!Quadrangle methodsFor: 'bordering'!borderColor: aColor 	"Set the borderColor of the receiver to aColor, a Form."	borderColor _ aColor! !!Quadrangle methodsFor: 'bordering'!borderWidth	"Answer the borderWidth of the receiver."	^borderWidth! !!Quadrangle methodsFor: 'bordering'!borderWidth: anInteger 	"Set the borderWidth of the receiver to anInteger."	borderWidth _ anInteger! !!Quadrangle methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border width of the receiver to a Rectangle that represents the 	left, right, top, and bottom border widths."	borderWidth _ anInteger1 @ anInteger3 corner: anInteger2 @ anInteger4! !!Quadrangle methodsFor: 'bordering'!inside	"Answer a Rectangle that is the receiver inset by the borderWidth."	^self insetBy: borderWidth! !!Quadrangle methodsFor: 'bordering'!insideColor	"Answer the form that is the insideColor of the receiver."	^insideColor! !!Quadrangle methodsFor: 'bordering'!insideColor: aColor 	"Set the insideColor of the receiver to aColor, a Form."	insideColor _ aColor! !!Quadrangle methodsFor: 'bordering'!region	"Answer a Rectangle that defines the area of the receiver."	^origin corner: corner! !!Quadrangle methodsFor: 'bordering'!region: aRectangle 	"Set the rectangular area of the receiver to aRectangle."	origin _ aRectangle origin.	corner _ aRectangle corner! !!Quadrangle methodsFor: 'rectangle functions'!intersect: aRectangle 	"Answer a new Quadrangle whose region is the intersection of the 	receiver's area and aRectangle.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class	 	region: (super intersect: aRectangle)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Answer a new Quadrangle translated by aPoint2 - aPoint1.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: aPoint2 - aPoint1)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!alignedTo: alignPointSelector	"Return a copy with offset according to alignPointSelector which is one of...	#(topLeft, topCenter, topRight, leftCenter, center, etc)	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: (0@0) - (self perform: alignPointSelector))		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!scaleBy: aPoint 	"Answer a new Quadrangle scaled by aPoint.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super scaleBy: aPoint)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'transforming'!translateBy: aPoint 	"Answer a new Quadrangle translated by aPoint.	 5/24/96 sw: removed hard-coded class name so subclasses can gain same functionality."	^ self class		region: (super translateBy: aPoint)		borderWidth: borderWidth		borderColor: borderColor		insideColor: insideColor! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium	"Display the border and insideRegion of the receiver."	borderWidth ~~ 0		ifTrue:	[aDisplayMedium				border: self region				widthRectangle: borderWidth				rule: Form over				fillColor: borderColor].	insideColor ~~ nil		ifTrue:	[aDisplayMedium fill: self inside fillColor: insideColor]! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium align: aPoint1 with: aPoint2 clippingBox: aRectangle	"Display the border and region of the receiver so that its position at 	aPoint1 is aligned with position aPoint2. The displayed information 	should be clipped so that only information with the area determined by 	aRectangle is displayed."	| savedRegion |	savedRegion _ self region.	self region: ((savedRegion align: aPoint1 with: aPoint2) intersect: aRectangle).	self displayOn: aDisplayMedium.	self region: savedRegion! !!Quadrangle methodsFor: 'displaying-generic'!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle _ 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	borderWidth ~~ 0 & (insideColor ~~ nil)		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!Quadrangle methodsFor: 'displaying-generic'!displayOnPort: aPort at: p	"Display the border and insideRegion of the receiver."	(insideColor == nil or: [borderWidth <= 0])		ifFalse: [aPort fill: (self region translateBy: p) 			fillColor: borderColor rule: Form over].	insideColor == nil		ifFalse: [aPort fill: (self inside translateBy: p) 			fillColor: insideColor rule: Form over]! !!Quadrangle methodsFor: 'displaying-Display'!display 	"Display the border and insideRegion of the receiver on the Display."	self displayOn: Display! !!Quadrangle methodsFor: 'displaying-Display'!displayAlign: aPoint1 with: aPoint2 clippingBox: aRectangle 	"Display the border and region of the receiver on the Display so that its 	position at aPoint1 is aligned with position aPoint2. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed." 	self displayOn: Display align: aPoint1 with: aPoint2 clippingBox: aRectangle! !!Quadrangle methodsFor: 'displaying-Display'!displayTransformation: aWindowingTransformation clippingBox: aRectangle 	"Display the border and region of the receiver on the Display so that it 	is scaled and translated with respect to aWindowingTransformation. The 	displayed information should be clipped so that only information with 	the area determined by aRectangle is displayed." 	self displayOn: Display transformation: aWindowingTransformation clippingBox: aRectangle! !!Quadrangle methodsFor: 'private'!setRegion: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	origin _ aRectangle origin.	corner _ aRectangle corner.	borderWidth _ anInteger.	borderColor _ aMask1.	insideColor _ aMask2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quadrangle class	instanceVariableNames: ''!!Quadrangle class methodsFor: 'instance creation'!new	"Answer an instance of me, initialized to a null Rectangle, 	with borderWidth of 1, borderColor of black, and insideColor of white."	^super new initialize! !!Quadrangle class methodsFor: 'instance creation'!region: aRectangle borderWidth: anInteger borderColor: aMask1 insideColor: aMask2	"Answer an instance of me with rectangle, border width and color, and 	inside color determined by the arguments."	^super new		setRegion: aRectangle		borderWidth: anInteger		borderColor: aMask1		insideColor: aMask2! !CharacterScanner subclass: #QuickPrint	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!QuickPrint commentStamp: 'di 5/22/1998 16:37' prior: 0!QuickPrint comment:'This class supports fast, single-line string display. It is significantly faster than using a Paragraph for the same purpose.'!!QuickPrint methodsFor: 'displaying' stamp: 'di 10/29/97 20:52'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: clipX + clipWidth + font maxWidth		stopConditions: stopConditions		displaying: true! !!QuickPrint methodsFor: 'displaying'!lineHeight	"Answer the height of the font used by QuickPrint."	^ font height! !!QuickPrint methodsFor: 'displaying' stamp: 'di 10/29/97 20:52'!stringWidth: aString	"Answer the width of the given string."	destX _ 0.	destY _ 0.	self scanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		displaying: false.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!QuickPrint methodsFor: 'private' stamp: 'di 10/29/97 12:21'!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	font _ aStrikeFont ifNil: [TextStyle default fontAt: 1].	self setFont.	destForm _ aForm.	self colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: ((textColor bitPatternForDepth: destForm depth) at: 1)).	combinationRule _ Form paint.	self clipRect: aRectangle.	sourceY _ 0.	kern _ 0.	"sourceX is set when selecting the character from the font strike bitmap"! !!QuickPrint methodsFor: 'private'!setFont	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QuickPrint class	instanceVariableNames: ''!!QuickPrint class methodsFor: 'instance creation'!new	"Create an instance to print on the display in the default font."	^ super new newOn: Display box: Display boundingBox font: self defaultFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: self defaultFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^(super new) newOn: aForm box: aRectangle font: aStrikeFont color: Color black! !!QuickPrint class methodsFor: 'instance creation'!newOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Create an instance to print on the given form in the given rectangle."	^ (super new) newOn: aForm box: aRectangle font: aStrikeFont color: textColor! !!QuickPrint class methodsFor: 'queries'!defaultFont	^ (TextStyle default) fontArray at: 1! !!QuickPrint class methodsFor: 'example'!example	"This will quickly print all the numbers from 1 to 100 on the display,	and then answer the default width and height of the string 'hello world'."	"QuickPrint example"	| scanner |	scanner _ QuickPrint new.	0 to: 99 do: [: i | scanner drawString: i printString at: (i//10*20) @ (i\\10*12) ].	^ (scanner stringWidth: 'hello world') @ (scanner lineHeight)! !ReadWriteStream subclass: #RWBinaryOrTextStream	instanceVariableNames: 'isBinary '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!RWBinaryOrTextStream commentStamp: 'di 5/22/1998 16:37' prior: 0!A simulation of a FileStream, but living totally in memory.  Hold the contents of a file or web page from the network.  Can then fileIn like a normal FileStream.Need to be able to switch between binary and text, as a FileStream does, without recopying the whole collection.  Convert to binary upon input and output.  Always keep as text internally.!!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/25/97 13:22'!ascii	isBinary _ false! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:46'!binary	isBinary _ true! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 12:49'!contents	"Answer with a copy of my collection from 1 to readLimit."	| newArray |	isBinary ifFalse: [^ super contents].	"String"	readLimit _ readLimit max: position.	newArray _ ByteArray new: readLimit.	^ newArray replaceFrom: 1		to: readLimit		with: collection		startingAt: 1.! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'jm 11/4/97 08:25'!contentsOfEntireFile	"For compatibility with file streams."	^ self contents! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:47'!isBinary	^ isBinary! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 12/13/97 13:07'!next	| byte |	^ isBinary 			ifTrue: [byte _ super next.				 byte ifNil: [nil] ifNotNil: [byte asciiValue]]			ifFalse: [super next].! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 12:51'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].		"Could be done faster than this!!"	^newArray! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 07:38'!nextPut: charOrByte	super nextPut: charOrByte asCharacter! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/21/97 13:04'!reset	"Set the receiver's position to the beginning of the sequence of objects."	super reset.	isBinary ifNil: [isBinary _ false].	collection class == ByteArray ifTrue: ["Store as String and convert as needed."		collection _ collection asString.		isBinary _ true].! !!RWBinaryOrTextStream methodsFor: 'all' stamp: 'tk 6/20/97 19:47'!text	isBinary _ false! !Object subclass: #Random	instanceVariableNames: 'seed a m q r '	classVariableNames: ''	poolDictionaries: ''	category: 'Numeric-Numbers'!!Random commentStamp: 'di 5/22/1998 16:37' prior: 0!Random comment:'This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG which uses Floats to avoid the need for LargeInteger arithmetic.'!!Random methodsFor: 'all'!initialize	" Set a reasonable Park-Miller starting seed "	seed := Time millisecondClockValue.	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!Random methodsFor: 'all'!next	" This method generates random instances of Float in the interval 0to 1. "	seed := self nextValue.	^ seed / m! !!Random methodsFor: 'all'!nextValue	" This method generates random instances of Integer	in the interval 0 to 16r7FFFFFFF.	This method does NOT update the seed; repeated sends answer thesame value.	The algorithm is described in detail in 'Random Number Generators:	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988). "	| lo hi aLoRHi answer |	hi := (seed quo: q) asFloat.	lo := seed - (hi*q).     " = seed rem: q"  	aLoRHi := (a * lo) - (r * hi).	answer := (aLoRHi > 0.0)		ifTrue:  [ aLoRHi ]		ifFalse: [ aLoRHi + m ].	^ answer! !!Random methodsFor: 'all'!seed: anInteger	 seed := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Random class	instanceVariableNames: ''!!Random class methodsFor: 'examples'!example	"If you just want a quick random integer, use:		10 atRandom	Every integer interval can give a random number:		(6 to: 12) atRandom	Most Collections can give randomly selected elements:		'pick one of these letters randomly' atRandom	Collections also respond to shuffled, as in:		($A to: $Z) shuffled	The correct way to use class Random is to store one in 	an instance or class variable:		myGenerator _ Random new.	Then use it every time you need another number between 0.0 and 1.0		myGenerator next"! !!Random class methodsFor: 'testing'!bucketTest: randy	"Execute this:   Random bucketTest: Random new"	" A quick-and-dirty bucket test. Prints nbuckets values on theTranscript.	  Each should be 'near' the value of ntries. Any run with any value'far' from ntries	  indicates something is very wrong. Each run generates differentvalues.	  For a slightly better test, try values of nbuckets of 200-1000 ormore; go get coffee.	  This is a poor test; see Knuth.   Some 'OK' runs:		1000 1023 998 969 997 1018 1030 1019 1054 985 1003		1011 987 982 980 982 974 968 1044 976		1029 1011 1025 1016 997 1019 991 954 968 999 991		978 1035 995 988 1038 1009 988 993 976"	| nbuckets buckets ntrys slot |	nbuckets := 20.	buckets := Array new: nbuckets.	buckets atAllPut: 0.	ntrys :=  100.	ntrys*nbuckets timesRepeat: [		slot := (randy next * nbuckets) floor + 1.		buckets at: slot put: (buckets at: slot) + 1 ].	Transcript cr.	1 to: nbuckets do: [ :nb |		Transcript show: (buckets at: nb) printString, ' ' ]! !!Random class methodsFor: 'testing'!theItsCompletelyBrokenTest	"Random theItsCompletelyBrokenTest"	"The above should print as...	(0.149243269650845 0.331633021743797 0.75619644800024 0.393701540023881 0.941783181364547 0.549929193942775 0.659962596213428 0.991354559078512 0.696074432551896 0.922987899707159 )	If they are not these values (accounting for precision of printing) then something is horribly wrong: DO NOT USE THIS CODE FOR ANYTHING. "	| rng |	rng := Random new.	rng seed: 2345678901.	^ (1 to: 10) collect: [:i | rng next]! !!Random class methodsFor: 'instance creation'!new	^ super new		initialize! !PluggableTextController subclass: #ReadOnlyTextController	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Pluggable'!!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:41'!accept 	"Overridden to allow accept of clean text"	(view setText: paragraph text from: self) ifTrue:		[initialText _ paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]].! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 14:02'!userHasEdited	"Ignore this -- I stay clean"! !!ReadOnlyTextController methodsFor: 'as yet unclassified' stamp: 'di 5/7/1998 13:45'!zapSelectionWith: aText	view flash  "no edits allowed"! !PositionableStream subclass: #ReadStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!ReadStream commentStamp: 'di 5/22/1998 16:37' prior: 0!ReadStream comment:'I represent an accessor for a sequence of objects that can only read objects from the sequence.'!!ReadStream methodsFor: 'accessing'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!ReadStream methodsFor: 'accessing'!nextPut: anObject	self shouldNotImplement! !!ReadStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection _ aCollection.	readLimit _  lastIndex > (len _ collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position _ firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReadStream class	instanceVariableNames: ''!!ReadStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer with a new instance streaming over a copy of aCollection from	firstIndex to lastIndex."	^self basicNew		on: aCollection		from: firstIndex		to: lastIndex! !WriteStream subclass: #ReadWriteStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!ReadWriteStream commentStamp: 'di 5/22/1998 16:37' prior: 0!ReadWriteStream comment:'I represent an accessor for a sequence of objects. My instances can both read and store objects.'!!ReadWriteStream methodsFor: 'accessing'!contents	"Answer with a copy of my collection from 1 to readLimit."	readLimit _ readLimit max: position.	^collection copyFrom: 1 to: readLimit! !!ReadWriteStream methodsFor: 'accessing'!name	^ 'a stream'   "for fileIn compatibility"! !!ReadWriteStream methodsFor: 'accessing'!next	"Primitive. Return the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	"treat me as a FIFO"	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!ReadWriteStream methodsFor: 'file status'!close	"Presumably sets the status of the receiver to be closed. This message does 	nothing at this level, but is included for FileStream compatibility."	^self! !!ReadWriteStream methodsFor: 'file status'!closed	"If you have close (for FileStream compatibility), you must respond to closed.  The result in nonsense here.  TK 29 May 96"	^ false! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 1/13/98 16:57'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| val |	'Reading ' , self name		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)							ifTrue: [(Compiler evaluate: self nextChunk logged: false)									scanFrom: self]							ifFalse: [Compiler evaluate: self nextChunk logged: true].				self skipStyleChunk].		self close].	^ val! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/17/97 16:12'!fileInObjectAndCode	"This file may contain:1) a fileIn of code  2) just an object in SmartReferenceStream format 3) both code and an object.	File it in and return the object.  Note that self must be a FileStream or RWBinaryOrTextStream.  Maybe ReadWriteStream incorporate RWBinaryOrTextStream?"	| refStream object |	self text.	self peek asciiValue = 4		ifTrue: [  "pure object file"			refStream _ SmartRefStream on: self.			object _ refStream nextAndClose]		ifFalse: [  "objects mixed with a fileIn"			self fileIn.  "reads code and objects, then closes the file"			object _ SmartRefStream scannedObject].	"set by side effect of one of the chunks"	SmartRefStream scannedObject: nil.  "clear scannedObject"	^ object! !!ReadWriteStream methodsFor: 'fileIn/Out'!fileNameEndsWith: aString	"See comment in FileStream fileNameEndsWith:"	^false! !!ReadWriteStream methodsFor: 'fileIn/Out'!fileOutChanges	"Append to the receiver a description of all class changes."	Cursor write showWhile:		[self header; timeStamp.		Smalltalk changes fileOutOn: self.		self trailer; close]! !!ReadWriteStream methodsFor: 'fileIn/Out'!fileOutChangesFor: class	"Append to the receiver a description of the changes to the class."	Cursor write showWhile:		[self header; timeStamp.		Smalltalk changes fileOutChangesFor: class on: self;			fileOutPSFor: class on: self.		(class inheritsFrom: Class)			ifFalse: [Smalltalk changes fileOutChangesFor: class class on: self;						fileOutPSFor: class class on: self].		self trailer; close]! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'tk 3/11/98 09:40'!fileOutClass: extraClass andObject: theObject	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically."	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self header; timeStamp.	extraClass ifNotNil: [		class _ extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	"Append the object's raw data"	srefStream _ SmartRefStream on: self.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'tk 3/13/98 22:25'!fileOutClass: extraClass andObject: theObject blocking: anIdentDict	"Write a file that has both the source code for the named class and an object as bits.  Any instance-specific object will get its class written automatically.  Accept a list of objects to map to nil or some other object (blockers).  In addition to teh choices in each class's objectToStoreOnDataStream"	| class srefStream |	self setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	self header; timeStamp.	extraClass ifNotNil: [		class _ extraClass.	"A specific class the user wants written"		class sharedPools size > 0 ifTrue:			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: self moveSource: false toFile: 0].	self trailer.	"Does nothing for normal files.  HTML streams will have trouble with object data"	"Append the object's raw data"	srefStream _ SmartRefStream on: self.	srefStream blockers: anIdentDict.	srefStream nextPut: theObject.  "and all subobjects"	srefStream close.		"also closes me"! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 7/14/97 22:57'!timeStamp	"Append the current time to the receiver as a String."	self nextChunkPut:	"double string quotes and !!s"		(String streamContents: [:s | Smalltalk timeStamp: s]) printString.	self cr! !Object subclass: #RealEstateAgent	instanceVariableNames: ''	classVariableNames: 'ReverseStaggerOffset ScreenTopSetback ScrollBarSetback StaggerOffset StaggerOrigin StandardWindowOrigins '	poolDictionaries: ''	category: 'Interface-Support'!!RealEstateAgent commentStamp: 'di 5/22/1998 16:37' prior: 0!RealEstateAgent comment:'Responsible for real-estate management on the screen, which is to say, controlling where new windows appear, with what sizes, etc.  5/20/96 sw'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RealEstateAgent class	instanceVariableNames: ''!!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 5/20/1998 08:47'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames y free topLeft |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | true])					collect: [:w | w collapsedFrame]					thenSelect: [:rect | rect notNil]]		ifFalse: [ScheduledControllers scheduledWindowControllers					collect: [:aController | aController view collapsedFrame]					thenSelect: [:rect | rect notNil]].	y _ 0.	[(y _ y + grid) <= (Display height - grid)]		whileTrue:		[topLeft _ 0@y.		free _ true.		otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].		free ifTrue: [^ topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen.  5/22/96 sw"	| allOrigins screenRight screenBottom initialExtent putativeOrigin putativeFrame allowedArea staggerOrigin |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView].	allowedArea _ Display usableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	initialExtent _ aView initialExtent.	allOrigins _ ScheduledControllers windowOriginsInUse.	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (ScrollBarSetback @ ScreenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.	ScrollBarSetback _ 44.	ScreenTopSetback _ 18! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 5/22/96'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ ScrollBarSetback +   ((anArea width - ScrollBarSetback)  // 2).	midY _ ScreenTopSetback + ((anArea height - ScreenTopSetback) // 2).	aList _ OrderedCollection with: (ScrollBarSetback @ ScreenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ ScreenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (ScrollBarSetback @ (midY+ScreenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+ScreenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'sw 5/23/96'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent - (ScrollBarSetback @ ScreenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ ScrollBarSetback @ ScreenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 5/20/1998 09:18'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ ScrollBarSetback @ ScreenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (ScrollBarSetback @ ScreenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified'!windowColumnsDesired	"Answer how many separate vertical columns of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(Display usableArea width > 640)				ifTrue:					[2]				ifFalse:					[1]]! !!RealEstateAgent class methodsFor: 'as yet unclassified'!windowRowsDesired	"Answer how many separate horizontal rows of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(Display usableArea height > 480)				ifTrue:					[2]				ifFalse:					[1]]! !MessageSet subclass: #RecentMessageSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Browser'!!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'tk 4/25/1998 00:04'!contents: c notifying: n	| result |	result _ super contents: c notifying: n.	result == true ifTrue:		[self initializeMessageList: Utilities recentlySubmittedMessages.		self messageListIndex: (messageList size min: 1).	"0 or 1"		self changed: #messageList.		self changed: #messageListIndex].	^ result! !!RecentMessageSet methodsFor: 'as yet unclassified' stamp: 'tk 4/10/1998 07:19'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0.	contents _ ''! !!RecentMessageSet methodsFor: 'as yet unclassified'!maybeSetSelection	"After a browser's message list is changed, this message is dispatched to the model, to give it a chance to refigure a selection"		self messageListIndex: 1! !AlignmentMorph subclass: #RecordingControlsMorph	instanceVariableNames: 'recorder recordingStatusLight recordMeter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 5/19/1998 10:41'!addButtonRows	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Tile' action: #makeTile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Show' action: #show).	self addMorphBack: r.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 5/19/1998 10:07'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'accessing' stamp: 'jm 9/13/97 17:20'!recorder	^ recorder! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 15:28'!done	recorder stopRecording.	self makeTile.	self delete.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 12/15/97 14:30'!makeTile	| newStyleTile sndName tile |	recorder pause.	newStyleTile _ true.	newStyleTile		ifTrue: [			sndName _ FillInTheBlank				request: 'Please enter a name this sound'				initialAnswer: 'sound'.			sndName isEmpty ifTrue: [^ self].			sndName _ SampledSound unusedSoundNameLike: sndName.			SampledSound				addLibrarySoundNamed: sndName				samples: recorder condensedSamples				sampleRate: recorder samplingRate.			tile _ SoundTile new literal: sndName]		ifFalse: [			tile _ InterimSoundMorph new sound: 				(SampledSound					samples: recorder condensedSamples					samplingRate: recorder samplingRate)].	self world hands first attachMorph: tile.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 10/18/97 11:41'!playback	recorder pause.	recorder playback.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 14:30'!record	recorder clearRecordedSound.	recorder resumeRecording.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 10/18/97 11:50'!show	"Show my samples in a GraphMorph."	| g m |	recorder pause.	g _ GraphMorph new extent: 500@150; data: recorder condensedSamples.	m _ StringMorph new contents: 'Index:'.	g addMorph: (m position: 5@5).	m _ UpdatingStringMorph new		target: g; getSelector: #cursor; putSelector: #cursor:; step.	g addMorph: (m position: 45@5).	m _ StringMorph new contents: 'Value:'.	g addMorph: (m position: 5@20).	m _ UpdatingStringMorph new		target: g; getSelector: #valueAtCursor; putSelector: #valueAtCursor:; step.	g addMorph: (m position: 45@20).	self world hands first attachMorph: g.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jhm 10/15/97 14:30'!stop	recorder pause.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 11/17/97 18:58'!trim	"Show my samples in a GraphMorph."	recorder pause.	recorder trim: 1400 normalizedVolume: 80.0.! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 5/22/1998 11:35'!startStepping	"Make the level meter active when dropped into the world. Do nothing if already recording. Note that this will cause other recorders to stop recording..."	super startStepping.	recorder isPaused ifTrue: [		SoundRecorder allInstancesDo: [:r | r stopRecording].  "stop all other sound recorders"		recorder pause].  "meter is updated while paused"! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:00'!step	recorder isPaused		ifTrue: [recordingStatusLight color: Color transparent]		ifFalse: [recordingStatusLight color: Color red].	recordMeter extent: (recorder meterLevel + 1) @ recordMeter height.! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 8/24/97 21:00'!stepTime	^ 50! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:13'!stopStepping	"Turn off recording."	super stopStepping.	recorder stopRecording.! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jhm 10/15/97 14:30'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 8/24/97 21:31'!makeRecordMeter	| outerBox |	outerBox _ Morph new extent: 102@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: outerBox topLeft + (1@1).	outerBox addMorph: recordMeter.	^ outerBox! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jhm 10/15/97 15:06'!makeStatusLight	recordingStatusLight _ Morph new extent: 18@18.	recordingStatusLight color: Color transparent.	^ recordingStatusLight! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 10/17/97 15:17'!updateReferencesUsing: aDictionary	"Copy my recorder."	super updateReferencesUsing: aDictionary.	recorder _ SoundRecorder new.! !Object subclass: #Rectangle	instanceVariableNames: 'origin corner '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Rectangle commentStamp: 'di 5/22/1998 16:37' prior: 0!Rectangle comment:'I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.'!!Rectangle methodsFor: 'accessing'!area	"Answer the receiver's area, the product of width and height."	| w |	(w _ self width) < 0 ifTrue: [^ 0].	^ w * self height max: 0! !!Rectangle methodsFor: 'accessing'!bottom	"Answer the position of the receiver's bottom horizontal line."	^corner y! !!Rectangle methodsFor: 'accessing'!bottomCenter	"Answer the point at the center of the bottom horizontal line of the 	receiver."	^self center x @ self bottom! !!Rectangle methodsFor: 'accessing'!bottomLeft	"Answer the point at the left edge of the bottom horizontal line of the 	receiver."	^origin x @ corner y! !!Rectangle methodsFor: 'accessing'!bottomRight	"Answer the point at the right edge of the bottom horizontal line of the 	receiver."	^corner! !!Rectangle methodsFor: 'accessing'!boundingBox	^ self! !!Rectangle methodsFor: 'accessing'!center	"Answer the point at the center of the receiver."	^self topLeft + self bottomRight // 2! !!Rectangle methodsFor: 'accessing'!corner	"Answer the point at the bottom right corner of the receiver."	^corner! !!Rectangle methodsFor: 'accessing'!corners	"Return an array of corner points in the order of a quadrilateral spec for WarpBlt."	^ Array		with: self topLeft		with: self bottomLeft		with: self bottomRight		with: self topRight! !!Rectangle methodsFor: 'accessing'!extent	"Answer with a rectangle with origin 0@0 and corner the receiver's 	width @ the receiver's height."	^corner - origin! !!Rectangle methodsFor: 'accessing'!height	"Answer the height of the receiver."	^corner y - origin y! !!Rectangle methodsFor: 'accessing'!innerCorners	"Return an array of inner corner points,	ie, the most extreme pixels included,	in the order of a quadrilateral spec for WarpBlt"	| r1 |	r1 _ self topLeft corner: self bottomRight - (1@1).	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !!Rectangle methodsFor: 'accessing'!left	"Answer the position of the receiver's left vertical line."	^origin x! !!Rectangle methodsFor: 'accessing'!leftCenter	"Answer the point at the center of the receiver's left vertical line."	^self left @ self center y! !!Rectangle methodsFor: 'accessing'!origin	"Answer the point at the top left corner of the receiver."	^origin! !!Rectangle methodsFor: 'accessing'!right	"Answer the position of the receiver's right vertical line."	^corner x! !!Rectangle methodsFor: 'accessing'!rightCenter	"Answer the point at the center of the receiver's right vertical line."	^self right @ self center y! !!Rectangle methodsFor: 'accessing'!top	"Answer the position of the receiver's top horizontal line."	^origin y! !!Rectangle methodsFor: 'accessing'!topCenter	"Answer the point at the center of the receiver's top horizontal line."	^self center x @ self top! !!Rectangle methodsFor: 'accessing'!topLeft	"Answer the point at the top left corner of the receiver's top horizontal line."	^origin! !!Rectangle methodsFor: 'accessing'!topRight	"Answer the point at the top right corner of the receiver's top horizontal 	line."	^corner x @ origin y! !!Rectangle methodsFor: 'accessing'!width	"Answer the width of the receiver."	^corner x - origin x! !!Rectangle methodsFor: 'comparing'!= aRectangle 	"Answer true if the receiver's species, origin and corner match aRectangle's."	self species = aRectangle species		ifTrue: [^origin = aRectangle origin and: [corner = aRectangle corner]]		ifFalse: [^false]! !!Rectangle methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^origin hash bitXor: corner hash! !!Rectangle methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!Rectangle methodsFor: 'rectangle functions'!amountToTranslateWithin: aRectangle	"Answer a Point, delta, such that self + delta is forced within aRectangle."	"Altered so as to prefer to keep self topLeft inside when all of self	cannot be made to fit 7/27/96 di"	| dx dy |	dx _ 0.  dy _ 0.	self right > aRectangle right ifTrue: [dx _ aRectangle right - self right].	self bottom > aRectangle bottom ifTrue: [dy _ aRectangle bottom - self bottom].	(self left + dx) < aRectangle left ifTrue: [dx _ aRectangle left - self left].	(self top + dy) < aRectangle top ifTrue: [dy _ aRectangle top - self top].	^ dx@dy! !!Rectangle methodsFor: 'rectangle functions'!areasOutside: aRectangle	"Answer an Array of Rectangles comprising the parts of the receiver not 	intersecting aRectangle."	| areas yOrigin yCorner |	"Make sure the intersection is non-empty"	(origin <= aRectangle corner and: [aRectangle origin <= corner])		ifFalse: [^Array with: self].	areas _ OrderedCollection new.	aRectangle origin y > origin y		ifTrue: [areas addLast: (origin corner: corner x @ (yOrigin _ aRectangle origin y))]		ifFalse: [yOrigin _ origin y].	aRectangle corner y < corner y		ifTrue: [areas addLast: (origin x @ (yCorner _ aRectangle corner y) corner: corner)]		ifFalse: [yCorner _ corner y].	aRectangle origin x > origin x 		ifTrue: [areas addLast: (origin x @ yOrigin corner: aRectangle origin x @ yCorner)].	aRectangle corner x < corner x 		ifTrue: [areas addLast: (aRectangle corner x @ yOrigin corner: corner x @ yCorner)].	^areas! !!Rectangle methodsFor: 'rectangle functions'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) <= (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) <= (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions'!encompass: aPoint 	"Answer a Rectangle that contains both the receiver and aPoint.  5/30/96 sw"	^ Rectangle 		origin: (origin min: aPoint)		corner: (corner max:  aPoint)! !!Rectangle methodsFor: 'rectangle functions'!expandBy: delta 	"Answer a Rectangle that is outset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin - delta origin 					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin - delta 					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions'!extendBy: delta 	"Answer a Rectangle with the same origin as the receiver, but whose corner is offset by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin					corner: corner + delta corner]		ifFalse: [^Rectangle 					origin: origin					corner: corner + delta]! !!Rectangle methodsFor: 'rectangle functions'!insetBy: delta 	"Answer a Rectangle that is inset from the receiver by delta. delta is a 	Rectangle, Point, or scalar."	(delta isKindOf: Rectangle)		ifTrue: [^Rectangle 					origin: origin + delta origin 					corner: corner - delta corner]		ifFalse: [^Rectangle 					origin: origin + delta 					corner: corner - delta]! !!Rectangle methodsFor: 'rectangle functions'!insetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint 	"Answer a Rectangle that is inset from the receiver by a given amount in 	the origin and corner."	^Rectangle		origin: origin + originDeltaPoint		corner: corner - cornerDeltaPoint! !!Rectangle methodsFor: 'rectangle functions'!intersect: aRectangle 	"Answer a Rectangle that is the area in which the receiver overlaps with 	aRectangle."	^Rectangle 		origin: (origin max: aRectangle origin)		corner: (corner min: aRectangle corner)! !!Rectangle methodsFor: 'rectangle functions'!merge: aRectangle 	"Answer a Rectangle that contains both the receiver and aRectangle."	^Rectangle 		origin: (origin min: aRectangle origin)		corner: (corner max: aRectangle corner)! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 4/30/1998 11:22'!pointNearestTo: aPoint	"Return the point on my border closest to aPoint"	| side |	(self containsPoint: aPoint)		ifTrue:			[side _ self sideNearestTo: aPoint.			side == #right ifTrue: [^ self right @ aPoint y].			side == #left ifTrue: [^ self left @ aPoint y].			side == #bottom ifTrue: [^ aPoint x @ self bottom].			side == #top ifTrue: [^ aPoint x @ self top]]		ifFalse:			[^ aPoint adhereTo: self]! !!Rectangle methodsFor: 'rectangle functions'!quickMerge: aRectangle 	"Answer the receiver if it encloses the given rectangle or the merge of the two rectangles if it doesn't. THis method is an optimization to reduce extra rectangle creations."	| useRcvr rOrigin rCorner minX maxX minY maxY |	useRcvr _ true.	rOrigin _ aRectangle topLeft.	rCorner _ aRectangle bottomRight.	minX _ rOrigin x < origin x ifTrue: [useRcvr _ false. rOrigin x] ifFalse: [origin x].	maxX _ rCorner x > corner x ifTrue: [useRcvr _ false. rCorner x] ifFalse: [corner x].	minY _ rOrigin y < origin y ifTrue: [useRcvr _ false. rOrigin y] ifFalse: [origin y].	maxY _ rCorner y > corner y ifTrue: [useRcvr _ false. rCorner y] ifFalse: [corner y].	useRcvr		ifTrue: [^ self]		ifFalse: [^ Rectangle origin: minX@minY corner: maxX@maxY].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/20/97 23:01'!rectanglesAt: y height: ht	(y+ht) > self bottom ifTrue: [^ Array new].	^ Array with: (origin x @ y corner: corner x @ (y+ht))! !!Rectangle methodsFor: 'rectangle functions'!translatedToBeWithin: aRectangle	"Answer a copy of the receiver that does not extend beyond aRectangle.  7/8/96 sw"	^ self translateBy: (self amountToTranslateWithin: aRectangle)! !!Rectangle methodsFor: 'rectangle functions'!withBottom: y 	"Return a copy of me with a different bottom y"	^ origin x @ origin y corner: corner x @ y! !!Rectangle methodsFor: 'rectangle functions'!withHeight: height 	"Return a copy of me with a different height"	^ origin corner: corner x @ (origin y + height)! !!Rectangle methodsFor: 'rectangle functions'!withLeft: x 	"Return a copy of me with a different left x"	^ x @ origin y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withRight: x 	"Return a copy of me with a different right x"	^ origin x @ origin y corner: x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withSide: side setTo: value  "return a copy with side set to value"	^ self perform: (#(withLeft: withRight: withTop: withBottom: )							at: (#(left right top bottom) indexOf: side))		with: value! !!Rectangle methodsFor: 'rectangle functions'!withTop: y 	"Return a copy of me with a different top y"	^ origin x @ y corner: corner x @ corner y! !!Rectangle methodsFor: 'rectangle functions'!withWidth: width 	"Return a copy of me with a different width"	^ origin corner: (origin x + width) @ corner y! !!Rectangle methodsFor: 'testing'!containsPoint: aPoint 	"Answer whether aPoint is within the receiver."	^origin <= aPoint and: [aPoint < corner]! !!Rectangle methodsFor: 'testing'!containsRect: aRect	"Answer whether aRect is within the receiver (OK to coincide)."	^ aRect origin >= origin and: [aRect corner <= corner]! !!Rectangle methodsFor: 'testing'!hasPositiveExtent	^ (corner x > origin x) and: [corner y > origin y]! !!Rectangle methodsFor: 'testing'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	^(origin max: aRectangle origin) < (corner min: aRectangle corner)! !!Rectangle methodsFor: 'testing'!isTall	^ self height > self width! !!Rectangle methodsFor: 'testing'!isWide	^ self width > self height! !!Rectangle methodsFor: 'testing' stamp: 'di 4/29/1998 21:53'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!Rectangle methodsFor: 'truncation and round off'!rounded	"Answer a Rectangle whose origin and corner are rounded."	^Rectangle origin: origin rounded corner: corner rounded! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 8/2/97 13:54'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!Rectangle methodsFor: 'truncation and round off'!truncateTo: grid	"Answer a Rectangle whose origin and corner are truncated to grid x and grid y."	^Rectangle origin: (origin truncateTo: grid)				corner: (corner truncateTo: grid)! !!Rectangle methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Answer a Rectangle that is a translated by aPoint2 - aPoint1."	^self translateBy: aPoint2 - aPoint1! !!Rectangle methodsFor: 'transforming'!centeredBeneath: aRectangle	 "Move the reciever so that its top center point coincides with the bottom center point of aRectangle.  5/20/96 sw:"	^ self align: self topCenter with: aRectangle bottomCenter! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 16:24'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	^ (origin flipBy: direction centerAt: aPoint)		rect: (corner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming'!newRectFrom: newRectBlock	"Track the outline of a new rectangle until mouse button changes.	newFrameBlock produces each new rectangle from the previous"	| rect newRect buttonStart buttonNow |	buttonStart _ buttonNow _ Sensor anyButtonPressed.	rect _ self.	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	[buttonNow == buttonStart] whileTrue: 		[Processor yield.		buttonNow _ Sensor anyButtonPressed.		newRect _ newRectBlock value: rect.		newRect = rect ifFalse:			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.			rect _ newRect]].	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.	^ rect! !!Rectangle methodsFor: 'transforming' stamp: 'di 6/11/97 15:11'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	^ (origin rotateBy: direction centerAt: aPoint)		rect: (corner rotateBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming'!scaleBy: scale 	"Answer a Rectangle scaled by scale, a Point or a scalar."	^Rectangle origin: origin * scale corner: corner * scale! !!Rectangle methodsFor: 'transforming'!scaleFrom: rect1 to: rect2	"Produce a rectangle stretched according to the stretch from rect1 to rect2"	^ (origin scaleFrom: rect1 to: rect2)		corner: (corner scaleFrom: rect1 to: rect2)! !!Rectangle methodsFor: 'transforming' stamp: 'sw 5/21/96'!squishedWithin: aRectangle	"Return an adjustment of the receiver that fits within aRectangle by reducing its size, not by changing its origin.  "	^ origin corner: (corner min: aRectangle bottomRight)"(50 @ 50 corner: 160 @ 100) squishedWithin:  (20 @ 10 corner: 90 @ 85)"! !!Rectangle methodsFor: 'transforming'!translateBy: factor 	"Answer a Rectangle translated by factor, a Point or a scalar."	^Rectangle origin: origin + factor corner: corner + factor! !!Rectangle methodsFor: 'copying'!copy 	"Refer to the comment in Object|copy."	^self deepCopy! !!Rectangle methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	origin printOn: aStream.	aStream nextPutAll: ' corner: '.	corner printOn: aStream! !!Rectangle methodsFor: 'printing'!storeOn: aStream 	"printed form is good for storing too"	self printOn: aStream! !!Rectangle methodsFor: 'private'!setOrigin: topLeft corner: bottomRight	origin _ topLeft.	corner _ bottomRight! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Rectangle class	instanceVariableNames: ''!!Rectangle class methodsFor: 'instance creation' stamp: 'tk 3/9/97'!center: centerPoint extent: extentPoint 	"Answer an instance of me whose center is centerPoint and width 	by height is extentPoint.  "	^self origin: centerPoint - (extentPoint//2) extent: extentPoint! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:42'!encompassing: listOfPoints	"A number of callers of encompass: should use this method."	| topLeft bottomRight |	topLeft _ bottomRight _ nil.	listOfPoints do:		[:p | topLeft == nil			ifTrue: [topLeft _ bottomRight _ p]			ifFalse: [topLeft _ topLeft min: p.					bottomRight _ bottomRight max: p]].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation'!fromUser	"Answer an instance of me that is determined by having the user 	designate the top left and bottom right corners. The gridding for user 	selection is 1@1."	^self fromUser: 1 @ 1! !!Rectangle class methodsFor: 'instance creation'!fromUser: gridPoint	"Answer a Rectangle that is determined by having the user 	designate the top left and bottom right corners. 	The cursor reamins linked with the sensor, but	the outline is kept gridded."	| originRect |	originRect _ Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: 0@0) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: 0@0]].	^ Cursor corner showWhile:		[originRect newRectFrom:			[:f | f origin corner: (Sensor cursorPoint grid: gridPoint)]]! !!Rectangle class methodsFor: 'instance creation'!left: leftNumber right: rightNumber top: topNumber bottom: bottomNumber 	"Answer an instance of me whose left, right, top, and bottom coordinates 	are determined by the arguments."	^ self new setOrigin: leftNumber @ topNumber corner: rightNumber @ bottomNumber! !!Rectangle class methodsFor: 'instance creation' stamp: 'di 12/1/97 10:36'!merging: listOfRects	"A number of callers of merge: should use this method."	| topLeft bottomRight |	topLeft _ bottomRight _ nil.	listOfRects do:		[:r | topLeft == nil			ifTrue: [topLeft _ r topLeft.					bottomRight _ r bottomRight]			ifFalse: [topLeft _ topLeft min: r topLeft.					bottomRight _ bottomRight max: r bottomRight]].	^ topLeft corner: bottomRight! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint corner: cornerPoint 	"Answer an instance of me whose corners (top left and bottom right) are 	determined by the arguments."	^self new setOrigin: originPoint corner: cornerPoint! !!Rectangle class methodsFor: 'instance creation'!origin: originPoint extent: extentPoint 	"Answer an instance of me whose top left corner is originPoint and width 	by height is extentPoint."	^self new setOrigin: originPoint corner: originPoint + extentPoint! !!Rectangle class methodsFor: 'instance creation'!originFromUser: extentPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is 1@1."	^self originFromUser: extentPoint grid: 1 @ 1! !!Rectangle class methodsFor: 'instance creation'!originFromUser: extentPoint grid: gridPoint 	"Answer an instance of me that is determined by having the user 	designate the top left corner. The width and height are determined by 	extentPoint. The gridding for user selection is scaleFactor. Assumes that 	the sender has determined an extent that is a proper multiple of 	scaleFactor."	^ Cursor origin showWhile: 		[((Sensor cursorPoint grid: gridPoint) extent: extentPoint) newRectFrom:			[:f | (Sensor cursorPoint grid: gridPoint) extent: extentPoint]].! !BorderedMorph subclass: #RectangleMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!RectangleMorph methodsFor: 'initialization' stamp: 'sw 8/4/97 12:05'!initialize	super initialize.	color _ Color gray! !DataStream subclass: #ReferenceStream	instanceVariableNames: 'references objects currentReference fwdRefEnds blockers '	classVariableNames: 'RefTypes '	poolDictionaries: ''	category: 'System-Object Storage'!!ReferenceStream commentStamp: 'di 5/22/1998 16:37' prior: 0!ReferenceStream comment:'This is an interim save-to-disk facility. A ReferenceStream can storeone or more objects in a persistent form, including sharing andcycles. Cf. DataStream.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: ''test.obj''.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: ''test.obj''.	<your object> _ rr next.	rr close.ReferenceStreams can now write "weak" references. nextPutWeak:writes a "weak" reference to an object, which refers to that object*if* it also gets written to the stream by a normal nextPut:.Public messages:	resetPublic inherited messages (see DataStream)	(class) on:	(class) fileNamed:	(class) fileTypeCode	atEnd	beginInstance:size: (for use by storeDataOn: methods)	beginReference: (for use by readDataFrom:size: methods)	close	next	next:	nextPut:	nextPutAll:	nextPutWeak:	setType:	shorten	sizeNOTE: A ReferenceStream should be treated as a read-stream *or* as awrite-stream, *not* as a read/write-stream. The reference-rememberingmechanism would probably do bad things if you tried to read and writefrom the same ReferenceStream.[TBD] Should we override "close" to do	self forgetReferences. super close?Instance variables references -- an IdentityDictionary mapping objects already written	to their byteStream positions. If asked to write any object a	second time, we just write a reference to its stream position.	This handles shared objects and reference cycles between objects.	To implement "weak references" (for Aliases), the references	dictionary also maps objects not (yet?) written to a Collection	of byteStream positions with hopeful weak-references to it. If	asked to definitely write one of these objects, we''ll fixup those	weak references. objects -- an IdentityDictionary mapping relative byte stream positions to	objects already read in. If asked to follow a reference, we	return the object already read.	This handles shared objects and reference cycles between objects. currentReference -- the current reference position. Positon relative to the 	start of object data in this file.  (Allows user to cut and paste smalltalk 	code from the front of the file without effecting the reference values.)  	This variable is used to help install each new object in "objects" as soon	as it''s created, **before** we start reading its contents, in	case any of its content objects reference it. fwdRefEnds -- A weak reference can be a forward reference, which	requires advance-reading the referrent. When we later come to the	object, we must get its value from "objects" and not re-read it so	refs to it don''t become refs to copies. fwdRefEnds remembers the	ending byte stream position of advance-read objects. transients -- an IdentitySet of byte stream positions corresponding	to objects that we''ve started to read in (and already added to	"objects" in case of reference cycles) but haven''t yet handed out	OOPs for. If we hand out an OOP to one of these interim OOPs, and	if internalizing it (comeFullyUpOnReload) returns a different OOP,	then we must ask it to #become: the new OOP. Tracking the interim	OOPs handed out lets us save most calls to (costly) #become:.-- 11/17/92 jhm'!!ReferenceStream methodsFor: 'all' stamp: 'tk 3/26/98 10:19'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	short & (ref isInteger) ifTrue: [short _ (ref < 65536) & (ref > 0)].	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:25 tk'!beginReference: anObject	"Remember anObject as the object we read at the position recorded by	 noteCurrentReference:. This must be done after instantiating anObject but	 before reading any of its contents that might (directly or indirectly) refer to	 it. (It's ok to do this redundantly, which is convenient for #next.)	 Answer the reference position. -- jhm"	objects at: currentReference put: anObject.	"relative to start of data portion of file"	^ currentReference		"relative position"! !!ReferenceStream methodsFor: 'all' stamp: 'tk 3/15/98 19:54'!blockers	^ blockers! !!ReferenceStream methodsFor: 'all' stamp: 'tk 3/13/98 20:00'!blockers: anIdentDict	"maps objects -> nil if they should not be written.  object -> anotherObject if they need substitution."	anIdentDict class == IdentityDictionary ifFalse: [self error: 'must be IdentityDictionary'].	blockers _ anIdentDict! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:26 tk'!getCurrentReference    "PRIVATE -- Return the currentReference posn.  Always a relative position.  So user can cut and paste the Smalltalk source code at the beginning of the file."    ^ currentReference	"relative position"! !!ReferenceStream methodsFor: 'all' stamp: 'tk 8/14/96'!internalize: externalObject	"PRIVATE -- We just read externalObject. Give it a chance to internalize. Return the internalized object.	 If become: is expensive, we could use it less often. It's needed when we've already given out references to the object being read (while recursively reading its contents).  In other cases, we could just change the entry in the objects Dictionary.	If an object is pointed at from inside itself, then it cannot have a different external and internal form.  It cannot be a PathFromHome or return anything other than self when sent comeFullyUpOnReload. (DiskProxy is OK)	Objects that do return something other than self when sent comeFullyUpOnReload must not point to themselves, even indirectly.    	Allowin the use of DiskProxy for shared sysem objects.  "	| internalObject |	internalObject _ externalObject comeFullyUpOnReload.	(self isAReferenceType: (self typeIDFor: internalObject))			ifTrue: [self beginReference: internalObject].			"save the final object and give it out next time.  Substitute for become"	^ internalObject"This code was removed.  I don't understand it.  	(externalObject ~~ internalObject and: [externalObject isKindOf: DiskProxy])		ifTrue: [externalObject become: internalObject]		ifFalse: [(self isAReferenceType:(self typeIDFor: internalObject))			ifTrue: [self beginReference: internalObject]]."! !!ReferenceStream methodsFor: 'all'!isAReferenceType: typeID	"Return true iff typeID is one of the classes that can be written as a reference to an instance elsewhere in the stream. -- jhm, 8/9/96 tk"	"too bad we can't put Booleans in an Array literal"	^ (RefTypes at: typeID) == 1! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 09:02 tk'!next	"Answer the next object in the stream. If this object was already read by a	 forward ref, don't re-read it. Cf. class comment. -- 11/18-24/92 jhm"	| curPosn skipToPosn |	"Did we already read the next object? If not, use ordinary super next."	skipToPosn _ fwdRefEnds removeKey: (curPosn _ byteStream position - basePos)							 ifAbsent: [nil].	skipToPosn ifNil: [^ super next].		"Compared to ifAbsent: [^ super next], this saves 2 stack frames per cycle		 in the normal case of this deep recursion. This is mainly a debugging aid		 but it also staves off stack overflow."	"Skip over the object and return the already-read-in value from 'object'."	byteStream position: skipToPosn + basePos.	"make absolute"	^ objects at: curPosn ifAbsent: [self errorInternalInconsistency]! !!ReferenceStream methodsFor: 'all' stamp: 'jhm 11/15/92'!nextPutWeak: anObject    "Write a weak reference to anObject to the receiver stream. Answer anObject.     If anObject is not a reference type of object, then just put it normally.     A 'weak' reference means: If anObject gets written this stream via nextPut:,     then its weak references will become normal references. Otherwise they'll     read back as nil. -- "    | typeID referencePosn |    "Is it a reference type of object? If not, just write it normally."    typeID _ self typeIDFor: anObject.    (self isAReferenceType: typeID) ifFalse: [^ self nextPut: anObject].    "Have we heard of and maybe even written anObject before?"    referencePosn _ references at: anObject ifAbsent: [			references at: anObject put: OrderedCollection new].    "If referencePosn is an Integer, it's the stream position of anObject.     Else it's a collection of hopeful weak-references to anObject."    referencePosn isInteger ifFalse:        [referencePosn add: byteStream position - basePos.		"relative"        referencePosn _ self vacantRef].    self outputReference: referencePosn.		"relative"    ^ anObject! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 09:00 tk'!noteCurrentReference: typeID	"PRIVATE -- If we support references for type typeID, remember	 the current byteStream position so beginReference: can add the	 next object to the 'objects' dictionary of reference positions,	 then return true. Else return false."	| answer |	(answer _ self isAReferenceType: typeID)		ifTrue: [self setCurrentReference: (byteStream position - 1) - basePos "relative"				"subtract 1 because we already read the object's type ID byte"].	^ answer! !!ReferenceStream methodsFor: 'all' stamp: ' 6/9/97'!objectAt: anInteger    "PRIVATE -- Read & return the object at a given stream position.     If we already read it, just get it from the objects dictionary.     (Reading it again wouldn't work with cycles or sharing.)     If not, go read it and put it in the objects dictionary.     NOTE: This resolves a cross-reference in the ReferenceStream:       1. A backward reference to an object already read (the normal case).       2. A forward reference which is a sated weak reference (we record where          the object ends so when we get to it normally we can fetch it from          'objects' and skip over it).       3. A backward reference to a 'non-reference type' per the long NOTE in          nextPut: (we compensate here--seek back to re-read it and add the object          to 'objects' to avoid seeking back to read it any more times).       4. While reading a foward weak reference (case 2), we may recursively hit an          ordinary backward reference to an object that we haven't yet read because          we temporarily skipped ahead. Such a reference is forward in time so we          treat it much like case 2.     11/16-24/92 jhm: Handle forward refs. Cf. class comment and above NOTE.	08:57 tk   anInteger is a relative position"    | savedPosn refPosn anObject |    ^ objects at: anInteger "relative position.  case 1: It's in 'objects'"        ifAbsent:   "do like super objectAt:, but remember the fwd-ref-end position"            [savedPosn _ byteStream position.		"absolute"            refPosn _ self getCurrentReference.	"relative position"            byteStream position: anInteger + basePos.	"was relative"            anObject _ self next.            (self isAReferenceType: (self typeIDFor: anObject))                ifTrue:  [fwdRefEnds at: anInteger put: byteStream position - basePos] "cases 2, 4"                ifFalse: [objects at: anInteger put: anObject]. "case 3"            self setCurrentReference: refPosn.		"relative position"            byteStream position: savedPosn.		"absolute"            anObject]! !!ReferenceStream methodsFor: 'all' stamp: 'tk 3/13/98 22:18'!objectIfBlocked: anObject	"See if this object is blocked -- not written out and another object substituted."	^ (blockers includesKey: anObject) 		ifTrue: [blockers at: anObject]		ifFalse: [anObject]! !!ReferenceStream methodsFor: 'all'!references	^ references! !!ReferenceStream methodsFor: 'all' stamp: 'tk 3/13/98 22:30'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references _ IdentityDictionary new: 4096 * 5.	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new.	blockers ifNil: [blockers _ IdentityDictionary new]. ! !!ReferenceStream methodsFor: 'all' stamp: '6/9/97 08:24 tk'!setCurrentReference: refPosn    "PRIVATE -- Set currentReference to refPosn.  Always a relative position."    currentReference _ refPosn		"relative position"! !!ReferenceStream methodsFor: 'all' stamp: 'tk 3/13/98 22:34'!setStream: aStream	"PRIVATE -- Initialization method."	super setStream: aStream.	references _ IdentityDictionary new: 4096 * 5.	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new.	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream methodsFor: 'all' stamp: 'tk 2/17/98 15:24'!statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents n kids nm ownerBags tallies owners |	parents _ IdentityDictionary new: references size * 2.	n _ 0.	'Finding Owners...'	displayProgressAt: Sensor cursorPoint	from: 0 to: references size	during: [:bar |	references keysDo:		[:parent | bar value: (n _ n+1).		kids _ parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].		(kids select: [:x | references includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags _ Dictionary new.	tallies _ Bag new.	n _ 0.	'Tallying Owners...'	displayProgressAt: Sensor cursorPoint	from: 0 to: references size	during: [:bar |	references keysDo:  "For each class of obj, tally a bag of owner classes"		[:obj | bar value: (n _ n+1).		nm _ obj class name.		tallies add: nm.		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(parent _ parents at: obj ifAbsent: [nil]) == nil			ifFalse: [owners add: parent class name]]].	^ String streamContents:		[:strm |  tallies sortedCounts do:			[:assn | n _ assn key.  nm _ assn value.			owners _ ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue:				[strm cr; tab; print: owners sortedCounts]]]! !!ReferenceStream methodsFor: 'all' stamp: ' 6/9/97'!tryToPutReference: anObject typeID: typeID	"PRIVATE -- If we support references for type typeID, and if	   anObject already appears in my output stream, then put a	   reference to the place where anObject already appears. If we	   support references for typeID but didn't already put anObject,	   then associate the current stream position with anObject in	   case one wants to nextPut: it again.	 Return true after putting a reference; false if the object still	   needs to be put.	 : Added support for weak refs. Split out outputReference:.	08:42 tk  references stores relative file positions."	| referencePosn nextPosn |	"Is it a reference type of object?"	(self isAReferenceType: typeID) ifFalse: [^ false].	"Have we heard of and maybe even written anObject before?"	referencePosn _ references at: anObject ifAbsent:			["Nope. Remember it and let the sender write it."			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"If referencePosn is an Integer, it's the stream position of anObject."	referencePosn isInteger ifTrue:		[self outputReference: referencePosn.	"relative"		^ true].	"Else referencePosn is a collection of positions of weak-references to anObject.	 Make them full references since we're about to really write anObject."	references at: anObject put: (nextPosn _ byteStream position) - basePos.	"store relative"	referencePosn do: [:weakRefPosn |			byteStream position: weakRefPosn + basePos.		"make absolute"			self outputReference: nextPosn - basePos].	"make relative"	byteStream position: nextPosn.		"absolute"	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ReferenceStream class	instanceVariableNames: ''!!ReferenceStream class methodsFor: 'all'!example2"Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: ''test.obj''.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: ''test.obj''.	<your object> _ rr next.	rr close.""An example and test of DataStream/ReferenceStream.	 11/19/92 jhm: Use self testWith:."	"ReferenceStream example2"	| input sharedPoint |	"Construct the test data."	input _ Array new: 9.	input at: 1 put: nil.	input at: 2 put: true.	input at: 3 put: false.	input at: 4 put: #(-4 -4.0 'four' four).	input at: 5 put: (Form extent: 63 @ 50 depth: 8).		(input at: 5) fillWithColor: Color lightOrange.	input at: 6 put: 1024 @ -2048.	input at: 7 put: input. "a cycle"	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).	input at: 9 put: sharedPoint.	"Write it out, read it back, and return it for inspection."	^ self testWith: input! !!ReferenceStream class methodsFor: 'all'!refTypes: oc	RefTypes _ oc! !!ReferenceStream class methodsFor: 'all' stamp: 'sw 12/2/92'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	^ 3! !RWBinaryOrTextStream subclass: #RemoteFileStream	instanceVariableNames: 'remoteFile '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!RemoteFileStream commentStamp: 'di 5/22/1998 16:37' prior: 0!An in-memory stream that can be used to fileIn code from the network.  Knows its ServerFile, and thus its name, path, etc.!!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:50'!close	"Write if we have data to write.  FTP files are always binary to preserve the data exactly.  The binary/text (ascii) flag is just for tell how the bits are delivered from a read."	remoteFile writable ifTrue: [			remoteFile putFile: self named: remoteFile fileName]! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:57'!contentsOfEntireFile	"Fetch the data off the server and store it in me.  But not if I already have it."	readLimit _ readLimit max: position.	readLimit > 0 ifTrue: [^ super contentsOfEntireFile].	collection size = 0 ifTrue: [self on: (String new: 2000)].	remoteFile getFileNamed: remoteFile fileName into: self.	^ super contentsOfEntireFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:19'!directory	^ remoteFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:30'!localName	^ remoteFile fileName! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:38'!openReadOnly	"If we have data, don't reread.  Is this OK????"	self readOnly.	readLimit _ readLimit max: position.	readLimit > 0 ifFalse: [remoteFile getFileNamed: remoteFile fileName into: self]. ! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:32'!readOnly	^ remoteFile readOnly! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:18'!remoteFile	^ remoteFile! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 09:18'!remoteFile: aServerFile	remoteFile _ aServerFile! !HandMorph subclass: #RemoteHandMorph	instanceVariableNames: 'remoteWorldExtent socket waitingForConnection receiveBuffer '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Kernel'!!RemoteHandMorph methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	remoteWorldExtent _ 100@100.  "initial guess"	socket _ nil.	waitingForConnection _ false.	receiveBuffer _ ''.! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!connectRemoteUser	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!disconnectAllRemoteUsers	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'meta menu' stamp: 'jm 11/4/97 07:15'!disconnectRemoteUser	"This menu command does nothing when invoked by a RemoteHandMorph."! !!RemoteHandMorph methodsFor: 'connections' stamp: 'jm 11/4/97 07:15'!remoteHostAddress	"Return the address of the remote host or zero if not connected."	(socket ~~ nil and: [socket isUnconnectedOrInvalid not])		ifTrue: [^ socket remoteAddress]		ifFalse: [^ 0].! !!RemoteHandMorph methodsFor: 'connections' stamp: 'jm 11/4/97 07:15'!startListening	"Create a socket and start listening for a connection."	self stopListening.	Transcript show: 'My address is ', NetNameResolver localAddressString; cr.	Transcript show: 'Remote hand ', userInitials, ' waiting for a connection...'; cr.	socket _ Socket new.	socket listenOn: 54323.	waitingForConnection _ true.! !!RemoteHandMorph methodsFor: 'connections'!stopListening	"Destroy the socket, if any, terminating the connection."	socket ifNotNil: [		socket destroy.		socket _ nil].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!drawOn: aCanvas	"For remote cursors, always draw the hand itself (i.e., the cursor)."	super drawOn: aCanvas.	aCanvas image: NormalCursor at: self position.! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 5/6/1998 16:02'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt anyButtonPressed and:		 [evt controlKeyPressed and:		 [lastEvent anyButtonPressed not]]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self invokeMetaMenu: evt].		(evt blueButtonPressed and:		 [lastEvent blueButtonPressed not]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self specialGesture: evt].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	self stopListening.	Transcript show: 'Remote hand ', userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!RemoteHandMorph methodsFor: 'other' stamp: 'jm 11/4/97 07:15'!worldBounds	^ 0@0 extent: remoteWorldExtent! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!appendNewDataToReceiveBuffer	"Append all available raw data to my receive buffer. Assume that my socket is not nil."	| newData tempBuf bytesRead |	socket dataAvailable ifTrue: [		"get all the data currently available"		newData _ WriteStream on: (String new: receiveBuffer size + 1000).		newData nextPutAll: receiveBuffer.		tempBuf _ String new: 1000.		[socket dataAvailable] whileTrue: [			bytesRead _ socket receiveDataInto: tempBuf.			1 to: bytesRead do: [:i | newData nextPut: (tempBuf at: i)]].		receiveBuffer _ newData contents].! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!getNextRemoteEvent	"Return the next remote event, or nil if the receive buffer does not contain a full event record. An event record is the storeString for a MorphicEvent terminated by a <CR> character."	| i s |	self receiveData.	receiveBuffer isEmpty ifTrue: [^ nil].	i _ receiveBuffer indexOf: Character cr ifAbsent: [^ nil].	s _ receiveBuffer copyFrom: 1 to: i - 1.	receiveBuffer _ receiveBuffer copyFrom: i + 1 to: receiveBuffer size.	^ (MorphicEvent readFromString: s) setHand: self! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!receiveData	"Check my connection status and withdraw from the world if the connection has been broken. Append any data that has arrived to receiveBuffer. "	socket ifNotNil: [		socket isConnected			ifTrue: [  "connected"				waitingForConnection ifTrue: [					Transcript show: 'Remote hand ', userInitials, ' connected'; cr.					waitingForConnection _ false].				self appendNewDataToReceiveBuffer]			ifFalse: [  "not connected"				waitingForConnection ifFalse: [					"connection was established, then broken"					self withdrawFromWorld.					receiveBuffer _ '']]].! !Object subclass: #RemoteString	instanceVariableNames: 'sourceFileNumber filePositionHi '	classVariableNames: 'CurrentTextAttStructure CurrentTextAttVersion TextAttributeStructureVersions '	poolDictionaries: ''	category: 'System-Files'!!RemoteString commentStamp: 'di 5/22/1998 16:37' prior: 0!My instances provide an external file reference to a piece of text.  It may be the sourceCode of a method, or the class comments of a class.The changes file or file-in file usually has a chunk that is just the source string of a method:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!I can return either a String or a Text.  Some a chunk is followed by a second chunk (beginning with ]style[) containing style information.  The encoding is like this:max: aNumber	^ self > aNumber ifTrue: [self] ifFalse: [aNumber]!!]style[(14 50 312)f1,f1b,f1LInteger +;i!!Allowed TextAttributes are TextFontChange, TextEmphasis, TextColor, TextDoIt, TextKern, TextLink, TextURL.  TextFontReference and TextAnchor are not supported.See PositionableStream nextChunkText and RunArray class scanFrom:.!]style[(748 32 5 24 1)f1,f1LPositionableStream nextChunkText;,f1,f1LRunArray class scanFrom:;,f1!!RemoteString methodsFor: 'accessing'!position 	"Answer the location of the string on a file."	^ filePositionHi! !!RemoteString methodsFor: 'accessing'!sourceFileNumber	"Answer the index of the file on which the string is stored."	^sourceFileNumber! !!RemoteString methodsFor: 'accessing' stamp: 'tk 12/14/97 05:27'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^ (sourceFileNumber * 16r1000000) + filePositionHi! !!RemoteString methodsFor: 'accessing' stamp: 'di 1/13/98 16:57'!string 	"Answer the receiver's string if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^''].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunk! !!RemoteString methodsFor: 'accessing' stamp: 'tk 1/21/95 17:55'!text 	"Answer the receiver's string asText if remote files are enabled."	| theFile |	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^ nil].	theFile _ SourceFiles at: sourceFileNumber.	theFile position: filePositionHi.	^ theFile nextChunkText! !!RemoteString methodsFor: 'private' stamp: 'tk 12/11/97 10:33'!checkSum: aString	"Construct a checksum of the string.  A three byte number represented as Base64 characters."| sum shift bytes ss bb |sum _ aString size.shift _ 0.aString do: [:char |	(shift _ shift + 7) > 16 ifTrue: [shift _ shift - 17].		"shift by 7 to keep a change of adjacent chars from xoring to same value"	sum _ sum bitXor: (char asInteger bitShift: shift)].bytes _ ByteArray new: 3.sum _ sum + 16r10000000000.1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].ss _ ReadWriteStream on: (ByteArray new: 3).ss nextPutAll: bytes.bb _ Base64MimeConverter mimeEncode: ss.^ bb contents! !!RemoteString methodsFor: 'private'!fileNumber: fileNumber position: position 	sourceFileNumber _ fileNumber.	filePositionHi _ position! !!RemoteString methodsFor: 'private' stamp: 'tk 12/11/97 10:31'!makeNewTextAttVersion	"Create a new TextAttributes version because some inst var has changed.  If no change, don't make a new one."	"Don't delete this method even though it has no callers!!!!!!!!!!"| obj cls struct tag |"Note that TextFontReference and TextAnchor are forbidden."obj _ #(RunArray TextDoIt TextLink TextURL TextColor TextEmphasis TextFontChange TextKern TextLinkToImplementors 3 'a string') collect: [:each | 		cls _ Smalltalk at: each ifAbsent: [nil].		cls ifNil: [each] ifNotNil: [cls new]].struct _ (SmartRefStream on: (RWBinaryOrTextStream on: String new)) instVarInfo: obj.tag _ self checkSum: struct printString.TextAttributeStructureVersions ifNil: [TextAttributeStructureVersions _ Dictionary new].(struct = CurrentTextAttStructure) & (tag = CurrentTextAttVersion) 	ifTrue: [^ false].CurrentTextAttStructure _ struct.CurrentTextAttVersion _ tag.TextAttributeStructureVersions at: tag put: struct.^ true! !!RemoteString methodsFor: 'private'!string: aString onFileNumber: fileNumber	"Store this as my string if source files exist."	| theFile |	(SourceFiles at: fileNumber) == nil ifFalse: 		[theFile _ SourceFiles at: fileNumber.		theFile setToEnd; cr.		self string: aString onFileNumber: fileNumber toFile: theFile]! !!RemoteString methodsFor: 'private' stamp: 'tk 12/12/97 10:41'!string: aStringOrText onFileNumber: fileNumber toFile: aFileStream 	"Store this as the receiver's text if source files exist. If aStringOrText is a Text, store a marker with the string part, and then store the runs of TextAttributes in the next chunk."	| position |	position _ aFileStream position.	self fileNumber: fileNumber position: position.	aFileStream nextChunkPutWithStyle: aStringOrText	"^ self		(important)"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RemoteString class	instanceVariableNames: ''!!RemoteString class methodsFor: 'all' stamp: 'tk 12/12/97 11:46'!currentTextAttVersion	"The current configuration of the TextAttributes classes has a structures array describing the inst vars of the classes (SmartRefStream instVarInfo:).  Return tag that indexes the TextAttributeStructureVersions dictionary (4 random characters)."	^ CurrentTextAttVersion	"Be sure to run makeNewTextAttVersion when any TextAttributes class changes inst vars"! !!RemoteString class methodsFor: 'all' stamp: 'tk 12/11/97 10:35'!initialize	"Derive the current TextAttributes classes object structure"	self new makeNewTextAttVersion! !!RemoteString class methodsFor: 'all'!newFileNumber: sourceIndex position: anInteger 	"Answer an instance of me fora file indexed by sourceIndex, at the 	position anInteger. Assume that the string is already stored on the file 	and the instance will be used to access it."	^self new fileNumber: sourceIndex position: anInteger! !!RemoteString class methodsFor: 'all'!newString: aString onFileNumber: sourceIndex 	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file and create the remote reference."	^self new string: aString onFileNumber: sourceIndex! !!RemoteString class methodsFor: 'all'!newString: aString onFileNumber: sourceIndex toFile: aFileStream	"Answer an instance of me for string, aString, on file indexed by 	sourceIndex. Put the string on the file, aFileStream, and create the 	remote reference. Assume that the index corresponds properly to 	aFileStream."	^self new string: aString onFileNumber: sourceIndex toFile: aFileStream! !!RemoteString class methodsFor: 'all' stamp: 'tk 12/13/97 13:36'!structureAt: styleVersion	^ TextAttributeStructureVersions at: styleVersion ifAbsent: [nil]! !AbstractSound subclass: #RepeatingSound	instanceVariableNames: 'sound iterationCount iteration '	classVariableNames: 'CarMotorSamples '	poolDictionaries: ''	category: 'System-Sound'!!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 15:54'!setPitch: p dur: d loudness: l	self error: 'RepeatingSounds do not support playing notes'.! !!RepeatingSound methodsFor: 'initialization' stamp: 'jm 9/12/97 16:39'!setSound: aSound iterations: anIntegerOrSymbol	"Initialize the receiver to play the given sound the given number of times. If iteration count is the symbol #forever, then repeat indefinitely."	"(RepeatingSound repeat: AbstractSound scaleTest count: 2) play"	"(RepeatingSound repeatForever: PluckedSound lowMajorScale) play"	super initialize.	sound _ aSound.	iterationCount _ anIntegerOrSymbol.	self reset.! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!iterationCount	^ iterationCount! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!iterationCount: aNumber	iterationCount _ aNumber.! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 11/17/97 18:48'!sound	^ sound! !!RepeatingSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:39'!sound: aSound	sound _ aSound.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:40'!doControl	super doControl.	sound doControl.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:05'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"(RepeatingSound new		setSound: FMSound majorScale		iterations: 2) play"	| i count samplesNeeded |	iteration <= 0 ifTrue: [^ self].	i _ startIndex.	samplesNeeded _ n.	[samplesNeeded > 0] whileTrue: [		count _ sound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			iterationCount == #forever				ifFalse: [					iteration _ iteration - 1.					iteration <= 0 ifTrue: [^ self]].  "done"			sound reset.			count _ sound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		sound mixSampleCount: count			into: aSoundBuffer			startingAt: i			leftVol: leftVol			rightVol: rightVol.		i _ i + count.		samplesNeeded _ samplesNeeded - count].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 9/12/97 16:09'!reset	super reset.	sound reset.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 9/12/97 16:09'!samplesRemaining	iteration > 0		ifTrue: [^ 1000000]		ifFalse: [^ 0].! !!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sound."	^ super copy copySound! !!RepeatingSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:34'!copySound	"Private!! Support for copying. Copy my component sound."	sound _ sound copy.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RepeatingSound class	instanceVariableNames: ''!!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:14'!repeat: aSound count: anInteger	"Return a RepeatingSound that will repeat the given sound for the given number of iterations."	^ self new setSound: aSound iterations: anInteger! !!RepeatingSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 16:13'!repeatForever: aSound	"Return a RepeatingSound that will repeat the given sound forever."	^ self new setSound: aSound iterations: #forever! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!carMotorSound	"Return a repeating sound for the sound of a car engine."	"RepeatingSound carMotorSound play"	^ self carMotorSound: 18050! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!carMotorSound: samplingRate	"Return a repeating sound for the sound of a car engine. Different sampling rates give different motor sounds."	"(RepeatingSound carMotorSound: 12050) play"	CarMotorSamples ifNil: [self initializeCarMotor].	^ RepeatingSound repeatForever:		(SampledSound samples: CarMotorSamples samplingRate: samplingRate)! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 11/16/97 11:29'!initializeCarMotor	"Initialize the samples array for the sound of a car engine."	CarMotorSamples _ SoundBuffer fromArray: #(36 199 190 508 332 167 253 302 788 884 1233 1145 977 904 991 1371 1361 1495 1253 1346 1696 1454 1631 1784 1752 1826 1389 1234 1202 1152 1188 1000 1048 898 724 937 1145 1537 2023 2079 2371 2156 2098 1855 1843 2208 2126 2218 1664 1457 1389 1454 1481 1458 1661 1400 1548 1499 1949 2055 2130 2220 2038 1904 1750 1993 2114 2272 2418 2101 1976 1791 2161 2690 2958 3013 2888 2798 2792 2875 3207 3627 3732 3842 3791 3836 3964 4082 4351 4550 4755 4746 4851 5180 5507 6100 6491 6533 6133 5394 4627 3886 3133 2209 1073 -368 -1876 -3170 -4067 -4641 -4963 -5049 -4922 -4634 -4147 -3544 -2805 -1962 -1219 -592 -326 -374 -627 -901 -1075 -1159 -1252 -1312 -1444 -1397 -1338 -1142 -748 -541 -350 -314 -265 -143 52 464 653 927 1269 1617 2048 2365 2654 2924 3306 3669 3855 3799 3160 2372 1629 1289 1635 1841 1838 1557 987 630 557 857 1005 868 435 -309 -1083 -1765 -2025 -2055 -2219 -2388 -2409 -2438 -2314 -2002 -1687 -1477 -1533 -1641 -1878 -1885 -1776 -1580 -1005 -525 -164 -84 396 768 1160 1788 2219 2365 1836 1435 1097 988 1326 1423 2106 2191 1965 1829 1578 1835 1429 1570 1596 1301 1357 1233 1634 2386 2597 3037 3225 3406 3339 3049 2935 2611 2428 2340 2728 2621 2994 2599 2591 3010 3341 3922 3992 3824 2982 2128 1376 1455 1437 2022 1927 1730 1841 1832 2334 2942 3183 3124 3362 3342 3549 3322 3474 3686 4164 4550 4051 3701 2742 2656 3210 4011 4641 4416 3697 2998 3382 3715 3729 3687 3375 3521 3932 4273 4172 3970 3598 3675 4879 5887 6320 5794 4623 4179 4453 5626 6412 6353 5563 4689 4683 5058 5905 6270 6218 6134 5704 5297 4087 2627 1221 -181 -1351 -2616 -4341 -6598 -8702 -9888 -10087 -9286 -8357 -7568 -6878 -6063 -4839 -3540 -2281 -1176 -315 248 409 337 -353 -1326 -2135 -2392 -2324 -2288 -2486 -3272 -3618 -3573 -2804 -1503 -604 267 808 1389 2069 2643 3328 3964 4706 5502 6136 6163 5665 4956 4491 4507 4409 4042 3132 1996 998 330 -116 -475 -877 -1370 -1250 -1048 -851 -740 -1207 -1166 -1040 -395 405 441 342 -281 -763 -799 -774 -447 -319 -190 -120 115 182 91 207 387 959 1462 1811 1767 1335 972 730 979 1157 1338 1347 807 591 232 417 696 664 1406 1512 2065 2416 2374 2539 2395 2483 2677 2674 2585 2299 1134 320 -336 -65 676 743 538 16 -374 -515 138 463 1043 1533 1786 2332 2258 2566 2663 2961 3599 3498 3518 2952 2309 2045 1667 1571 1504 1213 1118 1029 874 843 710 977 1377 1816 2236 2114 1989 1698 1618 1672 1682 1602 1382 1044 689 364 55 -24 4 322 669 948 1148 1193 1280 1463 1873 2261 2578 2654 2543 2312 1976 1772 1738 1763 1855 1834 1664 1469 1312 1399 1484 1732 1880 2004 2124 2090 2056 2000 2048 2227 2464 2670 2721 2511 2234 2056 2081 2263 2522 2737 2768 2728 2693 2711 2768 2891 3068 3182 3126 2913 2545 2171 1950 1820 1765 1710 1538 1319 1020 764 600 538 607 742 808 710 517 307 162 62 17 -8 -205 -486 -858 -1288 -1581 -1720 -1795 -1834 -1863 -1906 -1966 -1895 -1855 -1651 -1350 -1049 -721 -464 -265 -65 75 189 306 412 472 458 374 222 113 101 178 309 481 568 576 516 497 582 724 844 964 914 774 662 509 472 576 610 572 554 517 605 785 1008 1312 1555 1786 1957 2044 2081 2118 2193 2264 2328 2335 2277 2205 2098 2002 1981 1982 2017 1972 1912 1788 1611 1519 1428 1393 1367 1209 1045 842 624 564 509 465 398 172 11 -157 -264 -259 -269 -248 -249 -222 -266 -355 -372 -288 -158 -55 1 71 91 102 228 420 619 798 829 930 1012 1047 1210 1359 1531 1676 1702 1787 1809 1729 1668 1653 1721 1808 1793 1747 1616 1485 1476 1516 1751 1961 2029 2057 2006 1955 1893 1904 1960 1967 1975 1934 1827 1814 1749 1809 1947 2037 2098 2067 1970 1754 1627 1667 1759 1904 1890 1819 1747 1644 1698 1746 1834 1959 1922 1887 1864 1712 1734 1770 1895 2029 2062 2153 2132 2203 2206 2202 2194 2075 2019 1889 1923 1930 2090 2250 2335 2372 2209 2085 1902 1805 1826 1843 1804 1761 1605 1580 1680 1713 1825 1904 2097 2269 2373 2384 2235 2351 2445 2530 2610 2560 2618 2511 2445 2374 2111 1959 1760 1602 1474 1208 1021 786 688 654 573 526 409 452 566 694 746 831 914 1008 1043 821 513 214 -45 -242 -453 -723 -898 -1103 -1078 -1081 -1087 -1015 -1073 -869 -884 -720 -555 -329 -24 -63 14 -96 5 260 412 636 623 611 785 788 1001 1025 989 1162 1215 1404 1408 1305 1311 1120 1076 956 785 740 371 389 164 202 522 478 770 483 259 250 79 497 987 1288 1453 1283 1350 1436 1441 1804 1861 2059 2156 1969 2142 2148 2384 2652 2470 2383 1883 1739 1618 1475 1523 1134 1167 1031 816 674 274 251 162 301 387 23 -176 -345 -333 -198 -356 -363 -444 -421 -192 -226 -230 -239 -326 10 106 195 132 95 202 79 -68 -222 -45 429 788 954 1256 1426 1521 1704 1729 2053 1867 1581 1434 1367 1554 1386 1221 1165 1253 1571 1394 1425 1390 948 1288 999 1421 1568 1292 1478 1019 1053 591 693 520 302 314 116 847 1340 1792 1883 1582 1474 1821 2140 2486 2651 2167 1728 1380 1345 1811 1993 2052 2325 2231 2148 2271 2450 2831 2866 2908 2721 2623 2252 2025 2393 2667 3015 2817 2668 2588 2540 2736 2761 3275 3232 3252 3168 3112 3284 3138 3458 3716 3876 3928 3824 3928 4040 4330 4923 5226 5205 5183 5172 5510 5926 6225 6306 6020 5433 4448 3261 2118 959 -239 -1741 -3208 -4507 -5623 -6134 -6133 -5617 -4931 -4192 -3378 -2817 -2219 -1588 -817 -110 199 281 -5 -417 -652 -749 -679 -890 -1261 -1549 -1905 -1928 -2002 -1885 -1552 -1185 -655 -235 222 793 1424 1992 2599 2940 3081 2982 2695 2667 2771 2919 2980 2662 2146 1537 1215 1217 1374 1337 1061 790 376 250 -97 -111 5 -149 -243 -733 -936 -1395 -1810 -1781 -1762 -1500 -1716 -2039 -2318 -2398 -1907 -1592 -1422 -1900 -2619 -3034 -3024 -2335 -1429 -557 323 1051 1587 2021 2282 2438 2207 1843 1789 1482 1392 1056 742 1220 1294 1464 1641 1731 1847 1291 1682 1970 2097 2253 1624 1474 1312 1312 1873 2315 2523 2486 2323 2385 2924 3638 4341 4431 4045 3644 2945 2939 2935 2867 3411 2886 2731 2211 1405 1001 640 1077 1430 1688 1803 1857 2036 2447 3394 3628 3702 3468 3361 3782 3668 3672 4050 3895 4188 4564 4217 3965 2693 1946 1878 2245 3152 3267 3120 2670 2675 3308 4567 5358 5556 5114 3953 3653 3658 4111 4688 4262 3819 3732 4224 4771 5579 5622 5585 5613 5501 5593 5452 5570 5632 6094 5985 5579 4982 4206 3878 3683 3274 2172 698 -1224 -2821 -3890 -4742 -5518 -6463 -7297 -7730 -8054 -7991 -7508 -6683 -5163 -3562 -2162 -1401 -1000 -650 -255 344 643 475 -347 -1530 -2545 -3189 -3506 -3525 -3563 -3239 -2710 -1975 -1174 -649 117 1250 2603 3929 4750 4920 4876 4692 4897 5263 5455 5008 4285 3535 2650 2480 2198 1908 1831 1412 1060 602 80 -281 -245 -37 518 694 559 449 134 264 395 501 454 294 14 -188 -258 -603 -471 -526 -212 202 413 643 447 674 1151 2015 2779 2830 2783 2349 2213 2223 1805 1467 750 640 762 709 685 202 48 360 1103 1707 1935 1604 992 986 883 1293 1285 840 880 25 72 -201 -568 -194 -266 416 698 748 1106 930 1391 2268 2672 3350 3207 3010 3183 2888 3077 3048 2737 2684 2102 1594 1047 146 -39 -397 -420 -237 -520 -465 -526 -247 398 929 1605 2176 2568 2979 3102 3165 3206 3205 3315 3167 2841 2330 1660 1172 909 881 992 1021 1063 1098 1184 1407 1681 1927 2245 2498 2652 2755 2740 2720 2600 2599 2547 2529 2425 2327 2216 1983 1798 1578 1501 1596 1707 1778 1775 1794 1832 1945 2157 2368 2534 2679 2726 2647 2546 2482 2500 2613 2715 2858 2909 2875 2798 2847 3002 3238 3544 3763 3906 3870 3762 3684 3570 3510 3375 3115 2665 2099 1534 1114 848 744 650 462 329 147 161 282 430 614 681 701 635 505 263 -31 -284 -523 -787 -1040 -1310 -1530 -1694 -1726 -1660 -1541 -1319 -1101 -872 -661 -468 -289 -53 235 439 581 607 542 488 496 442 476 539 528 480 404 353 383 409 514 643 801 911 1039 1099 1060 1002 1008 1079 1079 1088 1043 998 953 947 1077 1232 1417 1630 1737 1807 1861 1947 2139 2352 2521 2494 2388 2251 2163 2142 2183 2246 2312 2333 2215 2167 2080 1954 1856 1767 1725 1685 1560 1366 1157 915 754 677 570 434 268 50 -48 -106 -80 23 -6 3 -105 -143 -106 -86 -10 15 72 129 151 224 269 377 540 615 755 802 841 986 1126 1263 1430 1501 1565 1592 1629 1704 1769 1780 1815 1868 1875 1853 1767 1657 1676 1777 1954 2063 2033 2006 1997 2052 2132 2218 2192 2163 2068 1935 1832 1731 1692 1644 1603 1587 1656 1704 1735 1707 1693 1778 1855 1886 1808 1854 1866 2020 2082 2051 2063 1922 1994 2055 1979 1867 1654 1725 1958 2103 2250 2210 2181 2136 1990 1769 1538 1555 1690 1847 1927 1833 1861 1845 1916 1901 1878 1827 1965 2079 2011 1813 1442 1294 1314 1438 1527 1471 1351 1346 1433 1541 1742 1882 2055 2187 2137 2094 2026 2216 2547 2788 2910 2700 2476 2276 2271 2219 2140 2106 1948 1839 1563 1271 991 871 785 695 490 237 93 101 302 452 541 637 735 773 731 667 554 479 381 262 -30 -313 -571 -871 -940 -1094 -1156 -946 -946 -789 -822 -1016 -846 -729 -380 -130 -174 -291 -393 -459 -370 -385 -488 -235 -189 -29 66 20 251 506 931 1376 1399 1348 1192 940 1022 839 916 1173 1247 1303 1207 950 888 944 1151 1385 1216 1012 762 741 964 995 1072 1129 1201 1243 1189 1214 1209 1090 1188 1226 962 840 480 309 201 8 -27 -108 19 120 122 175 188 247 298 326 490 659 638 530 299 294 391 561 749 632 677 592 520 445 175 452 195 476 279 54 216 -444 -153 -497 -42 65 -76 89 -307 613 424 736 729 692 1203 923 1051 761 782 993 912 1361 971 671 640 713 1230 870 821 292 243 774 1172 1686 1286 1348 1303 1523 1622 1578 1833 1810 1913 1658 1535 1352 1375 1673 2156 2537 2408 2275 2078 2090 2117 2030 2120 2227 2296 2388 2667 2966 3152 3134 2987 2799 2665 2686 2666 2584 2637 2572 2631 2836 3106 3325 3066 2882 2869 3046 3325 3369 3339 3398 3350 3293 3457 3587 3759 3999 4191 4413 4437 4477 4519 4628 4905 5061 5239 5014 4922 5179 5616 6008 6053 5515 4650 3634 2615 2101 1403 430 -981 -2592 -4097 -5331 -6002 -6365 -6339 -5996 -5552 -4825 -4058 -3378 -2538 -1678 -858 -70 377 250 -342 -1019 -1354 -1355 -1196 -1361 -1521 -1624 -1862 -1561 -1109 -638 -510 -705 -845 -1026 -585 -35 768 1668 2308 2850 3002 3103 3216 3453 3876 4335 4501 4065 3249 2233 1669 1518 1717 1688 1115 370 -493 -662 -599 -225 85 -153 -466 -954 -1270 -1132 -935 -978 -1481 -2039 -2683 -3353 -3678 -3673 -3362 -2780 -2386 -2281 -2137 -2034 -1498 -801 -239 351 480 608 886 1176 1592 1788 2106 2205 2010 1893 1582 1539 1597 1795 1990 2158 2092 1255 800 1029 1404 1884 2085 1537 1103 919 870 2111 3220 3367 3480 2671 2319 2914 3620 4073 3498 2841 2067 1810 2225 2669 3168 2603 1347 499 729 1563 2063 1953 1175 432 458 1393 2521 3149 3279 2822 2467 2697 3005 3756 4386 4418 4555 3662 3241 3320 3520 3914 4087 3923 2896 2532 1732 1807 2221 2972 3933 3101 2464 1657 1615 2639 3948 4718 5026 4305 3909 3815 3811 4014 3853 4090 4153 4670 4783 4527 4113 4296 4866 5695 6258 6024 5748 5089 5020 5101 4974 4353 3499 2056 779 -738 -2628 -4028 -5515 -6213 -6815 -7376 -7953 -8558 -8565 -7680 -6158 -4573 -3152 -2390 -1579 -792 -128 414 470 360 165 -390 -1164 -2225 -3460 -4085 -4255 -3862 -3277 -2975 -2731 -2390 -1656 -387 1008 2146 3014 3428 3832 4526 4822 4875 4472 3941 3954 3945 3710 2856 1848 931 619 1054 1206 877 318 -270 -412 34 160 399 532 402 655 568 472 246 -92 356 716 776 540 -331 -730 -548 -242 338 202 -72 4 -6 637 885 1005 1330 1619 2174 2350 2069 1709 1412 1476 1747 1558 1230 711 321 398 293 313 92 81 454 659 806 581 346 351 585 870 851 436 -76 -479 -756 -907 -1190 -1414 -1586 -1628 -1483 -1389 -1238 -816 -177 556 1249 1735 2074 2385 2710 3065 3264 3285 3143 2928 2692 2297 1832 1387 1022 955 1088 1101 1028 872 870 1090 1475 1976 2316 2578 2716 2705 2557 2467 2367 2328 2364 2301 2073 1686 1366 1175 1116 1199 1196 1109 962 920 934 983 1051 1258 1536 1752 1836 1770 1680 1643 1800 1954 2082 2111 1986 1885 1813 1824 1898 2088 2236 2353 2399 2340 2255 2213 2244 2350 2365 2326 2266 2154 2072 2068 2093 2130 2223 2295 2394 2515 2449 2426 2527 2778 3021 3240 3286 3216 3108 3004 3042 3106 3147 2990 2690 2282 1902 1641 1457 1359 1172 825 473 189 106 166 377 569 634 551 403 364 415 437 366 107 -242 -524 -723 -824 -959 -1100 -1264 -1381 -1408 -1252 -1072 -932 -889 -819 -581 -341 -107 56 128 156 158 185 260 284 270 324 376 391 423 449 446 429 521 569 566 584 546 589 624 594 594 584 607 725 876 976 1004 1046 1082 1193 1341 1372 1434 1446 1409 1528 1618 1747 1911 1985 2090 2092 2110 2170 2230 2360 2411 2433 2402 2317 2280 2227 2126 2017 1878 1729 1564 1406 1237 1073 957 906 841 788 706 548 437 429 449 554 653 664 582 500 486 511 519 430 339 318 294 287 265 288 299 429 605 681 822 808 887 950 1042 1240 1348 1547 1638 1752 1787 1765 1864 1949 2025 2058 1990 1921 1818 1707 1755 1810 2007 2069 2017 1840 1623 1633 1646 1803 1962 2002 1985 1838 1694 1588 1493 1551 1685 1756 1784 1604 1458 1532 1660 1898 1986 1737 1551 1457 1665 1890 2078 2066 2082 2181 2156 2167 2174 2290 2341 2314 2302 2134 2114 2054 2020 2109 1974 1916 1841 1628 1718 1718 1860 1951 1774 1893 1745 1701 1769 1541 1733 1542 1509 1547 1370 1640 1572 1480 1679 1501 1747 1697 1748 1973 1763 1949 1795 2000 2185 2249 2600 2532 2713 2672 2558 2572 2506 2691 2760 2797 2680 2299 1992 1796 1558 1444 1055 663 489 6 -197 -508 -713 -632 -763 -579 -532 -472 -253 -174 -66 75 -39 72 208 312 339 87 16 -170 -198 -166 -227 -270 -498 -495 -406 -544 -569 -766 -656 -500 -344 -121 -161 -67 -60 97 96 47 31 -76 163 173 417 465 257 332 5 48 -14 -135 124 -51 17 -190 -361 -127 -23 352 410 491 632 489 608 746 1100 1463 1473 1668 1380 1289 1319 1575 1979 1935 1824 1385 1265 1351 1528 1675 1429 1018 548 133 -254 -466 -736 -796 -815 -994 -916 -948 -584 -366 -196 -132 -119 -108 -165 12 -235 -107 -353 -349 -579 -765 -953 -1235 -888 -764 -286 -769 -804 -787 -508 255 127 169 -177 -373 -111).! !AbstractSound subclass: #RestSound	instanceVariableNames: 'initialCount count '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!RestSound methodsFor: 'initialization' stamp: 'jm 1/28/98 13:08'!setDur: d	"Set rest duration in seconds."	initialCount _ (d * self samplingRate asFloat) rounded.	count _ initialCount.	self reset.! !!RestSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:04'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play silence for a given duration."	"(RestSound dur: 1.0) play"	count _ count - n.! !!RestSound methodsFor: 'sound generation'!reset	super reset.	count _ initialCount.! !!RestSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:37'!samplesRemaining	^ count! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RestSound class	instanceVariableNames: ''!!RestSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 15:54'!dur: d	"Return a rest of the given duration."	^ self basicNew setDur: d! !!RestSound class methodsFor: 'instance creation' stamp: 'jm 12/15/97 22:38'!pitch: p dur: d loudness: l	"Return a rest of the given duration."	"Note: This message allows one to silence one or more voices of a multi-voice piece by using RestSound as their instrument."	^ self new setDur: d! !ParseNode subclass: #ReturnNode	instanceVariableNames: 'expr pc '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!ReturnNode commentStamp: 'di 5/22/1998 16:37' prior: 0!ReturnNode comment:'I represent an expression of the form ^expr.'!!ReturnNode methodsFor: 'initialize-release'!expr: e	expr _ e! !!ReturnNode methodsFor: 'initialize-release'!expr: e encoder: encoder sourceRange: range	expr _ e.	encoder noteSourceRange: range forNode: self! !!ReturnNode methodsFor: 'converting'!asReturnNode! !!ReturnNode methodsFor: 'testing'!isReturnSelf	^expr == NodeSelf! !!ReturnNode methodsFor: 'testing'!isSpecialConstant	^expr isSpecialConstant! !!ReturnNode methodsFor: 'testing'!isVariableReference	^expr isVariableReference! !!ReturnNode methodsFor: 'code generation'!code	^expr code! !!ReturnNode methodsFor: 'code generation'!emitForReturn: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!ReturnNode methodsFor: 'code generation'!emitForValue: stack on: strm	expr emitForReturn: stack on: strm.	pc _ strm position! !!ReturnNode methodsFor: 'code generation'!pc	"Used by encoder source mapping."	^pc! !!ReturnNode methodsFor: 'code generation'!sizeForReturn: encoder	^expr sizeForReturn: encoder! !!ReturnNode methodsFor: 'code generation'!sizeForValue: encoder	^expr sizeForReturn: encoder! !!ReturnNode methodsFor: 'printing'!printOn: aStream indent: level	aStream nextPutAll: '^ '.	expr printOn: aStream indent: level.	expr printCommentOn: aStream indent: level! !!ReturnNode methodsFor: 'C translation'!asTranslatorNode	^TReturnNode new setExpression: expr asTranslatorNode! !AbstractSound subclass: #ReverbSound	instanceVariableNames: 'sound tapDelays tapGains tapCount bufferSize bufferIndex leftBuffer rightBuffer '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/7/98 22:41'!sound	^ sound! !!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/7/98 22:42'!sound: aSound	sound _ aSound.! !!ReverbSound methodsFor: 'accessing' stamp: 'jm 1/27/98 19:10'!tapDelays: delayList gains: gainList	"ReverbSound new tapDelays: #(537 691 1191) gains: #(0.07 0.07 0.07)"	| maxDelay gain d |	delayList size = gainList size		ifFalse: [self error: 'tap delay and gains lists must be the same size'].	tapCount _ delayList size.	tapDelays _ Bitmap new: tapCount.	tapGains _ Bitmap new: tapCount.	maxDelay _ 0.	1 to: tapGains size do: [:i |		tapDelays at: i put: (delayList at: i) asInteger.		gain _ gainList at: i.		gain >= 1.0 ifTrue: [self error: 'reverb tap gains must be under 1.0'].		tapGains at: i put: (gain * ScaleFactor) asInteger.		d _ tapDelays at: i.		d > maxDelay ifTrue: [maxDelay _ d]].	bufferSize _ maxDelay.	leftBuffer _ SoundBuffer newMonoSampleCount: maxDelay.	rightBuffer _ SoundBuffer newMonoSampleCount: maxDelay.	bufferIndex _ 1.! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 14:32'!doControl	super doControl.	sound doControl.! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 15:00'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play my sound with reberberation."	sound mixSampleCount: n		into: aSoundBuffer		startingAt: startIndex		leftVol: leftVol		rightVol: rightVol.	self applyReverbTo: aSoundBuffer startingAt: startIndex count: n.! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 16:47'!reset	super reset.	sound reset.	1 to: bufferSize do: [:i |		leftBuffer at: i put: 0.		rightBuffer at: i put: 0].! !!ReverbSound methodsFor: 'sound generation' stamp: 'jm 1/21/98 17:02'!samplesRemaining	^ sound samplesRemaining! !!ReverbSound methodsFor: 'copying' stamp: 'jm 1/21/98 14:29'!copy	"Copy my component sound."	^ super copy copySound! !!ReverbSound methodsFor: 'copying' stamp: 'jm 1/21/98 16:18'!copySound	"Private!! Support for copying. Copy my component sound."	sound _ sound copy.	leftBuffer _ leftBuffer clone.	rightBuffer _ rightBuffer clone.! !!ReverbSound methodsFor: 'private' stamp: 'jm 1/26/98 20:34'!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 183>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #tapDelays declareC: 'int *tapDelays'.	self var: #tapGains declareC: 'int *tapGains'.	self var: #leftBuffer declareC: 'short int *leftBuffer'.	self var: #rightBuffer declareC: 'short int *rightBuffer'.	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft _ delayedRight _ 0.		1 to: tapCount do: [:tapIndex |			i _ bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i _ i + bufferSize].  "wrap"			tapGain _ tapGains at: tapIndex.			delayedLeft _ delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight _ delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j _ (2 * sliceIndex) - 1.		out _ (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out _  32767].  "clipping!!"		out < -32767 ifTrue: [out _ -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j _ j + 1.		out _ (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out _  32767].  "clipping!!"		out < -32767 ifTrue: [out _ -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex _ (bufferIndex \\ bufferSize) + 1].! !RectangleMorph subclass: #RulerMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!RulerMorph methodsFor: 'all'!drawOn: aCanvas	| s |	super drawOn: aCanvas.	s _ self width printString, 'x', self height printString.	aCanvas text: s bounds: (bounds insetBy: borderWidth + 5) font: nil color: Color red.! !!RulerMorph methodsFor: 'all'!initialize	super initialize.	self color: (Color r: 0.8 g: 1.0 b: 1.0).	self borderWidth: 1.! !ArrayedCollection subclass: #RunArray	instanceVariableNames: 'runs values lastIndex lastRun lastOffset '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Arrayed'!!RunArray commentStamp: 'di 5/22/1998 16:37' prior: 0!My instances provide space-efficient storage of data which tends to be constant over long runs of the possible indices. Essentially repeated values are stored singly and then associated with a "run" length that denotes the number of consecutive occurrences of the value.My two important variables are	runs	An array of how many elements are in each run	values	An array of what the value is over those elementsThe variables lastIndex, lastRun and lastOffset cache the last accessso that streaming through RunArrays is not an N-squared process.Many complexities of access can be bypassed by using the method	RunArray withStartStopAndValueDo:!]style[(615 33)f1,f1LRunArray withStartStopAndValueDo:;!!RunArray methodsFor: 'accessing'!at: index	self at: index setRunOffsetAndValue: [:run :offset :value | ^value]! !!RunArray methodsFor: 'accessing'!runLengthAt: index 	"Answer the length remaining in run beginning at index."	self at: index 		setRunOffsetAndValue: [:run :offset :value | ^(runs at: run) - offset]! !!RunArray methodsFor: 'accessing'!size	| size |	size _ 0.	1 to: runs size do: [:i | size _ size + (runs at: i)].	^size! !!RunArray methodsFor: 'accessing' stamp: 'di 11/10/97 13:34'!withStartStopAndValueDo: aBlock	| start stop |	start _ 1.	runs with: values do:		[:len : val | stop _ start + len - 1.		aBlock value: start value: stop value: val.		start _ stop + 1]		! !!RunArray methodsFor: 'adding'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs_ (Array with: 1) , runs.		values_ (Array with: value) , values]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs_ runs copyWith: 1.		values_ values copyWith: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'tk 1/28/98 09:28'!coalesce	"Try to combine adjacent runs"	| ind |	ind _ 2.	[ind > values size] whileFalse: [		(values at: ind-1) = (values at: ind) 			ifFalse: [ind _ ind + 1]			ifTrue: ["two are the same, combine them"				values _ values copyReplaceFrom: ind to: ind with: #().				runs at: ind-1 put: (runs at: ind-1) + (runs at: ind).				runs _ runs copyReplaceFrom: ind to: ind with: #().				"self error: 'needed to combine runs' "]].			! !!RunArray methodsFor: 'copying'!, aRunArray 	"Answer a new RunArray that is a concatenation of the receiver and	aRunArray."	| new newRuns |	(aRunArray isMemberOf: RunArray)		ifFalse: 			[new _ self copy.			"attempt to be sociable"			aRunArray do: [:each | new addLast: each].			^new].	runs size = 0 ifTrue: [^aRunArray copy].	aRunArray runs size = 0 ifTrue: [^self copy].	values last ~= aRunArray first		ifTrue: [^RunArray					runs: runs , aRunArray runs					values: values , aRunArray values].	newRuns _ runs					copyReplaceFrom: runs size					to: runs size					with: aRunArray runs.	newRuns at: runs size put: runs last + aRunArray runs first.	^RunArray		runs: newRuns		values: 			(values				copyReplaceFrom: values size				to: values size				with: aRunArray values)! !!RunArray methodsFor: 'copying'!copyFrom: start to: stop	| newRuns |	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacement	^(self copyFrom: 1 to: start - 1)		, replacement 		, (self copyFrom: stop + 1 to: self size)! !!RunArray methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs printOn: aStream.	aStream nextPutAll: ' values: '.	values printOn: aStream.! !!RunArray methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	aStream nextPutAll: self class name.	aStream nextPutAll: ' runs: '.	runs storeOn: aStream.	aStream nextPutAll: ' values: '.	values storeOn: aStream.	aStream nextPut: $)! !!RunArray methodsFor: 'printing'!writeOn: aStream	aStream nextWordPut: runs size.	1 to: runs size do:		[:x |		aStream nextWordPut: (runs at: x).		aStream nextWordPut: (values at: x)]! !!RunArray methodsFor: 'printing' stamp: 'tk 12/16/97 09:18'!writeScanOn: strm	"Write out the format used for text runs in source files. (14 50 312)f1,f1b,f1LInteger +;i"	strm nextPut: $(.	runs do: [:rr | rr printOn: strm.  strm space].	strm skip: -1; nextPut: $).	values do: [:vv |		vv do: [:att | att writeScanOn: strm].		strm nextPut: $,].	strm skip: -1.  "trailing comma"! !!RunArray methodsFor: 'private'!at: index setRunOffsetAndValue: aBlock 	"Supply all run information to aBlock."	"Tolerates index=0 and index=size+1 for copyReplace: "	| run limit offset |	limit _ runs size.	(lastIndex == nil or: [index < lastIndex])		ifTrue:  "cache not loaded, or beyond index - start over"			[run _ 1.			offset _ index-1]		ifFalse:  "cache loaded and before index - start at cache"			[run _ lastRun.			offset _ lastOffset + (index-lastIndex)].	[run <= limit and: [offset >= (runs at: run)]]		whileTrue: 			[offset _ offset - (runs at: run).			run _ run + 1].	lastIndex _ index.  "Load cache for next access"	lastRun _ run.	lastOffset _ offset.	run > limit		ifTrue: 			["adjustment for size+1"			run _ run - 1.			offset _ offset + (runs at: run)].	^aBlock		value: run	"an index into runs and values"		value: offset	"zero-based offset from beginning of this run"		value: (values at: run)	"value for this run"! !!RunArray methodsFor: 'private'!mapValues: mapBlock	"NOTE: only meaningful to an entire set of runs"	values _ values collect: [:val | mapBlock value: val]! !!RunArray methodsFor: 'private'!runs	^runs! !!RunArray methodsFor: 'private'!setRuns: newRuns setValues: newValues	lastIndex _ nil.  "flush access cache"	runs _ newRuns.	values _ newValues! !!RunArray methodsFor: 'private'!values	"Answer the values in the receiver."	^values! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RunArray class	instanceVariableNames: ''!!RunArray class methodsFor: 'instance creation'!fromBraceStack: itsSize 	"Answer an instance of me with itsSize elements, popped in reverse order from	 the stack of thisContext sender.  Do not call directly: this is called by {1. 2. 3}	 constructs."	^ self newFrom: ((Array new: itsSize) fill: itsSize fromStack: thisContext sender)! !!RunArray class methodsFor: 'instance creation'!new	^self runs: Array new values: Array new! !!RunArray class methodsFor: 'instance creation'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (Array with: size) values: (Array with: value)! !!RunArray class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new.	aCollection do: [:x | newCollection addLast: x].	^newCollection"	RunArray newFrom: {1. 2. 2. 3}	{1. $a. $a. 3} as: RunArray	({1. $a. $a. 3} as: RunArray) values"! !!RunArray class methodsFor: 'instance creation'!readFrom: aStream	"Answer an instance of me as described on the stream, aStream."	| size runs values |	size _ aStream nextWord.	runs _ Array new: size.	values _ Array new: size.	1 to: size do:		[:x |		runs at: x put: aStream nextWord.		values at: x put: aStream nextWord].	^ self runs: runs values: values! !!RunArray class methodsFor: 'instance creation'!runs: newRuns values: newValues 	"Answer an instance of me with runs and values specified by the 	arguments."	| instance |	instance _ self basicNew.	instance setRuns: newRuns setValues: newValues.	^instance! !!RunArray class methodsFor: 'instance creation' stamp: 'di 1/13/98 16:36'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds."	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv _ OrderedCollection new.	"Value array"	aa _ OrderedCollection new.	"Attributes list"	[(this _ strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].		this == $f ifTrue: [aa add: (TextFontChange new fontNumber: (Number readFrom: strm))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].	"R cap so it can follow a number"		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !AbstractSound subclass: #SampledSound	instanceVariableNames: 'initialCount count samples originalSamplingRate samplesSize incrementTimes1000 indexTimes1000 '	classVariableNames: 'CoffeeCupClink DefaultSampleTable NominalSamplePitch SoundLibrary '	poolDictionaries: ''	category: 'System-Sound'!!SampledSound methodsFor: 'initialization' stamp: 'jm 1/31/98 15:07'!setPitch: p dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	super setPitch: p dur: d loudness: vol.	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 9/12/97 17:19'!setSamples: anArray	"There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSamplesFromAIFF:samplePitch:)."	"(SampledSound new setSamples: SampledSound coffeeCupClink) play"	self setSamples: anArray samplingRate: self samplingRate.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 1/27/98 10:33'!setSamples: anArray samplingRate: rate	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."	"(SampledSound		samples: SampledSound coffeeCupClink		samplingRate: 5000) play"	"copy the array into a SoundBuffer if necessary"	anArray class isWords		ifTrue: [samples _ anArray]		ifFalse: [samples _ SoundBuffer fromArray: anArray].	samplesSize _ samples size.	originalSamplingRate _ rate.	initialCount _ (samplesSize * self samplingRate) // originalSamplingRate.	self setLoudness: 0.25.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 3/28/98 05:46'!duration	^ initialCount asFloat / self samplingRate asFloat! !!SampledSound methodsFor: 'accessing' stamp: 'jm 1/31/98 15:54'!duration: seconds	super duration: seconds.	initialCount _ (seconds * self samplingRate asFloat) rounded.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 12/15/97 22:51'!originalSamplingRate	^ originalSamplingRate! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/12/97 16:46'!samples	^ samples! !!SampledSound methodsFor: 'playing' stamp: 'jm 1/5/98 18:30'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex sliceIndex sampleIndex sample i s |	<primitive: 182>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex _ (startIndex + n) - 1.	sliceIndex _ startIndex.	sampleIndex _ indexTimes1000 // 1000.	[(sampleIndex <= samplesSize) and: [sliceIndex <= lastIndex]] whileTrue: [		sample _ ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]].		indexTimes1000 _ indexTimes1000 + incrementTimes1000.		sampleIndex _ indexTimes1000 // 1000.		sliceIndex _ sliceIndex + 1].	count _ count - n.! !!SampledSound methodsFor: 'playing' stamp: 'jm 12/15/97 23:00'!reset	"Details: The increment amount is represented as 1000 * the increment value to allow fractional increments without having to do floating point arithmetic in the inner loop."	super reset.	incrementTimes1000 _		((originalSamplingRate asFloat / self samplingRate asFloat) * 1000.0) rounded.	count _ initialCount.	indexTimes1000 _ 1000.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/13/97 19:07'!samplesRemaining	^ count! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SampledSound class	instanceVariableNames: ''!!SampledSound class methodsFor: 'class initialization' stamp: 'jm 10/18/97 14:19'!initialize	"SampledSound initialize"	self useCoffeeCupClink.	SoundLibrary _ Dictionary new.! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 3/17/98 21:13'!from16BitAIFFfileNamed: fileName samplingRate: anInteger	"Read a SampledSound from the 16-bit AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 16-bit uncompressed mono data. The headers of such AIFF files are 54 bytes."	"(SampledSound from16BitAIFFfileNamed: 'b2Pageturn.aif' samplingRate: 22050) play"	| data |	data _ self rawDataFromAIFFfileNamed: fileName.	data _ self convertBytesTo16BitSamples: data mostSignificantByteFirst: true.	^ self samples: data samplingRate: anInteger! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/13/97 10:39'!fromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name assuming a default sampling rate."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	"| snd |	 FileDirectory default fileNames do: [:n |		(n endsWith: '.aif')			ifTrue: [				snd _ SampledSound fromAIFFfileNamed: n.				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	| data |	data _ self rawDataFromAIFFfileNamed: fileName.	data _ self convert8bitSignedTo16Bit: data.	^ self samples: data samplingRate: 11025! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 21:29'!fromAIFFfileNamed: fileName samplingRate: anInteger	"Read a SampledSound from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 8-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The headers of such AIFF files are 54 bytes."	"(SampledSound fromAIFFfileNamed: '1.aif' samplingRate: 8000) play"	| data |	data _ self rawDataFromAIFFfileNamed: fileName.	data _ self convert8bitSignedTo16Bit: data.	^ self samples: data samplingRate: anInteger! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 3/17/98 21:08'!fromWaveFileNamed: fileName	"(SampledSound fromWaveFileNamed: 'c:\windows\media\chimes.wav') play"	"| snd fd |	fd := FileDirectory on:'c:\windows\media\'.	fd fileNames do: [:n |		(n asLowercase endsWith: '.wav')			ifTrue: [				snd _ SampledSound fromWaveFileNamed: (fd pathName,n).				snd play.				SoundPlayer waitUntilDonePlaying: snd]]."	| stream header data type channels samplingRate blockAlign bitsPerSample leftData rightData index dataWord |	stream _ FileStream oldFileNamed: fileName.	header _ self readWaveChunk: 'fmt ' inRIFF: stream.	data _ self readWaveChunk: 'data' inRIFF: stream.	stream close.	stream _ ReadStream on: header.	type _ self next16BitWord: false from: stream.	type = 1 ifFalse: [^ self error:'Unexpected wave format'].	channels _ self next16BitWord: false from: stream.	(channels < 1 or: [channels > 2])		ifTrue: [^ self error: 'Unexpected number of wave channels'].	samplingRate _ self next32BitWord: false from: stream.	stream skip: 4. "skip average bytes per second"	blockAlign _ self next16BitWord: false from: stream.	bitsPerSample _ self next16BitWord: false from: stream.	(bitsPerSample = 8 or: [bitsPerSample = 16])		ifFalse: [  "recompute bits per sample"			bitsPerSample _ (blockAlign // channels) * 8].	bitsPerSample = 8		ifTrue: [data _ self convert8bitUnsignedTo16Bit: data]		ifFalse: [data _ self convertBytesTo16BitSamples: data mostSignificantByteFirst: false].	channels = 2 ifTrue: [		leftData _ SoundBuffer newMonoSampleCount: data size.		rightData _ SoundBuffer newMonoSampleCount: data size.		stream _ ReadStream on: data.		index _ 1.		[stream atEnd] whileFalse: [			dataWord _ self next16BitWord: false from: stream.			dataWord > 16r8000 ifTrue: [dataWord _ dataWord - 16r10000].			leftData at: index put: dataWord.			dataWord _ self next16BitWord: false from: stream.			dataWord > 16r8000 ifTrue: [dataWord _ dataWord - 16r10000].			rightData at: index put: dataWord.			index _ index + 1].		^ MixedSound new			add: (self samples: leftData samplingRate: samplingRate) pan: 0.0;			add: (self samples: rightData samplingRate: samplingRate) pan: 1.0;			yourself].	^ self samples: data samplingRate: samplingRate! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 9/12/97 19:20'!samples: anArrayOf16BitSamples samplingRate: samplesPerSecond	"Return a SampledSound with the given samples array and sampling rate."	^ self new setSamples: anArrayOf16BitSamples samplingRate: samplesPerSecond! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 13:10'!defaultSamples: anArray repeated: n	| data |	data _ WriteStream on: (SoundBuffer newMonoSampleCount: anArray size * n).	n timesRepeat: [		anArray do: [:sample | data nextPut: sample truncated]].	DefaultSampleTable _ data contents.! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/12/97 19:17'!defaultSamplesFromAIFF: fileName samplePitch: aNumber	"Set the sample table to be used as the default waveform from the AIFF file of the given name. The sample pitch is an estimate of the normal pitch of the sampled sound."	"SampledSound defaultSamplesFromAIFF: 'boing.aiff' samplePitch: 200"	self defaultSampleTable: (self fromAIFFfileNamed: fileName) samples.	self nominalSamplePitch: aNumber.! !!SampledSound class methodsFor: 'default sound'!defaultSampleTable	"Return the sample table to be used as the default waveform for playing a score."	^ DefaultSampleTable! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 9/17/97 12:49'!defaultSampleTable: anArray	"Set the sample table to be used as the default waveform for playing a score such as the Bach fugue. Array is assumed to contain monaural signed 16-bit sample values."	DefaultSampleTable _ SoundBuffer fromArray: anArray.! !!SampledSound class methodsFor: 'default sound'!nominalSamplePitch: aNumber	"Record an estimate of the normal pitch of the sampled sound."	NominalSamplePitch _ aNumber.! !!SampledSound class methodsFor: 'default sound' stamp: 'jm 5/8/1998 18:53'!useCoffeeCupClink	"Set the sample table to be used as the default waveform to the sound of a coffee cup being tapped with a spoon."	"SampledSound useCoffeeCupClink bachFugue play"	DefaultSampleTable _ self coffeeCupClink.	NominalSamplePitch _ 400.! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 8/23/97 22:25'!coffeeCupClink	"Return the samples array for the sound of a spoon being tapped against a coffee cup."	CoffeeCupClink ifNil: [self initializeCoffeeCupClink].	^ CoffeeCupClink! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 9/17/97 12:50'!initializeCoffeeCupClink	"Initialize the samples array for the sound of a spoon being tapped against a coffee cup."	"SampledSound initializeCoffeeCupClink"	| samples |	samples _ #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256).	CoffeeCupClink _ SoundBuffer fromArray: samples.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/13/97 21:55'!addLibrarySoundNamed: aString fromAIFFfileNamed: fileName sampleRate: samplesPerSecond	"Add a sound from the given AIFF file to the library. The file is assumed to be 8-bits, mono, uncompressed."	"SampledSound addLibrarySoundNamed: 'shutterClick'		fromAIFFfileNamed: '7.aif'		sampleRate: 11025"	self addLibrarySoundNamed: aString		samples: (self rawDataFromAIFFfileNamed: fileName)		sampleRate: samplesPerSecond.! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/12/97 19:45'!addLibrarySoundNamed: aString samples: sampleData sampleRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples (as from an AIFF file). If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 12/15/97 14:29'!addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples (as from an AIFF file). If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 10/20/97 17:10'!atSoundLibraryKey:  aString put: anObject	"SampledSound atSoundLibraryKey: 'no sound' put: nil"	SoundLibrary at: aString put: anObject! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 9/19/97 18:58'!playSoundNamed: aString	"SampledSound playSoundNamed: 'croak'"	| aSound |	(aSound _ self soundNamed: aString) ifNotNil: [aSound play]! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 10/18/97 14:56'!putCoffeeCupClinkInSoundLibrary	"SampledSound putCoffeeCupClinkInSoundLibrary"	self addLibrarySoundNamed: 'clink'		samples: self coffeeCupClink		sampleRate: 11025! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 12/5/97 15:40'!readLibrarySoundsFromDisk	"Scan the current directory for .aif files, read them in, put them in the sound library"	"SampledSound readLibrarySoundsFromDisk "	 (FileDirectory default fileNamesMatching: '*.aif') do:		[:fileName |			self addLibrarySoundNamed: (fileName copyUpTo: $.)				fromAIFFfileNamed: fileName				sampleRate: 11025].! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 9/12/97 19:46'!removeSoundNamed: aString	"Remove the sound with the given name from the sound library."	SoundLibrary removeKey: aString ifAbsent: [].! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 10/23/97 11:05'!soundLibrary	"Return the sound library dictionary."	^ SoundLibrary! !!SampledSound class methodsFor: 'sound library' stamp: 'sw 10/20/97 17:03'!soundNamed: aString	"Return a list of sound names for the sounds stored in the sound library."	"(SampledSound soundNamed: 'shutterClick') play"	| entry samples |	entry _ SoundLibrary		at: aString		ifAbsent:			[self inform: aString, ' not found in the Sound Library'.			^ nil].	entry ifNil: [^ nil].	samples _ entry at: 1.	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].	^ self samples: samples samplingRate: (entry at: 2)! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 11/2/97 17:44'!soundNames	"Return a list of sound names for the sounds stored in the sound library."	"SampledSound soundNames do: [:n | SampledSound playSoundNamed: n]"	^ SoundLibrary keys asArray! !!SampledSound class methodsFor: 'sound library' stamp: 'jhm 10/15/97 14:57'!unusedSoundNameLike: desiredName	"Pick an unused sound name based on the given string. If necessary, append digits to avoid name conflicts with existing sounds."	"SampledSound unusedSoundNameLike: 'chirp'"	| newName i |	newName _ desiredName.	i _ 2.	[SoundLibrary includesKey: newName] whileTrue: [		newName _ desiredName, i printString.		i _ i + 1].	^ newName! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 2/15/98 19:09'!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 236>	self var: #aByteArray declareC: 'unsigned char *aByteArray'.	self var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'.	n _ aByteArray size.	1 to: n do: [:i |		s _ aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 2/15/98 18:13'!convert8bitSignedTo16Bit: aByteArray	"Convert the given array of samples--assumed to be 8-bit signed, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed AIFF sound data."	| result |	result _ SoundBuffer newMonoSampleCount: aByteArray size.	self convert8bitSignedFrom: aByteArray to16Bit: result.	^ result! !!SampledSound class methodsFor: 'utilities' stamp: 'ar 1/27/98 23:11'!convert8bitUnsignedTo16Bit: anArray	"Convert the given array of samples--assumed to be 8-bit unsigned, linear data--into 16-bit signed samples. Return an array containing the resulting samples. Typically used to read uncompressed WAVE sound data."	| n samples s |	n _ anArray size.	samples _ SoundBuffer newMonoSampleCount: n.	1 to: n do: [:i |		s _ anArray at: i.		samples at: i put: (s - 128 * 256)].	^ samples! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 3/17/98 21:07'!convertBytesTo16BitSamples: aByteArray mostSignificantByteFirst: msbFirst	"Convert the given ByteArray (with the given byte ordering) into 16-bit sample buffer."	| n data src b1 b2 w |	n _ aByteArray size // 2.	data _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		b1 _ aByteArray at: src.		b2 _ aByteArray at: src + 1.		msbFirst			ifTrue: [w _ (b1 bitShift: 8) + b2]			ifFalse: [w _ (b2 bitShift: 8) + b1].		w > 32767 ifTrue: [w _ w - 65536].		data at: i put: w.		src _ src + 2].	^ data! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/12/97 20:02'!rawDataFromAIFFfileNamed: fileName	"Read a SampledSound from the AIFF file of the given name. This method skips the header without parsing it; it assumes the file contains 8-bit uncompressed mono data as recorded by the shareware program SoundMachine 2.1. The headers of such AIFF files are 54 bytes."	"(SampledSound fromAIFFfileNamed: '1.aif') play"	| data f sz |	f _ (FileStream oldFileNamed: fileName) binary.	sz _ f size.	f skip: 54.  "skip AIFF header"	data _ (f next: sz - 54).	f close.	^ data! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/12/97 19:51'!readTrimmedSamplesFromAIFF: fileName	"Read samples from the given AIFF file and trim off leading and trailing silence."	| data first last i s |	data _ (FileStream oldFileNamed: fileName) binary contentsOfEntireFile.	first _ last _ nil.	i _ 55.	[(first == nil) and: [i < data size]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [first _ i].		i _ i + 1].	first ifNil: [^ SoundBuffer new].  "all silence"	i _ data size.	[(last == nil) and: [i > first]] whileTrue: [		s _ data at: i.		s > 127 ifTrue: [s _ s - 256].		s abs > 10 ifTrue: [last _ i].		i _ i - 1].	^ self convert8bitSignedTo16Bit: (data copyFrom: first to: last)! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/17/97 13:11'!uLawDecode: aByteArray	"Convert the given array of uLaw-encoded 8-bit samples into a SoundBuffer of 16-bit signed samples."	| n out decodingTable |	n _ aByteArray size.	out _ SoundBuffer newMonoSampleCount: n.	decodingTable _ self uLawDecodeTable.	1 to: n do: [:i | out at: i put: (decodingTable at: (aByteArray at: i) + 1)].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 16:41'!uLawDecodeTable	"Return a 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"Details: This table was computed as follows:		| d encoded lastEncodedPos lastEncodedNeg |		d _ Array new: 256.		lastEncodedPos _ nil.		lastEncodedNeg _ nil.		4095 to: 0 by: -1 do: [:s |			encoded _ SampledSound uLawEncodeSample: s.			lastEncodedPos = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3).					lastEncodedPos _ encoded].			encoded _ encoded bitOr: 16r80.			lastEncodedNeg = encoded				ifFalse: [					d at: (encoded + 1) put: (s bitShift: 3) negated.					lastEncodedNeg _ encoded]].		d "	^ #(32760 31608 30584 29560 28536 27512 26488 25464 24440 23416 22392 21368 20344 19320 18296 17272 16248 15736 15224 14712 14200 13688 13176 12664 12152 11640 11128 10616 10104 9592 9080 8568 8056 7800 7544 7288 7032 6776 6520 6264 6008 5752 5496 5240 4984 4728 4472 4216 3960 3832 3704 3576 3448 3320 3192 3064 2936 2808 2680 2552 2424 2296 2168 2040 1912 1848 1784 1720 1656 1592 1528 1464 1400 1336 1272 1208 1144 1080 1016 952 888 856 824 792 760 728 696 664 632 600 568 536 504 472 440 408 376 360 344 328 312 296 280 264 248 232 216 200 184 168 152 136 120 112 104 96 88 80 72 64 56 48 40 32 24 16 8 0 -32760 -31608 -30584 -29560 -28536 -27512 -26488 -25464 -24440 -23416 -22392 -21368 -20344 -19320 -18296 -17272 -16248 -15736 -15224 -14712 -14200 -13688 -13176 -12664 -12152 -11640 -11128 -10616 -10104 -9592 -9080 -8568 -8056 -7800 -7544 -7288 -7032 -6776 -6520 -6264 -6008 -5752 -5496 -5240 -4984 -4728 -4472 -4216 -3960 -3832 -3704 -3576 -3448 -3320 -3192 -3064 -2936 -2808 -2680 -2552 -2424 -2296 -2168 -2040 -1912 -1848 -1784 -1720 -1656 -1592 -1528 -1464 -1400 -1336 -1272 -1208 -1144 -1080 -1016 -952 -888 -856 -824 -792 -760 -728 -696 -664 -632 -600 -568 -536 -504 -472 -440 -408 -376 -360 -344 -328 -312 -296 -280 -264 -248 -232 -216 -200 -184 -168 -152 -136 -120 -112 -104 -96 -88 -80 -72 -64 -56 -48 -40 -32 -24 -16 -8 0)! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:52'!uLawEncode: anArray	"Convert the given array of 16-bit signed samples into a ByteArray of uLaw-encoded 8-bit samples."	| n out s |	n _ anArray size.	out _ ByteArray new: n.	1 to: n do: [:i |		s _ anArray at: i.		s _ s bitShift: -3.  "drop 4 least significant bits"		s < 0			ifTrue: [s _ (self uLawEncodeSample: s negated) bitOr: 16r80]			ifFalse: [s _ (self uLawEncodeSample: s)].		out at: i put: s].	^ out! !!SampledSound class methodsFor: 'utilities' stamp: 'jm 9/13/97 15:40'!uLawEncodeSample: s	"Encode the given 16-bit signed sample using the uLaw 8-bit encoding."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !!SampledSound class methodsFor: 'WAV reading' stamp: 'ar 1/27/98 23:06'!next16BitWord: msbFirst from: stream	"Read a 16-bit positive integer from the input stream."	"Assume: Stream has at least two bytes left."	| n |	n _ stream next: 2.	^msbFirst		ifTrue:[(n at: 1) * 256 + (n at: 2)]		ifFalse:[(n at: 2) * 256 + (n at: 1)]! !!SampledSound class methodsFor: 'WAV reading' stamp: 'ar 1/27/98 23:06'!next32BitWord: msbFirst from: stream	"Read a 32-bit positive integer from the input stream."	"Assume: Stream has at least four bytes left."	| n |	n _ stream next: 4.	^msbFirst		ifTrue:[(n at: 1) * 256 + (n at: 2) * 256 + (n at: 3) * 256 + (n at: 4)]		ifFalse:[(n at: 4) * 256 + (n at: 3) * 256 + (n at: 2) * 256 + (n at: 1)]! !!SampledSound class methodsFor: 'WAV reading' stamp: 'jm 3/17/98 21:03'!readWaveChunk: chunkType inRIFF: stream	"Search the stream for a format chunk of the given type and return its contents."	| id count |	stream reset; binary.	stream skip: 8.  "skip 'RIFF' and total length"	id _ (stream next: 4) asString.  "contents type"	id = 'WAVE' ifFalse: [^ ''].     "content type must be WAVE"	"search for a chunk of the given type"	[id _ (stream next: 4) asString.	 count _ self next32BitWord: false from: stream.	 id = chunkType] whileFalse: [		"skip this chunk, rounding length up to a word boundary"		stream skip: (count + 1 bitAnd: 16rFFFFFFFE).		stream atEnd ifTrue: [^ '']].	^ stream next: count  "return raw chunk data"! !RectangleMorph subclass: #ScaleMorph	instanceVariableNames: 'caption start stop minorTick minorTickLength majorTick majorTickLength tickPrintBlock '	classVariableNames: 'ClassVarName1 ClassVarName2 '	poolDictionaries: ''	category: 'Morphic-Widgets'!!ScaleMorph methodsFor: 'as yet unclassified' stamp: 'di 1/26/98 21:14'!buildLabels	| scale x1 y1 y2 x captionMorph tickMorph |	self removeAllMorphs.	caption ifNotNil:		[captionMorph _ StringMorph contents: caption.		captionMorph align: captionMorph bounds bottomCenter				with: self bounds bottomCenter - (0@majorTickLength)						- (0@(captionMorph height + 2)).		self addMorph: captionMorph].	tickPrintBlock ifNotNil:		[scale _ (self innerBounds width-1) / (stop-start) asFloat.		x1 _ self innerBounds left.		y1 _ self innerBounds bottom.		y2 _ y1 - majorTickLength.		start to: stop by: majorTick do:			[:v | x _ x1 + (scale*v).			tickMorph _ StringMorph contents: (tickPrintBlock value: v).			tickMorph align: tickMorph bounds bottomCenter						with: x@y2.			tickMorph left < self left ifTrue:				[tickMorph position: self left@tickMorph top].			tickMorph right > self right ifTrue:				[tickMorph position: (self right-tickMorph width)@tickMorph top].			self addMorph: tickMorph]]! !!ScaleMorph methodsFor: 'as yet unclassified' stamp: 'di 2/17/98 12:07'!drawOn: aCanvas	| scale x1 y1 y2 x y3 even yy |	super drawOn: aCanvas.	scale _ (self innerBounds width-1) / (stop-start) asFloat.	x1 _ self innerBounds left.	y1 _ self innerBounds bottom - 1.	y2 _ y1 - minorTickLength.	start to: stop by: minorTick do:		[:v | x _ x1 + (scale*v).		aCanvas line: x@y1 to: x@y2 width: 1 color: Color black].	x1 _ self innerBounds left.	y2 _ y1 - majorTickLength.	y3 _ y1 - (minorTickLength+majorTickLength//2).	even _ true.	start to: stop by: majorTick/2.0 do:		[:v | x _ x1 + (scale*v).		yy _ even ifTrue: [y2] ifFalse: [y3].		aCanvas line: x@y1 to: x@yy width: 1 color: Color black.		even _ even not].! !!ScaleMorph methodsFor: 'as yet unclassified' stamp: 'di 2/19/98 21:41'!extent: newExtent	| pixPerTick newWidth |	pixPerTick _ (newExtent x - (self borderWidth*2) - 1)						/ ((stop-start) asFloat / minorTick).	pixPerTick _ pixPerTick detentBy: 0.1 atMultiplesOf: 1.0 snap: false.	newWidth _ pixPerTick * ((stop-start) asFloat / minorTick)						+ (self borderWidth*2) + 1.	super extent: newWidth @ newExtent y.	self buildLabels! !!ScaleMorph methodsFor: 'as yet unclassified' stamp: 'di 1/26/98 20:26'!initialize	super initialize.	borderWidth _ 0.	color _ Color lightGreen.	start _ 0.  stop _ 100.	minorTick _ 1.  majorTick _ 10.	minorTickLength _ 3.  majorTickLength _ 10.	caption _ 'sample'.  tickPrintBlock _ [:v | v printString].! !!ScaleMorph methodsFor: 'as yet unclassified' stamp: 'di 2/17/98 12:11'!start: strt stop: stp	minorTick: mnt minorTickLength: mntLen	majorTick: mjt majorTickLength: mjtLen	caption: cap tickPrintBlock: blk	start _ strt.  stop _ stp.	minorTick _ mnt.  minorTickLength _ mntLen.	majorTick _ mjt.  majorTickLength _ mjtLen.	caption _ cap.  tickPrintBlock_ blk fixTemps.	self buildLabels! !Object subclass: #Scanner	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable '	classVariableNames: 'TypeTable '	poolDictionaries: ''	category: 'System-Compiler'!!Scanner commentStamp: 'di 5/22/1998 16:37' prior: 0!Scanner comment:'I scan a string or text, picking out Smalltalk syntactic tokens. I look one character ahead. I put each token found into the instance variable, token, and its type (a Symbol) into the variable, tokenType. At the end of the input stream, I pretend to see an endless sequence of special characters called doits.'!!Scanner methodsFor: 'initialize-release'!initScanner	buffer _ WriteStream on: (String new: 40).	typeTable _ TypeTable! !!Scanner methodsFor: 'initialize-release'!scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer."	source _ inputStream.	self step.	self step.	self scanToken! !!Scanner methodsFor: 'public access'!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	| strm |	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	self scan: (ReadStream on: stringOrArray asString).	strm _ WriteStream on: (Array new: 10).	[tokenType = #doIt]		whileFalse: 			[tokenType = #word ifTrue: [strm nextPut: token].			self scanToken].	^strm contents	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!Scanner methodsFor: 'public access'!scanStringStruct: textOrString 	"The input is a string whose elements are identifiers and parenthesized	 groups of identifiers.  Answer an array reflecting that structure, representing	 each identifier by an uninterned string."	self scan: (ReadStream on: textOrString asString).	self scanStringStruct.	^token	"Scanner new scanStringStruct: 'a b (c d) (e f g)'"! !!Scanner methodsFor: 'public access'!scanTokens: textOrString 	"Answer an Array that has been tokenized as though the input text, 	textOrString, had appeared between the array delimitors #( and ) in a 	Smalltalk literal expression."	self scan: (ReadStream on: textOrString asString).	self scanLitVec.	^token	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !!Scanner methodsFor: 'expression types'!advance	| prevToken |	prevToken _ token.	self scanToken.	^prevToken! !!Scanner methodsFor: 'expression types'!nextLiteral	"Same as advance, but -4 comes back as a number instead of two tokens"	| prevToken |	prevToken _ self advance.	(prevToken == #- and: [token isKindOf: Number])		ifTrue: 			[^self advance negated].	^prevToken! !!Scanner methodsFor: 'expression types'!scanLitVec	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanLitVec]				ifFalse: 					[tokenType = #word | (tokenType = #keyword)						ifTrue: 							[self scanLitWord]						ifFalse:							[(token == #- 									and: [(typeTable at: hereChar asciiValue) = #xDigit])								ifTrue: 									[self scanToken.									token _ token negated]]].			s nextPut: token.			self scanToken].	token _ s contents! !!Scanner methodsFor: 'expression types'!scanLitWord	"Accumulate keywords and asSymbol the result."	| t |	[(typeTable at: hereChar asciiValue) = #xLetter]		whileTrue: 			[t _ token.			self xLetter.			token _ t , token].	token _ token asSymbol! !!Scanner methodsFor: 'expression types'!scanStringStruct	| s |	s _ WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanStringStruct]				ifFalse: 					[tokenType = #word ifFalse:						[^self error: 'only words and parens allowed']].			s nextPut: token.			self scanToken].	token _ s contents! !!Scanner methodsFor: 'expression types'!scanToken	[(tokenType _ typeTable at: hereChar asciiValue) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark _ source position - 1.	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token _ self step asSymbol "else just unique the first char"].	^token! !!Scanner methodsFor: 'expression types'!step	| c |	c _ hereChar.	hereChar _ aheadChar.	source atEnd		ifTrue: [aheadChar _ 30 asCharacter "doit"]		ifFalse: [aheadChar _ source next].	^c! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 4/23/1998 14:55'!xBinary	tokenType _ #binary.	token _ Symbol internCharacter: self step.	((typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-])		ifTrue: [token _ (token , (String with: self step)) asSymbol]! !!Scanner methodsFor: 'multi-character scans'!xColon		"Allow := for assignment by converting to #_ "	aheadChar = $= ifTrue:		[self step.		tokenType _ #leftArrow.		self step.		^ token _ #_].	"Otherwise, just do what normal scan of colon would do"	tokenType _ #colon.	^ token _ self step asSymbol! !!Scanner methodsFor: 'multi-character scans'!xDelimiter	"Ignore blanks, etc."	self scanToken! !!Scanner methodsFor: 'multi-character scans' stamp: 'tao 4/23/98 12:55'!xDigit	"Form a number."	tokenType _ #number.	(aheadChar = 30 asCharacter and: [source atEnd			and:  [source skip: -1. source next ~= 30 asCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token _ [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].	self step; step! !!Scanner methodsFor: 'multi-character scans'!xDollar	"Form a Character literal."	self step. "pass over $"	token _ self step.	tokenType _ #number "really should be Char, but rest of compiler doesn't know"! !!Scanner methodsFor: 'multi-character scans' stamp: 'wod 1/10/98 00:43'!xDoubleQuote    "Collect a comment."    "wod 1/10/98: Allow 'empty' comments by testing the first characterfor $"" rather than blindly adding it to the comment being collected."    | aStream stopChar |    stopChar _ 30 asCharacter.    aStream _ WriteStream on: (String new: 200).    self step.    [hereChar == $"]        whileFalse:            [(hereChar == stopChar and: [source atEnd])                ifTrue: [^self offEnd: 'Unmatched comment quote'].            aStream nextPut: self step.].    self step.    currentComment == nil        ifTrue: [currentComment _ OrderedCollection with: aStreamcontents]        ifFalse: [currentComment add: aStream contents].    self scanToken! !!Scanner methodsFor: 'multi-character scans'!xLetter	"Form a word or keyword."	| type |	buffer reset.	[(type _ typeTable at: hereChar asciiValue) == #xLetter or: [type == #xDigit]]		whileTrue:			["open code step for speed"			buffer nextPut: hereChar.			hereChar _ aheadChar.			source atEnd				ifTrue: [aheadChar _ 30 asCharacter "doit"]				ifFalse: [aheadChar _ source next]].	(type == #colon or: [type = #xColon and: [aheadChar ~= $=]])		ifTrue: 			[buffer nextPut: self step.			tokenType _ #keyword]		ifFalse: 			[tokenType _ #word].	token _ buffer contents! !!Scanner methodsFor: 'multi-character scans'!xLitQuote	"UniqueStrings and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse:.	 For ##x answer #x->nil.  For ###x answer nil->#x."	| start |	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[start _ mark.			self scanToken; scanLitVec.			tokenType == #doIt				ifTrue: [mark _ start.						self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isMemberOf: Association)								ifTrue: "###word"									[token _ nil->token key].							(token isMemberOf: Symbol)								ifTrue: "##word"									[token _ token->nil]]]].	tokenType _ #literal"	#(Pen)	#Pen	##Pen	###Pen"! !!Scanner methodsFor: 'multi-character scans'!xSingleQuote	"String."	self step.	buffer reset.	[hereChar = $' 		and: [aheadChar = $' 				ifTrue: [self step. false]				ifFalse: [true]]]		whileFalse: 			[buffer nextPut: self step.			(hereChar = 30 asCharacter and: [source atEnd])				ifTrue: [^self offEnd: 'Unmatched string quote']].	self step.	token _ buffer contents.	tokenType _ #string! !!Scanner methodsFor: 'error handling'!notify: string 	"Refer to the comment in Object|notify:." 	self error: string! !!Scanner methodsFor: 'error handling'!offEnd: aString 	"Parser overrides this"	^self notify: aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Scanner class	instanceVariableNames: ''!!Scanner class methodsFor: 'class initialization'!initialize	| newTable |	newTable _ Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	newTable atAll: ($A asciiValue to: $Z asciiValue) put: #xLetter.	newTable atAll: ($a asciiValue to: $z asciiValue) put: #xLetter.	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable _ newTable "bon voyage!!"	"Scanner initialize"! !!Scanner class methodsFor: 'instance creation'!new	^super new initScanner! !!Scanner class methodsFor: 'testing'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()' includes: (aSymbol at: 1)) ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !AbstractSound subclass: #ScorePlayer	instanceVariableNames: 'score instruments leftVols rightVols muted rate tempo secsPerTick done repeat ticksSinceStart ticksClockIncr trackEventIndex tempoMapIndex activeSounds '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!ScorePlayer methodsFor: 'initialization' stamp: 'jm 3/4/98 09:22'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 3/4/98 09:24'!onScore: aMIDIScore	| n totalVol incr curr vol |	score _ aMIDIScore.	n _ score tracks size.	instruments _ (1 to: n) collect: [:i | FMSound oboe1].	leftVols _ Array new: n.	rightVols _ Array new: n.	muted  _ Array new: n withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	n = 0 ifTrue: [^ self].	n = 1 ifTrue: [  "center solo voice"		leftVols at: i put: ScaleFactor // 8.		rightVols at: i put: ScaleFactor // 8.		^ self].			"distribute inital panning of tracks left-to-right"	totalVol _ ScaleFactor // (2 * n).	incr _ totalVol // (((n // 2) + 1) * 2).	curr _ 0.	1 to: n do: [:i |		i even			ifTrue: [vol _ curr]			ifFalse: [				curr _ curr + incr.				vol _ totalVol - curr].		leftVols at: i put: vol.		rightVols at: i put: (totalVol - vol)].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 3/4/98 09:27'!doControl	| t |	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	t _ ticksSinceStart asInteger.	self processTempoMapAtTick: t.	self processEventsAtTick: t.	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/3/98 09:44'!isDone	| track |	activeSounds size > 0  ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/5/98 13:42'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| someSoundIsDone pair snd trk left right |	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (leftVol * (leftVols at: trk)) // ScaleFactor.		right _ (rightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/29/98 22:50'!processEventsAtTick: scoreTicks	| instr j snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[snd _ score soundForTrack: i			after: j			ticks: scoreTicks			instrument: instr			secsPerTick: secsPerTick.		 snd ~~ nil]			whileTrue: [				(muted at: i)					ifFalse: [activeSounds add: (Array with: snd with: i)].				j _ j + 1.				trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 11:14'!processTempoMapAtTick: scoreTicks	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTicks]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 1/4/98 10:43'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	trackEventIndex _ Array new: score tracks size withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 12/30/97 17:38'!samplesRemaining	done		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/3/98 12:14'!infoForTrack: i	"Return the info string for the given track."	"Note: MIDI files follow varying conventions on their use of comment strings. Often, the first string in the track suggests the role of that track in the score, such as 'flute 1' or 'soprano'."	^ score trackInfo at: i! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:37'!instrumentForTrack: trackIndex	^ instruments at: trackIndex! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:38'!instrumentForTrack: trackIndex put: aSoundProto	instruments at: trackIndex put: aSoundProto.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/29/98 18:33'!mutedForTrack: trackIndex	^ muted at: trackIndex! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/29/98 22:56'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifTrue: [		activeSounds do: [:pair |			pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/21/98 23:56'!panForTrack: i	^ ((leftVols at: i) asFloat / ((leftVols at: i) + (rightVols at: i))) roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/22/98 15:13'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| total left |	total _ (leftVols at: i) + (rightVols at: i).	left _ ((aNumber asFloat min: 1.0) * total) asInteger.	leftVols at: i put: left.	rightVols at: i put: (total - left).! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!rate	^ rate! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:07'!rate: aNumber	"Set the playback rate. For example, a rate of 2.0 will playback at twice normal speed."	rate _ aNumber asFloat.	self tempoOrRateChanged.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/4/98 09:30'!repeat	"Return true if this player will repeat when it gets to the end of the score, false otherwise."	^ repeat! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 3/4/98 09:31'!repeat: aBoolean	"Turn repeat mode on or off."	repeat _ aBoolean.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:33'!score	^ score! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/4/98 10:10'!tempo	"Return the current tempo in beats (quarter notes) per minute. The tempo at any given moment is defined by the score and cannot be changed by the client. To change the playback speed, the client may change the rate parameter."	^ tempo! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/3/98 09:35'!trackCount	^ score tracks size! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/22/98 01:00'!volumeForTrack: i	| total |	total _ (leftVols at: i) + (rightVols at: i).	^ (total asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 1/22/98 00:54'!volumeForTrack: i put: aNumber	| oldTotal newTotal left |	oldTotal _ (leftVols at: i) + (rightVols at: i).	newTotal _ (aNumber asFloat min: 1.0) * ScaleFactor.	oldTotal = 0		ifTrue: [left _ newTotal // 2]		ifFalse: [left _ ((newTotal * (leftVols at: i)) / oldTotal) asInteger].	leftVols at: i put: left.	rightVols at: i put: (newTotal - left).! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 1/30/98 14:03'!disableReverb: aBoolean	aBoolean		ifTrue: [SoundPlayer stopReverb]		ifFalse: [SoundPlayer startReverb].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 3/4/98 13:17'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	super resumePlaying.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 1/29/98 22:48'!reverbState: aBoolean	aBoolean		ifTrue: [SoundPlayer startReverb]		ifFalse: [SoundPlayer stopReverb].! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 12/15/97 19:13'!copy	"Copy my component sounds."	^ super copy copySounds! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 1/29/98 18:32'!copySounds	"Private!! Support for copying."	instruments _ instruments copy.	leftVols _ leftVols copy.	rightVols _ rightVols copy.	muted _ muted copy.	self reset.! !!ScorePlayer methodsFor: 'copying' stamp: 'jm 1/4/98 10:36'!tempoOrRateChanged	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScorePlayer class	instanceVariableNames: ''!!ScorePlayer class methodsFor: 'instance creation' stamp: 'jm 1/29/98 18:18'!onScore: aMIDIScore	^ self new onScore: aMIDIScore! !AlignmentMorph subclass: #ScorePlayerMorph	instanceVariableNames: 'scorePlayer trackInstNames instrumentSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/5/98 17:40'!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection	| oldSnd name snd |	oldSnd _ scorePlayer instrumentForTrack: trackIndex.	(selection beginsWith: 'edit ') ifTrue: [		name _ selection copyFrom: 6 to: selection size.		aPopUpChoice contentsClipped: name.		(oldSnd isKindOf: FMSound) ifFalse: [^ self].		EnvelopeEditorMorph openOn: oldSnd title: name.		^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((trackIndex ~= i) and:		 [selection = (instrumentSelector at: i) contents])			ifTrue: [snd _ scorePlayer instrumentForTrack: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/4/98 09:38'!initialize	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 3.	color _ Color veryLightGray.	self borderWidth: 2.	self onScorePlayer: (ScorePlayer new initialize) title: ' '.	self extent: 20@20.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/5/98 16:14'!instrumentChoicesForTrack: trackIndex	| names |	names _ AbstractSound soundNames asOrderedCollection.	names add: 'clink'.	names add: 'edit ' , (instrumentSelector at: trackIndex) contents.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 2/2/98 14:40'!instrumentNames	| names |	names _ AbstractSound soundNames asOrderedCollection.	names add: 'clink'.	names add: 'edit instrument'.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:10'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'Reset Insts.';		actionSelector: #reset).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	repeatSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Repeat';		actionSelector: #repeat:;		target: scorePlayer;		setSwitchState: scorePlayer repeat.	r addMorphBack: repeatSwitch.	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:11'!makeRow	^ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:11'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:10'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 0.4;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 1/31/98 20:12'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 151@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/5/98 17:56'!reset	self updateInstrumentsFromLibrary.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/5/98 17:55'!rewind	scorePlayer reset.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 1/30/98 15:23'!setLogRate: logOfRate	scorePlayer rate: (3.5 raisedTo: logOfRate).! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 1/30/98 14:52'!trackControlsFor: trackIndex	| r |	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	r addMorphBack: (self trackNumAndMuteButtonFor: trackIndex).	r addMorphBack: (Morph new extent: 10@5; color: color).  "spacer"	r addMorphBack: (self panAndVolControlsFor: trackIndex).	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:10'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 60@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 3/5/98 17:47'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| myInstruments name |	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name)].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScorePlayerMorph class	instanceVariableNames: ''!!ScorePlayerMorph class methodsFor: 'all' stamp: 'jm 3/3/98 11:48'!onMIDIFileNamed: fileName	"Return a ScorePlayerMorph on the score from the MIDI file of the given name."	| score player |	score _ MIDIFileReader scoreFromFileNamed: fileName	.	player _ ScorePlayer onScore: score.	^ self new onScorePlayer: player title: fileName! !!ScorePlayerMorph class methodsFor: 'all' stamp: 'di 5/15/1998 09:49'!openOn: aScore title: aString	| player |	player _ ScorePlayer onScore: aScore.	player play.  "start playing immediately"	(self new onScorePlayer: player title: aString) openInWorld! !MouseMenuController subclass: #ScreenController	instanceVariableNames: ''	classVariableNames: 'ChangesMenu HelpMenu OpenMenu ProjectScreenMenu TopScreenMenu WindowMenu '	poolDictionaries: ''	category: 'Interface-Support'!!ScreenController commentStamp: 'di 5/22/1998 16:37' prior: 0!ScreenController comment:'I am the controller for the parts of the display screen that have no view on them. I only provide a standard yellow button menu. I view (a FormView of) an infinite gray form.'!!ScreenController methodsFor: 'control defaults'!isControlActive	^super isControlActive and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'control defaults'!isControlWanted	^super isControlWanted and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'menu messages' stamp: 'di 5/6/1998 17:03'!aboutThisSystem 	"Identify software version"	| aString eToySystem aNumber |	aString _ Smalltalk version.	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'EToy System: ', eToySystem version, ' of ', eToySystem versionDate].	aNumber _ ChangeSorter highestNumberedChangeSet.	aNumber > 0 ifTrue:		[aString _ aString, 'Highest-numbered Change Set: ', aNumber printString].	^ self inform: aString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/7/1998 20:58'!absorbUpdatesFromServer 	Utilities absorbUpdatesFromServer! !!ScreenController methodsFor: 'menu messages'!blueButtonActivity	self yellowButtonActivity! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 1/18/96'!browseChangedMessages	"Browse all methods in the current change set.  , "	ChangedMessageSet openFor: Smalltalk changes! !!ScreenController methodsFor: 'menu messages'!browseRecentLog	"Open a changelist browser on changes submitted since the last snapshot.  1/17/96 sw"	ChangeList browseRecentLog! !!ScreenController methodsFor: 'menu messages'!browseRecentSubmissions	"Open a method-list browser on recently-submitted methods.  5/16/96 sw"	Utilities browseRecentSubmissions! !!ScreenController methodsFor: 'menu messages'!changeWindowPolicy	Preferences setPreference: #reverseWindowStagger		toValue: (Preferences valueOfFlag: #reverseWindowStagger) not! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:12'!chooseDirtyBrowser	"Put up a list of browsers with unsubmitted edits and activate the one selected by the user, if any."	"ScheduledControllers screenController chooseDirtyBrowser"	ScheduledControllers findWindowSatisfying:		[:c | (c model isKindOf: Browser) and: [c model canDiscardEdits not]]. ! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!chooseDirtyWindow	"Put up a list of windows with unaccepted edits and let the user chose one to activate."	"ScheduledControllers screenController chooseDirtyWindow"	ScheduledControllers findWindowSatisfying:		[:c | c model canDiscardEdits not].! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:13'!closeUnchangedWindows	"Close any window that doesn't have unaccepted input."	| clean |	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	clean _ ScheduledControllers scheduledControllers select:		[:c | c model canDiscardEdits and: [(c isKindOf: ScreenController) not]].	clean do: [:c | c closeAndUnscheduleNoTerminate].	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages'!collapseAll	"Collapses all open windows"	ScheduledControllers scheduledControllers do:		[:controller | controller == self ifFalse:			[controller view isCollapsed ifFalse:					[controller collapse.					controller view deEmphasize]]]! !!ScreenController methodsFor: 'menu messages'!commonRequests 	"Put up a popup of common requests, and perform whatever the user request.  2/1/96 sw"	Utilities offerCommonRequests! !!ScreenController methodsFor: 'menu messages'!editPreferences	"Open up a Preferences inspector.  2/7/96 sw"	Preferences openPreferencesInspector! !!ScreenController methodsFor: 'menu messages'!emergencyCollapse	"Emergency collapse of a selected window"	| controller |	(controller _ ScheduledControllers windowFromUser) notNil		ifTrue:			[controller collapse.			controller view deEmphasize]! !!ScreenController methodsFor: 'menu messages'!exitProject 	"Leave the current Project and enter the Project in which the receiver's 	view is scheduled."	Project current exit! !!ScreenController methodsFor: 'menu messages'!expandAll	"Reopens all collapsed windows"	ScheduledControllers scheduledControllers reverseDo:		[:controller | controller == self ifFalse:			[controller view isCollapsed				ifTrue:  [controller view expand]				ifFalse: [controller view displayDeEmphasized]]]! !!ScreenController methodsFor: 'menu messages'!fastWindows	StandardSystemView cachingBits		ifTrue: [StandardSystemView dontCacheBits]		ifFalse: [StandardSystemView doCacheBits]! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 3/18/98 17:21'!fileOutChanges	"File out changes to a file whose name is a function of the current date and time."	Smalltalk changes fileOut.	Transcript show: 'Changes filed out ', Date dateAndTimeNow printString; cr.! !!ScreenController methodsFor: 'menu messages'!findWindow	"Put up a menu of all windows on the screen, and let the user select one.	 1/18/96 sw: the real work devolved to ControlManager>>findWindowSatisfying:"	ScheduledControllers findWindowSatisfying: [:c | true]! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 3/12/98 11:31'!fullScreenOff	Smalltalk fullScreenMode: false.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 3/12/98 11:31'!fullScreenOn	Smalltalk fullScreenMode: true.	self restoreDisplay.! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 4/19/1998 20:09'!garbageCollect	"Do a garbage collection, and report results to the user."	self inform:		(Smalltalk bytesLeft asStringWithCommas, ' bytes available').! !!ScreenController methodsFor: 'menu messages'!hyperSqueakMenu 	"Put up a popup of HyperSqueak-related menu items.  7/24/96 sw"	(Smalltalk at: #SqueakSupport ifAbsent: [^ self beep]) offerHyperSqueakMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/20/1998 23:28'!jumpToProject	Project jumpToProject.! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 4/6/98 23:14'!openBrowser 	"Create and schedule a Browser view for browsing code."	Browser openBrowser! !!ScreenController methodsFor: 'menu messages'!openChangeManager	"Open a dual change sorter.  For looking at two change sets at once."	DualChangeSorter new open! !!ScreenController methodsFor: 'menu messages'!openCommandKeyHelp	"1/18/96 sw Open a window that explains command-keys"	Utilities openCommandKeyHelp! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/14/97 00:30'!openEToy	(Smalltalk includesKey: #EToySystem) ifFalse:		[^ self inform: 'Sorry, this system does not support EToys'].	(Smalltalk at: #EToySystem) newEToy! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/2/97 15:44'!openEToyPanel	| toySystem |	toySystem _ Smalltalk at: #EToySystem ifAbsent: [^ self inform: 'Sorry, this system does not support EToys'].	toySystem openEToyControls! !!ScreenController methodsFor: 'menu messages'!openFileList	"Create and schedule a FileList view for specifying files to access."	FileList open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/2/97 15:34'!openImagineeringStudio	(Smalltalk includesKey: #EToySystem) ifFalse:		[^ self inform: 'Sorry, this system does not support EToys'].	(Smalltalk at: #EToySystem) openImagineeringStudio! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/4/1998 22:03'!openMorphicConstructionWorld 	WorldMorph openWithStandardPartsBinShowing! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/8/1998 20:18'!openMorphicProject	ProjectView open: Project newMorphic.! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 7/4/97 08:06'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	WorldMorph new open.! !!ScreenController methodsFor: 'menu messages'!openProject 	"Create and schedule a Project."	ProjectView open: Project new! !!ScreenController methodsFor: 'menu messages'!openStandardWorkspace	"Open a standard, throwaway window chock full of useful expressions.  1/17/96 sw"	Utilities openStandardWorkspace! !!ScreenController methodsFor: 'menu messages' stamp: 'di 5/8/1998 12:49'!openTranscript 	"Create and schedule the System Transcript."	Transcript open! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 5/4/1998 17:25'!openWorkspace 	"Create and schedule workspace."	Workspace open! !!ScreenController methodsFor: 'menu messages'!quit	Smalltalk		snapshot:			(self confirm: 'Save changes before quitting?'				orCancel: [^ self])		andQuit: true! !!ScreenController methodsFor: 'menu messages'!redButtonActivity	self yellowButtonActivity! !!ScreenController methodsFor: 'menu messages'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Display extent = DisplayScreen actualScreenSize ifFalse:		[DisplayScreen startUp.		ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/22/1998 06:45'!returnToPreviousProject	Project returnToPreviousProject.! !!ScreenController methodsFor: 'menu messages'!saveAs	^ Smalltalk saveAs! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 5/10/96'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	Utilities setAuthorInitials! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 11/26/96'!setDesktopColor	"Let the user choose a new color for the desktop.   Based on an idea by Georg Gollmann.   "	Preferences desktopColor: Color fromUser.	ScheduledControllers updateGray; restore! !!ScreenController methodsFor: 'menu messages' stamp: 'di 2/28/98 11:56'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result _ (SelectionMenu selections: #('1' '2' '4' '8' '16' '32')) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result asNumber]! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 3/18/98 19:31'!shiftedYellowButtonMessages	"Answer an array of message selectors corresponding to the shifted-yellow-button menu for the Screen.  1/18/96 sw	 1/24/96 sw: added unshiftedYellowButtonActivity	 2/1/96 sw: common requests"	^ #(editPreferences  collapseAll expandAll chooseDirtyWindow closeUnchangedWindows		openProject exitProject openCommandKeyHelp garbageCollect commonRequests unshiftedYellowButtonActivity)! !!ScreenController methodsFor: 'menu messages'!snapshot	Smalltalk snapshot: true andQuit: false! !!ScreenController methodsFor: 'menu messages'!snapshotAndQuit	"Snapshot and quit without bother the user further.  2/4/96 sw"	Smalltalk		snapshot: true		andQuit: true! !!ScreenController methodsFor: 'menu messages'!viewGIFImports	"Open an inspector on forms imported from GIF files.  7/24/96 sw"	Smalltalk viewGIFImports! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 5/4/1998 17:33'!vmStatistics	"Open a string view on a report of vm statistics"	(StringHolder new contents: Utilities vmStatisticsReportString)		openLabel: 'VM Statistics'! !!ScreenController methodsFor: 'cursor'!centerCursorInView	"Override so this doesn't happen when taking control"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 1/29/98 13:07'!changesMenu	"Answer a menu for changes-related items"	ChangesMenu == nil ifTrue: 		[ChangesMenu _ SelectionMenu labelList:		#(	'file out changes'			'open changes sorter'			'browse changed methods'			'browse recent submissions'			'recent change log')		lines: #(1 4)		selections: #(fileOutChanges openChangeManager browseChangedMessages browseRecentSubmissions browseRecentLog)].	^ ChangesMenu"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 5/7/1998 20:58'!helpMenu	"Answer the help menu to be put up as a screen submenu"	HelpMenu == nil ifTrue:		[HelpMenu _ SelectionMenu labelList:		#(	'preferences...'			'update code from server'			'about this system...'			'command-key help'			'useful expressions'			'set author initials...'			'set desktop color...'			'set display depth...'			'full screen on'			'full screen off'			'view GIF imports'			'space left'			'vm statistics'				)		lines: #(2 5 8 10)		selections: #(editPreferences  absorbUpdatesFromServer aboutThisSystem openCommandKeyHelp openStandardWorkspace setAuthorInitials setDesktopColor setDisplayDepth fullScreenOn fullScreenOff viewGIFImports garbageCollect vmStatistics)].	^ HelpMenu"ScreenController new helpMenu startUpScreenController initialize"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 5/21/1998 12:10'!openMenu	"ScreenController initialize"	OpenMenu == nil ifTrue:		[OpenMenu _ SelectionMenu labelList:		#(	'open browser'			'open workspace'			'open file list'			'open change sorter'			'open project (mvc)'			'open project (morphic)'			'open transcript'			'open Morphic world'			'open Morphic construction')		lines: #(7)		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject  openMorphicProject openTranscript  openMorphicWorld openMorphicConstructionWorld)].	^ OpenMenu"ScreenController new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/21/1998 15:29'!projectScreenMenu	"Answer the project screen menu."	ProjectScreenMenu == nil ifTrue:		[ProjectScreenMenu _ SelectionMenu labelList:		#(	'previous project'			'  jump to project...'			'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(2 3 8)		selections: #(returnToPreviousProject jumpToProject restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ ProjectScreenMenu"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/24/96'!topScreenMenu	"Answer the screen menu for the top project, from whence there is no relevance to the 'exit project' item.  "	TopScreenMenu == nil ifTrue:		[TopScreenMenu _ SelectionMenu labelList:		#(	'restore display'			'open...'			'changes...'			'window...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit...')		lines: #(1 6)		selections: #( restoreDisplay openMenu changesMenu windowMenu helpMenu commonRequests  snapshot saveAs snapshotAndQuit quit)].	^ TopScreenMenu"ScreenController new newScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/21/1998 16:07'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows') ,			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(3 5 6)		selections: #(findWindow chooseDirtyBrowser chooseDirtyWindow				collapseAll expandAll				closeUnchangedWindows				fastWindows changeWindowPolicy)"ScreenController new windowMenu startUpScreenController initialize"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 5/8/96'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[reply _ (self perform: reply) startUp.			reply == nil ifTrue: [^ super controlActivity]].	^ self perform: reply! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScreenController class	instanceVariableNames: ''!!ScreenController class methodsFor: 'class initialization' stamp: 'di 6/24/97 00:16'!initialize	"Initialize the screen menus.  Call this method to reset everything back to nil, so that the various menu retrieval methods will duly reinitialize them."	"ScreenController initialize"	ChangesMenu _ HelpMenu _ TopScreenMenu _ OpenMenu _ WindowMenu _ ProjectScreenMenu _ nil.! !!ScreenController class methodsFor: 'class initialization'!revertToStandardMenus	"Restore the standard version of the screen menu, after it has been changed by some nonconformist.  7/24/96 sw"	ProjectScreenMenu _ TopScreenMenu _ nil	"ScreenController revertToStandardMenus"! !!ScreenController class methodsFor: 'nested menus' stamp: 'di 5/21/1998 12:11'!initializeOpenMenuForInternalUse	"Resets the standard open menu to add internal items"	"ScreenController initializeOpenMenuForInternalUse"	OpenMenu _ SelectionMenu labelList:		#(	'open browser'			'open workspace'			'open file list'			'open change sorter'			'open project (mvc)'			'open project (morphic)'			'open transcript'			'open Morphic world'			'open Morphic construction'			'open etoy controls'			'open blank etoy'			'open Imagineering Studio')		lines: #(7 9)		selections: #(openBrowser openWorkspace openFileList openChangeManager openProject openMorphicProject openTranscript openMorphicWorld openMorphicConstructionWorld openEToyPanel openEToy openImagineeringStudio)! !Morph subclass: #ScreeningMorph	instanceVariableNames: 'screenForm displayMode '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!ScreeningMorph commentStamp: 'di 5/22/1998 16:37' prior: 0!ScreeningMorph comment:'ScreeningMorph uses its first submorph as a screen, and its second submorph as a source.  It also wants you to choose (when showing only the screen) the passing color in the screen.  It then makes up a 1-bit mask which clips the source, and displays transparently outside it.'!!ScreeningMorph methodsFor: 'initialization'!initialize	super initialize.	displayMode _ #showScreened! !!ScreeningMorph methodsFor: 'menu' stamp: 'di 11/4/97 09:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	submorphs size = 0 ifTrue:		[^ aCustomMenu add: '*Please add a source morph*' action: #itself].	submorphs size = 1 ifTrue:		[^ aCustomMenu add: '*Please add a screen morph*' action: #itself].	submorphs size > 2 ifTrue:		[^ aCustomMenu add: '*I have too many submorphs*' action: #itself].	aCustomMenu add: 'show screen only' action: #showScreenOnly.	aCustomMenu add: 'show source only' action: #showSourceOnly.	aCustomMenu add: 'show screen over source' action: #showScreenOverSource.	aCustomMenu add: 'show source screened' action: #showScreened.	aCustomMenu add: 'exchange source and screen' action: #exchange.	displayMode == #showScreenOnly ifTrue:		[aCustomMenu add: 'choose passing color' action: #choosePassingColor.		aCustomMenu add: 'choose blocking color' action: #chooseBlockingColor].! !!ScreeningMorph methodsFor: 'menu'!chooseBlockingColor	self mapColor: Color fromUser to: 0 othersTo: 16rFFFFFFFF! !!ScreeningMorph methodsFor: 'menu'!choosePassingColor	self mapColor: Color fromUser to: 16rFFFFFFFF othersTo: 0! !!ScreeningMorph methodsFor: 'menu'!exchange	submorphs swap: 1 with: 2.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreened	displayMode _ #showScreened.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreenOnly	displayMode _ #showScreenOnly.	self changed! !!ScreeningMorph methodsFor: 'menu'!showScreenOverSource	displayMode _ #showScreenOverSource.	self changed! !!ScreeningMorph methodsFor: 'menu'!showSourceOnly	displayMode _ #showSourceOnly.	self changed! !!ScreeningMorph methodsFor: 'drawing' stamp: 'di 7/17/97 10:09'!fullDrawOn: aCanvas	| mergeForm |	submorphs size = 2 ifFalse: [^ super fullDrawOn: aCanvas].	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	"self drawOn: aCanvas."	displayMode == #showScreenOnly ifTrue:		[self screenMorph fullDrawOn: aCanvas].	displayMode == #showSourceOnly ifTrue:		[self sourceMorph fullDrawOn: aCanvas].	screenForm ifNil:		[self mapColor: Color black to: 16rFFFFFFFF othersTo: 0].	displayMode == #showScreenOverSource ifTrue:		[self sourceMorph fullDrawOn: aCanvas.		aCanvas image: screenForm at: self position].	displayMode == #showScreened ifTrue:		[mergeForm _ self sourceMorph imageFormForRectangle: self bounds.		(BitBlt toForm: mergeForm) copyForm: screenForm to: 0@0 rule: Form and			colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		aCanvas image: mergeForm at: self position]! !!ScreeningMorph methodsFor: 'geometry'!containsPoint: aPoint	submorphs size = 2 ifFalse: [^ super containsPoint: aPoint].	^ self screenMorph containsPoint: aPoint! !!ScreeningMorph methodsFor: 'private'!mapColor: aColor to: pickValue othersTo: elseValue	| screenImage colorMap |	screenImage _ self screenMorph imageForm.	colorMap _ screenImage newColorMap atAllPut: elseValue.	colorMap at: (aColor indexInMap: colorMap) put: pickValue.	screenForm _ Form extent: screenImage extent.	screenForm copyBits: screenForm boundingBox			from: screenImage at: 0@0 colorMap: colorMap.	self changed.	self privateBounds: (screenImage offset extent: screenForm extent).	self changed! !!ScreeningMorph methodsFor: 'private'!screenMorph	^ submorphs at: 1! !!ScreeningMorph methodsFor: 'private'!sourceMorph	^ submorphs at: 2! !ServerAction subclass: #ScreenshotAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!ScreenshotAction methodsFor: 'URL processing' stamp: 'tk 2/4/98 12:31'!process: request	FileDirectory default deleteFileNamed: 'screenshot.GIF'.	GIFReadWriter putForm: Display onFileNamed: 'screenshot.GIF'.	request reply: (PWS success), (PWS content: 'image/gif'), PWS crlf.	request reply: (FileStream fileNamed: 'screenshot.GIF') contentsOfEntireFile.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScreenshotAction class	instanceVariableNames: ''!!ScreenshotAction class methodsFor: 'setupForPWS' stamp: 'mjg 12/31/97 08:19'!setUp	PWS link: 'screenshot' to: ScreenshotAction new.! !AlignmentMorph subclass: #ScriptEditorMorph	instanceVariableNames: 'scriptName firstTileRow timeStamp playerScripted '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 5/13/1998 11:57'!bringUpToDate	"Make certain that the script name and the names of actors within are up to date"	| currentName titleMorph newName |	currentName _ playerScripted externalName.	titleMorph _ self findDeepSubmorphThat: [:m | m externalName = 'title'] ifAbsent: [nil].	titleMorph ifNotNil:		[newName _ self isAnonymous			ifTrue:				['script']			ifFalse:				[self scriptName].		titleMorph label: currentName, ' ', newName font: ScriptingSystem fontForTiles]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'tk 12/3/97 20:01'!donorActor: donorActor ownActor: ownActor	"The receiver has been cloned as part of cloning an actor; all references within the receiver to the donor actor need to become references to own actor"	(self allMorphs "copyWithout: self") do:		[:m | (m isKindOf: TileMorph) ifTrue:			[m donorActor: donorActor ownActor: ownActor]]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 5/2/1998 15:03'!initialize	super initialize.	color _ ScriptingSystem colorBehindTiles.	orientation _ #vertical.	hResizing _ #spaceFill.	vResizing _ #shrinkWrap.	self setDefaultBorderCharacteristics.	firstTileRow _ 1.  "index of first tile-carrying submorph"	self addNewRow! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/4/98 00:45'!playerScripted: aPlayer	playerScripted _ aPlayer ! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'di 5/6/1998 21:09'!scriptName: aScriptName phrase: aPhraseTileMorph	"Make the receiver be an anonymous editor around aPhraseTileMorph"	scriptName _ aScriptName.	self addMorphFront: self buttonRowForEditor.	self updateStatus.	firstTileRow _ 2.	self addMorphBack: (AlignmentMorph newRow addMorphBack: aPhraseTileMorph).	self install! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/14/98 14:35'!setDefaultBorderCharacteristics		borderWidth _ 1.	borderColor _ Color black.	inset _ 2.! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 1/29/98 18:24'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted _ anActorMorph costumee! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/13/98 16:35'!setMorph: anActorMorph scriptName: aString	"Create a script editor for editing a named script."	self setMorph: anActorMorph.	scriptName _ aString.	self addMorphFront: self buttonRowForEditor.	self updateStatus.	firstTileRow _ 2! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 5/6/1998 16:36'!startOutEmptyForScriptName: aScriptName	"Make the receiver be an anonymous editor around initially empty content"	scriptName _ aScriptName.	self addMorphFront: self buttonRowForEditor.	self updateStatus.	firstTileRow _ 2.	self install! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 2/16/98 02:03'!morph	^ self playerScripted costume! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 1/29/98 18:25'!myMorph	^ self playerScripted costume! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 4/30/1998 14:34'!scriptInstantiation	^ playerScripted scriptInstantiationForSelector: scriptName! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 2/25/98 00:32'!titleMorph	^ self firstSubmorph submorphs third! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'jm 5/16/1998 10:38'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph player))			after: i.		i _ i + 1].	self removeSpaces.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/30/97 14:15'!handlesMouseOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/20/97 08:22'!indexOfMorphAbove: aPoint	"Return index of lowest morph whose bottom is above aPoint.	Will return 0 if the first morph is not above aPoint"	submorphs doWithIndex:		[:m :i | m fullBounds bottom >= aPoint y ifTrue:					[^ (i max: firstTileRow) - 1]].	^ submorphs size! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/19/97 14:46'!mouseEnter: evt	| hand tile |	hand _ evt hand.	(hand submorphs size = 1 and: [hand lastEvent redButtonPressed]) ifTrue:		[tile _ hand firstSubmorph.		(self wantsDroppedMorph: tile) ifTrue:			[(tile isKindOf: PhraseTileMorph) ifTrue: [tile brightenTiles].			self startStepping]].! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/19/97 13:50'!mouseLeave: evt	| hand tile |	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	self stopStepping.	self removeSpaces.	hand _ evt hand.	(hand submorphs size = 1) & (hand lastEvent redButtonPressed) ifTrue:		[tile _ hand firstSubmorph.		(tile isKindOf: PhraseTileMorph) ifTrue: [tile unbrightenTiles]].! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/24/98 17:28'!prepareToUndoDropOf: aMorph	"No longer functional"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/14/97 12:28'!removeSpaces	self submorphsDo:		[:m | (m isMemberOf: Morph) ifTrue: [m delete]].	self removeEmptyRows! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ aMorph isTileLike not! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/18/97 18:20'!rootForGrabOf: aMorph	"Allow TileMorphs to be extracted, and note that script has changed."	| root |	root _ aMorph.	[root = self] whileFalse:		[root isTileLike ifTrue:			[self scriptEdited.			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'jm 11/4/97 15:44'!step	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii |	hand _ self primaryHand.	(hand lastEvent redButtonPressed)		ifTrue:		[hand submorphCount > 0 ifTrue:			[insertion _ hand firstSubmorph.			insHt _ insertion height.			self removeSpaces.			i _ (ii _ self indexOfMorphAbove: insertion fullBounds topLeft)					min: submorphs size-1.			prevBot _ i <= 0 ifTrue: [(self innerBounds) top]					ifFalse: [(self submorphs at: i) bottom].			nxtHt _ (submorphs isEmpty					ifTrue: [insertion]					ifFalse: [self submorphs at: i+1]) height.			d _ ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (insertion top - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 _ Color green.  c2 _ Color transparent.			ht2 _ d*insHt//nxtHt.			space1 _ Morph newBounds: (0@0 extent: 30@(insHt-ht2))					color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 _ Morph newBounds: (0@0 extent: 30@ht2)					color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]]		ifFalse:		[self stopStepping.		self removeSpaces.		self allMorphsDo: [:m |			(m isKindOf: TileMorph) ifTrue: [				m color: (TilePadMorph unbrightColorFor: m color)]]]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'tk 9/30/97 14:09'!stepTime	^ 0! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/19/1998 14:17'!wantsDroppedMorph: aMorph	^ (aMorph isTileLike and: [aMorph resultType == #command]) and:		[self isTextuallyCoded not]! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/17/97 16:28'!wantsDroppedMorph: aMorph event: evt	^ self wantsDroppedMorph: aMorph! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:11'!actuallyDestroyScript	| aHandler |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName.		"not quite enough yet in the multiple-instance case..."	(aHandler _ playerScripted costume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	playerScripted updateAllViewers! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:39'!addDismissButtonTo: aRowMorph	aRowMorph addMorphBack:		((SimpleButtonMorph new label: 'X' font: ScriptingSystem fontForScriptorButtons)			target: self;			color:  Color lightRed;			actionSelector: #dismiss;			balloonTextSelector: #dismiss).	^ aRowMorph! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/14/97 13:00'!addYesNoToHand	self primaryHand attachMorph: CompoundTileMorph new! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 17:42'!buttonRowForEditor	| r aString aButtonMorph buttonFont aStatusMorph aStatus |	buttonFont _ ScriptingSystem fontForScriptorButtons.	r _ AlignmentMorph newRow color: Color transparent; inset: 0.	r addMorphFront:		(SimpleButtonMorph new			label: '!!' font: (StrikeFont familyName: #ComicBold size: 16);			target: self;			color: Color yellow;			actWhen: #whilePressed;			actionSelector: #tryMe;			balloonTextSelector: #tryMe).	r addTransparentSpacerOfSize: 6@10.	aString _ playerScripted externalName, ' ', self scriptTitle.	r addMorphBack:		(aButtonMorph _ SimpleButtonMorph new label: aString font: buttonFont; target: self; setNameTo: 'title').	aButtonMorph actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButtonMorph borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButtonMorph color: (self isAnonymous ifTrue: [Color blue muchLighter] ifFalse: [ScriptingSystem uniformTileInteriorColor]).	aButtonMorph balloonTextSelector: #offerScriptorMenu.	r addTransparentSpacerOfSize: 6@10.	aStatus _ self scriptInstantiation status.	r addMorphBack:			(aStatusMorph _ SimpleButtonMorph new label: aStatus font: buttonFont;				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger;				balloonTextSelector: #chooseTrigger).	r addTransparentSpacerOfSize: 10@10.	r addMorphBack:		((SimpleButtonMorph new label: '�' font: buttonFont)			target: self;			color: Color veryLightGray;			actWhen: #buttonDown;			actionSelector: #addYesNoToHand;			balloonTextSelector: #addYesNoToHand).	r addTransparentSpacerOfSize: 12@10.	self addDismissButtonTo: r.	self updateStatusMorph: aStatusMorph.	^ r! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/18/1998 16:16'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters me with button up'		'mouseLeave -- when mouse exits me with button up'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 "8")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume startStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/20/1998 01:33'!destroyScript	| aMenu reply |	(playerScripted okayToDestroyScriptNamed: scriptName)		ifFalse:			[^ self inform: 'Sorry, this script is being calledfrom another script.'].	(self isAnonymous not and: [submorphs size > 1]) ifTrue:		[aMenu _ SelectionMenu selections: #('destroy it' 'oops, no, don''t destroy').		reply _ aMenu startUpWithCaption: 'Do you really want todestroy this script?'.		(reply = 'destroy it') ifFalse: [^ self]].	self actuallyDestroyScript! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 14:05'!dismiss	| aMenu reply |	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	(self isAnonymous and:			[(submorphs size > 3) or: [self scriptInstantiation status ~~ #normal]]) ifTrue:		[aMenu _ SelectionMenu selections: #('yes, name it' 'no, discard it' 'cancel').		reply _ aMenu startUpWithCaption: 'Do you want to give thisscript a name and save it? '.		(reply size == 0 or: [reply = 'cancel']) ifTrue: [^ self].		(reply = 'yes, name it') ifTrue: [^ self renameScript].		self actuallyDestroyScript].	self delete! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 14:16'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	^ Browser openBrowserView: (newBrowser openMessageEditString: nil)		label: ('textual script for "', scriptName, '" in ', playerScripted externalName)! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/2/1998 13:49'!goScript	self scriptInstantiation status: #ticking.	self install.	self playerScripted costume startStepping.	self color: self colorWhenRunning.	playerScripted startRunningScripts! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/12/98 13:24'!install	"Keep me for editing"	self removeSpaces.	scriptName ifNotNil:		[playerScripted acceptScript: self topEditor for:  scriptName asSymbol]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/12/98 13:25'!installWithNewLiteral	self removeSpaces.	scriptName ifNotNil:		[playerScripted ifNotNil: [playerScripted acceptScript: self topEditor for:  scriptName]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 18:30'!playerScripted	^ playerScripted! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 18:37'!scriptee	| editor |	playerScripted ifNotNil: [^ playerScripted].	(editor _ self topEditor) == self ifTrue: [self error: 'unattached script editor'. ^ nil].	^ editor scriptee! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 03:26'!scriptName	^ scriptName! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/13/1998 11:58'!scriptTitle	^ self isAnonymous ifFalse: [scriptName] ifTrue: ['script']! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/19/1998 15:27'!tryMe	self playerScripted perform: scriptName! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 3/3/98 15:12'!updateStatus	(self topEditor == self) ifTrue:		[self updateStatusMorph: (submorphs first submorphNamed: 'trigger')]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/6/1998 15:18'!updateStatusMorph: statusMorph	"my status button may need to reflect an externally-induced change in status"	|  statusSymbol colorSelector |	statusMorph ifNil: [^ self].	statusSymbol _ self scriptInstantiation status.	colorSelector _ ScriptingSystem statusColorSymbolFor: statusSymbol.	statusMorph recolor: (Color perform: colorSelector) muchLighter.	statusMorph label: statusSymbol asString font: ScriptingSystem fontForScriptorButtons! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/14/97 12:32'!appendTileRows: tileRows	"Append the given rows of tiles to my script."	tileRows do: [:r | self insertTileRow: r after: submorphs size].	self removeSpaces.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 15:24'!becomeTextuallyCoded	self isTextuallyCoded ifTrue: [^ self].	self saveScriptVersion.	self userScriptObject becomeTextuallyCoded.	(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete].	self color: Color darkGray! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/11/98 18:03'!browseScripts	 Browser newOnClass: playerScripted class label: 'Compiled scripts for ', playerScripted externalName! !!ScriptEditorMorph methodsFor: 'other'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s.	^ s contents! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/2/1998 15:03'!colorWhenRunning	^ ScriptingSystem colorBehindTiles! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/23/98 01:07'!hasScriptInvoking: aScriptName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which invoke the given script of the given player.  Place-holder for now, needs to be implemented"	^ false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/23/98 01:07'!hasScriptReferencing: aSlotName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which reference the given slot of the given player.  Place-holder for now, needs to be implemented"	^ false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/1/1998 20:50'!isAnonymous	^ self scriptInstantiation isAnonymous! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 13:57'!isTextuallyCoded	^ self userScriptObject isTextuallyCoded! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/21/1998 21:34'!isTileScriptingElement	^ true! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/98 13:37'!markEdited	"A hook called in several places in the UI when something has been dragged & dropped into or out of the script."	self install.	"self stopScript"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/29/98 18:14'!methodString	| s |	s _ WriteStream on: ''.	s nextPutAll: scriptName; cr; cr; tab.	s nextPutAll: self codeString.	^ s contents! !!ScriptEditorMorph methodsFor: 'other'!minHeight	| extra |	extra _ 2 * (inset + borderWidth).	^ (super minHeight - extra max: TileMorph defaultH) + extra! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 10/28/97 12:20'!minWidth	^ super minWidth max: 160! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/21/1998 15:05'!offerScriptorMenu	| aMenu result  aList lines title |	self isAnonymous		ifTrue:			[aList _ #(				('name and save this script'	renameScript)				('destroy this script'			destroyScript)).			title _ 'temporary script'.			lines _ #()]		ifFalse:			[title _ scriptName asString.			self isTextuallyCoded				ifTrue:					[title _ title, ' (textually coded)'.					aList _ #(						('revert to tile version...'		revertScriptVersion)						('modify textual script'			editScriptTextually)				"		('view all scripts'				browseScripts)"						('destroy this script'				destroyScript)).					lines _ #(2)]				ifFalse:					[aList _ #(						('save this version'				saveScriptVersion)						('revert to prior version...'		revertScriptVersion)						('edit this script textually'		editScriptTextually)					"	('view all scripts'				browseScripts)"						('destroy this script'				destroyScript)).					lines _ #(2 3)]].	aMenu _ SelectionMenu labelList: (aList collect: [:pair | pair first]) lines: lines selections: (aList collect: [:pair | pair second]).	result _ aMenu startUpWithCaption: title.	result ifNotNil: [self perform: result]"		('add parameter to this script'	addParameter)"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/2/1998 17:35'!renameScript	"Invoked at user menu request"	| reply aPosition oldSelector dflt oldStatus |	oldSelector _ self scriptName.	oldStatus _ self scriptInstantiation status.	dflt _ self isAnonymous ifTrue: [''] ifFalse: [self scriptTitle].	reply _   FillInTheBlank request: 'Script Name' initialAnswer: dflt. 	reply size == 0 ifTrue: [^ self].	reply first isUppercase ifTrue: [^ self inform: 'Illegal script name'].	((reply _ reply asSymbol) == scriptName) ifTrue: [^ self].	(Scanner isLiteralSymbol: reply) ifFalse: [^ self inform: 'Bad script name, please try again'].	self titleMorph borderColor: Color black.	scriptName _ reply.	playerScripted class atSelector: reply putScriptEditor: self.	self scriptInstantiation status: oldStatus.	playerScripted class removeScriptNamed: oldSelector.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: oldSelector.	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"	self install.	aPosition _ self position.	self delete	playerScripted costume viewAfreshShowingScript: scriptName at: aPosition! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/30/1998 13:46'!revertScriptVersion	| aUserScript |	aUserScript _ playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertScriptVersionFrom: self! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 14:12'!saveScriptVersion	self userScriptObject saveScriptVersion: self setTimeStamp! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 4/10/1998 06:48'!setTimeStamp	timeStamp _ Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 8).	^ timeStamp! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/13/97 22:48'!storeCodeOn: aStream	| lastOwner |	lastOwner _ nil.	self tileRows do: [:r |		r do: [:m |			((m isKindOf: TileMorph) or: [(m isKindOf: CompoundTileMorph) or: [m isKindOf: PhraseTileMorph]])				ifTrue:					[((m owner ~= lastOwner) and: [lastOwner ~= nil])						ifTrue:							[aStream nextPut: $.; cr; tab.							m storeCodeOn: aStream]						ifFalse:							[(lastOwner ~= nil) ifTrue: [aStream space].							m storeCodeOn: aStream].					lastOwner _ m owner]]]! !!ScriptEditorMorph methodsFor: 'other'!tileRows	"Return an collection of arrays of Tiles in which each array is one line of tiles."	| rows r |	rows _ OrderedCollection new.	firstTileRow to: submorphs size do: [:i |		r _ submorphs at: i.		r submorphCount > 0 ifTrue: [rows addLast: r submorphs]].	^ rows! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/29/98 18:02'!timeStamp	^ timeStamp! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/13/97 08:54'!topEditor	| editor |	editor _ self outermostMorphThat: [:m | (m isKindOf: ScriptEditorMorph) or:		 [m isKindOf: CompoundTileMorph]].	^ editor ifNil: [self] ifNotNil: [editor]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/19/1998 13:57'!userScriptObject	^ playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScriptEditorMorph methodsFor: 'private' stamp: 'di 5/6/1998 21:09'!addNewRow	| row |	row _ AlignmentMorph newRow		vResizing: #spaceFill;		inset: 0;		borderWidth: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	self addMorphBack: row.	^ row! !!ScriptEditorMorph methodsFor: 'private' stamp: 'di 10/17/97 21:31'!enclosingEditor	"Return the next scriptor outward in the containment hierarchy"	| current |	current _ owner.	[current == nil] whileFalse:		[((current isKindOf: ScriptEditorMorph)				or: [current isKindOf: CompoundTileMorph])			ifTrue: [^ current].		current _ current owner].	^ nil! !!ScriptEditorMorph methodsFor: 'private' stamp: 'di 5/6/1998 21:09'!insertTileRow: tileList after: index	"Return a row to be used to insert an entire row of tiles."	| row |	row _ AlignmentMorph newRow		vResizing: #spaceFill;		inset: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	row addAllMorphs: tileList.	self privateAddMorph: row atIndex: index + 1.! !!ScriptEditorMorph methodsFor: 'private'!labelForButton	self tileRows do: [:r |		r do: [:t |			t type = #operator ifTrue: [^ t operatorOrExpression]]].	^ 'button'! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 5/13/1998 16:22'!removeEmptyRows	submorphs copy do: [:m |		(m isAlignmentMorph and: [m submorphCount = 0])			ifTrue: [m delete]].	self fullBounds.	self layoutChanged.	self flag: #noteToJohn.  "Screws up when we have nested IFs.  got broken in 11/97 when you made some emergency fixes for some other reason, and has never worked since...  Would be nice to have a more robust reaction to this!!""	self removeEmptyLayoutMorphs.	spacer _ LayoutMorph new extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: self indexForLeadingSpacer.	spacer _ LayoutMorph new  extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: (submorphs size + 1).	self fullBounds; layoutChanged."! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 2/13/98 15:44'!rowInsertionIndexFor: aPoint	"Return the row into which the given morph should be inserted."	| m |	firstTileRow to: submorphs size do: [:i |		m _ submorphs at: i.		((m top <= aPoint y) and: [m bottom >= aPoint y]) ifTrue:			[(aPoint y > m center y)				ifTrue: [^ i]				ifFalse: [^ (i - 1) max: firstTileRow]]].	^ firstTileRow > submorphs size		ifTrue:			[submorphs size]		ifFalse:			[(submorphs at: firstTileRow) top > aPoint y 				ifTrue: [firstTileRow - 1]				ifFalse: [submorphs size]]! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 10/12/97 21:48'!scriptEdited	| anEditor |	(anEditor _ self topEditor) ifNotNil: [anEditor markEdited]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScriptEditorMorph class	instanceVariableNames: ''!!ScriptEditorMorph class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !ScriptEditorMorph subclass: #ScriptEvaluatorMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/5/98 00:02'!acceptDroppingMorph: aMorph event: evt	(aMorph isKindOf: PhraseTileMorph) ifTrue: [^ self].	^ super acceptDroppingMorph: aMorph event: evt! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 5/7/1998 09:10'!initializeFor: aPhraseTileMorph	| lm aStatus |	self playerScripted: aPhraseTileMorph actualObject.	scriptName _ aPhraseTileMorph userScriptSelector.	self removeAllMorphs.	self addMorphFront: (lm _ AlignmentMorph newRow).	lm color: Color transparent; inset: 0.	lm vResizing: #shrinkWrap.	lm addMorphBack: (ScriptingSystem tryButtonFor: aPhraseTileMorph).	lm addTransparentSpacerOfSize: 6@1.	lm addMorphBack: aPhraseTileMorph beSticky.	lm addTransparentSpacerOfSize: 4@1.		aStatus _ (playerScripted scriptInstantiationForSelector: scriptName) status.	lm addMorphBack:			(SimpleButtonMorph new label: aStatus font: (ScriptingSystem fontForScriptorButtons);				setNameTo: 'trigger';				target: self;				actWhen: #buttonDown;				actionSelector: #chooseTrigger).	lm addTransparentSpacerOfSize: 4@1.	self addDismissButtonTo: lm.	self openToDragNDrop: false.	lm openToDragNDrop: true! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 5/18/1998 16:08'!insertTileRow: tileList after: index	"Return a row to be used to insert an entire row of tiles."	self isThisEverCalled.   "an error if so.... evaluator can't add or delete rows"! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/16/98 04:31'!rootForGrabOf: aMorph	"Still struggling to find the incantation that will open up easy dragging of this thing!!"	true ifTrue: [^ super rootForGrabOf: aMorph]! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/16/98 04:31'!rowInsertionIndexFor: aPoint	^ nil! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/14/98 14:33'!setDefaultBorderCharacteristics		borderWidth _ 2.	borderColor _ Color blue.	inset _ 2.! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/4/98 01:04'!step	"Don't do what ScriptEditors do about playing footsie with PhraseTileMorphs"! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 2/16/98 04:32'!wantsDroppedMorph: aMorph	true ifTrue: [^ false].  "for now anyway"	^ aMorph isTileLike and: [aMorph resultType ~~ #command]! !Object subclass: #ScriptInstantiation	instanceVariableNames: 'player selector status frequency anonymous '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!ScriptInstantiation commentStamp: 'di 5/22/1998 16:37' prior: 0!One of these is associated with each user-defined script for each Player.   Holds the state that defines when the script should be run automatically by the system.	player				The player whose script this is.	selector				The message to send my player to activate this script	status				#ticking, #paused, #normal, #mouseDown, #mouseStillDown, #mouseUp,							#mouseEnter, #mouseLeave, #keyStroke	frequency			For ticking scripts, their frequency.  Place-holder: not implemented yet	anonymous			If true, the script has is unnamed -- in this case, the selector is private to the implementation!!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 4/30/1998 14:48'!anonymous: b	anonymous _ b! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 4/30/1998 14:06'!initializeAnonymousScriptFor: aPlayer	anonymous _ true.	player _ aPlayer.	status _ #normal.	selector _ aPlayer unusedScriptName! !!ScriptInstantiation methodsFor: 'anonymity' stamp: 'sw 4/30/1998 14:08'!isAnonymous	^ anonymous == true! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 4/30/1998 14:06'!player	^ player! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/13/1998 10:43'!player: p	"Needed for making duplicate players, otherwise private"	player _ p! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/1/1998 21:33'!player: p selector: s	self player: p selector: s status: #normal! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 5/1/1998 21:33'!player: p selector: s status: st	frequency _ 0.	status _ st.	player _ p.	selector _ s! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 4/30/1998 14:07'!selector	^ selector! !!ScriptInstantiation methodsFor: 'player & selector access' stamp: 'sw 4/30/1998 14:07'!selector: sel	selector _ sel! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 4/30/1998 13:57'!runIfTicking	status == #ticking ifTrue:		[player perform: selector]! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 4/30/1998 14:11'!startRunningIfPaused	status == #paused ifTrue:		[status _ #ticking]! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 4/30/1998 14:10'!status	status ifNil: [status _ #normal].	^ status! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 5/7/1998 22:06'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 4/30/1998 14:09'!stopTicking	"If I'm ticking stop, else do nothing"	status == #ticking ifTrue: [status _ #paused]! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 5/13/1998 13:06'!assureEventHandlerRepresentsStatus	self status: self status! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 5/2/1998 02:05'!copyWithPlayerObliterated	| holdPlayer copy |	holdPlayer _ player.	player _ nil.	copy _ self deepCopy.	player _ holdPlayer.	^ copy ! !!ScriptInstantiation methodsFor: 'misc' stamp: 'sw 4/30/1998 13:47'!userScriptObject	"Answer the UserScript object in the receiver's class that holds on to the editing state for this script"	^ player class userScriptForPlayer: player selector: selector! !Slider subclass: #ScrollBar	instanceVariableNames: 'menuButton upButton downButton pagingArea scrollDelta pageDelta interval menuSelector '	classVariableNames: 'UpArrow '	poolDictionaries: ''	category: 'Morphic-Windows'!!ScrollBar commentStamp: 'di 5/22/1998 16:37' prior: 0!ScrollBar comment:'Inspired by an oiginal design of Hans-Martin Mosner, this ScrollBar is intended to exercise the handling of input events in Morphic.  With sufficient flexibility in this area, all particular behavior can be concentrated in this single class with no need to specialize any other morphs to achieve button, slider and menu-button behavior.Once we have this working, put in logic for horizontal operation as well.'!!ScrollBar methodsFor: 'initialize'!initialize	super initialize.	scrollDelta _ 0.02.	pageDelta _ 0.2! !!ScrollBar methodsFor: 'initialize'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #borderInset to: downButton.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize'!initializeMenuButton	menuButton := RectangleMorph			newBounds: (self innerBounds topLeft extent: self buttonExtent)			color: Color lightGray.	menuButton on: #mouseEnter send: #menuButtonMouseEnter: to: self.	menuButton on: #mouseDown send: #menuButtonMouseDown: to: self.	menuButton on: #mouseLeave send: #menuButtonMouseLeave: to: self.	menuButton addMorphCentered:		(RectangleMorph newBounds: (0@0 extent: 4@2) color: Color black).	menuButton setBorderWidth: 2 borderColor: #raised.	self addMorph: menuButton! !!ScrollBar methodsFor: 'initialize'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #nextPage: to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize'!initializeSlider	self initializeMenuButton; initializeUpButton; initializeDownButton; initializePagingArea.	super initializeSlider! !!ScrollBar methodsFor: 'initialize'!initializeUpButton	upButton := RectangleMorph		newBounds: ((bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #borderInset to: upButton.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'access'!interval: d	"Supply an optional floating fraction so slider can expand to indicate range"	interval _ d.	self computeSlider! !!ScrollBar methodsFor: 'access'!scrollDelta	^ scrollDelta! !!ScrollBar methodsFor: 'access'!scrollDelta: d1 pageDelta: d2	"Supply optional increments for better scrolling of, eg, text"	scrollDelta _ d1.	pageDelta _ d2.! !!ScrollBar methodsFor: 'geometry'!buttonExtent	^ bounds isWide		ifTrue: [9 @ self innerBounds height]		ifFalse: [self innerBounds width @ 9]! !!ScrollBar methodsFor: 'geometry'!computeSlider	super computeSlider.	interval ifNotNil: [self expandSlider]! !!ScrollBar methodsFor: 'geometry'!expandSlider	| r val2 |	val2 _ value + interval min: 1.0.	r _ self roomToMove.	slider extent: (bounds isWide		ifTrue: [((r width * (val2 - value)) asInteger + self sliderThickness) @ slider height]		ifFalse: [slider width @ ((r height * (val2 - value)) asInteger + self sliderThickness)])! !!ScrollBar methodsFor: 'geometry'!extent: p	p x > p y	ifTrue: [super extent: (p x max: 36) @ 16]	ifFalse: [super extent: 16 @ (p y max: 36)]! !!ScrollBar methodsFor: 'geometry'!totalSliderArea	^ bounds isWide		ifTrue: [upButton bounds topRight corner: downButton bounds bottomLeft]		ifFalse: [upButton bounds bottomLeft corner: downButton bounds topRight]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 6/12/97 12:26'!nextPage: event	event cursorPoint >= slider topLeft		ifTrue: [self setValue: value + pageDelta]		ifFalse: [self setValue: value - pageDelta]! !!ScrollBar methodsFor: 'scrolling'!scrollDown	self setValue: value + scrollDelta! !!ScrollBar methodsFor: 'scrolling'!scrollUp	self setValue: value - scrollDelta! !!ScrollBar methodsFor: 'scrolling'!setValue: newValue	^ super setValue: (newValue + 0.0001 truncateTo: scrollDelta)! !!ScrollBar methodsFor: 'other events'!menuButtonMouseDown: event	event hand showTemporaryCursor: nil.	self use: menuSelector orMakeModelSelectorFor: 'MenuButtonPressed:'		in: [:sel | menuSelector _ sel.  model perform: sel with: event]! !!ScrollBar methodsFor: 'other events'!menuButtonMouseEnter: event	event hand showTemporaryCursor: Cursor menu! !!ScrollBar methodsFor: 'other events'!menuButtonMouseLeave: event	event hand showTemporaryCursor: nil! !!ScrollBar methodsFor: 'other events'!mouseDownInSlider	slider color: Color veryLightGray! !!ScrollBar methodsFor: 'other events'!mouseUpInSlider	slider color: Color lightGray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScrollBar class	instanceVariableNames: ''!!ScrollBar class methodsFor: 'class initialization'!initialize "ScrollBar initialize"	UpArrow _ Form		extent: 6@3		fromArray: #(2r11e28 2r1111e27 2r111111e26)		offset: 0@0.! !MouseMenuController subclass: #ScrollController	instanceVariableNames: 'scrollBar marker savedArea menuBar savedMenuBarArea '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!ScrollController commentStamp: 'di 5/22/1998 16:37' prior: 0!ScrollController comment:'I represent control for scrolling using a scrollBar. I am a MouseMenuController that creates a scrollBar, rather than menus. My subclasses add the button menus. I keep control as long as the cursor is inside the view or the scrollBar area.	A scrollBar is a rectangular area representing the length of the information being viewed. It contains an inner rectangle whose top y-coordinate represents the relative position of the information visible on the screen with respect to all of the information, and whose size represents the relative amount of that information visible on the screen. The user controls which part of the information is visible by pressing the red button. If the cursor is to the right of the inner rectangle, the window onto the visible information moves upward, if the cursor is to the left, the window moves downward, and if the cursor is inside, the inner rectangle is grabbed and moved to a desired position.'!!ScrollController methodsFor: 'initialize-release'!initialize	super initialize.	scrollBar _ Quadrangle new.	scrollBar borderWidthLeft: 2 right: 0 top: 2 bottom: 2.	marker _ Quadrangle new.	marker insideColor: Preferences scrollBarColor.	menuBar _ Quadrangle new.	menuBar borderWidthLeft:  2 right: 0 top: 2 bottom: 2.! !!ScrollController methodsFor: 'basic control sequence'!controlInitialize	"Recompute scroll bars.  Save underlying image unless it is already saved."	| |	super controlInitialize.	scrollBar region: (0 @ 0 extent: 24 @ view apparentDisplayBox height).	scrollBar insideColor: view backgroundColor.	marker region: self computeMarkerRegion.	scrollBar _ scrollBar align: scrollBar topRight with: view apparentDisplayBox topLeft.	marker _ marker align: marker topCenter with: self upDownLine @ (scrollBar top + 2).	savedArea isNil ifTrue: [savedArea _ Form fromDisplay: scrollBar].	scrollBar displayOn: Display.	"Show a border around yellow-button (menu) region""	yellowBar _ Rectangle left: self yellowLine right: scrollBar right + 1		top: scrollBar top bottom: scrollBar bottom.	Display border: yellowBar width: 1 mask: Form veryLightGray."	self moveMarker! !!ScrollController methodsFor: 'basic control sequence'!controlTerminate	super controlTerminate.	savedArea notNil 			ifTrue: 			[savedArea displayOn: Display at: scrollBar topLeft.			savedArea _ nil].! !!ScrollController methodsFor: 'control defaults'!controlActivity	self scrollBarContainsCursor				ifTrue: [self scroll]				ifFalse: [super controlActivity]! !!ScrollController methodsFor: 'control defaults'!isControlActive 	view isNil ifTrue: [^ false].	^ (view insetDisplayBox merge: scrollBar inside)		containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'control defaults'!isControlWanted	^self viewHasCursor! !!ScrollController methodsFor: 'scrolling'!anyButtonActivity	"deal with red button down in scrollBar beyond yellowLine"	self yellowButtonActivity! !!ScrollController methodsFor: 'scrolling'!downLine	"if cursor before downLine, display down cursor and scroll down on button down"	^scrollBar left + 6 ! !!ScrollController methodsFor: 'scrolling'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[Processor yield.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling'!scrollAmount	"Answer the number of bits of y-coordinate should be scrolled. This is a 	default determination based on the view's preset display transformation."	^((view inverseDisplayTransform: sensor cursorPoint)		- (view inverseDisplayTransform: scrollBar inside topCenter)) y! !!ScrollController methodsFor: 'scrolling'!scrollView	"The scroll bar jump method was used so that the view should be 	updated to correspond to the location of the scroll bar gray area.	Return true only if scrolling took place."	^ self scrollView: self viewDelta! !!ScrollController methodsFor: 'scrolling'!scrollView: anInteger 	"Tell the reciever's view to scroll by anInteger amount.	Return true only if scrolling actually resulted."	(view scrollBy: 0 @ 				((anInteger min: view window top - view boundingBox top)						max: view window top - view boundingBox bottom))		ifTrue: [view clearInside; display.  ^ true]		ifFalse: [^ false]! !!ScrollController methodsFor: 'scrolling'!scrollViewDown	"Scroll the receiver's view down the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount! !!ScrollController methodsFor: 'scrolling'!scrollViewUp	"Scroll the receiver's view up the default amount.	Return true only if scrolling actually took place."	^ self scrollView: self scrollAmount negated! !!ScrollController methodsFor: 'scrolling'!upDownLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!upLine	"if cursor beyond upLine, display up cursor and scroll up on button down"	^scrollBar left + 12! !!ScrollController methodsFor: 'scrolling'!viewDelta	"Answer an integer that indicates how much the view should be scrolled. 	The scroll bar has been moved and now the view must be so the amount 	to scroll is computed as a ratio of the current scroll bar position."	^view window top - view boundingBox top -		((marker top - scrollBar inside top) asFloat /			scrollBar inside height asFloat *				view boundingBox height asFloat) rounded! !!ScrollController methodsFor: 'scrolling'!yellowLine	"Check to see whether the user wishes to jump, scroll up, or scroll down."	^scrollBar left + 16! !!ScrollController methodsFor: 'cursor'!changeCursor: aCursor 	"The current cursor should be set to be aCursor."	sensor currentCursor ~~ aCursor ifTrue: [aCursor show]! !!ScrollController methodsFor: 'cursor'!markerContainsCursor	"Answer whether the gray area inside the scroll bar area contains the 	cursor."	^marker inside containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'cursor'!menuBarContainsCursor	"Answer whether the cursor is anywhere within the menu bar area."	^ menuBar notNil and:			[menuBar containsPoint: sensor cursorPoint]! !!ScrollController methodsFor: 'cursor'!scrollBarContainsCursor	"Answer whether the cursor is anywhere within the scroll bar area."	^scrollBar containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'marker adjustment'!computeMarkerRegion	"Answer the rectangular area in which the gray area of the scroll bar 	should be displayed."	^0@0 extent: Preferences scrollBarWidth @			((view window height asFloat /						view boundingBox height *							scrollBar inside height)				 rounded min: scrollBar inside height)! !!ScrollController methodsFor: 'marker adjustment'!markerDelta	^ marker top 		- scrollBar inside top  		- ((view window top - view boundingBox top) asFloat 			/ view boundingBox height asFloat *				scrollBar inside height asFloat) rounded! !!ScrollController methodsFor: 'marker adjustment'!markerRegion: aRectangle 	"Set the area defined by aRectangle as the marker. Fill it with gray tone."	Display fill: marker fillColor: scrollBar insideColor.	marker region: aRectangle.	marker _ marker align: marker topCenter 			with: self upDownLine @ (scrollBar top + 2) ! !!ScrollController methodsFor: 'marker adjustment'!moveMarker	"The view window has changed. Update the marker."	self moveMarker: self markerDelta negated anchorMarker: nil! !!ScrollController methodsFor: 'marker adjustment'!moveMarker: anInteger anchorMarker: anchorMarker	"Update the marker so that is is translated by an amount corresponding to 	a distance of anInteger, constrained within the boundaries of the scroll 	bar.  If anchorMarker ~= nil, display the border around the area where the	marker first went down."	Display fill: marker fillColor: scrollBar insideColor.	anchorMarker = nil		ifFalse: [Display border: anchorMarker width: 1 fillColor: Color gray].	marker _ marker translateBy: 0 @				((anInteger min: scrollBar inside bottom - marker bottom) max:					scrollBar inside top - marker top).	marker displayOn: Display! !!ScrollController methodsFor: 'marker adjustment'!moveMarkerTo: aRectangle 	"Same as markerRegion: aRectangle; moveMarker, except a no-op if the marker	 would not move."	(aRectangle height = marker height and: [self viewDelta = 0]) ifFalse:		[self markerRegion: aRectangle.		self moveMarker]! !!ScrollController methodsFor: 'private'!scrollAbsolute	| markerOutline oldY markerForm |	self changeCursor: Cursor rightArrow.	oldY _ -1.	sensor anyButtonPressed ifTrue: 	  [markerOutline _ marker deepCopy.	  markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  Display border: markerOutline width: 1 fillColor: Color gray.	  markerForm 		follow: 			[oldY ~= sensor cursorPoint y				ifTrue: 					[oldY _ sensor cursorPoint y.					marker _ marker translateBy: 					  0 @ ((oldY - marker center y 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).					self scrollView].				marker origin] 		while: [sensor anyButtonPressed].	  Display fill: markerOutline fillColor: scrollBar insideColor.	  self moveMarker]! !!ScrollController methodsFor: 'private'!scrollDown	| markerForm firstTime |	self changeCursor: Cursor down.	sensor anyButtonPressed ifTrue:	  [markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime _ true.	  markerForm 		follow: 			[self scrollViewDown ifTrue:				[marker _ marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime _ false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !!ScrollController methodsFor: 'private'!scrollUp	| markerForm firstTime |	self changeCursor: Cursor up.	sensor anyButtonPressed ifTrue:	  [markerForm _ Form fromDisplay: marker.	  Display fill: marker fillColor: scrollBar insideColor.	  firstTime _ true.	  markerForm 		follow: 			[self scrollViewUp ifTrue:				[marker _ marker translateBy: 0 @					((self markerDelta negated 						min: scrollBar inside bottom - marker bottom) 						max: scrollBar inside top - marker top).				firstTime					ifTrue: [						"pause before scrolling repeatedly"						(Delay forMilliseconds: 250) wait.						firstTime _ false.					] ifFalse: [						(Delay forMilliseconds: 50) wait.					].				].			marker origin] 		while: [sensor anyButtonPressed].	  self moveMarker.]! !ComponentLikeModel subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller retractableScrollBar scrollBarOnLeft getMenuSelector scrollBarHidden '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!ScrollPane methodsFor: 'initialization'!fullCopy	| copy |	self mouseEnter.          "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.  "So that references are updated properly"	self mouseLeave.	^ copy mouseLeave! !!ScrollPane methodsFor: 'initialization' stamp: 'di 5/21/1998 23:15'!initialize	| |	super initialize.	borderWidth _ 2.  borderColor _ #inset.	retractableScrollBar _ scrollBarOnLeft _ true.	scrollBar := ScrollBar new model: self slotName: 'scrollBar'.	scrollBar borderWidth: 2; borderColor: #inset.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	scroller := TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	self on: #mouseEnter send: #mouseEnter: to: self.	self on: #mouseLeave send: #mouseLeave: to: self.	self extent: 150@120! !!ScrollPane methodsFor: 'access' stamp: 'sw 2/12/98 00:30'!colorForInsets	"My submorphs use the surrounding color"	| aColor |	(aColor _ owner color) ifKindOf: Color thenDo: [:c | ^ aColor].	"This workaround relates to cases where the scrollPane's color is not a true color but rather an InfiniteForm, which is not happy to be returned here"	^ Color white! !!ScrollPane methodsFor: 'access'!scroller	^ scroller! !!ScrollPane methodsFor: 'access' stamp: '6/7/97 10:42 di'!wantsSlot	"For now do it the old way, until we sort this out"	^ true! !!ScrollPane methodsFor: 'geometry'!containsPoint: aPoint	(super containsPoint: aPoint) ifTrue: [^ true].	"Also include scrollbar when it is extended..."	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar containsPoint: aPoint]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 4/8/98 13:09'!extent: newExtent	super extent: (newExtent max: 36@16).	self resizeScrollBar; resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: '6/6/97 11:59 di'!resizeScrollBar	| d | d _ retractableScrollBar ifTrue: [14@0] ifFalse: [0@0].	scrollBar bounds: (scrollBarOnLeft		ifTrue: [bounds topLeft - d extent: 16 @ bounds height]		ifFalse: [bounds topRight - (16@0) + d extent: 16 @ bounds height])! !!ScrollPane methodsFor: 'geometry'!resizeScroller	| d inner |	d _ retractableScrollBar ifTrue: [16@0] ifFalse: [0@0].	inner _ self innerBounds.	scroller bounds: (scrollBarOnLeft		ifTrue: [inner topLeft + (16@0) - d corner: inner bottomRight]		ifFalse: [inner topLeft corner: inner bottomRight - (16@0) + d])! !!ScrollPane methodsFor: 'geometry' stamp: 'di 5/22/1998 11:21'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	scrollBar value: (newYoffset asFloat / self totalScrollRange)! !!ScrollPane methodsFor: 'geometry'!totalScrollRange	^ (scroller submorphBounds encompass: 0@0) height - (bounds height // 2) max: 0! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 5/21/1998 23:15'!mouseEnter  "OBSOLETE"	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self privateAddMorph: scrollBar atIndex: 1.				self resizeScrollBar.				scrollBar changed]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 5/21/1998 23:37'!mouseEnter: event	(retractableScrollBar and: [(submorphs includes: scrollBar) not])		ifTrue: [self privateAddMorph: scrollBar atIndex: 1.				self resizeScrollBar.				scrollBar changed]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 5/21/1998 23:15'!mouseLeave  "OBSOLETE"	retractableScrollBar ifTrue: [self privateRemoveMorph: scrollBar]! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 5/21/1998 23:14'!mouseLeave: event	retractableScrollBar ifTrue: [self privateRemoveMorph: scrollBar]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 5/7/1998 09:52'!handlesMouseDown: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 5/21/1998 23:29'!keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller submorphs last keyStroke: evt! !!ScrollPane methodsFor: 'pane events' stamp: 'di 5/7/1998 11:46'!mouseDown: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 5/7/1998 11:46'!mouseMove: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseMove: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 5/7/1998 11:46'!mouseUp: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseUp: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 4/21/1998 13:51'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu) ifNotNil:		[menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'scroll bar events'!scrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: -3 @ (self totalScrollRange * scrollValue)! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 4/11/98 18:55'!shiftedYellowButtonActivity	| menu event |	(menu _ self getMenu: true) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 4/22/1998 10:49'!yellowButtonActivity	| menu event |	(menu _ self getMenu: false) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	retractableScrollBar		ifTrue: [aCustomMenu add: 'make scrollbar inboard' action: #retractableOrNot]		ifFalse: [aCustomMenu add: 'make scrollbar retractable' action: #retractableOrNot].	scrollBarOnLeft		ifTrue: [aCustomMenu add: 'scroll bar on right' action: #leftOrRight]		ifFalse: [aCustomMenu add: 'scroll bar on left' action: #leftOrRight]! !!ScrollPane methodsFor: 'menu' stamp: 'di 4/11/98 18:49'!getMenu	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	^ self getMenu: Sensor leftShiftDown! !!ScrollPane methodsFor: 'menu' stamp: 'di 4/11/98 18:48'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftKeyState].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:09'!leftOrRight  "Change scroll bar location"	scrollBarOnLeft _ scrollBarOnLeft not.	self extent: self extent! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:14'!retractableOrNot  "Change scroll bar operation"	retractableScrollBar _ retractableScrollBar not.	retractableScrollBar		ifTrue: [self privateRemoveMorph: scrollBar]		ifFalse: [(submorphs includes: scrollBar) 					ifFalse: [self privateAddMorph: scrollBar atIndex: 1]].	self extent: self extent! !!ScrollPane methodsFor: 'menu' stamp: 'sw 1/13/98 21:27'!scrollBarOnLeft: aBoolean	scrollBarOnLeft _ aBoolean.	self extent: self extent! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScrollPane class	instanceVariableNames: ''!!ScrollPane class methodsFor: 'as yet unclassified' stamp: 'di 2/21/98 11:02'!includeInNewMorphMenu	"OK to instantiate"	^ true! !Object subclass: #ScrollingToolHolder	instanceVariableNames: 'pickupButtons stampButtons stamps thumbnailPics start '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!ScrollingToolHolder commentStamp: 'di 5/22/1998 16:37' prior: 0!Used to hold stamp images in the PaintBox. Displays a small number of the available stamps and allows scrolling to access the others. One stamp is always kept blank as a way to create new stamps.Note:	stamps are the full size Forms	thumbnailPics are the shrunken ones	nil in both lists means no stamp yet, so user can create one!!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 15:00'!clear	"wipe out all existing stamps"	stamps _ OrderedCollection new: 16.	thumbnailPics _ OrderedCollection new: 16.	stampButtons do: [:each | 		stamps addLast: nil.	"hold a space"		thumbnailPics addLast: nil].	start _ 1.	self normalize.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 3/9/98 13:17'!normalize	"Correspondence between buttons and stamp forms has changed.  Make all thumbnails show up right."	| shrunkForm button trans |	1 to: stampButtons size do: [:ind |		shrunkForm _ thumbnailPics atWrap: ind+start-1.		button _ stampButtons at: ind.		shrunkForm 			ifNil: [trans _ Form extent: button extent depth: 8.				trans fill: trans boundingBox fillColor: Color transparent.				button onImage: trans]			ifNotNil: [button onImage: shrunkForm].		button offImage: shrunkForm; pressedImage: shrunkForm.	"later modify them"		].! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 11:46'!otherButtonFor: aButton	"Find the corresponding button for either a pickup or a stamp button"	| ii |	(ii _ pickupButtons indexOf: aButton) > 0 ifTrue: [^ stampButtons at: ii].	(ii _ stampButtons indexOf: aButton) > 0 ifTrue: [^ pickupButtons at: ii].	self error: 'stamp button not found'.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/16/97 19:22'!pickupButtons	^ pickupButtons! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 10:51'!pickupButtons: anArray	"Save the list of buttons that are for making a new stamp.  Left to right"	pickupButtons _ anArray! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 17:04'!remove: tool	"Remove a stamp.  Make this stamp blank.  OK to have a bunch of blank ones."	| which |	which _ stampButtons indexOf: tool ifAbsent: [				pickupButtons indexOf: tool ifAbsent: [^ self]].	stamps atWrap: which+start-1 put: nil.	thumbnailPics atWrap: which+start-1 put: nil.	self normalize.	"show them"! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:37'!scroll: amt	"Move the stamps over"	start _ start - 1 + amt \\ stamps size + 1.	self normalize.	"show them"! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/16/97 19:22'!stampButtons	^ stampButtons! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 10:21'!stampButtons: anArray	"Pop in a new list of buttons that are the tools for stamping.  Left to right"	stampButtons _ anArray.	self clear.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/17/97 09:59'!stampForm: stampForm for: aPickupButton	"Install this form to stamp. Find its index.  Make a thumbnail."	| which scale shrunkForm stampBtn mini |	which _ pickupButtons indexOf: aPickupButton.	which = 0 ifTrue: [which _ stampButtons indexOf: aPickupButton].	stamps atWrap: which+start-1 put: stampForm.	"Create the thumbnail"	stampBtn _ stampButtons at: which.	scale _ stampBtn width / (stampForm extent x max: stampForm extent y).	scale _ scale min: 1.0.	"do not expand it"	mini _ stampForm magnify: stampForm boundingBox by: scale smoothing: 1.	shrunkForm _ mini class extent: stampBtn extent depth: stampForm depth.	mini displayOn: shrunkForm at: (stampBtn extent - mini extent)//2.	thumbnailPics atWrap: which+start-1 put: shrunkForm.	stampBtn offImage: shrunkForm; onImage: shrunkForm; pressedImage: shrunkForm.		"Emphasis is done by border of enclosing layoutMorph, not modifying image"	(stamps indexOf: nil) = 0 ifTrue: ["Add an extra blank place"		"Keep stamp we just installed in the same location!!"		start+which-1 > stamps size ifTrue: [start _ start + 1].		stamps addLast: nil.		thumbnailPics addLast: nil.		self normalize].! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:04'!stampFormFor: aButton	| which |	which _ stampButtons indexOf: aButton ifAbsent: [1].	^ stamps atWrap: which+start-1! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'jm 7/28/97 11:54'!updateReferencesUsing: aDictionary	"Fix up the Morphs I own"	"Note: Update this method when adding new inst vars that could contain Morphs."	stampButtons _ stampButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].	pickupButtons _ pickupButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].! !CompositionScanner subclass: #SegmentScanner	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!SegmentScanner methodsFor: 'all' stamp: 'di 11/26/97 21:23'!setFont	super setFont.	stopConditions at: Character space asciiValue + 1 put: nil.! !PopUpMenu subclass: #SelectionMenu	instanceVariableNames: 'selections '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Menus'!!SelectionMenu methodsFor: 'basic control sequence'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object	 the selector corresponding to the menu item selected by the user. Return	 nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"(SelectionMenu labels:'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'di 5/21/1998 14:42'!startUpWithCaption: captionOrNil at: location	"Overridden to return value returned by manageMarker."	| index |	index _ super startUpWithCaption: captionOrNil at: location.	(selections = nil or: [(index between: 1 and: selections size) not]) ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu methodsFor: 'access'!selections	^ selections! !!SelectionMenu methodsFor: 'access'!selections: selectionArray	selections _ selectionArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SelectionMenu class	instanceVariableNames: ''!!SelectionMenu class methodsFor: 'instance creation'!confirm: queryString 	"Put up a yes/no menu with caption queryString. Answer true if the response is yes, false if no. This is a modal question--the user must respond yes or no."	"SelectionMenu confirm: 'Are you hungry?'"	| menu choice |	menu _ self selections: #('yes' 'no').	[true] whileTrue: [		choice _ menu startUpWithCaption: queryString.		choice = 'yes' ifTrue: [^ true].		choice = 'no' ifTrue: [^ false]]! !!SelectionMenu class methodsFor: 'instance creation'!labelList: labelList lines: lines selections: selections	^ self labels: (String streamContents:			[:strm |  "Concatenate labels with CRs"			labelList do: [:each | strm nextPutAll: each; cr].			strm skip: -1])  "No CR at end"		lines: lines selections: selections! !!SelectionMenu class methodsFor: 'instance creation'!labelList: labelList selections: selections	^ self labelList: labelList lines: nil selections: selections! !!SelectionMenu class methodsFor: 'instance creation'!labels: aString lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	^ (self labels: aString lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation'!labels: aString selections: selectionsArray	"Answer an instance of me whose items are in aString, recording	 the given array of selections corresponding to the items in aString."	^ self labels: aString lines: #() selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 6/27/96'!selections: aList	"Answer an instance of me whose labels and selections are identical.  "	^ self labelList: aList lines: nil selections: aList! !!SelectionMenu class methodsFor: 'instance creation'!selections: aList lines: lineList	"Answer an instance of me whose labels and selections are identical"	^ self labelList: aList lines: lineList selections: aList! !LeafNode subclass: #SelectorNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!SelectorNode commentStamp: 'di 5/22/1998 16:37' prior: 0!SelectorNode comment:'I am a parse tree leaf representing a selector.'!!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: strm	self emit: stack		args: nArgs		on: strm		super: false! !!SelectorNode methodsFor: 'code generation'!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index! !!SelectorNode methodsFor: 'code generation'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder litIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!SelectorNode methodsFor: 'printing'!printOn: aStream indent: level	aStream nextPutAll: key! !!SelectorNode methodsFor: 'inappropriate'!emitForEffect: stack on: strm	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!emitForValue: stack on: strm	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!sizeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'inappropriate'!sizeForValue: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'testing'!isPvtSelector	"Answer if this selector node is a private message selector."	^key isPvtSelector! !LinkedList subclass: #Semaphore	instanceVariableNames: 'excessSignals '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!Semaphore commentStamp: 'di 5/22/1998 16:37' prior: 0!Semaphore comment:'I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.'!!Semaphore methodsFor: 'initialize-release'!initSignals	"Consume any excess signals the receiver may have accumulated."	excessSignals _ 0.! !!Semaphore methodsFor: 'initialize-release'!terminateProcess	"Terminate the process waiting on this semaphore, if any."	self isEmpty ifFalse: [ self removeFirst terminate ].! !!Semaphore methodsFor: 'communication'!signal	"Primitive. Send a signal through the receiver. If one or more processes 	have been suspended trying to receive a signal, allow the first one to 	proceed. If no process is waiting, remember the excess signal. Essential. 	See Object documentation whatIsAPrimitive."	<primitive: 85>	self primitiveFailed	"self isEmpty    		ifTrue: [excessSignals _ excessSignals+1]    		ifFalse: [Processor resume: self removeFirstLink]"! !!Semaphore methodsFor: 'communication'!wait	"Primitive. The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 86>	self primitiveFailed	"excessSignals>0  		ifTrue: [excessSignals _ excessSignals-1]  		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !!Semaphore methodsFor: 'communication' stamp: 'jm 9/15/97 17:11'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	| d |	d _ Delay timeoutSemaphore: self afterMSecs: (anInteger max: 0).	self wait.	d unschedule.! !!Semaphore methodsFor: 'communication' stamp: 'jm 9/12/97 11:39'!waitTimeoutSeconds: anInteger	"Wait on this semaphore for up to the given number of seconds, then timeout. It is up to the sender to determine the difference between the expected event and a timeout."	self waitTimeoutMSecs: anInteger * 1000.! !!Semaphore methodsFor: 'mutual exclusion'!critical: mutuallyExcludedBlock 	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue |	self wait.	blockValue _ mutuallyExcludedBlock value.	self signal.	^blockValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Semaphore class	instanceVariableNames: ''!!Semaphore class methodsFor: 'instance creation'!forMutualExclusion	"Answer an instance of me that contains a single signal. This new 	instance can now be used for mutual exclusion (see the critical: message 	to Semaphore)."	^self new signal! !!Semaphore class methodsFor: 'instance creation'!new	"Answer a new instance of Semaphore that contains no signals."	^self basicNew initSignals! !Collection subclass: #SequenceableCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!!SequenceableCollection commentStamp: 'di 5/22/1998 16:37' prior: 0!SequenceableCollection comment:'I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices.'!!SequenceableCollection methodsFor: 'comparing'!= otherCollection	"Answer whether the species of the receiver is the same as	otherCollection's species, and the receiver's size is the same as	otherCollection's size, and each of the receiver's elements equal the	corresponding element of otherCollection."	| size |	(size _ self size) = otherCollection size ifFalse: [^false].	self species == otherCollection species ifFalse: [^false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^false]].	^true! !!SequenceableCollection methodsFor: 'accessing'!allButFirst	^ self copyFrom: 2 to: self size! !!SequenceableCollection methodsFor: 'accessing'!allButLast	^ self copyFrom: 1 to: self size - 1! !!SequenceableCollection methodsFor: 'accessing'!at: index ifAbsent: exceptionBlock	"Answer the element at my position index. If I do not contain an element	at index, answer the result of evaluating the argument, exceptionBlock."	(index between: 1 and: self size) ifTrue:		[^self at: index].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 7/13/97 09:49'!atAll: indexArray	"Return the selected elements in order"	^ indexArray collect: [:i | self at: i]! !!SequenceableCollection methodsFor: 'accessing'!atAll: anInterval put: anObject 	"Put anObject at every index specified by the integer elements of 	anInterval."	anInterval do: [:index | self at: index put: anObject]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 7/13/97 09:50'!atAll: indexArray putAll: valueArray	"Store the elements of valueArray into the slots	of this collection selected by indexArray."	indexArray with: valueArray do:		[:i :x | self at: i put: x]! !!SequenceableCollection methodsFor: 'accessing'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	1 to: self size do:		[:index | self at: index put: anObject]! !!SequenceableCollection methodsFor: 'accessing'!atRandom	"Return a random element of myself.  Uses a shared random number generator owned by class Collection.  If you use this a lot, define your own instance of Random and use atRandom:.  Causes an error if self has no elements."	| index |	index _ (RandomForPicking next * self size) asInteger + 1.	^ self at: index"  #('one' 'or' 'the' 'other') atRandom   (1 to: 10) atRandom   'Just pick one of these letters at random' atRandom"! !!SequenceableCollection methodsFor: 'accessing'!atRandom: aGenerator	"Return a random element of myself.  Uses the instance of class Random supplied by the caller.  Caller should keep the generator in a variable and use the same one every time.  Use this instead of atRandom for better uniformity of random numbers because only you use the generator.  Causes an error if self has no elements."	| index |	index _ (aGenerator next * self size) asInteger + 1.	^ self at: index"	| aGen |	aGen _ Random new.   	(1 to: 10) atRandom: aGen  "! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:06'!fifth	"Answer the fifth element of the receiver. Create an error notification if 	the receiver contains fewer than four elements."	^ self at: 5 ifAbsent: [self error: 'element not found']! !!SequenceableCollection methodsFor: 'accessing'!first	"Answer the first element of the receiver. Create an error notification if 	the receiver contains no elements."	self emptyCheck.	^self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:06'!fourth	"Answer the fourth element of the receiver. Create an error notification if 	the receiver contains fewer than four elements."	^ self at: 4 ifAbsent: [self error: 'element not found']! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement 	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer 0."	^self indexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | (self at: i) = anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	start to: self size do:		[:i | (self at: i) = anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: aSubCollection startingAt: anIndex 	"Answer the index of the receiver's first element, such that that element 	equals the first element of aSubCollection, and the next elements equal 	the rest of the elements of aSubCollection. Begin the search at element 	anIndex of the receiver. If no such match is found, answer 0."	^self		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	"Answer the index of the receiver's first element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	start of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| first index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first _ sub first.	start to: self size - sub size + 1 do:		[:startIndex |		(self at: startIndex) = first ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index _ index+1]]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing'!last	"Answer the last element of the receiver. Create an error notification if 	the receiver contains no elements."	self emptyCheck.	^self at: self size! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement 	"This destructively replaces elements from start to stop in the receiver. 	Answer the receiver itself. Use copyReplaceFrom:to:with: for 	insertion/deletion which may alter the size of the result."	replacement size = (stop - start + 1)		ifFalse: [self error: 'Size of replacement doesnt match'].	^self replaceFrom: start to: stop with: replacement startingAt: 1! !!SequenceableCollection methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver 	starting at index, repStart, in the sequenceable collection, 	replacementCollection. Answer the receiver. No range checks are 	performed."	| index repOff |	repOff _ repStart - start.	index _ start - 1.	[(index _ index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:06'!second	"Answer the second element of the receiver. Create an error notification if 	the receiver contains fewer than two elements."	^ self at: 2 ifAbsent: [self error: 'element not found']! !!SequenceableCollection methodsFor: 'accessing'!size	self subclassResponsibility! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 7/28/97 17:14'!smartInspect	"Like inspect, but for collections with only one element, inspects that element"	^ self size == 1		ifTrue:			[self first smartInspect]		ifFalse:			[self inspect]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sw 4/30/1998 12:06'!third	"Answer the third element of the receiver. Create an error notification if 	the receiver contains fewer than three elements."	^ self at: 3 ifAbsent: [self error: 'element not found']! !!SequenceableCollection methodsFor: 'removing'!remove: oldObject ifAbsent: anExceptionBlock 	"SequencableCollections cannot implement removing."	self shouldNotImplement! !!SequenceableCollection methodsFor: 'copying' stamp: 'di 1/16/98 16:40'!, otherCollection 	"Concatenate two Strings or Collections."		^ self copyReplaceFrom: self size + 1		  to: self size		  with: otherCollection"#(2 4 6 8) , #(who do we appreciate)((2989 printStringBase: 16) copyFrom: 4 to: 6) , ' boy!!'"! !!SequenceableCollection methodsFor: 'copying'!copyAt: anIndex put: anElement	"Answer a copy of the receiver with anElement inserted at anIndex."	^ self copyReplaceFrom: anIndex to: anIndex with: (Array with: anElement)! !!SequenceableCollection methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| newSize |	newSize _ stop - start + 1.	^(self species new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying'!copyReplaceAll: oldSubstring with: newSubstring 	"Default is not to do token matching.	See also String copyReplaceTokens:with:"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: false	"'How now brown cow?' copyReplaceAll: 'ow' with: 'ello'"	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Pile'"! !!SequenceableCollection methodsFor: 'copying'!copyReplaceFrom: start to: stop with: replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| newSequenceableCollection newSize endReplacement |	newSize _ self size - (stop - start + 1) + replacementCollection size.	endReplacement _ start - 1 + replacementCollection size.	newSequenceableCollection _ self species new: newSize.	newSequenceableCollection		replaceFrom: 1		to: start - 1		with: self		startingAt: 1.	newSequenceableCollection		replaceFrom: start		to: endReplacement		with: replacementCollection		startingAt: 1.	newSequenceableCollection		replaceFrom: endReplacement + 1		to: newSize		with: self		startingAt: stop + 1.	^newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying'!copyWith: newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| newIC |	newIC _ self species new: self size + 1.	newIC 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newIC at: newIC size put: newElement.	^newIC! !!SequenceableCollection methodsFor: 'copying'!copyWithout: oldElement 	"Answer a copy of the receiver in which all occurrences of oldElement 	have been left out."	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do: [:each | oldElement = each ifFalse: [aStream nextPut: each]].	^aStream contents! !!SequenceableCollection methodsFor: 'copying'!copyWithoutAll: aList	"Answer a copy of the receiver in which all occurrences of all elements in aList have been removed.  6/17/96 sw"	| aStream |	aStream _ WriteStream on: (self species new: self size).	self do: [:each | (aList includes: each) ifFalse: [aStream nextPut: each]].	^ aStream contents! !!SequenceableCollection methodsFor: 'copying'!forceTo: length paddingWith: elem	"Force the length of the collection to length, padding if necissary	with elem.  Note that this makes a copy."	| newCollection copyLen |	newCollection _ self species new: length.	copyLen _ self size.	1 to: length do: [ :index |		(index <= copyLen) ifTrue: [			newCollection at: index put: (self at: index) ]		ifFalse: [			newCollection at: index put: elem ] ].	^ newCollection! !!SequenceableCollection methodsFor: 'copying'!shallowCopy	^self copyFrom: 1 to: self size! !!SequenceableCollection methodsFor: 'copying' stamp: 'ward 7/28/97 14:33'!shuffled	| copy |  "($A to: $Z) shuffled"	copy _ self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: (1 to: i) atRandom].	^ copy! !!SequenceableCollection methodsFor: 'copying'!sortBy: aBlock	"Create a copy that is sorted.  Sort criteria is the block that accepts two arguments.  When the block is true, the first arg goes first ([:a :b | a > b] sorts in descending order)."	| sorted other |	sorted _ (SortedCollection sortBlock: aBlock) addAll: self.	other _ self copy.	1 to: self size do: [:index |  other at: index put: 		(sorted at: index)].	^ other! !!SequenceableCollection methodsFor: 'enumerating'!adjacent: aBlock2	"Evaluate aBlock with adjacent pairs of elements of the receiver. 	Collect the resulting values into a collection like the receiver.	Answer the new collection."	| result |	self size < 2 ifTrue: [^ self species new].	result _ self species new: self size-1.	1 to: self size-1 do:		[:index | result at: index put:		(aBlock2 value: (self at: index)				value: (self at: index+1))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:41'!asDigitsToPower: anInteger do: aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating'!collect: aBlock 	"Refer to the comment in Collection|collect:."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put: (aBlock value: (self at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:44'!collectWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexCollect: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'tk 7/30/97 12:52'!combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| aCollection |	aCollection _ Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating'!do: aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:43'!doWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexDo: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating'!findFirst: aBlock	"Return the index of my first element for which aBlock evaluates as true."	| index |	index _ 0.	[(index _ index + 1) <= self size] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating'!findLast: aBlock	"Return the index of my last element for which aBlock evaluates as true."	| index |	index _ self size + 1.	[(index _ index - 1) >= 1] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sw 12/23/96'!pairsDo: aBlock 	"March through the receiver two elements at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  "	| i |	1 to: self size // 2 do:		[:index |			i _ 2 * index - 1.			 aBlock value: (self at: i) value: (self at: i + 1)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ward 7/28/97 09:41'!permutationsDo: aBlock	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"	self shallowCopy permutationsStartingAt: 1 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating'!reverseDo: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument, 	starting with the last element and taking each in sequence up to the 	first. For SequenceableCollections, this is the reverse of the enumeration 	for do:."	self size to: 1 by: -1 do: [:index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating'!reverseWith: aSequenceableCollection do: aBlock 	"Evaluate aBlock with each of the receiver's elements, in reverse order, 	along with the  	corresponding element, also in reverse order, from 	aSequencableCollection. "	self size ~= aSequenceableCollection size ifTrue: [^ self errorNoMatch].	self size		to: 1		by: -1		do: [:index | aBlock value: (self at: index)				value: (aSequenceableCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream _ WriteStream on: (self species new: self size).	1 to: self size do: 		[:index |		(aBlock value: (self at: index))			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:30'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:32'!with: otherCollection do: twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	1 to: self size do:		[:index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 5/17/1998 13:34'!withIndexCollect: elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| result |	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:35'!withIndexDo: elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block."	1 to: self size do:		[:index |		elementAndIndexBlock			value: (self at: index)			value: index]! !!SequenceableCollection methodsFor: 'converting'!asArray	"Answer an Array whose elements are the elements of the receiver, in 	the same order."	| newArray |	newArray _ Array new: self size.	1 to: self size do: [:index | newArray at: index put: (self at: index)].	^newArray! !!SequenceableCollection methodsFor: 'converting'!asDictionary	"Answer a Dictionary whose keys are string versions of my indices and whose values are my elements.  6/12/96 sw"	| aDictionary |	aDictionary _ Dictionary new.	1 to: self size do:		[:i | aDictionary add:			(Association key: i printString value: (self at: i))].	^ aDictionary! !!SequenceableCollection methodsFor: 'converting'!asSortedArray	1 to: (self size - 1) do:		[:i | (self at: i) >= (self at: (i+1)) ifTrue: 				[self flag: #developmentNote.				"The optimization used here is, I HOPE, really an optimization.  The idea is that most collections processed will already be sorted, so we don't bother going through the double-transformation of the next line until we're sure that it is necessary.  On the other hand, the test for need-to-sort is itself not free.  sw"				^ self asSortedCollection asArray]].	^ self asArray! !!SequenceableCollection methodsFor: 'converting'!asStringWithCr	"Convert to a string with returns between items.  Elements are usually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: String)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream; cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'di 7/7/97 09:51'!reversed	"Answer a copy of the receiver with element order reversed."	| reversal strm |	reversal _ self species new: self size.	strm _ WriteStream on: reversal.	self reverseDo: [:elem | strm nextPut: elem].	^ reversal" 'frog' reversed "! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!asDigitsAt: anInteger in: aCollection do: aBlock	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	self do: 		[:each | 		aCollection at: anInteger put: each.		anInteger = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self asDigitsAt: anInteger + 1 in: aCollection do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 7/30/97 12:42'!combinationsAt: jj in: aCollection after: nn do: aBlock	"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1."	"(1 to: 6) combinationsSize: 3 do: [:each | Transcript cr; show: each printString]"nn+1 to: self size do: [:index | 		aCollection at: jj put: (self at: index).		jj = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self combinationsAt: jj + 1 in: aCollection after: index do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'tk 1/7/98 10:57'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	(ifTokens and: [(self isKindOf: String) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString _ self.	startSearch _ 1.	[(currentIndex _ aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex _ currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString _ aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch _ currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch _ currentIndex + 1]					ifFalse: [startSearch _ currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection methodsFor: 'private'!errorOutOfBounds	self error: 'indices are out of bounds'! !!SequenceableCollection methodsFor: 'private' stamp: 'ward 7/28/97 09:38'!permutationsStartingAt: anInteger do: aBlock	"#(1 2 3 4) permutationsDo: [:each | Transcript cr; show: each printString]"	anInteger > self size ifTrue: [^self].	anInteger = self size ifTrue: [^aBlock value: self].	anInteger to: self size do:		[:i | self swap: anInteger with: i.		self permutationsStartingAt: anInteger + 1 do: aBlock.		self swap: anInteger with: i]! !!SequenceableCollection methodsFor: 'private'!swap: oneIndex with: anotherIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| element |	element _ self at: oneIndex.	self at: oneIndex put: (self at: anotherIndex).	self at: anotherIndex put: element! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SequenceableCollection class	instanceVariableNames: ''!!SequenceableCollection class methodsFor: 'stream creation'!streamContents: blockWithArg	| stream |	stream _ WriteStream on: (self new: 100).	blockWithArg value: stream.	^stream contents! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'di 6/20/97 09:07'!streamContents: blockWithArg limitedTo: sizeLimit	| stream |	stream _ LimitedWriteStream on: (self new: (100 min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !AbstractSound subclass: #SequentialSound	instanceVariableNames: 'sounds currentIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!SequentialSound methodsFor: 'initialization' stamp: 'jm 2/4/98 10:00'!initialize	super initialize.	sounds _ Array new.	currentIndex _ 0.! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/25/97 13:41'!doControl	super doControl.	currentIndex > 0		ifTrue: [(sounds at: currentIndex) doControl].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 11/24/97 16:16'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a collection of sounds in sequence."	"PluckedSound chromaticScale play"	| finalIndex i snd remaining count |	currentIndex = 0 ifTrue: [^ self].  "already done"	finalIndex _ (startIndex + n) - 1.	i _ startIndex.	[i <= finalIndex] whileTrue: [		snd _ (sounds at: currentIndex).		[(remaining _ snd samplesRemaining) <= 0] whileTrue: [			"find next undone sound"			currentIndex < sounds size				ifTrue: [					currentIndex _ currentIndex + 1.					snd _ (sounds at: currentIndex)]				ifFalse: [					currentIndex _ 0.					^ self]].  "no more sounds"		count _ (finalIndex - i) + 1.		remaining < count ifTrue: [count _ remaining].		snd mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i _ i + count].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47'!reset	super reset.	sounds do: [:snd | snd reset].	sounds size > 0 ifTrue: [currentIndex _ 1].! !!SequentialSound methodsFor: 'sound generation' stamp: 'jm 12/15/97 22:47'!samplesRemaining	currentIndex = 0		ifTrue: [^ 0]		ifFalse: [^ 1000000].! !!SequentialSound methodsFor: 'composition'!, aSound	"Return the concatenation of the receiver and the argument sound."	^ self add: aSound! !!SequentialSound methodsFor: 'composition' stamp: 'jm 12/15/97 22:48'!add: aSound	sounds _ sounds copyWith: aSound.! !!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 19:10'!copy	"Copy my component sounds."	^ super copy copySounds! !!SequentialSound methodsFor: 'copying' stamp: 'jm 12/15/97 22:48'!copySounds	"Private!! Support for copying. Copy my component sounds."	sounds _ sounds collect: [:s | s copy].! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 2/4/98 13:36'!sounds	^ sounds! !Object subclass: #SerialPort	instanceVariableNames: 'port baudRate stopBitsType parityType dataBits outputFlowControlType inputFlowControlType xOnByte xOffByte '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Serial Port'!!SerialPort commentStamp: 'di 5/22/1998 16:37' prior: 0!This class supports a simple interface to the serial ports of the underlying platform, if it supports serial ports. The mapping of port numbers to hardware ports is platform specific, but typically follows platform ordering conventions. For example, on the Macintosh, port 0 is the modem port and port 1 is the printer port, since in the programmers documentation these ports are referred to as ports A and B.!!SerialPort methodsFor: 'initialization' stamp: 'jm 5/5/1998 15:49'!initialize	"Default port settings."	port _ nil.					"set when opened"	baudRate _ 9600.			"9600 baud"	stopBitsType _ 1.				"one stop bit"	parityType _ 0.				"no parity"	dataBits _ 8.					"8 bits"	outputFlowControlType _ 0.	"none"	inputFlowControlType _ 0.	"none"	xOnByte _ 19.				"ctrl-S"	xOffByte _ 24.				"ctrl-X"! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!baudRate	^ baudRate! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!baudRate: anInteger	"Set the baud rate for this serial port."	baudRate _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!dataBits	^ dataBits! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!dataBits: anInteger	"Set the number of data bits for this serial port to 5, 6, 7, or 8."	dataBits _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:21'!inputFlowControlType	^ inputFlowControlType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!inputFlowControlType: anInteger	"Set the type of input flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	inputFlowControlType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!outputFlowControlType	^ outputFlowControlType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!outputFlowControlType: anInteger	"Set the type of output flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	outputFlowControlType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!parityType	^ parityType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!parityType: anInteger	"Set the parity type for this serial port, where:		0 - no parity		1 - odd parity		2 - even parity"	parityType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!stopBitsType	^ stopBitsType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 18:02'!stopBitsType: anInteger	"Set the stop bits type for this serial port, where:		0 - 1.5 stop bits		1 - one stop bit		2 - two stop bits"	stopBitsType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:20'!xOffByte	^ xOffByte! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOffByte: anInteger	"Set the value of the XOff byte to be used if XOn/XOff flow control is enabled."	xOffByte _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:20'!xOnByte	^ xOnByte! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOnByte: anInteger	"Set the value of the XOn byte to be used if XOn/XOff flow control is enabled."	xOnByte _ anInteger.! !!SerialPort methodsFor: 'open/close' stamp: 'jm 5/18/1998 15:40'!close	"Close the serial port. Do nothing if the port is not open."	port ifNotNil: [self primClosePort: port].	port _ nil.! !!SerialPort methodsFor: 'open/close' stamp: 'jm 5/18/1998 15:37'!openPort: portNumber	"Open the given serial port, using the settings specified by my instance variables."	self close.	self primClosePort: portNumber.	self primOpenPort: portNumber		baudRate: baudRate		stopBitsType: stopBitsType		parityType: parityType		dataBits: dataBits		inFlowControlType: inputFlowControlType		outFlowControlType: outputFlowControlType		xOnByte: xOnByte		xOffByte: xOffByte.	port _ portNumber.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:41'!nextPutAll: aStringOrByteArray	"Send the given bytes out this serial port. The port must be open."	self primWritePort: port		from: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:44'!readByteArray	"Answer a ByteArray read from this serial port. Answer an empty ByteArray if no data is available. The port must be open."	| buf count |	buf _ ByteArray new: 1000.	count _ self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:46'!readInto: aStringOrByteArray startingAt: index	"Read data into the given String or ByteArray object starting at the given index, and answer the number of bytes read. Does not go past the end of the given String or ByteArray."	^ self primReadPort: port		into: aStringOrByteArray		startingAt: index		count: (aStringOrByteArray size - index) + 1.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:43'!readString	"Answer a String read from this serial port. Answer the empty String if no data is available. The port must be open."	| buf count |	buf _ String new: 1000.	count _ self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!SerialPort methodsFor: 'printing' stamp: 'jm 5/1/1998 18:02'!printOn: aStream	aStream		nextPutAll: 'SerialPort(';		nextPutAll:			(port ifNil: ['closed'] ifNotNil: ['#', port printString]);		nextPutAll: ', ';		print: baudRate; nextPutAll: ' baud, ';		print: dataBits; nextPutAll: ' bits, ';		nextPutAll: (#('1.5' '1' '2') at: stopBitsType + 1); nextPutAll: ' stopbits, ';		nextPutAll: (#('no' 'odd' 'even') at: parityType + 1); nextPutAll: ' parity)'.! !!SerialPort methodsFor: 'primitives' stamp: 'jm 5/1/1998 16:38'!primClosePort: portNumber	<primitive: 239>	self primitiveFailed.! !!SerialPort methodsFor: 'primitives' stamp: 'jm 5/5/1998 15:32'!primOpenPort: portNumber baudRate: baud stopBitsType: stop	parityType: parity dataBits: numDataBits	inFlowControlType: inFlowCtrl outFlowControlType: outFlowCtrl	xOnByte: xOn xOffByte: xOff	<primitive: 238>	self primitiveFailed.! !!SerialPort methodsFor: 'primitives' stamp: 'jm 5/1/1998 16:38'!primReadPort: portNumber into: byteArray startingAt: startIndex count: count	<primitive: 241>	self primitiveFailed.! !!SerialPort methodsFor: 'primitives' stamp: 'jm 5/18/1998 12:40'!primWritePort: portNumber from: byteArray startingAt: startIndex count: count	<primitive: 240>	self primitiveFailed.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SerialPort class	instanceVariableNames: ''!!SerialPort class methodsFor: 'instance creation' stamp: 'jm 5/1/1998 17:39'!new	^ super new initialize! !Object subclass: #ServerAction	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!ServerAction commentStamp: 'di 5/22/1998 16:37' prior: 0!The ServerAction class is the default ServerAction (if the first token in the URL does not match any in the PWS ActionTable). Instances of ServerAction act like Mac Web servers -- they parse the URL into a Mac file path (including use of default.html if no final filename is provided), then return the contents of that file as the reply. All ServerActions get asked to process: a PWS request. This ServerAction does the processing by asking itself to checkAuthorization, to parse the request, to log the parsed request, and then to reply to the request.  Other ServerActions (like EmbeddedServerAction) can override one or more of those requests.The ServerAction class provides a ServerDirectory service.!!ServerAction methodsFor: 'file input/output' stamp: 'mjg 11/17/97 14:06'!fileContents: serverFileRef	^(FileStream fileNamed: (ServerAction serverDirectory) , serverFileRef)	 contentsOfEntireFile! !!ServerAction methodsFor: 'file input/output' stamp: 'mjg 11/25/97 14:17'!subdirectory: named	^named, (ServerAction pathSeparator)! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/4/97 16:37'!checkAuthorization: request	^self! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 10/25/97 15:02'!log: pieces to: request	| tab |	tab := String with: Character tab.	request log: ((Time now printString), tab, (Date today printString), tab, (pieces printString),	Character cr asString).! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/19/97 09:00'!parse: request	| filename |	filename := (ServerAction serverDirectory) , ((request url) allButFirst copyReplaceAll: '/' with: 		(ServerAction pathSeparator)).	(filename endsWith: (ServerAction pathSeparator)) ifTrue: [filename _ filename , (ServerAction defaultFile)].	^filename! !!ServerAction methodsFor: 'URL processing' stamp: 'mjg 11/4/97 16:37'!process: request	| pieces |	self checkAuthorization: request.	pieces _ self parse: request.	self log: pieces to: request.	self replyTo: pieces from: request.! !!ServerAction methodsFor: 'URL processing' stamp: 'jm 3/13/98 15:33'!replyTo: pieces from: request	"Transcript show: 'Reply: ', pieces; cr."	(StandardFileStream isAFileNamed: pieces) 		ifTrue: [			request reply: PWS success; reply: PWS contentHTML, PWS crlf.			request reply: (FileStream fileNamed: pieces) contentsOfEntireFile]		ifFalse: [			request error: PWS notFound].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServerAction class	instanceVariableNames: ''!!ServerAction class methodsFor: 'System Services' stamp: 'mjg 11/17/97 11:17'!defaultFile	^'default.html'! !!ServerAction class methodsFor: 'System Services' stamp: 'mjg 11/20/97 10:12'!pathSeparator  ^String with: FileDirectory pathNameDelimiter! !!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!serverDirectory	^ 'Home Plate:Valentine II:Server:'! !Object subclass: #ServerDirectory	instanceVariableNames: 'server directory type user passwordHolder group moniker url '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!ServerDirectory commentStamp: 'di 5/22/1998 16:37' prior: 0!Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.url			When a FTP server holds some web pages, the url of those pages is often			different from the FTP directory.  Put the url here.  If the directory is 			'public_html/Squeak/', the url might be 'www.webPage.com/~kaehler2/Squeak/'!]style[(615 8 464)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 1/6/98 12:55'!fileExists: fileName	"Does the file exist on this server directory?  fileName must be simple with no / or references to other directories."	^ (self getFileList contentsOfEntireFile findTokens: FTPSocket crLf) includes: fileName! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 2/16/98 15:30'!getDirectory	"Return a stream with a listing of the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'LIST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 2/16/98 15:30'!getFileList	"Return a stream with a list of files in the current server directory.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'NLST'.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"RWStream with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/20/1998 11:01'!getFileNamed: fileNameOnServer	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; space;		show: fileNameOnServer; cr.	resp _ dd getAllDataWhileWatching: so.	"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/19/1998 09:38'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 5/20/1998 10:55'!openFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  It has opened passive, and has a dataPort number assigned to a data FTPSocket.  But the data connection is not open.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so resp portInfo list dataPort dd rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	so sendCommand: 'TYPE L 8'.	(rr _ so lookFor: '200 ') == true ifFalse: [^ rr].	"200 Type set to L"	so sendCommand: 'PASV'.	resp _ (so getResponseUpTo: FTPSocket crLf) first.		"Tells which port on server to use for data"	Transcript show: resp; cr.	(resp beginsWith: '227 Entering Passive Mode (') ifFalse: [		so sendCommand: 'QUIT'.		so destroy.		^ self error: 'can''t get into passive mode'].	portInfo _ (resp findTokens: '()') at: 2.	list _ portInfo findTokens: ','.	dataPort _ (list at: 5) asNumber * 256 + (list at: 6) asNumber.	dd _ FTPSocket new.	dd portNum: dataPort.	so dataSocket: dd.	"save it, not opened yet"	^ so! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 2/16/98 15:30'!putFile: fileStream named: fileNameOnServer	"Just FTP a local fileStream to the server.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'STOR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'store via port ', dd portNum printString; cr.	dd sendData: fileStream contentsOfEntireFile.	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(resp _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"226 Transfer complete."! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/22/1998 13:57'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (url size > 0) ifTrue: [			strm _ HTTPSocket httpGet: url accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/1/1998 15:03'!outOfDate: aServer	"Inform the user that this server does not have a current version of 'Updates.list'  Return true if the user does not want any updates to happen."| response |response _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)		startUpWithCaption: 'The server ', aServer moniker, ' is not up to date.Please store the missing updates maually.'.^ response ~= 1! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 5/20/1998 11:59'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(local count: [:char | char == $.]) > 1 ifTrue: [		^ self inform: 'File name cannot have more than one period'].	(local at: 1) isDigit ifTrue: [		^ self inform: 'File name cannot begin with a number'].		"later offer to strip it off and put on new number"	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		^ self inform: 'File name cannot contain % / * or space'].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2363)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!directory: anObject	directory _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/21/1998 22:54'!fullPath: serverAndDirectory	"Parse and save a full path"	| start bare |	bare _ serverAndDirectory.	bare size > 7 ifTrue: [ 		start _ (bare copyFrom: 1 to: 8) asLowercase.		(start beginsWith: 'ftp://') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: 7 to: bare size].		(start beginsWith: 'http://') 			ifTrue: [type _ #http.				bare _ bare copyFrom: 8 to: serverAndDirectory size]].	server _ bare copyUpTo: self pathNameDelimiter.	bare size > (server size +2) 		ifTrue: [directory _ bare copyFrom: server size + 2 to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/6/98 11:11'!group	^group! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:16'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 22:20'!groupName	group ifNotNil: [^ group key].	^ self moniker! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 22:59'!moniker	"a plain language name for this directory"	moniker ifNil: [		^ directory first == $/ 			ifTrue: [server, directory]			ifFalse: [server, '/', directory]].	^ moniker! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/20/1998 12:26'!moniker: nickName	"a plain language name for this directory"	moniker _ nickName! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:55'!password	^ passwordHolder passwordFor: self! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/5/98 21:55'!password: pp	passwordHolder _ Password new.	pp class == String 		ifTrue: [passwordHolder cache: pp. ^ self].	pp isInteger 		ifTrue: [passwordHolder sequence: pp]		ifFalse: [passwordHolder _ pp].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!server: anObject	server _ anObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/13/1998 11:24'!url	^ url! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/13/1998 11:24'!url: aString	url _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!user: anObject	user _ anObject! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 11:41'!deleteFileNamed: fileName	self inform: 'Sorry, not implemented yet.'.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 08:56'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:42'!entries	"Return a list of the files here.  Later use the whole directory info with dates, sizes, times, etc."	^ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:53'!fileNameFormattedFrom: entry sizePad: sizePad sortMode: sortMode	"Parse one ftp directory entryd---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM"	^ (entry at: 1) == $d 		ifTrue: [(entry findTokens: ' ') last , self folderString, '    ()']		ifFalse: [(entry findTokens: ' ') last , '    ()']	"get fancier later"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:51'!folderString	^ ' [...]'! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 14:15'!fullNameFor: aFileName	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	^ server, self pathNameDelimiter asString, directory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:50'!listForPattern: pat sortMode: sortMode	"Make the list be those file names which match the pattern.  SortMode of #name ONLY for now."	| entries newList allFiles |	entries _ self entries.	newList _ true "sortMode == #name"  "case-insensitive compare"		ifTrue: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) <= 2]]		ifFalse: [(SortedCollection new: 30) sortBlock: [:x :y | (x compare: y) >= 2]].	allFiles _ pat = '*'.	entries do:		[:entry | "<name>"		(allFiles or: [pat match: entry]) ifTrue:			[newList add: (self fileNameFormattedFrom: entry 						sizePad: 8 sortMode: sortMode)]].	^ newList! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 13:33'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readWrite.	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/19/1998 14:20'!oldFileNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| file remoteStrm |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readOnly.	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 12:18'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"already have the rest"	file readOnly.	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 22:27'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/21/1998 22:55'!pathName	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 15:21'!pathNameDelimiter	"separator on that remote server.  How tell??"	type == #ftp ifTrue: [^ $/].	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/18/1998 17:48'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 5/20/1998 11:42'!rename: fileName toBe: newName	self inform: 'Sorry, not implemented yet.'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ServerDirectory class	instanceVariableNames: ''!!ServerDirectory class methodsFor: 'as yet unclassified' stamp: 'tk 1/7/98 12:18'!serverGroups	"Return all registered groups of servers (include individual servers not in any group).  Each is an association (name -> server)"	| grp set |	set _ Set new.	Smalltalk associationsDo: [:ass |		(ass value isKindOf: self) ifTrue: [			grp _ ass value group.			grp ifNil: [set add: ass]	"assoc"				ifNotNil: [ass value == grp value first ifTrue: [set add: ass]]]].	^ (set asOrderedCollection) collect: [:each | 				Association key: each value groupName value: each value].! !!ServerDirectory class methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 15:06'!servers	"Return all registered servers.  Each is an association (name -> server)"	| all |	all _ OrderedCollection new.	Smalltalk associationsDo: [:assoc |		(assoc value isKindOf: self) ifTrue: [all add: assoc copy]].	^ all! !ServerDirectory subclass: #ServerFile	instanceVariableNames: 'fileName rwmode '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Network'!!ServerFile commentStamp: 'di 5/22/1998 16:37' prior: 0!Represents the non-data part of a file on a server on the internet.  I am owned by a RemoteFileStream, who has the data.!!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:12'!exists	"Return true if the file exists on the server already"	^ self fileExists: fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 14:42'!fileName	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 14:43'!fileName: aString	fileName _ aString! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:32'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 14:08'!localName	^ fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 16:42'!readOnly	"Set the receiver to be read-only"	rwmode _ false! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:35'!readWrite	"Set the receiver to be writable"	rwmode _ true! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:35'!writable	^ rwmode! !Object subclass: #Session	instanceVariableNames: 'lastAccess data '	classVariableNames: 'Sessions '	poolDictionaries: ''	category: 'PluggableWebServer'!!Session commentStamp: 'di 5/22/1998 16:37' prior: 0!A Session can provide server-side storage of state/data between HTML pages. After creating a new session (which can be manipulated using at: and at:put:), it can be saved on the Sessions list by asking the Session class to store: the session. A random integer is returned as a key to the session, and the key can be stored in an HTML page in a hidden field.A session can be retrieved by ID by asking Session to recall: an ID. A session can be retired when it is no longer useful.Each recall: or use at:/at:put: "touches" (updates) the Session's last use time. A Session that is older than a certain period (default 30 minutes, in viableTime instance method) will generate an error. Every hour, the PWS, as part of its backup procedures, will clear out old sessions.!!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:12'!at: key	self touch.	^data at: key ifAbsent: [self error: 'Internal key error. Please alert administrator about key',key printString].! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:12'!at: key put: value	self touch.	^data at: key put: value.! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:07'!isViable	^ (Time now subtractTime: lastAccess) asSeconds > self viableTime! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:06'!touch	lastAccess := Time now.! !!Session methodsFor: 'access' stamp: 'mjg 11/4/97 14:07'!viableTime	"In seconds"	^60*30! !!Session methodsFor: 'initialize' stamp: 'tk 1/26/98 08:55'!initialize	data := Dictionary new.	lastAccess := Time now.	"PWS addToBackupJob: [Session user]."  "not implemented??"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Session class	instanceVariableNames: ''!!Session class methodsFor: 'store/recall' stamp: 'mjg 12/2/97 10:06'!clearOld	| aSession |	Sessions keys do: [:s |	aSession := Sessions at: s ifAbsent: [nil].	aSession isNil ifFalse:		[aSession isViable ifFalse: [self retire: s].]]! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:09'!recall: id	| aSession |	aSession := Sessions at: id ifAbsent: [self error: 'Non-existent session'].	aSession isViable ifFalse: [self error: 'Your session data has expired. Please restart the operation.'].	aSession touch.	^aSession! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:11'!retire: id	Sessions removeKey: id.! !!Session class methodsFor: 'store/recall' stamp: 'mjg 11/4/97 14:04'!store: aSession	| newID |	[	newID := SmallInteger maxVal atRandom.		Sessions includesKey: newID ] whileTrue.	Sessions at: newID put: aSession.	^newID! !!Session class methodsFor: 'initialization' stamp: 'mjg 11/4/97 16:43'!initialize	Sessions := Dictionary new.	PWS addToBackupJob: [Session clearOld].! !!Session class methodsFor: 'initialization' stamp: 'mjg 11/4/97 13:54'!new	^super new initialize! !Collection subclass: #Set	instanceVariableNames: 'tally array '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!Set methodsFor: 'testing'!= aSet	(aSet isKindOf: Set) ifFalse: [^ false].	self size = aSet size ifFalse: [^ false].	self do: [:each | (aSet includes: each) ifFalse: [^ false]].	^ true! !!Set methodsFor: 'testing'!includes: anObject 	^ (array at: (self findElementOrNil: anObject)) ~~ nil! !!Set methodsFor: 'testing'!occurrencesOf: anObject 	(self includes: anObject) ifTrue: [^1] ifFalse: [^0]! !!Set methodsFor: 'adding' stamp: 'go 10/1/97 09:33'!add: newObject	"Add an element. User error instead of halt. go 10/1/97 09:33"	| index |	newObject == nil ifTrue: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	(array at: index) == nil ifTrue:		[self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'removing'!remove: oldObject ifAbsent: aBlock	| index |	index _ self findElementOrNil: oldObject.	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally _ tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!Set methodsFor: 'enumerating'!collect: aBlock 	"Return a Set containing the result of evaluating aBlock	for each element of this set"	| newSet |	tally = 0 ifTrue: [^ Set new: 2].	newSet _ Set new: self size.	array do:		[:element |		element == nil ifFalse: [newSet add: (aBlock value: element)]].	^ newSet! !!Set methodsFor: 'enumerating'!do: aBlock 	tally = 0 ifTrue: [^ self].	array do: 		[:element | element == nil ifFalse: [aBlock value: element]]! !!Set methodsFor: 'enumerating'!doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index _ 0.	self do: [:item | aBlock2 value: item value: (index _ index+1)]! !!Set methodsFor: 'private'!array	^ array! !!Set methodsFor: 'private'!atNewIndex: index put: anObject	array at: index put: anObject.	tally _ tally + 1.	self fullCheck! !!Set methodsFor: 'private'!copy	^ self shallowCopy withArray: array shallowCopy! !!Set methodsFor: 'private'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	index _ self scanFor: anObject.	index > 0 ifTrue: [ ^ index ].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!Set methodsFor: 'private'!fixCollisionsFrom: index	"The element at index has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one"	| length oldIndex newIndex element |	oldIndex _ index.	length _ array size.	[oldIndex = length			ifTrue: [oldIndex _  1]			ifFalse: [oldIndex _  oldIndex + 1].	(element _ self keyAt: oldIndex) == nil]		whileFalse: 			[newIndex _ self findElementOrNil: element.			oldIndex = newIndex ifFalse: [self swap: oldIndex with: newIndex]]! !!Set methodsFor: 'private' stamp: 'di 11/4/97 20:11'!fullCheck	"Keep array at least 1/4 free for decent hash behavior"	array size - tally < (array size // 4 max: 1)		ifTrue: [self grow]! !!Set methodsFor: 'private'!grow	"Grow the elements array and reinsert the old elements"	| oldElements |	oldElements _ array.	array _ Array new: array size + self growSize.	tally _ 0.	oldElements do:		[:each | each == nil ifFalse: [self noCheckAdd: each]]! !!Set methodsFor: 'private'!growSize	^ array size max: 2! !!Set methodsFor: 'private'!init: n	"Initialize array to an array size of n"	array _ Array new: n.	tally _ 0! !!Set methodsFor: 'private'!keyAt: index	"May be overridden by subclasses so that fixCollisions will work"	^ array at: index! !!Set methodsFor: 'private'!noCheckAdd: anObject	array at: (self findElementOrNil: anObject) put: anObject.	tally _ tally + 1! !!Set methodsFor: 'private'!rehash	| newSelf |	newSelf _ self species new: self size.	self do: [:each | newSelf noCheckAdd: each].	array _ newSelf array! !!Set methodsFor: 'private'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [element = anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Set methodsFor: 'private'!size	^ tally! !!Set methodsFor: 'private'!swap: oneIndex with: otherIndex	"May be overridden by subclasses so that fixCollisions will work"	array swap: oneIndex with: otherIndex! !!Set methodsFor: 'private'!withArray: anArray	"private -- for use only in copy"	array _ anArray! !!Set methodsFor: 'accessing' stamp: 'sw 12/2/96'!asArray	"Return an array whose elements are those of the receiver.  "	^ self asOrderedCollection asArray! !!Set methodsFor: 'accessing' stamp: 'tk 2/14/97'!someElement	"Return some element of the Set.  "	^ array detect: [:each | each ~~ nil] ifNone: [ nil]! !!Set methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!readDataFrom: aDataStream size: anInteger	"Symbols have new hash in this world.  "	| aSet |	aSet _ super readDataFrom: aDataStream size: anInteger.	aSet rehash.	^ aSet! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Set class	instanceVariableNames: ''!!Set class methodsFor: 'instance creation'!fromBraceStack: itsSize 	"Answer an instance of me with itsSize elements, popped in reverse order from	 the stack of thisContext sender.  Do not call directly: this is called by {1. 2. 3}	 constructs."	^ (self new: itsSize) fill: itsSize fromStack: thisContext sender! !!Set class methodsFor: 'instance creation'!new	^ self new: 4! !!Set class methodsFor: 'instance creation'!new: nElements	"Create a Set large enough to hold nElements without growing"	^ super new init: (self sizeFor: nElements)! !!Set class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection _ self new: aCollection size.	newCollection addAll: aCollection.	^ newCollection"	Set newFrom: {1. 2. 3}	{1. 2. 3} as: Set"! !!Set class methodsFor: 'instance creation'!sizeFor: nElements	"Large enough size to hold nElements with some slop (see fullCheck)"	nElements <= 0 ifTrue: [^ 1].	^ nElements+1*4//3! !!Set class methodsFor: 'initialization'!rehashAllSets  "Set rehashAllSets"	| insts |	self withAllSubclassesDo:		[:c | insts _ c allInstances.		insts isEmpty ifFalse:		['Rehashing instances of ' , c name			displayProgressAt: Sensor cursorPoint			from: 1 to: insts size			during: [:bar |			1 to: insts size do:				[:x | bar value: x.				(insts at: x) rehash]]]]! !Object subclass: #SharedQueue	instanceVariableNames: 'contentsArray readPosition writePosition accessProtect readSynch '	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!SharedQueue commentStamp: 'di 5/22/1998 16:37' prior: 0!SharedQueue comment:'I provide synchronized communication of arbitrary objects between Processes. An object is sent by sending the message nextPut: and received by sending the message next. If no object has been sent when a next message is sent, the Process requesting the object will be suspended until one is sent.'!!SharedQueue methodsFor: 'accessing'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	| value |	readSynch wait.	accessProtect		critical: [readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value _ nil]					ifFalse: 						[value _ contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition _ readPosition + 1]].	^value! !!SharedQueue methodsFor: 'accessing'!nextPut: value 	"Send value through the receiver. If a Process has been suspended 	waiting to receive a value through the receiver, allow it to proceed."	accessProtect		critical: [writePosition > contentsArray size						ifTrue: [self makeRoomAtEnd].				 contentsArray at: writePosition put: value.				 writePosition _ writePosition + 1].	readSynch signal.	^value! !!SharedQueue methodsFor: 'accessing'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, suspend the requesting process until one is."	| value |	accessProtect		critical: [readPosition >= writePosition					ifTrue: [readPosition _ 1.							writePosition _ 1.							value _ nil]					ifFalse: [value _ contentsArray at: readPosition]].	^value! !!SharedQueue methodsFor: 'accessing'!size	"Answer the number of objects that have been sent through the	receiver and not yet received by anyone."	^writePosition - readPosition! !!SharedQueue methodsFor: 'testing'!isEmpty	"Answer whether any objects have been sent through the receiver and 	not yet received by anyone."	^readPosition = writePosition! !!SharedQueue methodsFor: 'private'!init: size	contentsArray _ Array new: size.	readPosition _ 1.	writePosition _ 1.	accessProtect _ Semaphore forMutualExclusion.	readSynch _ Semaphore new! !!SharedQueue methodsFor: 'private'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: 			[contentsArray _ contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize _ writePosition - readPosition.			1 to: contentsSize do: 				[:index | 				contentsArray 					at: index 					put: (contentsArray at: index + readPosition - 1)].			readPosition _ 1.			writePosition _ contentsSize + 1]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SharedQueue class	instanceVariableNames: ''!!SharedQueue class methodsFor: 'instance creation'!new	"Answer a new instance of SharedQueue that has 10 elements."	^self new: 10! !!SharedQueue class methodsFor: 'instance creation'!new: anInteger 	^super new init: anInteger! !RectangleMorph subclass: #SimpleButtonMorph	instanceVariableNames: 'target actionSelector arguments actWhen oldColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!SimpleButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self borderWidth: 1.	self borderColor: #raised.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	self label: 'Flash'.! !!SimpleButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].! !!SimpleButtonMorph methodsFor: 'menu'!setActionSelector	| newSel |	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed'		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!SimpleButtonMorph methodsFor: 'menu'!setActWhen	actWhen _ (SelectionMenu selections: #(buttonDown buttonUp whilePressed))		startUpWithCaption: 'Choose one of the following conditions'! !!SimpleButtonMorph methodsFor: 'menu'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!SimpleButtonMorph methodsFor: 'menu'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!SimpleButtonMorph methodsFor: 'menu'!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil. ^ self].! !!SimpleButtonMorph methodsFor: 'accessing'!actionSelector	^ actionSelector! !!SimpleButtonMorph methodsFor: 'accessing'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SimpleButtonMorph methodsFor: 'accessing'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen _ condition! !!SimpleButtonMorph methodsFor: 'accessing'!arguments	^ arguments! !!SimpleButtonMorph methodsFor: 'accessing'!arguments: aCollection	arguments _ aCollection asArray copy.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: '6/7/97 10:53 di'!extent: newExtent	| label |	super extent: newExtent.	submorphs size = 1 ifTrue:		["keep the label centered"		"NOTE: may want to test more that it IS a label..."		label _ self firstSubmorph.		label position: self center - (label extent // 2)]! !!SimpleButtonMorph methodsFor: 'accessing'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 15:49'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'di 10/20/97 20:26'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!SimpleButtonMorph methodsFor: 'accessing'!target	^ target! !!SimpleButtonMorph methodsFor: 'accessing'!target: anObject	target _ anObject! !!SimpleButtonMorph methodsFor: 'events'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sw 8/16/97 22:10'!handlesMouseDown: evt	^  self isPartsDonor not! !!SimpleButtonMorph methodsFor: 'events'!mouseDown: evt	oldColor _ color.	actWhen == #buttonDown		ifTrue: [self doButtonAction].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'di 12/8/97 10:48'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!SimpleButtonMorph methodsFor: 'events'!mouseUp: evt	self color: oldColor.	(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'sw 2/15/98 03:49'!recolor: c	self color: c.	oldColor _ c! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'jm 7/28/97 11:52'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleButtonMorph class	instanceVariableNames: ''!!SimpleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 5/6/1998 14:07'!authoringPrototype	^ super authoringPrototype label: 'Button'! !!SimpleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 2/16/98 01:31'!defaultNameStemForInstances	^ 'button'! !Socket subclass: #SimpleClientSocket	instanceVariableNames: ''	classVariableNames: 'CR CrLf LF '	poolDictionaries: ''	category: 'System-Network'!!SimpleClientSocket commentStamp: 'di 5/22/1998 16:37' prior: 0!SimpleClientSocket comment:'This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a (typically) single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.'!!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:21'!displayString: aString	"Display the given string on the Display. Used for testing."	| s |	aString isEmpty ifTrue: [^ self].	aString size > 60		ifTrue: [s _ aString copyFrom: 1 to: 60]  "limit to 60 characters"		ifFalse: [s _ aString].	s asParagraph displayOn: Display.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:36'!endsWithSinglePeriodLine: aString	"Return true if the given string ends with a period on a line by itself."	| sz |	sz _ aString size.	^ ((sz > 2) and:	   [(aString at: sz) = CR and:	   [(aString at: sz - 1) = $. and:	   [(aString at: sz - 2) = CR]]])! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:43'!getMultilineResponse	"Get a multiple line response to the last command, filtering out LF characters. A multiple line response ends with a line containing only a single period (.) character."	^ self getMultilineResponseShowing: false.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:41'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		response nextPutAll: chunk.		done _ self endsWithSinglePeriodLine: chunk].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:30'!getResponse	"Get the response to the last command, filtering out LF characters."	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'sw 1/14/98 11:09'!getResponseShowing: showFlag	"Get a the response to the last command, filtering out LF characters. If showFlag is true, each of the response is shown in the upper-left corner of the Display as it is received."	| response line buf bytesRead c |	self waitForDataQueryingUserEvery: 15.	response _ WriteStream on: ''.	line _ WriteStream on: ''.	buf _ String new: 1000.	[self dataAvailable]		whileTrue: [			bytesRead _ self receiveDataInto: buf.			1 to: bytesRead do: [:i |				(c _ buf at: i) ~= LF					ifTrue: [						line nextPut: c.						response nextPut: c]					ifFalse: [						showFlag ifTrue: [							self displayString: line contents.							line reset]]]].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/17/97 16:00'!sendCommand: commandString	"Send the given command as a single line followed by a <CR><LF> terminator."	self sendData: commandString, CrLf.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/15/97 15:46'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SimpleClientSocket class	instanceVariableNames: ''!!SimpleClientSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:42'!initialize	"SimpleClientSocket initialize"	CR _ Character cr.	LF _ Character linefeed.	"string for command line termination:"	CrLf _ String with: CR with: LF.! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'tk 5/4/1998 17:36'!nntpTest	"SimpleClientSocket nntpTest"	| addr s headers msgs header allNewsGroups |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 119.  "119 is the NNTP port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'group comp.lang.smalltalk'.	Transcript show: s getResponse.	"get all the message headers for the current newsgroup"	s sendCommand: 'xover 1-1000000'.	headers _ s getMultilineResponseShowing: true.	"print the headers of the first 10 messages of comp.lang.smalltalk"	s sendCommand: 'listgroup comp.lang.smalltalk'.	msgs _ self parseIntegerList: s getMultilineResponse.	msgs ifNotNil: [		1 to: 5 do: [:i |			s sendCommand: 'head ', (msgs at: i) printString.			header _ s getMultilineResponse.			Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr]].	"get a full list of usenet newsgroups"	s sendCommand: 'newgroups 010101 000000'.	allNewsGroups _ s getMultilineResponse.	Transcript show: allNewsGroups size printString, ' bytes in full newsgroup list'; cr.	Transcript show: 'Sending quit...'; cr.	s sendCommand: 'QUIT'.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	(headers ~~ nil and:	 [self confirm: 'show article headers from comp.lang.smalltalk?'])		ifTrue: [			(StringHolder new contents: (self parseHeaderList: headers))				openLabel: 'Newsgroup Headers'].	(allNewsGroups ~~ nil and:	 [self confirm: 'show list of all newsgroups available on your server?'])		ifTrue: [			(StringHolder new contents: allNewsGroups)				openLabel: 'All Usenet Newsgroups'].! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:25'!parseHeaderList: aString	"Parse a list of newsgroup headers."	| results s lineStart |	results _ WriteStream on: (String new: aString size).	s _ ReadStream on: aString.	[s atEnd]		whileFalse: [			lineStart _ s position + 1.			3 timesRepeat: [s skipTo: Character tab].  "find fourth tab"			lineStart to: s position - 1 do: [:i | results nextPut: (aString at: i)].			results cr.			s skipTo: Character cr].	^ results contents! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseIntegerList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s _ ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out _ OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!SimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseNTTPMsgList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s _ ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out _ OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/15/97 14:47'!extractDateFromAndSubjectFromHeader: headerString	| date from subject s lineBuf c line i |	date _ from _ subject _ ''.	s _ ReadStream on: headerString.	lineBuf _ WriteStream on: ''.	[s atEnd] whileFalse: [		c _ s next.		c = CR			ifTrue: [				line _ lineBuf contents.				(line beginsWith: 'Date: ')	ifTrue: [date _ line copyFrom: 7 to: line size].				(line beginsWith: 'From: ')	ifTrue: [from _ line copyFrom: 7 to: line size].				(line beginsWith: 'Subject: ')	ifTrue: [subject _ line copyFrom: 10 to: line size].				lineBuf _ WriteStream on: '']			ifFalse: [lineBuf nextPut: c]].	i _ date indexOf: $' ifAbsent: [0].	date _ date copyFrom: i + 1 to: date size.	^ (self simpleDateString: date), ', ', from, ':  ', subject! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/17/97 14:24'!popTest	"SimpleClientSocket popTest"	| addr userName userPassword s msgs header |	addr _ NetNameResolver promptUserForHostAddress.	userName _ FillInTheBlank		request: 'What is your email name?'		initialAnswer: 'johnm'.	userPassword _ FillInTheBlank		request: 'What is your email password?'.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 110.  "110 is the POP3 port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'USER ', userName.	Transcript show: s getResponse.	s sendCommand: 'PASS ', userPassword.	Transcript show: s getResponse.	s sendCommand: 'LIST'.	"the following should be tweaked to handle an empy mailbox:"	msgs _ self parseIntegerList: s getMultilineResponse.	1 to: (msgs size min: 5) do: [ :i |		s sendCommand: 'TOP ', (msgs at: i) printString, ' 0'.		header _ s getMultilineResponse.		Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr].	msgs size > 0 ifTrue: [		"get the first message"		s sendCommand: 'RETR 1'.		Transcript show: s getMultilineResponse].	Transcript show: 'closing connection'; cr.	s sendCommand: 'QUIT'.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SimpleClientSocket class methodsFor: 'POP mail example' stamp: 'tk 4/10/1998 06:47'!simpleDateString: dateString	| s |	s _ ReadStream on: dateString.	s skipTo: $,.  "scan thru first comma"	s atEnd ifTrue: [s reset].  "no comma found; reset s"	s skipSeparators.	^ (Date readFrom: s) mmddyyyy! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/17/97 14:25'!forkingRemoteCursorSender	"This is the client side of a test that sends samples of the local input sensor state to the server, which may be running on a local or remote host. This method opens the connection, then forks a process to send the cursor data. Data is sent continuously until the user clicks in a 20x20 pixel square at the top-left corner of the display. The server should be started first. Note the server's address, since this method will prompt you for it."	"SimpleClientSocket forkingRemoteCursorSender"	| sock addr stopRect |	Transcript show: 'starting remote cursor sender'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	addr _ NetNameResolver promptUserForHostAddress.	Transcript show: 'opening connection'; cr.	sock _ SimpleClientSocket new.	sock connectTo: addr port: 54323.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	stopRect _ 0@0 corner: 20@20.  "click in this rectangle to stop sending"	Display reverse: stopRect.	["the sending process"		[(stopRect containsPoint: Sensor cursorPoint) and:		 [Sensor anyButtonPressed]]			whileFalse: [				sock sendCommand: self sensorStateString.				(Delay forMilliseconds: 20) wait].		sock waitForSendDoneUntil: self standardDeadline.		sock destroy.		Transcript show: 'remote cursor sender done'; cr.		Display reverse: stopRect.	] fork.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 14:49'!parseSensorStateString: aString	"Parse the given sensor stat string and return an array whose first element is the cursor point and whose second is the cursor button state."	"SimpleClientSocket parseSensorStateString: SimpleClientSocket sensorStateString"	| s buttons x y |	s _ ReadStream on: aString.	x _ Integer readFrom: s.	s skipSeparators.	y _ Integer readFrom: s.	s skipSeparators.	buttons _ Integer readFrom: s.	^ Array with: x@y with: buttons! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 15:16'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[SimpleClientSocket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ SimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response _ sock getResponse.					response asParagraph displayOn: Display at: 10@10]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 15:16'!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"SimpleClientSocket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'opening connection'; cr.	sock1 _ SimpleClientSocket new.	sock2 _ SimpleClientSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend _ 100.	t _ Time millisecondsToRun: [		samplesSent _ 0.		done _ false.		[done]			whileFalse: [				(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [					sock1 sendCommand: self sensorStateString.					samplesSent _ samplesSent + 1].				sock2 dataAvailable ifTrue: [					sock2 getResponse asParagraph displayOn: Display at: 10@10].				done _ samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 13:11'!sensorStateString	"SimpleClientSocket sensorStateString"	| pt buttons s |	pt _ Sensor cursorPoint.	buttons _ Sensor primMouseButtons.	s _ WriteStream on: (String new: 100).	s nextPutAll: pt x printString.	s space.	s nextPutAll: pt y printString.	s space.	s nextPutAll: buttons printString.	^ s contents! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 9/17/97 14:27'!finger: userName	"SimpleClientSocket finger: 'stp'"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 79.  "finger port number"	s waitForConnectionUntil: self standardDeadline.	s sendCommand: userName.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'tk 5/4/1998 17:33'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.exploratorium.edu' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 4).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 9/17/97 14:22'!timeTest	"SimpleClientSocket timeTest"	| addr s |	addr _ NetNameResolver promptUserForHostAddress.	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 13.  "time port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SimpleClientSocket class methodsFor: 'queries' stamp: 'jm 2/26/98 09:50'!crLf	^ CrLf! !Slider subclass: #SimpleSliderMorph	instanceVariableNames: 'target arguments minVal maxVal truncate '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!SimpleSliderMorph methodsFor: 'initialization' stamp: 'jm 1/29/98 16:16'!initialize	super initialize.	target _ nil.	arguments _ EmptyArray.	minVal _ 0.0.	maxVal _ 1.0.	truncate _ false.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:17'!actionSelector	^ setValueSelector! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:17'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ setValueSelector _ nil].	setValueSelector _ aSymbolOrString asSymbol.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 16:17'!arguments	^ arguments! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 16:16'!arguments: aCollection	arguments _ aCollection asArray copy.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:41'!maxVal	^ maxVal! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:41'!maxVal: aNumber	maxVal _ aNumber.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:40'!minVal	^ minVal! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:41'!minVal: aNumber	minVal _ aNumber.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:09'!target	^ target! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:09'!target: anObject	target _ anObject! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 16:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'set action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'set minimum value' action: #setMinVal.	aCustomMenu add: 'set maximum value' action: #setMaxVal.	truncate		ifTrue: [aCustomMenu add: 'turn off truncating' action: #toggleTruncate]		ifFalse: [aCustomMenu add: 'turn on truncating' action: #toggleTruncate].	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].	target ifNotNil: [		aCustomMenu add: 'clear target' action: #clearTarget].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:08'!clearTarget	target _ nil.! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:24'!setActionSelector	| oldSel newSel |	setValueSelector == nil		ifTrue: [oldSel _ '']		ifFalse: [oldSel _ setValueSelector].	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this slider is changed'		initialAnswer: oldSel.	newSel isEmpty		ifFalse: [self actionSelector: newSel].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 16:18'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:05'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:41'!setMaxVal	| newMaxVal |	newMaxVal _ FillInTheBlank		request: 'Maximum value?'		initialAnswer: maxVal printString.	newMaxVal isEmpty ifFalse: [		maxVal _ newMaxVal asNumber.		minVal _ minVal min: maxVal].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:42'!setMinVal	| newMinVal |	newMinVal _ FillInTheBlank		request: 'Minimum value?'		initialAnswer: minVal printString.	newMinVal isEmpty ifFalse: [		minVal _ newMinVal asNumber.		maxVal _ maxVal max: minVal].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:07'!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:46'!toggleTruncate	truncate _ truncate not.! !!SimpleSliderMorph methodsFor: 'private' stamp: 'jm 1/30/98 13:17'!adjustToValue: aNumber	"Adjust the position of this slider to correspond to the given value in the range minVal..maxVal."	"Details: Internal values are normalized to the range 0..1."	self value:		(aNumber - minVal) asFloat / (maxVal - minVal).! !!SimpleSliderMorph methodsFor: 'private' stamp: 'jm 1/29/98 16:18'!setValue: newValue	"Update the target with this sliders new value."	| scaledValue |	self value: newValue.	scaledValue _ (newValue * (maxVal - minVal)) + minVal.	truncate ifTrue: [scaledValue _ scaledValue truncated].	(target ~~ nil and: [setValueSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target				perform: setValueSelector				withArguments: (arguments copyWith: scaledValue)]].! !!SimpleSliderMorph methodsFor: 'private' stamp: 'jm 1/29/98 16:18'!updateReferencesUsing: aDictionary	"Copy and update references in the arguments array during copying."	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !SimpleButtonMorph subclass: #SimpleSwitchMorph	instanceVariableNames: 'onColor offColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/30/98 14:01'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	| newState |	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		newState _ color = onColor.		target			perform: actionSelector			withArguments: (arguments copyWith: newState)].! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 15:43'!initialize	super initialize.	self borderWidth: 3.	self label: 'Toggle'.	self extent: self extent + 2.	onColor _ Color r: 1.0 g: 0.6 b: 0.6.	offColor _ Color lightGray.! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/30/98 13:58'!mouseDown: evt	oldColor _ color.! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/30/98 13:55'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [self setSwitchState: (oldColor = offColor)]		ifFalse: [self setSwitchState: (oldColor = onColor)].! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/30/98 13:58'!mouseUp: evt	(self containsPoint: evt cursorPoint)		ifTrue: [  "toggle and do action"			self setSwitchState: (oldColor = offColor).			self doButtonAction]		ifFalse: [  "restore old appearance"			self setSwitchState: (oldColor = onColor)].! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 20:18'!offColor	^ offColor! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 20:18'!offColor: aColor	offColor _ aColor.! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 20:18'!onColor	^ onColor! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 20:18'!onColor: aColor	onColor _ aColor.! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/30/98 13:51'!setSwitchState: aBoolean	aBoolean		ifTrue: [			self borderColor: #inset.			self color: onColor]		ifFalse: [			self borderColor: #raised.			self color: offColor].! !!SimpleSwitchMorph methodsFor: 'all' stamp: 'jm 1/29/98 16:15'!updateReferencesUsing: aDictionary	"Copy and update references in the arguments array during copying."	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !ServerAction subclass: #SinglePlugServerAction	instanceVariableNames: 'processBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!SinglePlugServerAction commentStamp: 'di 5/22/1998 16:37' prior: 0!When asked to process: a Web request, this ServerAction simply executes its processBlock -- the simplest possible server action. It is the responsibility of the block to send a reply: to the request.!!SinglePlugServerAction methodsFor: 'URL processing' stamp: 'mjg 11/10/97 09:00'!process: request	processBlock value: request.! !!SinglePlugServerAction methodsFor: 'accessing' stamp: 'mjg 11/10/97 09:00'!processBlock: aBlock	processBlock := aBlock.! !Morph subclass: #SketchEditorMorph	instanceVariableNames: 'hostView stampForm canvasRectangle palette currentColor ticksToDwell rotationCenter registrationPoint newPicBlock emptyPicBlock action paintingForm dimForm buff brush paintingFormPen formCanvas picToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton strokeOrigin cumRot cumMag undoBuffer lastEvent currentNib enclosingPasteUpMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!SketchEditorMorph commentStamp: 'di 5/22/1998 16:37' prior: 0!SketchEditorMorph comment:'	Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph''s registration point, rotation center, or ticksToDwell.Registration point convention:  In a GraphicFrame, reg point is relative to this image''s origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: '!!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 5/18/1998 10:10'!initializeFor: aSketchMorph inBounds: boundsToUse ofWorld: aWorldMorph	hostView _ aSketchMorph.  "Note that aSketchMorph may well be ownerless at this juncture"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: aWorldMorph viewBox origin.	palette _ aWorldMorph paintBox.	aWorldMorph addMorphFront: palette.	"Bring it in front"	aWorldMorph fullRepaintNeeded.	paintingForm _ Form extent: bounds extent 		depth: aWorldMorph assuredCanvas depth.	self dimTheWindow.	"And set up the bitBlts"	aSketchMorph ~~ nil ifTrue:		[aSketchMorph form displayOn: paintingForm 			at: (hostView bounds origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter].	palette rememberColorsFrom: paintingForm.	self resumePainting.! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 5/18/1998 10:10'!initializeFor: aSketchMorph inPasteUpMorph: aPasteUpMorph	self initializeFor: aSketchMorph inBounds: aPasteUpMorph bounds ofWorld: aPasteUpMorph world! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/31/97 15:08'!drawOn: aCanvas	"Put the painting on the display"	paintingForm ifNotNil: [		aCanvas image: paintingForm at: bounds origin]. ! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/28/97 11:49'!handlesMouseDown: evt	^ true! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 6/11/97 20:36'!initMorph	"Prepare to paint.  6/11/97 20:35 tk"! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 7/30/97 17:11'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	"verify that we are in a good state"	self verifyState.		"includes prepareToPaint and #scalingOrRotate"	undoBuffer _ paintingForm deepCopy.	"know we will draw something"	paintingFormPen place: (evt cursorPoint - bounds origin).	strokeOrigin _ evt cursorPoint.		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	action == #pickup: ifTrue: [		evt hand showTemporaryCursor: Cursor corner].	action == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 10/19/97 11:05'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| curs poly top |	super mouseEnter: evt.	top _ evt hand recipientForMouseDown: evt.	top == self ifTrue: ["none of my buttons in the way"		curs _ palette actionCursor.		evt hand showTemporaryCursor: curs			hotSpotOffset: (curs ifNil: [0@0] ifNotNil: [curs offset]).		palette getSpecial == #polygon: ifTrue:			[(poly _ self valueOfProperty: #polygon) ifNil: [^ self].			currentColor _ palette getColor.			poly color: currentColor; borderWidth: palette getNib width.			poly changed]].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'jm 5/22/1998 10:15'!mouseLeave: evt	"Revert to the normal hand cursor."	super mouseLeave: evt.	evt hand showTemporaryCursor: nil.  "back to normal"	"If this is modified to close down the SketchEditorMorph in any way, watch out for how it is called when entering a rotationButton and a scaleButton."! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 7/15/97 14:49'!mouseMove: evt	"In the middle of drawing a stroke.  6/11/97 19:51 tk"	| pt |	pt _ evt cursorPoint.	(lastEvent ~~ nil and: [pt = lastEvent cursorPoint]) ifTrue: [^ self].	self perform: action with: evt.		"Each action must do invalidRect:"	lastEvent _ evt.	false ifTrue: ["So senders will find the things performed here"		self paint: nil; fill: nil; areaFill: nil; erase: nil; pickup: nil; stamp: nil.		self rect: nil; ellipse: nil; polygon: nil; line: nil; star: nil].! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'tk 7/7/97 10:45'!mouseUp: evt	"Do nothing except those that work on mouseUp."	action == #fill: ifTrue: [		self perform: action with: evt.		"Each action must do invalidRect:"		].	action == #areaFill: ifTrue: ["old, remove it"		self perform: action with: evt.		"Each action must do invalidRect:"		].	action == #pickup: ifTrue: [		self pickupMouseUp: evt].	lastEvent _ nil.! !!SketchEditorMorph methodsFor: 'access'!currentColor	^ currentColor! !!SketchEditorMorph methodsFor: 'access'!currentColor: aColor	currentColor _ aColor.	"Caller must set the pens' color himself.  It is complicated."! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 9/2/97 16:02'!forwardDirection	"The direction object will go when issued a sent forward:.  Up iszero.  Clockwise like a compass.  From the arrow control."| bb |bb _ (self valueOfProperty: #fwdButton).^ (self center - bb vertices first) degrees - 90.0! !!SketchEditorMorph methodsFor: 'access'!hostView	^ hostView! !!SketchEditorMorph methodsFor: 'access'!painting	^ paintingForm! !!SketchEditorMorph methodsFor: 'access'!palette	^palette! !!SketchEditorMorph methodsFor: 'access'!registrationPoint	^ registrationPoint! !!SketchEditorMorph methodsFor: 'access'!registrationPoint: aPoint	registrationPoint _ aPoint! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 9/3/97 17:12'!rotationStyle^ (self valueOfProperty: #rotationStyle) ifNil: [#normal]! !!SketchEditorMorph methodsFor: 'access' stamp: 'tk 7/4/97 10:17'!save: aForm	"Save these bits.  Not to be confused with the Save command.  "	stampForm _ aForm! !!SketchEditorMorph methodsFor: 'access'!ticksToDwell	ticksToDwell == nil ifTrue: [ticksToDwell _ 1].	^ ticksToDwell! !!SketchEditorMorph methodsFor: 'access'!ticksToDwell: t	ticksToDwell _ t! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 15:31'!afterNewPicDo: goodBlock ifNoBits: badBlock	"If the user said 'Save' at the end of drawing, do this block to save the picture.goodBlock takes 2 args, the painted form and the bounding rectangle of its bits.badBlock takes no args.  "	newPicBlock _ goodBlock.	emptyPicBlock _ badBlock.! !!SketchEditorMorph methodsFor: 'start & finish'!backgroundFromUser	^ self deliverPainting: (self getPaintingStartingWith: nil at: nil).	"Caller will want to fetch (aSketchEditorMorph painting) to get one that has not been trimmed"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 4/20/97'!cancel	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	self deliverPainting: #cancel.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 15:52'!cancelOutOfPainting	self delete.	dimForm delete.	emptyPicBlock value.	"note no args to block!!"	hostView changed.	^ nil	"Tell them we cancelled"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/31/97 11:12'!deliverPainting: result	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm |	action == #areaFill: ifTrue: [palette setCurrentBrush: palette brush3a].	palette setAction: #paint:.	"Get out of odd modes"	"rot _ palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [^ self cancelOutOfPainting].	"for Morphic"	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox _ paintingForm innerPixelRectFor: 0 orNot: true.	registrationPoint ifNotNil:		[registrationPoint _ registrationPoint - newBox origin]. "relative to newForm origin"	newForm _ 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	self delete.	"so won't find me again"	dimForm delete.	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'jm 10/15/97 22:39'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans fwdButton pt toggle |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.	"Rotation and scaling handles"	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView forwardDirection direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 16:15'!getPaintingStartingWith: initialForm at: aRectangle	canvasRectangle _ bounds translateBy: self world viewBox origin.	paintingForm _ Form extent: canvasRectangle extent 		depth: self world canvas depth.	self dimTheWindow.	"And set up the bitBlts"	initialForm ~~ nil ifTrue:		["paintingForm copy: (0@0 extent: aRectangle extent) 			from: 0@0 in: initialForm form rule: Form over."		initialForm displayOn: paintingForm 			at: (aRectangle origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.			"assume they are the same depth"		"initialForm displayOn: Display 			at: (aRectangle translateBy: canvasRectangle origin) origin			clippingBox: (aRectangle translateBy: canvasRectangle origin)			rule: Form over			fillColor: nil."		].	^ self resumePainting.	! !!SketchEditorMorph methodsFor: 'start & finish'!getRepaintedBackgroundStartingWith: startingForm	"Obtain a revised background painting from the user, given that the point of departure is startingForm, to be displayed in aRectangle."	| result |	result _ self getPaintingStartingWith: startingForm at: canvasRectangle.	^ self deliverPainting: result	"Caller will want to fetch (aSketchEditorMorph painting) to get one that has not been trimmed"! !!SketchEditorMorph methodsFor: 'start & finish'!handlesMouseOver: evt	^true! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/21/97 12:26'!prepareToPaint	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode |	"Install the brush, color, (replace mode), and cursor."	specialMode _ palette getSpecial. 	currentColor  _ palette getColor.	brush _ currentNib _ palette getNib.	paintingFormPen _ Pen newOnForm: paintingForm.	stampForm _ nil.	"let go of stamp"	formCanvas _ FormCanvas on: paintingForm.	"remember to change when undo"	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		brush _ Form extent: brush extent depth: 1.		brush offset: (0@0) - (brush extent // 2).		currentNib displayOn: brush at: (0@0 - currentNib offset).		paintingFormPen sourceForm: brush.		paintingFormPen combinationRule: Form paint.		paintingFormPen color: currentColor.		currentColor isTransparent ifTrue: [			paintingFormPen combinationRule: Form erase1bitShape.			paintingFormPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep.		^ #erase:].	specialMode == #stamp: ifTrue: [		stampForm _ palette stampForm.	"keep it"		^ #stamp:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint:.	"set it to Paint"			^ self prepareToPaint].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 3/14/97'!resume	"Just came back from another window.  Keep painting.  Save the picture after.  "	^ self deliverPainting: self resumePainting! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 10/14/97 06:23'!resumePainting	"Set everything up.  Amazingly, it's all handled by verifyState!!"	"palette thumbnailOn: hostView.		not used in current paintbox"	"palette setRotation: hostView rotationStyle."	"stillScaling now will be indicated by action == #scaleOrRotate"	! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 14:14'!save	"Palette is telling us that the use wants to end the painting session.  "	Cursor blank show.	action == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"	^ self deliverPainting: #okay.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 4/3/97'!setRotations: num	"Tell the palette what number of rotations (or background) to show.  "	| key |	key _ 'ItTurns'.	"default and value for num > 1"	num == 1 ifTrue: [key _ 'JustAsIs'].	num == 18 ifTrue: [key _ 'ItTurns'].	num == 99 ifTrue: [key _ 'ToAndFro'].	num == #Background ifTrue: [key _ 'Background'].	num == #Repeated ifTrue: [key _ 'Repeated'].	palette setRotations: (palette contentsAtKey: key).! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 8/13/96'!singleImageFromUser	"Let the user paint a single image, and return an array consisting of the form and its bounding box.  "	| result |	ticksToDwell _ 1.	result _ self getPaintingStartingWith: nil at: nil.	^ self deliverPainting: result! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 9/10/97 15:34'!undo	"revert to a previous state.  "	| temp poly |	undoBuffer ifNil: [^ self beep].	"nothing to go back to"	(poly _ self valueOfProperty: #polygon) ifNotNil:		[poly delete.		self setProperty: #polygon toValue: nil.		^ self].	temp _ paintingForm.	paintingForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had byundoing again"	paintingFormPen setDestForm: paintingForm.	formCanvas _ FormCanvas on: paintingForm.	"used for lines,ovals, etc."	formCanvas _ formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	self render: bounds.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/21/97 12:31'!verifyState	"We are sure we will make a mark now.  Make sure the palette has not changed state while we were away.  If so, end this action and start another one.  6/11/97 19:52 tk  action, currentColor, brush"	"Install the brush, color, (replace mode), and cursor."	action == palette getSpecial ifFalse: [		self invalidRect: rotationButton bounds.	"snap these back"		rotationButton position: bounds topCenter - (6@0).		"later adjust by button width?"		self invalidRect: rotationButton bounds.		self invalidRect: scaleButton bounds.		scaleButton position: bounds rightCenter - ((scaleButton width)@6).		self invalidRect: scaleButton bounds.		action == #polygon: ifTrue: [self polyFreeze].		"end polygon mode"		^ action _ self prepareToPaint].	action == #paint: ifTrue: [		currentNib = palette getNib ifFalse: [			currentNib _ palette getNib.			"Change the nib on the cursor (Hand)"			"get it to one bit depth.  For speed, instead of going through 				a colorMap every time ."			brush _ Form extent: currentNib extent depth: 1.			brush offset: (0@0) - (brush extent // 2).			currentNib displayOn: brush at: (0@0 - currentNib offset).			paintingFormPen sourceForm: brush]].	action == #erase: ifFalse: [	 	currentColor = palette getColor ifFalse: [			currentColor _ palette getColor.			"Change the color of the nib on the cursor (Hand)"			paintingFormPen color: currentColor.			currentColor isTransparent 				ifTrue: [					paintingFormPen combinationRule: Form erase1bitShape.					paintingFormPen color: Color black]				ifFalse: [paintingFormPen combinationRule: Form paint]]]		ifTrue: [palette getNib width = brush width ifFalse: [self erasePrep]].	"it changed"	action == #stamp: ifTrue: [		stampForm _ palette stampForm.	"get the current form"		stampForm ifNil: [self error: 'no stamp']].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!areaFill: evt	"Find the area that is the same color as where you clicked.  Fill it with the current paint color."evt isMouseUp ifTrue: ["Only fill upon mouseUp"	Cursor execute showWhile:		[paintingForm shapeFill: self currentColor interiorPoint: evt cursorPoint - bounds origin.		self render: bounds.	"would like to only invalidate the area 				changed, but can't find out what it is."		]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 6/11/97 20:27'!brushAlphaFromGray	"Get currentNib again, (a gray-scale Form) and transform it into an alpha brush.  3/15/97 tk"	| d alphaMap this alpha colorMaker newBox smallNib |	currentNib _ palette getNib.	newBox _ currentNib innerPixelRectFor: 0 orNot: true.	"minimum size"	smallNib _ Form extent: newBox extent depth: currentNib depth.	smallNib copyBits: newBox from: currentNib at: 0@0 		clippingBox: smallNib boundingBox rule: Form over fillColor: nil."smallNib display.  newBox printString displayAt: 0@50."	d _ currentNib depth.	"usually 8"	alphaMap _ (Color cachedColormapFrom: d to: 32) copy.	"force a map to be there"	1 to: alphaMap size do: [:pixVal |		this _ Color colorFromPixelValue: pixVal-1 depth: d.		alpha _ 1.0 - this brightness.	"based on brightness"		"alpha _ alpha * 0.14 - 0.01."	"Adjust sensitivity for buffer depth"		"alpha _ alpha raisedTo: 2.0."	"Adjust sensitivity for buffer depth"		alphaMap at: pixVal 				put: ((currentColor alpha: alpha) pixelWordForDepth: 32)].		brush _ Form extent: smallNib extent depth: 32.	"brush offset: smallNib offset."	colorMaker _ BitBlt toForm: brush.	colorMaker sourceForm: smallNib; colorMap: alphaMap.	colorMaker sourceOrigin: 0@0; destOrigin: 0@0; combinationRule: Form over;		width: brush width; height: brush height; copyBits.	^ brush	! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/21/97 16:32'!clear	"wipe out all the paint"	self polyFreeze.		"end polygon mode"	paintingForm fillWithColor: Color transparent.	self invalidRect: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/28/97 14:58'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt |	ext _ (strokeOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext _ ext r].	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) abs + ww * 2.		lastEvent shiftPressed ifTrue: [oldExt _ oldExt r].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect _ Rectangle center: strokeOrigin extent: oldExt.			self restoreRect: oldRect]].	formCanvas fillOval: rect color: currentColor 		borderWidth: ww borderColor: Color black.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/2/97 09:02'!erase: evt	"Pen is set up to draw transparent squares"	self paint: evt! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/19/97 10:53'!erasePrep	"Transparent paint, square brush.  Be careful not to let this be undone by asking palette for brush and color."	| size |	size _ palette getNib width.	brush _ Form extent: size@size depth: 1.	brush offset: (0@0) - (brush extent // 2).	brush fillWithColor: Color black.	paintingFormPen sourceForm: brush.	"transparent"	paintingFormPen combinationRule: Form erase1bitShape.	paintingFormPen color: Color black.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!fill: evt	"Find the area that is the same color as where you clicked.  Fill it with the current paint color."evt isMouseUp ifTrue: ["Only fill upon mouseUp"	Cursor execute showWhile:		[paintingForm shapeFill: self currentColor interiorPoint: evt cursorPoint - bounds origin.		self render: bounds.	"would like to only invalidate the area 				changed, but can't find out what it is."		]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 22:23'!flipHoriz: evt	"Flip the image"| temp |temp _ buff deepCopy flipBy: #horizontal centerAt: buff center.temp offset: 0@0.paintingForm fillWithColor: Color transparent.temp displayOn: paintingForm at: (paintingForm center - buff center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 22:22'!flipVert: evt	"Flip the image"| temp |temp _ buff deepCopy flipBy: #vertical centerAt: buff center.temp offset: 0@0.paintingForm fillWithColor: Color transparent.temp displayOn: paintingForm at: (paintingForm center - buff center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:11'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/12/97 19:41'!line: evt	"Draw a line on the paintingForm using formCanvas aimed at it."	| rect oldRect ww now diff cor |	rect _ strokeOrigin rect: (now _ evt cursorPoint).	evt shiftPressed ifTrue:		[diff _ evt cursorPoint - strokeOrigin.		now _ strokeOrigin + (Point r: diff r degrees: (diffdegrees + 22.5 // 45 * 45)).		rect _ strokeOrigin rect: now].	ww _ palette getNib width.	lastEvent ifNotNil:		[oldRect _ strokeOrigin rect: lastEvent cursorPoint.		lastEvent shiftPressed ifTrue:			[diff _ lastEvent cursorPoint - strokeOrigin.			cor _ strokeOrigin + (Point r: diff r degrees:(diff degrees + 22.5 // 45 * 45)).			oldRect _ strokeOrigin rect: cor].		oldRect _ oldRect expandBy: ww@ww.		"Last draw will always stick out, must erase the area"		self restoreRect: oldRect].	formCanvas line: strokeOrigin to: now width: ww color: currentColor.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps'!notes	"Singleton costumes.Registration points"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!paint: evt	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  mousePoint startRect endRect |	mousePoint _ evt cursorPoint.	startRect _ paintingFormPen location + brush offset extent: brush extent.	paintingFormPen goto: mousePoint - bounds origin.	endRect _ paintingFormPen location + brush offset extent: brush extent.	"self render: (startRect merge: endRect).	Show the user what happened"	self invalidRect: ((startRect merge: endRect) translateBy: bounds origin).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/30/97 17:36'!pickup: evt	"Grab a part of the picture (or screen) and store it in a known place.  Note where we started.  Use a rubberband rectangle to show what is being selected."	| rect oldRect |	rect _ strokeOrigin rect: evt cursorPoint + (14@14).	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: oldRect].	formCanvas frameAndFillRectangle: rect fillColor: Color transparent		borderWidth: 2 borderColor: Color gray.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 10/15/97 22:41'!pickupMouseUp: evt	"Grab a part of the picture (or screen) and store it in a known place. Like Copy on the Mac menu. Then switch to the stamp tool."	| rr pp pForm ii oldRect curs |	lastEvent == nil ifFalse: [			"Last draw will stick out, must erase the area"			oldRect _ strokeOrigin rect: lastEvent cursorPoint + (14@14).			self restoreRect: oldRect].	self primaryHand showTemporaryCursor: nil.	"later get rid of this"		rr _ strokeOrigin rect: evt cursorPoint + (14@14).	pp _ rr translateBy: self world viewBox origin.	ii _ rr translateBy: (0@0) - bounds origin.	(rr intersects: bounds) ifTrue: [		pForm _ paintingForm copy: ii.		pForm primCountBits > 0 			ifTrue: []	"normal case.  Can be transparent in parts"			ifFalse: [pForm _ nil.			"Get an un-dimmed picture of other objects on the playfield"			"don't know how yet"]].	pForm ifNil: [pForm _ Form fromDisplay: pp].		"Anywhere on the screen"	palette pickupForm: pForm.	curs _ palette actionCursor.	evt hand		showTemporaryCursor: curs 		hotSpotOffset: (curs ifNil: [0@0] ifNotNil: [curs offset]).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/10/97 15:36'!polyFreeze	"A live polygon is on the painting.  Draw it into the painting anddelete it."	| poly |	(poly _ self valueOfProperty: #polygon) ifNil: [^ self].	poly drawOn: formCanvas.	poly delete.	self setProperty: #polygon toValue: nil.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 11:25'!polygon: evt	"Action is in polyVerts: from mouseDown:.  Do nothing here."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 22:04'!polyNew: evt	"Create a new polygon.  Add it to the sketch, and let the user dragits vertices around!!  Freeze it into the painting when the user choosesanother tool."	| poly |	self polyFreeze.		"any old one we were working on"	poly _ PolygonMorph new addHandles.	poly color: currentColor; borderWidth: palette getNib width;borderColor: Color black.	poly position: evt cursorPoint.	self addMorph: poly.	poly changed.	self setProperty: #polygon toValue: poly.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/21/97 12:31'!rect: evt	"While moving corner, just write on the canvas.  When done, writeon the paintingForm"	| rect within oldRect now diff cor |	rect _ strokeOrigin rect: (now _ evt cursorPoint).	evt shiftPressed ifTrue:		[diff _ evt cursorPoint - strokeOrigin.		now _ strokeOrigin +			(Point r: (diff x abs min: diff y abs)*2 degrees:(diff degrees // 90 * 90 + 45)).		rect _ strokeOrigin rect: now].	lastEvent == nil ifFalse:		[oldRect _ strokeOrigin rect: lastEvent cursorPoint.		lastEvent shiftPressed ifTrue:			[diff _ lastEvent cursorPoint - strokeOrigin.			cor _ strokeOrigin + (Point r: (diff x abs min:diff y abs)*2						degrees: (diff degrees //90 * 90 + 45)).			oldRect _ strokeOrigin rect: cor].		within _ (rect containsRect: oldRect).		within & (currentColor isTransparent not) ifFalse:			["Last draw will stick out, must erase the area"			self restoreRect: oldRect]].	formCanvas frameAndFillRectangle: rect fillColor: currentColor		borderWidth: (palette getNib width) borderColor: Color black.	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 09:14 '!render: damageRect	"Compose the damaged area again and store on the display.  damageRect is relative to paintingForm origin.  3/19/97 tk"	self invalidRect: damageRect.	"Now in same coords as self bounds""	| rect |	rect _ damageRect translateBy: composite.	just within this window	dimToComp destRect: rect; 		sourceOrigin: damageRect origin; copyBits.	picToComp destRect: rect; 		sourceOrigin: damageRect origin; copyBits.	rotationButton copyBits.	scaleButton copyBits.	compToDisplay sourceRect: rect; 		destOrigin: canvasRectangle origin + damageRect origin; copyBits."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 6/16/97 15:38'!replaceOnly: initialMousePoint	"Paint replacing only one color!!  Call this each stroke.  Also works for replacing all but one color.  "! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 7/28/97 14:56'!restoreRect: oldRect	"Restore the given rectangular area of the painting Form from the undo buffer."	formCanvas image: undoBuffer		at: oldRect origin		sourceRect: (oldRect translateBy: self topLeft negated)		rule: Form over.	self invalidRect: oldRect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!rotateBy: evt	"Left-right is rotation.  3/26/97 tk  Slider at top of window.  4/3/97 tk"| pt temp amt smooth |evt cursorPoint x - self left < 20 ifTrue: [^ self flipHoriz: evt].	"at left end flip horizontal"evt cursorPoint x - self right > -20 ifTrue: [^ self flipVert: evt].	"at right end flip vertical"pt _ evt cursorPoint - bounds center.smooth _ 2.  	"paintingForm depth > 8 ifTrue: [2] ifFalse: [1]."	"Could go back to 1 for speed"amt _ pt x abs < 12 ifTrue: [0 "detent"] ifFalse: [pt x - (12 * pt x abs // pt x)].amt _ amt * 1.8.temp _ buff rotateBy: amt magnify: cumMag smoothing: smooth.temp displayOn: paintingForm at: (paintingForm center - temp center + buff offset).rotationButton position: (evt cursorPoint x - 6) @ rotationButton position y.self render: bounds.cumRot _ amt.	"what we settled on"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 17:55 '!rotateDone: evt	"MouseUp, snap box back to center.""self render: rotationButton bounds.rotationButton position: (canvasRectangle width // 2 + composite x) @ rotationButton position y.self render: rotationButton bounds."		"Not snap back..."! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: '6/13/97 17:42 '!rotateScalePrep	"Make a source that is the paintingForm.  Work from that.  3/26/97 tk"	| newBox |	action == #scaleOrRotate ifTrue: [^ self].	"Already doing it"	paintingForm width > 120 		ifTrue: [newBox _ paintingForm innerPixelRectFor: 0 orNot: true.			"minimum size"			newBox _ newBox insetBy: 				((18 - newBox width max: 0)//2) @ ((18 - newBox height max: 0)//2) * -1]		ifFalse: [newBox _ paintingForm boundingBox].	newBox _ newBox expandBy: 1.	buff _ Form extent: newBox extent depth: paintingForm depth.	buff offset: newBox center - paintingForm center.	buff copyBits: newBox from: paintingForm at: 0@0 		clippingBox: buff boundingBox rule: Form over fillColor: nil.	"Could just run up owner chain asking colorUsed, but may not be embedded"	cumRot _ 0.0.  cumMag _ 1.0.	"start over"	action _ #scaleOrRotate.		"Only changed by mouseDown with tool in paint area"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 10/28/97 16:01'!scaleBy: evt	"up-down is scale.  3/26/97 tk  Now a slider on the right."| pt temp cy oldRect amt |pt _ evt cursorPoint - bounds center.cy _ bounds height * 0.5.oldRect _ buff boundingBox expandBy: (buff extent * cumMag / 2).amt _ pt y abs < 12 ifTrue: [1.0 "detent"] ifFalse: [pt y- (12 * pt y abs // pt x)].amt _ amt asFloat / cy + 1.0.temp _ buff rotateBy: cumRot magnify: amt smoothing: 2.cumMag > amt ifTrue: ["shrinking"	oldRect _ oldRect translateBy: (paintingForm center - oldRect center + buff offset).	paintingForm fill: (oldRect expandBy: 1@1) rule: Form over fillColor: Color transparent].temp displayOn: paintingForm at: (paintingForm center - temp center + buff offset).scaleButton position: scaleButton position x @ (evt cursorPoint y - 6).self render: bounds.cumMag _ amt.	"what we settled on"! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:11'!showDirType	"Display the proper symbol for this direction type.  rotationStyleis one of #(normal leftRight upDown none)."| rr poly |rr _ self rotationStyle.poly _ self valueOfProperty: #fwdButton.rr == #normal ifTrue: [^ poly makeBackArrow].rr == #leftRight ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0))].rr == #upDown ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (0@7) with:  polycenter + (0@7))].rr == #none ifTrue: [	poly makeNoArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0)		 with: poly center with: poly center - (0@7) with:  polycenter + (0@7))].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/7/97 17:56'!stamp: evt	"plop one copy of the user's chosen Form down."	"Check depths"	| pt |	pt _ evt cursorPoint - (stampForm extent // 2).	stampForm displayOn: paintingForm 		at: pt - bounds origin		clippingBox: paintingForm boundingBox		rule: Form paint		fillColor: nil.	self render: (pt extent: stampForm extent).! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'jm 8/2/97 14:21'!star: evt	"Draw an star from the center. "	| poly ext ww rect oldExt oldRect oldR verts pt |	ww _ palette getNib width.	ext _ (pt _ strokeOrigin - evt cursorPoint) r + ww * 2.	rect _ Rectangle center: strokeOrigin extent: ext.	ww _ palette getNib width.	lastEvent ifNotNil: [		oldExt _ (strokeOrigin - lastEvent cursorPoint) r + ww * 2.		"Last draw sticks out, must erase the area"		oldRect _ Rectangle center: strokeOrigin extent: oldExt.		self restoreRect: oldRect].	ext _ pt r.	oldR _ ext.	verts _ (0 to: 350 by: 36) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext]) degrees: angle + pt degrees)			+ strokeOrigin].		poly _ PolygonMorph new addHandles.	poly color: currentColor; borderWidth: ww; borderColor: Color black.	"self addMorph: poly."	poly privateOwner: self.	poly bounds: (strokeOrigin extent: ext).	poly setVertices: verts.	poly drawOn: formCanvas.	"poly delete."	self invalidRect: rect.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:17'!toggleDirType: evt in: handle	"Toggle from 'rotate' to 'to and fro' to 'up and down' to 'none'for the kind of rotation the object does.  An actor's rotationStyle is oneof #(normal leftRight upDown none)."| rr ii |"Clear the indicator""Find new style, store it, install the indicator"rr _ self rotationStyle.ii _ #(normal leftRight upDown none) indexOf: rr.self setProperty: #rotationStyle toValue:	(#(leftRight upDown none normal) at: ii).ii = 4 ifTrue: ["normal" self forward: self forwardDirection			direction: (self valueOfProperty: #fwdButton)]	ifFalse: [self showDirType.].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'di 12/1/97 12:13'!transBrush: evt	"Paint with a semi-transparent brush.  Call this each stroke.  , di"	|  prevP p buffSize theta brushRect buffRect delta newBuffRect updateRect scale half |	scale _ buffToPic cellSize.	"2"	buffSize _ (buff width - brush width) // scale.	"100"	half _ brush extent // 2.	"center"	"buffRect now relative to pictureForm"	buffRect _ (evt cursorPoint - bounds origin) - (buff extent // scale // 2) 		extent: buff extent // scale.	picToBuff copyQuad: buffRect innerCorners toRect: buff boundingBox.	prevP _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.	[Sensor redButtonPressed] whileTrue:		[p _ ((evt cursorPoint - bounds origin) - buffRect origin) * scale - half.				"p, prevP are rel to buff origin"		p ~= prevP ifTrue: [		(p dist: prevP) > buffSize ifTrue:			["Stroke too long to fit in buffer -- clip to buffer,				and next time through will do more of it"			theta _ (p-prevP) theta.			p _ ((theta cos@theta sin) * (buffSize-2) asFloat + prevP) truncated].		brushRect _ p extent: brush extent.		((buff boundingBox insetBy: scale) containsRect: brushRect) ifFalse:			["Brush is out of buffer region.  Scroll the buffer,				and fill new areas from the display"			delta _ (brushRect amountToTranslateWithin: 				(buff boundingBox insetBy: scale)) // scale.			buffToBuff copyFrom: buff boundingBox in: buff to: delta*scale.			newBuffRect _ buffRect translateBy: delta negated.			p _ p translateBy: delta*scale.			prevP _ prevP translateBy: delta*scale.			(newBuffRect areasOutside: buffRect) do:				[:r | picToBuff copyQuad: r innerCorners 						toRect: (r origin - newBuffRect origin*scale extent: r extent*scale)].			buffRect _ newBuffRect].		"Interpolate from prevP to p..."		brushToBuff drawFrom: prevP to: p withFirstPoint: false.		"Update only the altered pixels of the destination"		updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.		updateRect _ updateRect origin // scale * scale				corner: updateRect corner + scale // scale * scale.		"And finally store into the painting""buff displayAt: 0@0."		buffToPic copyQuad: updateRect innerCorners					toRect: (updateRect origin // scale + buffRect origin								extent: updateRect extent // scale).		prevP _ p.		self render: (updateRect origin // scale + buffRect origin										extent: updateRect extent // scale)]].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 3/26/97'!transBrushPrep	"Prepare to paint with a transparent brush at twice the resolution.  Do the work in 32-bits.  See BitBlt.alphaBlendDemo8 for details.  "	| buffSize scale cm1 cm2 |	currentColor class == Bitmap ifTrue: [currentColor _ palette getColor]. "do not force white"	brush _ self brushAlphaFromGray.	"Get currentNib again, 		(a gray-scale Form) and transform it into an alpha brush"	scale _ 3.  "Actual drawing happens at this magnification"	"Scale brush up for painting in magnified buffer"	brush _ brush magnify: brush boundingBox by: scale.	buffSize _ 100.	buff _ Form extent: (buffSize * scale) asPoint + brush extent depth: 32.  "Travelling 32-bit buffer"	picToBuff _ (WarpBlt toForm: buff)  "from Picture to buff - magnify by 2"		sourceForm: paintingForm;		combinationRule: Form over.	cm1 _ (Color cachedColormapFrom: paintingForm depth to: 32) copy.	cm1 ifNotNil: [		"map off-the-edge pixels to the background color, so blend will look right at edge"		cm1 at: 1 put: (self world color pixelValueForDepth: 32)].	picToBuff colorMap: cm1.	brushToBuff _ (BitBlt toForm: buff)  "from brush to buff"		sourceForm: brush;		sourceOrigin: 0@0;		combinationRule: Form blend.	"use buffToPic instead of paintingFormPen"	buffToPic _ (WarpBlt toForm: paintingForm)  "from buff to Picture - shrink by 2"		sourceForm: buff;		cellSize: scale;    "...and use smoothing"		combinationRule: Form over.	cm2 _ (Color cachedColormapFrom: 32 to: paintingForm depth) copy.	cm2 ifNotNil: [		"remap background color to transparent"		cm2 at: (self world color indexInMap: cm2) put: 0].	buffToPic colorMap: cm2.	buffToBuff _ BitBlt toForm: buff.  "for slewing the buffer"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SketchEditorMorph class	instanceVariableNames: ''!!SketchEditorMorph class methodsFor: 'instance creation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !Morph subclass: #SketchMorph	instanceVariableNames: 'originalForm rotationCenter rotationDegrees rotationStyle scalePoint framesToDwell rotatedForm offsetWhenRotated '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!SketchMorph methodsFor: 'initialization' stamp: 'sw 5/2/1998 15:05'!initialize	super initialize.	originalForm _ (ScriptingSystem formAtKey: 'Painting') deepCopy.	"(Form extent: 14@10 depth: 8) fillColor: Color gray."	rotationCenter _ 7@5.		"relative to the top-left corner of the Form"	rotationDegrees _ 0.0.		"clockwise angle of rotation"	rotationStyle _ #normal.		"styles: #normal, #leftRight, #upDown, or #none"	scalePoint _ 1.0@1.0.	framesToDwell _ 1.	rotatedForm _ originalForm.	"cached rotation of originalForm"	offsetWhenRotated _ 0@0.	"offset for rotated form"	self extent: originalForm extent.! !!SketchMorph methodsFor: 'accessing'!form	^ originalForm! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!form: aForm	originalForm _ aForm.	rotationCenter _ aForm extent // 2.	rotationDegrees _ 0.0.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 3/2/98 12:04'!forwardDirection	"Return the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	^ (self valueOfProperty: #forwardDirection) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 3/2/98 12:06'!forwardDirection: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) <= 0.0001		ifTrue: [self removeProperty: #forwardDirection]		ifFalse: [self setProperty: #forwardDirection toValue: degrees].! !!SketchMorph methodsFor: 'accessing'!framesToDwell	^ framesToDwell! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!framesToDwell: anInteger	framesToDwell _ anInteger.! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 3/11/98 20:33'!maxScaleFactor	^ 5! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 3/3/98 01:54'!newScaleFactor: scaleFactor previousScaleFactor: oldScaleFactor	self scalePoint: scaleFactor asPoint! !!SketchMorph methodsFor: 'accessing'!referencePosition	^ (bounds origin - offsetWhenRotated) + rotationCenter! !!SketchMorph methodsFor: 'accessing'!referencePosition: aPoint	self position: (aPoint - rotationCenter) + offsetWhenRotated.! !!SketchMorph methodsFor: 'accessing'!rotatedForm	rotatedForm ifNil: [self layoutChanged].	^ rotatedForm! !!SketchMorph methodsFor: 'accessing'!rotationCenter	^ rotationCenter! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!rotationCenter: aPoint	rotationCenter _ aPoint.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing'!rotationDegrees	^ rotationDegrees! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/8/97 16:31'!rotationDegrees: angleInDegrees	rotationDegrees ~= angleInDegrees ifTrue:		[rotationDegrees _ angleInDegrees asSmallAngleDegrees.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 11/4/97 07:42'!rotationDegrees: newRotationDegrees scalePoint: newScalePoint	((newRotationDegrees ~= rotationDegrees) or:	 [scalePoint ~= newScalePoint]) ifTrue: [		"rotationDegrees _ newRotationDegrees \\ 360.0."		rotationDegrees _ newRotationDegrees asSmallAngleDegrees.		scalePoint _ newScalePoint.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing'!rotationStyle	^ rotationStyle! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!rotationStyle: aSymbol	"Set my rotation style to #normal, #leftRight, #upDown, or #none. Styles mean:		#normal		-- continuous 360 degree rotation		#leftRight		-- quantize angle to left or right facing		#upDown		-- quantize angle to up or down facing		#none			-- do not rotate"	rotationStyle _ aSymbol.	self layoutChanged.! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint	scalePoint ifNil: [scalePoint _ 1.0@1.0].	^ scalePoint! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint: aPoint	scalePoint _ aPoint.	self layoutChanged.! !!SketchMorph methodsFor: 'drawing'!drawOn: aCanvas	aCanvas image: self rotatedForm at: bounds origin.! !!SketchMorph methodsFor: 'geometry'!containsPoint: aPoint	^ (self bounds containsPoint: aPoint) and:	  [(self rotatedForm isTransparentAt: aPoint - bounds origin) not]! !!SketchMorph methodsFor: 'geometry' stamp: 'jm 3/2/98 14:24'!extent: newExtent	"Change my scale to fit myself into the given extent."	| radians s c divisor w h origExtent |	radians _ rotationDegrees degreesToRadians.	s _ radians sin abs.	c _ radians cos abs.	divisor _ (c * c) - (s * s).	w _ ((c * newExtent x) - (s * newExtent y)) / divisor.	h _ ((c * newExtent y) - (s * newExtent x)) / divisor.	origExtent _ originalForm extent.	rotationStyle = #normal		ifTrue: [			scalePoint _				((w asFloat / origExtent x) max: 0.001) @				((h asFloat / origExtent y) max: 0.001).			divisor abs < 0.5 ifTrue: [  "avoid instability near multiples of 45 degrees"				s _ newExtent r / (origExtent r * 2 sqrt).				scalePoint _ s@s]]		ifFalse: [  "scaling for constraint rotation styles"			scalePoint _				((newExtent x max: 1) asFloat / origExtent x) @				((newExtent y max: 1) asFloat / origExtent y)].	self layoutChanged.! !!SketchMorph methodsFor: 'menu' stamp: 'sw 4/16/1998 22:43'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addPaintingItemsTo: aCustomMenu hand: aHandMorph! !!SketchMorph methodsFor: 'menu' stamp: 'sw 4/22/1998 17:29'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	self editDrawingIn: self pasteUpMorph forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'sw 5/19/1998 20:31'!editDrawingIn: aPasteUpMorph forBackground: aBoolean	| oldRotation aPaintWindow oldFwdDir w boundsToUse |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	aPaintWindow _ SketchEditorMorph new.	aBoolean ifTrue: [aPaintWindow setProperty: #background toValue: true].	w addMorphFront: aPaintWindow.	oldRotation _ rotationDegrees.	oldFwdDir _ self forwardDirection.	self rotationDegrees: 0.	aBoolean		ifTrue:			[aPaintWindow initializeFor: self inPasteUpMorph: aPasteUpMorph]		ifFalse:			[boundsToUse _ (aPasteUpMorph paintingBoundsAround: self bounds center) merge: self bounds.			aPaintWindow initializeFor: self inBounds: boundsToUse ofWorld: aPasteUpMorph world].	self rotationDegrees: oldRotation.  "while drawing is still rotated. cancel leaves it right"	aPaintWindow 		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self position: aRect origin.			self forwardDirection: aPaintWindow forwardDirection.			self rotationDegrees: oldRotation + (aPaintWindow forwardDirection - oldFwdDir).				"add in any changes"			self rotationStyle: aPaintWindow rotationStyle.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			aBoolean ifTrue: [self goBehind].  "shouldn't be necessary"			owner changed]		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil: [aPasteUpMorph standardPalette viewMorph: self]].	aPaintWindow changed.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 11/12/97 20:04'!erasePixelsOfColor: evt	| c |	c _ evt hand chooseColor.	originalForm mapColor: c to: Color transparent.	self form: (originalForm trimToPixelValue: Color transparent orNot: true).! !!SketchMorph methodsFor: 'menu' stamp: 'sw 4/2/98 15:47'!insertIntoMovie: evt	| movies aTarget |	movies _		(self world rootMorphsAt: evt hand targetOffset)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isKindOf: SketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget _ movies first.	(aTarget isKindOf: SketchMorph) ifTrue: [		aTarget _ aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 1/7/98 08:06'!recolorPixelsOfColor: evt	| c d newForm map newC |	c _ evt hand chooseColor.  "color to replace"	newC _ evt hand chooseColor.  "new color"	d _ originalForm depth.	newForm _ Form extent: originalForm extent depth: d.	map _ (Color cachedColormapFrom: d to: d) copy.	map at: (c indexInMap: map) put: (newC pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 7/24/97 15:06'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 8/2/97 14:45'!setRotationStyle	| menu newStyle |	menu _ CustomMenu new.	#('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate')		with: #(normal leftRight upDown none)		 do: [:name :action | menu add: name action: action].	newStyle _ menu startUp.	newStyle ifNotNil: [self rotationStyle: newStyle].! !!SketchMorph methodsFor: 'change reporting' stamp: 'jm 7/24/97 15:06'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	((rotationDegrees = 0.0 or: [rotationStyle = #none]) and:	 [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'sw 5/21/1998 21:44'!addOptionalHandlesTo: aHalo box: box	| aHandle |	aHandle _ aHalo addHandleAt: box rightCenter color: Color lightGray.	aHandle on: #mouseDown send: #editDrawing to: aHalo target renderedMorph! !!SketchMorph methodsFor: 'other' stamp: 'sw 8/10/97 01:12'!colorSettable	"Answer whether it is meaningful for the receiver to have its color set from outside"	^ false! !!SketchMorph methodsFor: 'other' stamp: 'jm 5/22/1998 12:50'!colorUnder	"Return the color of under the receiver's reference position."	self isInWorld		ifTrue: [^ self world colorAt: (self pointInWorld: self referencePosition) belowMorph: self]		ifFalse: [^ self color].! !!SketchMorph methodsFor: 'other' stamp: 'jm 3/2/98 12:54'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	adjustedAngle _ rotationDegrees - self forwardDirection.	((rotationStyle = #leftRight) or:	 [(rotationStyle = #upDown) or:	 [rotationStyle = #none]]) ifTrue: [adjustedAngle _ 0.0].	((adjustedAngle = 0.0) and: [0.0@0.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [			"do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + (((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: [rotationDegrees < -90.0]]) ifTrue: [		"headed down; use flipped"		rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + ((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).		^ self].! !!SketchMorph methodsFor: 'other' stamp: 'di 3/2/98 14:14'!releaseCachedState	"Clear cache of rotated, scaled Form."	super releaseCachedState.	rotatedForm _ nil.	originalForm hibernate! !!SketchMorph methodsFor: 'other' stamp: 'jm 7/24/97 15:06'!replaceSelfWithMovie	"Replace this SketchMorph in its owner with a MovieMorph containing this sketch as its only frame. This allows a SketchMorph to be turned into a MovieMorph by just insering additional frames."	| o movie |	self changed.	o _ self owner.	movie _ MovieMorph new position: self referencePosition.	movie insertFrames: (Array with: self).	o ifNil: [^ movie].	o addMorphFront: movie.	^ movie! !!SketchMorph methodsFor: 'other'!wearCostume: aMorph	"If the receiver and argument are both kinds of SketchMorph, make the receiver wear the costume of the argument. Otherwise, do nothing. This default implementation does nothing."	| p |	((aMorph isKindOf: SketchMorph) or:	 [aMorph isKindOf: MovieMorph]) ifTrue: [		self changed.		p _ self referencePosition.		originalForm _ aMorph form.		rotationCenter _ aMorph rotationCenter.		self referencePosition: p.		self layoutChanged].! !!SketchMorph methodsFor: 'object fileIn' stamp: 'jm 7/24/97 20:46'!convertbosfceorrrfro0: varDict bosfceorrrsfro0: smartRefStrm	"These variables are automatically stored into the new instance ('originalForm' 'rotationCenter' 'rotationDegrees' 'rotationStyle' 'framesToDwell' 'rotatedForm' 'offsetWhenRotated' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('scalePoint' ) and deal with the information in ()"	scalePoint _ 1.0@1.0.! !!SketchMorph methodsFor: 'pen support' stamp: 'jm 4/22/1998 17:14'!clearExtent: aPoint fillColor: aColor	"Make this sketch have the given pixel dimensions and fill it with given color. Its previous contents are replaced."	self form:		((Form extent: aPoint depth: Display depth) fillColor: aColor).! !!SketchMorph methodsFor: 'pen support' stamp: 'jm 4/22/1998 09:26'!penOnMyForm	"Support for experiments with drawing under program control. To get started, make a new SketchMorph in a morphic world. In an inspector, give it the desired pixel dimensions with clearExtent:fillColor:. Then use this method to get a pen to which you can send normal pen commands. Reveal the resulting drawing with revealPenStrokes."	^ Pen newOnForm: originalForm! !!SketchMorph methodsFor: 'pen support' stamp: 'jm 4/22/1998 09:08'!revealPenStrokes	"This message must be sent after a sequence of pen strokes to make the resulting changes visible."	rotatedForm _ nil.	self changed.! !MorphicModel subclass: #SlantedList	instanceVariableNames: 'listPane1 slider1 slider2 slider3 slider4 transform1 string1 string2 '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Models'!!SlantedList methodsFor: 'input events'!listPane1MenuButtonPressed: arg1	self confirm: 'Should the menu be slanted too?'! !!SlantedList methodsFor: 'input events'!listPane1NewSelection: arg1	string1 contents: arg1! !!SlantedList methodsFor: 'input events'!slider1Value: arg1	transform1 scale: slider1 value * 5.0 + 0.2! !!SlantedList methodsFor: 'input events'!slider2Value: arg1	transform1 offset: ((slider4 value @ slider2 value) * 400 - 200) asIntegerPoint! !!SlantedList methodsFor: 'input events'!slider3Value: arg1	transform1 angle: slider3 value - 0.5 * Float pi * 2! !!SlantedList methodsFor: 'input events'!slider4Value: arg1	transform1 offset: ((slider4 value @ slider2 value) * 400 - 200) asIntegerPoint! !MorphicModel subclass: #Slider	instanceVariableNames: 'slider value setValueSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!!Slider methodsFor: 'initialize'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderWidth := 2.	borderColor := #inset.	value _ 0.0.	self initializeSlider! !!Slider methodsFor: 'initialize'!initializeSlider	slider := RectangleMorph newBounds: self totalSliderArea color: Color veryLightGray.	slider on: #mouseStillDown send: #scrollAbsolute: to: self.	slider setBorderWidth: 2 borderColor: #raised.	self addMorph: slider.	self computeSlider.! !!Slider methodsFor: 'access'!value	^ value! !!Slider methodsFor: 'access' stamp: '6/7/97 10:42 di'!wantsSlot	"For now do it the old way, until we sort this out"	^ true! !!Slider methodsFor: 'geometry'!computeSlider	| r |	r _ self roomToMove.	slider position: (bounds isWide		ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]		ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)]).	slider extent: self sliderExtent! !!Slider methodsFor: 'geometry' stamp: 'di 5/19/1998 16:28'!extent: newExtent	newExtent = bounds extent ifTrue: [^ self].	super extent: (newExtent x max: self sliderThickness * 2)					@ (newExtent y max: self sliderThickness * 2).	self removeAllMorphs; initializeSlider! !!Slider methodsFor: 'geometry'!roomToMove	^ self totalSliderArea insetBy: (0@0 extent: self sliderExtent)! !!Slider methodsFor: 'geometry'!sliderExtent	^ bounds isWide		ifTrue: [self sliderThickness @ self innerBounds height]		ifFalse: [self innerBounds width @ self sliderThickness]! !!Slider methodsFor: 'geometry' stamp: 'jm 1/30/98 13:31'!sliderThickness	^ 7! !!Slider methodsFor: 'geometry'!totalSliderArea	^ self innerBounds! !!Slider methodsFor: 'scrolling'!scrollAbsolute: event	| r p |	r _ self roomToMove.	p _ event targetPoint adhereTo: r.	self setValue: (bounds isWide 		ifTrue: [(p x - r left) asFloat / r width]		ifFalse: [(p y - r top) asFloat / r height])! !!Slider methodsFor: 'model access'!setValue: newValue	"Called internally for propagation to model"	self value: newValue.	self use: setValueSelector orMakeModelSelectorFor: 'Value:'		in: [:sel | setValueSelector _ sel.  model perform: sel with: value]! !!Slider methodsFor: 'model access'!value: newValue	"Drive the slider position externally..."	value _ newValue min: 1.0 max: 0.0.	self computeSlider! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Slider class	instanceVariableNames: ''!!Slider class methodsFor: 'as yet unclassified' stamp: 'di 2/21/98 11:03'!includeInNewMorphMenu	"OK to instantiate"	^ true! !Integer subclass: #SmallInteger	instanceVariableNames: ''	classVariableNames: 'Digitbuffer '	poolDictionaries: ''	category: 'Numeric-Numbers'!!SmallInteger commentStamp: 'di 5/22/1998 16:38' prior: 0!SmallInteger comment:'My instances are 15 or 16-bit numbers, stored in twos complement form. The allowable range is from -16384 to 16383. You can type an instance of me in octal representation by typing a leading radix specification, such as in 8r377.'!!SmallInteger methodsFor: 'arithmetic'!* aNumber 	"Primitive. Multiply the receiver by the argument and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 9>	self = 0 ifTrue: [^0].	"This eliminates the need for a self=0 check in LargeInteger *"	^super * aNumber! !!SmallInteger methodsFor: 'arithmetic'!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 1>	^super + aNumber! !!SmallInteger methodsFor: 'arithmetic'!- aNumber 	"Primitive. Subtract the argument from the receiver and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation	whatIsAPrimitive."	<primitive: 2>	^super - aNumber! !!SmallInteger methodsFor: 'arithmetic'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber = 0 ifTrue: [^self error: 'division by 0'].	(aNumber isMemberOf: SmallInteger)		ifTrue: [^(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [^super / aNumber]! !!SmallInteger methodsFor: 'arithmetic'!// aNumber 	"Primitive. Divide the receiver by the argument and answer with the	result. Round the result down towards negative infinity to make it a	whole integer. Fail if the argument is 0 or is not a SmallInteger.	Essential. No Lookup. See Object documentation whatIsAPrimitive. "	<primitive: 12>	^super // aNumber"Do with quo: if primitive fails"! !!SmallInteger methodsFor: 'arithmetic' stamp: 'LC 4/22/1998 14:21'!gcd: anInteger 	"See SmallInteger (Integer) | gcd:"	| n m |	n _ self.	m _ anInteger.	[n = 0]		whileFalse: 			[n _ m \\ (m _ n)].	^ m abs! !!SmallInteger methodsFor: 'arithmetic'!quo: aNumber 	"Primitive. Divide the receiver by the argument and answer with the	result. Round the result down towards zero to make it a whole integer.	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^self error: 'Attempt to divide by zero'].	(aNumber isMemberOf: SmallInteger)		ifTrue: [self primitiveFailed]		ifFalse: [^super quo: aNumber]! !!SmallInteger methodsFor: 'arithmetic'!\\ aNumber 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided by	the argument Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 11>	^super \\ aNumber"Do with // if primitive fails"! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitAnd: arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 14>	self >= 0 ifTrue: [^ arg bitAnd: self].	^ (self bitInvert bitOr: arg bitInvert) bitInvert! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'di 4/30/1998 10:33'!bitOr: arg 	"Primitive. Answer an Integer whose bits are the logical OR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 15>	self >= 0 ifTrue: [^ arg bitOr: self].	^ arg < 0		ifTrue: [(self bitInvert bitAnd: arg bitInvert) bitInvert]		ifFalse: [(self bitInvert bitClear: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitShift: arg 	"Primitive. Answer an Integer whose value is the receiver's value shifted	left by the number of bits indicated by the argument. Negative arguments	shift right. The receiver is interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 17>	self >= 0 ifTrue: [^ super bitShift: arg].	^ arg >= 0		ifTrue: [(self negated bitShift: arg) negated]		ifFalse: [(self bitInvert bitShift: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitXor: arg 	"Primitive. Answer an Integer whose bits are the logical XOR of the	receiver's bits and those of the argument, arg.	Numbers are interpreted as having 2's-complement representation.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 16>	self >= 0 ifTrue: [^ arg bitXor: self].	^ arg < 0		ifTrue: [self bitInvert bitXor: arg bitInvert]		ifFalse: [(self bitInvert bitXor: arg) bitInvert]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'jm 5/1/1998 14:54'!highBit	"Answer the index of the high order bit of the receiver, or zero if the receiver is zero. Raise an error if the receiver is negative, since negative integers are defined to have an infinite number of leading 1's in 2's-complement arithmetic."	| shifted bitNo |	self < 0 ifTrue: [self error: 'highBit is not defined for negative integers'].	shifted _ self.	bitNo _ 0.	[shifted < 16] whileFalse:		[shifted _ shifted bitShift: -4.		bitNo _ bitNo + 4].	[shifted = 0] whileFalse:		[shifted _ shifted bitShift: -1.		bitNo _ bitNo + 1].	^ bitNo! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'jm 2/19/98 12:11'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 4, then single bits.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 1.	[ (n bitAnd: 16rF) = 0 ]		whileTrue: [			result := result + 4.			n := n bitShift: -4 ].	[ (n bitAnd: 1) = 0 ]		whileTrue: [			result := result + 1.			n := n bitShift: -1 ].	^ result! !!SmallInteger methodsFor: 'testing'!even	^(self bitAnd: 1) = 0! !!SmallInteger methodsFor: 'testing'!odd	^(self bitAnd: 1) = 1! !!SmallInteger methodsFor: 'comparing'!< aNumber 	"Primitive. Compare the receiver with the argument and answer with	true if the receiver is less than the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger. Essential. No Lookup. See	Object documentation whatIsAPrimitive."	<primitive: 3>	^super < aNumber! !!SmallInteger methodsFor: 'comparing'!<= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive. "	<primitive: 5>	^super <= aNumber! !!SmallInteger methodsFor: 'comparing'!= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is equal to the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive. "	<primitive: 7>	^super = aNumber! !!SmallInteger methodsFor: 'comparing'!> aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 4>	^super > aNumber! !!SmallInteger methodsFor: 'comparing'!>= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger. Optional. No Lookup.	See Object documentation whatIsAPrimitive."	<primitive: 6>	^super >= aNumber! !!SmallInteger methodsFor: 'comparing'!hash	^self! !!SmallInteger methodsFor: 'comparing'!identityHash	^self! !!SmallInteger methodsFor: 'comparing' stamp: 'di 9/27/97 20:32'!identityHashMappedBy: map	^ self! !!SmallInteger methodsFor: 'comparing'!~= aNumber 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is not equal to the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger. Essential. No Lookup. See Object	documentation whatIsAPrimitive."	<primitive: 8>	^super ~= aNumber! !!SmallInteger methodsFor: 'copying'!deepCopy! !!SmallInteger methodsFor: 'copying'!shallowCopy! !!SmallInteger methodsFor: 'converting'!adaptToFloat	"Fast conversion equivalent to self asFloat."	<primitive: 40>	self primitiveFailed! !!SmallInteger methodsFor: 'converting'!asFloat	"Primitive. Answer a Float that represents the value of the receiver.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 40>	self primitiveFailed! !!SmallInteger methodsFor: 'printing'!printOn: aStream base: b	"Refer to the comment in Integer|printOn:base:."	"SmallInteger maxVal printStringBase: 2"	| digitsInReverse x i |	self < 0 ifTrue: [		aStream nextPut: $-.		^ self negated printOn: aStream base: b.	].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	digitsInReverse _ Array new: 32.	x _ self.	i _ 0.	[x >= b] whileTrue: [		digitsInReverse at: (i _ i + 1) put: x \\ b.		x _ x // b.	].	digitsInReverse at: (i _ i + 1) put: x.	[i > 0] whileTrue: [		aStream nextPut: (Character digitValue: (digitsInReverse at: i)).		i _ i - 1.	].! !!SmallInteger methodsFor: 'system primitives'!asOop	"Answer an object pointer as an integer, return negative number for SmallInteger"	^ self! !!SmallInteger methodsFor: 'system primitives'!digitAt: n 	"Answer the value of an indexable field in the receiver. Fail if the 	argument (the index) is not an Integer or is out of bounds."	n>4 ifTrue: [^ 0].	self < 0		ifTrue: 			[self = SmallInteger minVal ifTrue:				["Can't negate minVal -- treat specially"				^ #(0 0 0 64) at: n].			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !!SmallInteger methodsFor: 'system primitives'!digitAt: n put: value 	"Fails. The digits of a small integer can not be modified."	self error: 'You cant store in a SmallInteger'! !!SmallInteger methodsFor: 'system primitives'!digitLength	"Answer the number of indexable fields in the receiver. This value is the 	same as the largest legal subscript. Included so that a SmallInteger can 	behave like a LargePositiveInteger or LargeNegativeInteger."	(self < 16r100 and: [self > -16r100]) ifTrue: [^ 1].	(self < 16r10000 and: [self > -16r10000]) ifTrue: [^ 2].	(self < 16r1000000 and: [self > -16r1000000]) ifTrue: [^ 3].	^ 4! !!SmallInteger methodsFor: 'system primitives'!instVarAt: i 	"Small integer has to be specially handled."	i = 1 ifTrue: [^self].	self error: 'argument too big for small integer instVarAt:'! !!SmallInteger methodsFor: 'private'!fromString: str radix: radix	| maxdigit c val |	maxdigit _ 		radix + (radix > 10					ifTrue: [55 - 1]					ifFalse: [48 - 1]).	val _ 0.	1 to: str size do: 		[:i | 		c _ str at: i.		(c < 48 ifFalse: [c > maxdigit])			ifTrue: [^false].		val _ val * radix + (c <= 57							ifTrue: [c - 48]							ifFalse: 								[c < 65 ifTrue: [^false].								c - 55])].	^val! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmallInteger class	instanceVariableNames: ''!!SmallInteger class methodsFor: 'class initialization'!initialize	"Initialize the digit buffer."	Digitbuffer _ Array new: 16		"SmallInteger initialize."! !!SmallInteger class methodsFor: 'instance creation'!new	self error: 'SmallIntegers can only be created by performing arithmetic'! !!SmallInteger class methodsFor: 'constants'!maxVal	"Answer the maximum value for a SmallInteger."	^ 16r3FFFFFFF! !!SmallInteger class methodsFor: 'constants'!minVal	"Answer the minimum value for a SmallInteger."	^ -16r40000000! !!SmallInteger class methodsFor: 'documentation'!guideToDivision	"Handy guide to the kinds of Integer division: 	/  exact division, returns a fraction if result is not a whole integer. 	//  returns an Integer, rounded towards negative infinity. 	\\ is modulo rounded towards negative infinity. 	quo:  truncated division, rounded towards zero."! !ReferenceStream subclass: #SmartRefStream	instanceVariableNames: 'writing structures steady reshaped renamed superclasses progressBar objCount '	classVariableNames: 'ScannedObject '	poolDictionaries: ''	category: 'System-Object Storage'!!SmartRefStream commentStamp: 'di 5/22/1998 16:38' prior: 0!SmartRefStream comment:'Ordinary ReferenceStreams cannot bring in objects whose instance variables have changed.  This class does that.  1/13/97 tk>>>>See SmartRefStream.aComment for details of how to transform incoming classes to newer versions.<<<< * Allows incoming object to have fewer instance variables than the current class.* Recognises that conversion to new versions is only done after the fact.  Nothing special needs to be done at object file write time.  Prompts for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure, which is big.  Writes triplets of (version, class structure dictionary, object) on the file.  Has methods for creating the structure description for file-out.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset ", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.Note that aDictionary has (old inst var name -> value) * There is a dispatch method to avoid N squared conversions when there are lots of old versions.  It can cascade calls on conversion methods. (not yet)* Prompts the user to write (or file in) a conversion method when needed.* (Does not use DiskProxy, DiskProxyQ, or IOWeakArray)writing		true if writing a file.  To avoid mixing next with nextPut:.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> origin corner)).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except some added on end now.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: coming from the outside.  nil if outside, a Context if 				internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file. '!!SmartRefStream methodsFor: 'all'!aComment"SmartRefStream implements the 'Seeds' object storage system.  Please see the class comment.Headlines:	To bring in an instance of a class whose instance variables have changed, you need only define one conversion method.  The method is named	convertxxxxx: aDictionary yyyyyy: aSmartRefStream.Where xxxxxx is the first letters of all the instance variables in the old instance, and yyyyy are the first letters of all instance variables in the current version of the class.  A Form has inst vars 'bits width height depth offset', so version 2 of it has version tag #bwhdo2.  If the old instance had variables 'bitMap extent depth offsetPoint textDescription', its code would be #bedot0.	Form new convertbedot0: aDictionary bwhdo3: aSmartRefStream.All you have to do is to write the method.  aDictionary has entries (old inst var name -> value), so you can fetch the old vars by name.  See SmartRefStream.catalogValues:size:.  aSmartRefStream is available so you can get at 'structures' which tells the inst vars of other old classes in this file.In the Squeak Goodies Folder, we provide an example.	Suppose there once was a file named ArrayTwoDee.  If it like Array2D in this system, but is implemented differently.  ArrayTwoDee was defined like this: (Array variableSubclass: #ArrayTwoDee instanceVariableNames: 'height '...) so it is a variable class with the array values directly in the instance.  	Array2D uses an instance var for 'contents' instead.   It has width varying most quickly, whereas the old ArrayTwoDee had height varying first.  The order of the elements must be changed.	File in the file ConvArrayTwoDee2.st.It defines SmartRefStream.arrayTwoDeeh2 to return Array2D, so we know what class to convert to.It defines Array2D.converth2:wc0: to do the actual conversion.  Look at the method.  The method 'test' has the code for actually doing the conversion:	| new2D ss |	ss _ SmartRefStream fileNamed: 'ArrayTwoDee.test.obj'.	new2D _ ss next.	ss close.	new2D class == Array2D ifFalse: [self error: 'Class conversion failed'].	(new2D atCol: 1) = #(1 2 3 4) ifFalse: [self error: 'not flipped properly'].	^ new2D	The file ArrayTwoDee.test.obj has the object data in it, and is the actual file we converted.  Note that we never had to file in the old class ArrayTwoDee.  It is never needs to be defined in our system.  	If ArrayTwoDee held an instance variable of another old class, say WeirdNumber, what form would it be in when converth2:wc0: gets run?  All objects get assigned instances in the current system before they are put into the value dictionary.  Generally, leaves of the object tree get converted first, so the values in an instance variable should be fully functioning objects in the current system."! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/15/98 20:28'!appendClassDefns	"Make this a fileOut format file.  For each UniClass mentioned, prepend its source code to the file.  Class name conflicts during reading will be resolved then.  Assume instVarInfo: has already been done."byteStream ascii.byteStream position = 0 ifTrue: [	byteStream setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	byteStream header; timeStamp].byteStream cr; nextPutAll: '!!ObjectScanner new initialize!!'; cr; cr.self uniClasesDo: [:class | class		class sharedPools size > 0 ifTrue:  "This never happens"			[class shouldFileOutPools				ifTrue: [class fileOutSharedPoolsOn: self]].		class fileOutOn: byteStream moveSource: false toFile: 0].			"UniClasses are filed out normally, no special format."	byteStream trailer.	"Does nothing for normal files.  		HTML streams will have trouble with object data"	"Append the object's raw data"	byteStream cr; cr; nextPutAll: '!!self smartRefStream!!'.	byteStream binary.		"get ready for objects"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/7/97'!catalogValues: instVarList size: varsOnDisk	"Create a dictionary of (name -> value) for the inst vars of this reshaped object.  Indexed vars as (1 -> val) etc.  "	| dict sz |	dict _ Dictionary new.	2 to: instVarList size do: [:ind |		dict at: (instVarList at: ind) put: self next].	sz _ varsOnDisk - (instVarList size - 1).	1 to: sz do: [:ii | 		dict at: ii put: self next].	"Total number read MUST be equal to varsOnDisk!!"	sz > 0 ifTrue: [dict at: #SizeOfVariablePart put: sz].	^ dict! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/26/98 10:21'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	^ Array with: 'class structure' with: structures with: 'superclasses' with: superclasses! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/15/98 19:06'!mapClass: incoming	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel nm |	nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"	cls _ Smalltalk at: nm ifAbsent: [nil].	cls ifNotNil: [^ cls]. 	"Known class.  It will know how to translate the instance."	oldVer _ self versionSymbol: (structures at: nm).	sel _ nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel _ sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			cls _ self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNotNil: [			renamed at: nm put: cls name.			^ cls].	"Never heard of it!!"	^ self writeClassRenameMethod: sel was: nm				fromInstVars: (structures at: nm).! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/6/97'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ thisContext.			writing _ false.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			writing _ #Unclassed.	"Pass 1"			object _ super next.	"all the action here"			topCall _ writing _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/11/98 15:41'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.  writing _ true. 		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream.	"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject].	"<- the real writing"					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ writing _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/15/98 20:29'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.  writing _ true. 			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject].	"<- the real writing"			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ writing _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'all' stamp: 'tk 12/9/97 21:27'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ thisContext.	writing _ false.! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/16/98 20:10'!readInstance	"Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream nextNumber: 4) - 1.	refPosn _ self getCurrentReference.	className _ self next asSymbol.	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/16/98 20:10'!readShortInst	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.1/7/97 tk	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn anObject newName newClass dict oldInstVars sel supers this |	instSize _ (byteStream next) - 1.	"one byte of size"	refPosn _ self getCurrentReference.	className _ self readShortRef.	"class symbol in two bytes of file pos"	self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName _ renamed at: className ifAbsent: [className].	newClass _ Smalltalk at: newName.	(steady includes: newClass) ifTrue: [	 	anObject _ newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject _ anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		^ anObject].	oldInstVars _ structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject _ newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict _ self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	supers _ OrderedCollection with: className.	this _ className.	[(this _ superclasses at: this) = 'nil'] whileFalse: [		supers addFirst: this].	supers do: [:aName |			sel _ reshaped at: aName ifAbsent: [nil].		sel ifNotNil: [			anObject perform: sel with: dict with: self]].	"exceptions"	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!SmartRefStream methodsFor: 'all'!renamed	^ renamed! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/10/98 11:17'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream.	ScannedObject _ self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/10/98 11:18'!setStream: aStream	"Initialize me. "	super setStream: aStream.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new].		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 5/26/97'!storeInstVarsIn: anObject from: dict	"For instance variables with the same names, store them in the new instance.  Values in variable-length part also.  This is NOT the normal inst var transfer!!  See Object.readDataFrom:size:.  This is for when inst var names have changed and some additional conversion is needed.  Here we handle the unchanged vars.  "	(anObject class allInstVarNames) doWithIndex: [:varName :index |		(dict includesKey: varName) ifTrue: [			anObject instVarAt: index put: (dict at: varName)]].	"variable part"	(dict includesKey: #SizeOfVariablePart) ifFalse: [^ anObject].	1 to: (dict at: #SizeOfVariablePart) do: [:index | 		anObject basicAt: index put: (dict at: index)].	^ anObject! !!SmartRefStream methodsFor: 'all'!structures	^ structures! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/28/97 11:17'!superclasses	^superclasses! !!SmartRefStream methodsFor: 'all' stamp: 'tk 3/15/98 20:27'!uniClasesDo: aBlock	"Examine structures and execute the block with each instance-specific class"	| cls |	structures keysDo: [:clsName | 		(cls _ Smalltalk at: clsName) isSystemDefined ifFalse: [aBlock value: cls]]! !!SmartRefStream methodsFor: 'all' stamp: 'tk 5/24/97'!verifyClass: newClass was: nm selector: sel newList: newShort oldList: oldShort	"Compare the incoming inst var name lists with the existing class.  See if the proper conversion method is present.  Works for either comparing inst vars for THIS class, or for allInstVars of the superclasses.  "	Symbol hasInterned: sel ifTrue: [:symb | reshaped at: nm put: symb].	newShort = oldShort ifFalse: ["Did change inst vars"		(reshaped includesKey: nm) ifFalse: ["No conversion method exists"				self close.				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ 'conversion method needed']]. "you need to restart the read-in"	(reshaped includesKey: nm) ifTrue: ["Symbol exists"		(newClass canUnderstand: sel asSymbol) ifFalse: ["But not in this class!!"			self close.				self writeConversionMethod: sel class: newClass was: nm						fromInstVars: oldShort to: newShort.				^ 'conversion method needed']]. "you need to restart the read-in"	"any other cases to test?"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/22/97 17:43'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "| sel newClass oldVer newList newVer oldList ans newShort oldShort sup |structures keysDo: [:nm "an old className (symbol)" |	"For missing classes, there needs to be a method in SmartRefStream like 		#rectangleoc2 that returns the new class."	newClass _ self mapClass: nm.		"does (renamed at: nm put: newClass name)"	newClass class == String ifTrue: [^ newClass].	"error, fileIn needed"	oldVer _ self versionSymbol: (structures at: nm).	newList _ (Array with: newClass classVersion), (newClass allInstVarNames).	newVer _ self versionSymbol: newList.	sel _ 'convert',oldVer,':',newVer, ':'.			"method name of conversion routine that is send after the object is created."	oldList _ structures at: nm.	superclasses ifNil: [newShort _ newList.  oldShort _ oldList]		ifNotNil: ["just compare inst vars for this class"			sup _ superclasses at: nm.			oldShort _ sup = 'nil' 				ifFalse: [oldList copyFrom: (structures at: sup) size + 1 to: oldList size]				ifTrue: [oldList copyFrom: 2 to: oldList size].			oldShort _ (Array with: (oldList at: 1)), oldShort.	"put version back".			newShort _ (Array with: newClass classVersion), (newClass instVarNames)].	newList = oldList 		ifTrue: [steady add: newClass]	"read it in as written"		ifFalse: [ans _ self verifyClass: newClass was: nm 					selector: sel newList: newShort oldList: oldShort.			ans = 'conversion method needed' ifTrue: [^ ans]]].! !!SmartRefStream methodsFor: 'all' stamp: 'tk 1/7/97'!versionSymbol: instVarList	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  "	| str |	str _ instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"	2 to: instVarList size do: [:ind |		str _ str, (instVarList at: ind) first asString].	str _ str, instVarList first printString.	"the number"	^ str" | list | list _ (Array with: Paragraph classVersion), (Paragraph alistInstVarNames).(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: list"! !!SmartRefStream methodsFor: 'all' stamp: 'tk 9/22/97 16:08'!writeClassRenameMethod: sel was: oldName fromInstVars: oldList	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "| tell choice  newName answ code |tell _ 'Reading an instance of ', oldName, '.Which modern class should it translate to?'.answ _ (PopUpMenu labels: 'Let me type the name nowLet me think about itLet me find a conversion file on the disk') startUpWithCaption: tell. answ = 1 ifTrue: [	tell _ 'Name of the modern class that ', oldName, 's should it translate to:'.	choice _ FillInTheBlank request: tell.		"class name"	(choice size = 0) 		ifTrue: [answ _ 'conversion method needed']		ifFalse: [newName _ choice.			answ _ Smalltalk at: newName asSymbol 				ifAbsent: ['conversion method needed'].			answ class == String ifFalse: [renamed at: oldName asSymbol put: answ name]]].(answ = 3) | (answ = 0) ifTrue: [self close.		^ 'conversion method needed'].answ = 2 ifTrue: [answ _ 'conversion method needed'].answ = 'conversion method needed' ifTrue: [		self close.  		newName _ 'PutNewClassHere'].code _ WriteStream on: (String new: 500).code nextPutAll: sel; cr; tab.code nextPutAll: '^ ', newName.	"Return new class"self class compile: code contents classified: 'conversion'.newName = 'PutNewClassHere' ifTrue: [	PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'.	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  	If this is true for class Foo, define classVersion in Foo class.  	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."	^ answ! !!SmartRefStream methodsFor: 'all' stamp: 'tk 4/26/97'!writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList	"No method sel was found in newClass.  Ask user to look for the fileIn.  Or help by writing a prototype conversion method.  "| tell choice code keywords newOthers oldOthers copied |newClass name = oldName 	ifTrue: [tell _ 'The class ', oldName]	ifFalse: [tell _ 'An instance of ', oldName, ' is coming in as an ', newClass name, '.  It'].tell _ tell, ' has different instance variables than before.  It needs a conversion method.  You may:'.choice _ (PopUpMenu labels: 'Find a conversion file on the disk and file it inWrite a conversion method by editing a prototype') startUpWithCaption: tell. choice = 1 ifTrue: [PopUpMenu notify: 'After filing in the conversion file, please read-in the object file again.'].	"you need to restart the read-in"choice = 2 ifTrue: [	code _ WriteStream on: (String new: 500).	keywords _ sel keywords.	code nextPutAll: (keywords at: 1); nextPutAll: ' varDict '; 			nextPutAll: (keywords at: 2); nextPutAll: ' smartRefStrm'; cr; tab.	newOthers _ newList asOrderedCollection "copy".	oldOthers _ oldList asOrderedCollection "copy".	copied _ OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code nextPutAll: '"These variables are automatically stored into the new instance '.	code nextPutAll: copied asArray printString; nextPut: $. .	code cr; tab; nextPutAll: 'This method is for additional changes.'; 		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; cr; cr; tab.	(newOthers size = 0) & (oldOthers size = 0) 		ifTrue: [code nextPutAll: '"Instance variables are the same.  Only the order changed.  This method should work as written."']		ifFalse: [code nextPutAll: '"Be sure to to fill in ', newOthers asArray printString, 			' and deal with the information in ', oldOthers asArray printString, '"'].	newClass compile: code contents classified: 'object fileIn'.	PopUpMenu notify: 'Please complete the following method and then read-in the object file again.'.	Smalltalk browseAllImplementorsOf: sel asSymbol]. 	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !!SmartRefStream methodsFor: 'all'!writing	^ writing! !!SmartRefStream methodsFor: 'conversion' stamp: 'jm 5/21/1998 06:44'!bookPageMorphbosfcepcbbfgcc0	"BookPageMorph->PasteUpMorph. For reading in old BookMorphs."	^ PasteUpMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'di 5/22/1998 15:03'!clippingMorphbosfcep0	^ PasteUpMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'jm 5/21/1998 06:44'!clippingMorphbosfcepc0	"ClippingMorph->PasteUpMorph. For reading in old BookMorphs."	^ PasteUpMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'jm 11/13/97 10:32'!gradientFillbosfcepbbfgcc0	^ GradientFillMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'di 5/21/1998 19:24'!layoutMorphbosfcepbbochvimol0	^ AlignmentMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 5/12/1998 16:18'!layoutMorphbosfcepcbbochvimol0	^ AlignmentMorph! !!SmartRefStream methodsFor: 'conversion' stamp: 'tk 9/22/97 16:30'!mouseWillPlaytgpspm0	^ EToyHolder! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmartRefStream class	instanceVariableNames: ''!!SmartRefStream class methodsFor: 'all' stamp: 'tk 12/9/97 21:31'!read: aByteStream withClasses: structureArray	"Read an object off the stream, but first check structureArray against the current system."	| me |	me _ self on: aByteStream.	me noHeader.	me structures: (structureArray at: 2).	me superclasses: (structureArray at: 4).	(me verifyStructure = 'conversion method needed') ifTrue: [^ nil].	^ super next! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	| me |	me _ self on: aByteStream.	ScannedObject _ me next.	aByteStream ascii.	aByteStream next == $!! ifFalse: [		aByteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scannedObject	"The most recently read in object.  Watch out for read-in that is interrupted and resumed.  May want to make this a dictionary?  "	^ ScannedObject! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/20/97'!scannedObject: objOrNil	"Used to free up the last object stashed here.  "	ScannedObject _ objOrNil! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/4/1998 17:34'!statsOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats in the form:	ScriptEditorMorph 51		SortedCollection (21->LayoutMorph 15->SimpleButtonMorph 9->Array 4->CompoundTileMorph 2->StringMorph )"	| dummy printOut |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	"(dummy references) is the raw data"	printOut _ dummy statisticsOfRefs.	(StringHolder new contents: printOut) 		openLabel: 'ReferenceStream statistics'.! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 3/11/98 09:45'!subObjects: anObject ofClass: aClass	"Return a collection of all instances of aClass that would be written out with anObject.  Does not actually write on the disk.  Inspect the result and ask for 'references to this object'."	| dummy coll |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	coll _ OrderedCollection new.	dummy references keysDo: [:each |		each class == aClass ifTrue: [coll add: each]].	^ coll! !!SmartRefStream class methodsFor: 'all' stamp: 'tk 5/4/1998 17:34'!tallyOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats are simply the number of instances of each class:	1450->Point   835->Rectangle   549->Array   300->String"	| dummy bag |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	bag _ Bag new.	dummy references keysDo: [:key | bag add: key class name].	"(bag sortedCounts) is the SortedCollection"	(StringHolder new contents: bag sortedCounts printString) 		openLabel: 'ReferenceStream statistics'.! !Object subclass: #Socket	instanceVariableNames: 'semaphore socketHandle '	classVariableNames: 'Connected DeadServer InvalidSocket OtherEndClosed ThisEndClosed Unconnected WaitingForConnection '	poolDictionaries: ''	category: 'System-Network'!!Socket commentStamp: 'di 5/22/1998 16:38' prior: 0!A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocols, although UDP is not yet implemented. It should be possible to support other protocols (such as AppleTalk) sockets by extending the socket primitives.Subclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.!]style[(347 4 6 3 150)f1,f1LHTTPSocket Comment;,f1,f1LFTPSocket Comment;,f1!!Socket methodsFor: 'initialize-destroy' stamp: 'jm 3/3/98 12:39'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isValid ifTrue: [self primSocketDestroy: socketHandle].			Smalltalk unregisterExternalObject: semaphore.			socketHandle _ nil.			semaphore _ nil].! !!Socket methodsFor: 'initialize-destroy' stamp: 'jm 5/13/1998 14:30'!initialize	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex |	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: 0			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil].! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!localAddress	^ self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:33'!localPort	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 3/13/98 12:11'!peerName	"Return the name of the host I'm connected to, or nil if its name isn't known to the domain name server or the request times out."	"Note: Slow. Calls the domain name server, taking up to 20 seconds to time out. Even when sucessful, delays of up to 13 seconds have been observed during periods of high network load." 	^ NetNameResolver		nameForAddress: self remoteAddress		timeout: 20! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remoteAddress	^ self primSocketRemoteAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'jm 9/17/97 14:34'!remotePort	^ self primSocketRemotePort: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:27'!dataAvailable	"Return true if this socket has unread received data."	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:27'!isConnected	"Return true if this socket is connected."	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'queries' stamp: 'jm 3/2/98 17:26'!isUnconnected	"Return true if this socket is connected."	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!Socket methodsFor: 'queries' stamp: 'jm 11/4/97 07:15'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle ifNil: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'queries' stamp: 'jm 11/4/97 07:15'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle ifNil: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'queries' stamp: 'jm 3/10/98 11:49'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!Socket methodsFor: 'queries' stamp: 'jm 9/11/97 20:28'!sendDone	"Return true if the most recent send operation on this socket has completed."	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 9/17/97 16:10'!statusString	"Return a string describing the status of this socket."	| status |	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'connection open/close' stamp: 'jm 9/11/97 20:29'!close	"Close this connection gracefully. For TCP, this sends a close request, but the stream remains open until the other side also closes it."	self primSocketCloseConnection: socketHandle.  "close this end"! !!Socket methodsFor: 'connection open/close' stamp: 'jm 11/4/97 07:15'!closeAndDestroy	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	self closeAndDestroy: 20.! !!Socket methodsFor: 'connection open/close' stamp: 'jm 3/9/98 19:09'!closeAndDestroy: timeoutSeconds	"First, try to close this connection gracefully. If the close attempt fails or times out, abort the connection. In either case, destroy the socket. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil		ifFalse: [			self isConnected ifTrue: [				self close.  "close this end"				(self waitForDisconnectionUntil: (Socket deadlineSecs: timeoutSeconds))					ifFalse: [						"if the other end doesn't close soon, just abort the connection"						self primSocketAbortConnection: socketHandle]].			self destroy].! !!Socket methodsFor: 'connection open/close'!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'connection open/close' stamp: 'jm 3/10/98 11:56'!disconnect	"Break this connection, no matter what state it is in. Data that has been sent but not received will be lost."	self primSocketAbortConnection: socketHandle.! !!Socket methodsFor: 'connection open/close'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/15/97 12:22'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf _ String new: 10000.	totalBytesDiscarded _ 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded _			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!Socket methodsFor: 'sending-receiving' stamp: 'go 9/29/97 15:44'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'getData timeout'].	buf _ String new: 2000.	bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'sending-receiving'!readInto: aStringOrByteArray startingAt: aNumber	"Read data into the given buffer starting at the given index and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'receive timeout'].	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size - aNumber + 1! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/15/97 12:21'!receiveDataInto: aStringOrByteArray	"Receive data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/17/97 16:00'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	| bytesSent bytesToSend count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (Socket deadlineSecs: 20))			ifFalse: [self error: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 9/17/97 15:55'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and return the number of bytes actually sent."	"Note: This operation may have to be repeated many times to send a large amount of data."	| bytesSent |	(self waitForSendDoneUntil: (Socket deadlineSecs: 20))		ifTrue: [			bytesSent _ self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: 1				count: aStringOrByteArray size]		ifFalse: [self error: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'waiting' stamp: 'jm 3/2/98 18:15'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status _ self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:05'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	dataArrived _ self primSocketReceiveDataAvailable: socketHandle.	[dataArrived not and:	 [self isConnected and:	 [Time millisecondClockValue < deadline]]] whileTrue: [		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		dataArrived _ self primSocketReceiveDataAvailable: socketHandle].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:06'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method."	| extraBytes status |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [status = ThisEndClosed]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'jm 9/15/97 17:06'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	sendDone _ self primSocketSendDone: socketHandle.	[sendDone not and:	 [self isConnected and:	 [Time millisecondClockValue < deadline]]] whileTrue: [		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		sendDone _ self primSocketSendDone: socketHandle].	^ sendDone! !!Socket methodsFor: 'primitives'!primSocket: socketID connectTo: hostAddress port: port	"Attempt to establish a connection to the given port of the given host. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 217>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID listenOn: port	"Listen for a connection on the given port. This is an asynchronous call; query the socket status to discover if and when the connection is actually completed."	<primitive: 218>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 221>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocket: socketID sendData: aStringOrByteArray startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive: 223>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketAbortConnection: socketID	"Terminate the connection on the given port immediately without going through the normal close sequence. This is an asynchronous call; query the socket status to discover if and when the connection is actually terminated."	<primitive: 220>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketCloseConnection: socketID	"Close the connection on the given port. The remote end is informed that this end has closed and will do no further sends. This is an asynchronous call; query the socket status to discover if and when the connection is actually closed."	<primitive: 219>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'jm 9/17/97 14:45'!primSocketConnectionStatus: socketID	"Return an integer reflecting the connection status of this socket. For a list of possible values, see the comment in the 'initialize' method of this class. If the primitive fails, return a status indicating that the socket handle is no longer valid, perhaps because the Squeak image was saved and restored since the socket was created. (Sockets do not survive snapshots.)"	<primitive: 211>	^ InvalidSocket! !!Socket methodsFor: 'primitives' stamp: 'jm 3/9/98 17:39'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	unreliable datagram socket (UDP if the protocol is IP) [NOTE: UDP is not yet implemented]		1	reliable stream socket (TCP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 209>	^ nil  "socket creation failed"! !!Socket methodsFor: 'primitives'!primSocketDestroy: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted."	<primitive: 210>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketError: socketID	"Return an integer encoding the most recent error on this socket. Zero means no error."	<primitive: 212>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketLocalAddress: socketID	"Return the local host address for this socket."	<primitive: 213>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketLocalPort: socketID	"Return the local port for this socket, or zero if no port has yet been assigned."	<primitive: 214>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'jm 9/11/97 20:22'!primSocketReceiveDataAvailable: socketID	"Return true if data may be available for reading from the current socket."	<primitive: 222>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketRemoteAddress: socketID	"Return the remote host address for this socket, or zero if no connection has been made."	<primitive: 215>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketRemotePort: socketID	"Return the remote port for this socket, or zero if no connection has been made."	<primitive: 216>	self primitiveFailed! !!Socket methodsFor: 'primitives'!primSocketSendDone: socketID	"Return true if there is no send in progress on the current socket."	<primitive: 224>	self primitiveFailed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Socket class	instanceVariableNames: ''!!Socket class methodsFor: 'class initialization' stamp: 'jm 9/17/97 14:42'!initialize	"Socket initialize"	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.! !!Socket class methodsFor: 'instance creation' stamp: 'jm 2/26/98 09:16'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'jm 2/26/98 09:29'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	^ super new initialize! !!Socket class methodsFor: 'network initialization' stamp: 'jm 3/9/98 13:13'!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection."	"Socket ensureNetworkConnected"	Socket initializeNetwork.	Utilities		informUser: 'Contacting domain name server...'		during: [			NetNameResolver				addressForName: 'bogusNameToForceDNSToBeConsulted.org'				timeout: 30].! !!Socket class methodsFor: 'network initialization' stamp: 'jm 3/9/98 13:13'!initializeNetwork	"Initialize the network drivers and the NetNameResolver. Do nothing if the network is already initialized."	"Note: The network must be re-initialized every time Squeak starts up, so applications that persist across snapshots should be prepared to re-initialize the network as needed. Such applications should call 'Socket initializeNetwork' before every network transaction. "	NetNameResolver initializeNetworkIfFail:		[self error: 'Cannot open network; is it connected?'].! !!Socket class methodsFor: 'network initialization' stamp: 'jm 3/9/98 13:15'!initializeNetworkIfFail: failBlock	"Initialize the network drivers. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails, perhaps because this computer isn't currently connected to a network."	NetNameResolver initializeNetworkIfFail: failBlock.! !!Socket class methodsFor: 'tests' stamp: 'jm 11/4/97 08:25'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"Socket loopbackTest"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes |	Transcript cr; show: 'starting loopback test'; cr.	Transcript show: '---------- Connecting ----------'; cr.	Socket initializeNetwork.	sock1 _ Socket new.	sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 5000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				bytesSent _ bytesSent + (sock1 sendSomeData: sendBuf)].			sock2 dataAvailable ifTrue: [				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].	Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnectedOrInvalid) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnectedOrInvalid) ifFalse: [self error: 'sock2 not closed'].	Transcript show: '---------- Connection Closed ----------'; cr.	sock1 destroy.	sock2 destroy.	Transcript show: 'loopback test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'tests' stamp: 'sw 5/8/1998 12:45'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	Socket initializeNetwork.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'create.ucsb.edu'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', serverName].	sock _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [		sock destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend _ 100000.	sendBuf _ String new: 5000 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendSomeData: sendBuf)]]].	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:54'!deadServer	^ DeadServer! !!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:56'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer _ aStringOrNil! !!Socket class methodsFor: 'utilities' stamp: 'jm 9/15/97 06:56'!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	^ Time millisecondClockValue + (secs * 1000)! !!Socket class methodsFor: 'utilities' stamp: 'jm 9/15/97 06:56'!standardDeadline	"Return a default deadline time some seconds into the future."	^ self deadlineSecs: 45! !OrderedCollection subclass: #SortedCollection	instanceVariableNames: 'sortBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Sequenceable'!!SortedCollection commentStamp: 'di 5/22/1998 16:38' prior: 0!NewSortedCollection comment:'I represent a collection of objects ordered by some property of the objects themselves. The ordering is specified in a BlockContext.'!!SortedCollection methodsFor: 'accessing'!at: anInteger put: anObject 	"Storing into a SortedCollection with at:put: is not allowed."	self error: 'to add to a sorted collection, you must use add:'! !!SortedCollection methodsFor: 'accessing'!sortBlock	"Answer the blockContext which is the criterion for sorting elements of 	the receiver."	^sortBlock! !!SortedCollection methodsFor: 'accessing'!sortBlock: aBlock 	"Make the argument, aBlock, be the criterion for ordering elements of the 	receiver."	sortBlock _ aBlock fixTemps.	"The sortBlock must copy its home context, so as to avoid circularities!!"	"Therefore sortBlocks with side effects may not work right"	self size > 0 ifTrue: [self reSort]! !!SortedCollection methodsFor: 'comparing'!= aSortedCollection	"Answer true if my and aSortedCollection's species are the same,	and if our blocks are the same, and if our elements are the same."	self species = aSortedCollection species ifFalse: [^ false].	sortBlock = aSortedCollection sortBlock		ifTrue: [^ super = aSortedCollection]		ifFalse: [^ false]! !!SortedCollection methodsFor: 'copying'!copy	| newCollection |	newCollection _ self species sortBlock: sortBlock.	newCollection addAll: self.	^newCollection! !!SortedCollection methodsFor: 'copying'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^SortedCollection sortBlock: sortBlock! !!SortedCollection methodsFor: 'adding'!add: newObject	| nextIndex |	self isEmpty ifTrue: [^self addLast: newObject].	nextIndex _ self indexForInserting: newObject.	self insert: newObject before: nextIndex.	^newObject! !!SortedCollection methodsFor: 'adding'!addAll: aCollection	aCollection size > (self size // 3)		ifTrue: 			["Faster to add the new elements and resort"			aCollection do: [:each | self addLast: each].			self reSort]		ifFalse: ["Faster to add the elements individually in their proper places"			aCollection do: [:each | self add: each]]! !!SortedCollection methodsFor: 'enumerating'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection _ OrderedCollection new.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection! !!SortedCollection methodsFor: 'private'!indexForInserting: newObject	| index low high |	low _ firstIndex.	high _ lastIndex.	[index _ high + low // 2.	low > high]		whileFalse: 			[(sortBlock value: (array at: index) value: newObject)				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]].	^low! !!SortedCollection methodsFor: 'private'!reSort	self sort: firstIndex to: lastIndex! !!SortedCollection methodsFor: 'private'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	(sortBlock value: di value: dj) "i.e., should di precede dj?"		ifFalse: 			[array swap: i with: j.			 tt _ di.			 di _ dj.			 dj _ tt].	n > 2		ifTrue:  "More than two elements."			[ij _ (i + j) // 2.  "ij is the midpoint of i and j."			 dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (sortBlock value: di value: dij) "i.e. should di precede dij?"			   ifTrue: 				[(sortBlock value: dij value: dj) "i.e., should dij precede dj?"				  ifFalse: 					[array swap: j with: ij.					 dij _ dj]]			   ifFalse:  "i.e. di should come after dij"				[array swap: i with: ij.				 dij _ di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k _ i.				 l _ j.				 [[l _ l - 1.  k <= l and: [sortBlock value: dij value: (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k _ k + 1.  k <= l and: [sortBlock value: (array at: k) value: dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self sort: i to: l.				self sort: k to: j]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SortedCollection class	instanceVariableNames: ''!!SortedCollection class methodsFor: 'instance creation'!new: anInteger 	"The default sorting function is a <= comparison on elements."	^(super new: anInteger) sortBlock: [:x :y | x <= y]! !!SortedCollection class methodsFor: 'instance creation'!sortBlock: aBlock 	"Answer an instance of me such that its elements are sorted according to 	the criterion specified in aBlock."	^(super new: 10) sortBlock: aBlock! !ArrayedCollection variableWordSubclass: #SoundBuffer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:00'!monoSampleCount	"Return the number of monaural 16-bit samples that fit into this SoundBuffer."	^ super size * 2! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:28'!size	"Return the number of 16-bit sound samples that fit in this sound buffer. To avoid confusion, it is better to get the size of SoundBuffer using monoSampleCount or stereoSampleCount."	^ self monoSampleCount! !!SoundBuffer methodsFor: 'accessing' stamp: 'jm 9/17/97 13:01'!stereoSampleCount	"Return the number of stereo slices that fit into this SoundBuffer. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ super size! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index	"Return the 16-bit integer value at the given index of the receiver."	<primitive: 143>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber ifTrue: [^ self at: index truncated].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/17/97 13:03'!at: index put: value	"Store the given 16-bit integer at the given index in the receiver."	<primitive: 144>	index isInteger		ifTrue: [			(index >= 1 and: [index <= self size])				ifTrue: [self errorImproperStore]				ifFalse: [self errorSubscriptBounds: index]].	index isNumber ifTrue: [^ self at: index truncated put: value].	self errorNonIntegerIndex.! !!SoundBuffer methodsFor: 'primitives' stamp: 'jm 9/2/97 16:07'!primFill: aPositiveInteger	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays."	"Note: Since 16-bit word arrays are not built into the virtual machine, this primitive fills by 32-bit words."	<primitive: 145>	self errorImproperStore.! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfFirstSampleOver: threshold	"Return the index of the first sample whose absolute value is over the given threshold value. Return an index one greater than my size if no sample is over the threshold."	1 to: self size do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ self size + 1! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!indexOfLastSampleOver: threshold	"Return the index of the last sample whose absolute value is over the given threshold value. Return zero if no sample is over the threshold."	self size to: 1 by: -1 do: [:i |		(self at: i) abs > threshold ifTrue: [^ i]].	^ 0! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!normalized: percentOfFullVolume	"Increase my amplitudes so that the highest peak is the given percent of full volume. For example 's normalized: 50' would normalize to half of full volume."	| peak s mult |	peak _ 0.	1 to: self size do: [:i |		s _ (self at: i) abs.		s > peak ifTrue: [peak _ s]].	mult _ (32767.0 * percentOfFullVolume) / (100.0 * peak).	1 to: self size do: [:i | self at: i put: (mult * (self at: i)) asInteger].! !!SoundBuffer methodsFor: 'utilities' stamp: 'jhm 10/15/97 15:13'!trimmedThreshold: threshold	| start end |	start _ self indexOfFirstSampleOver: threshold.	end _  self indexOfLastSampleOver: threshold.	start > end ifTrue: [^ SoundBuffer new].	start _ (start - 200) max: 1.	end _ (end + 200) min: self size.	^ self copyFrom: start to: end! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundBuffer class	instanceVariableNames: ''!!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:39'!fromArray: anArray	"Return a new SoundBuffer whose contents are copied from the given Array or ByteArray."	| new |	new _ SoundBuffer newMonoSampleCount: anArray size.	1 to: anArray size do: [:i | new at: i put: (anArray at: i)].	^ new! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 13:25'!new: anInteger	"See the comment in newMonoSampleCount:. To avoid confusion, it is best to create new instances using newMonoSampleCount: or newStereoSampleCount:."	^ self newMonoSampleCount: anInteger! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:44'!newMonoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of monaural samples (i.e., 16-bit words)."	"Details: The size is rounded up to an even number, since the underlying representation is in terms of 32-bit words."	^ self basicNew: (anInteger + 1) // 2! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 9/17/97 12:52'!newStereoSampleCount: anInteger	"Return a SoundBuffer large enough to hold the given number of stereo slices. A stereo 'slice' consists of two 16-bit samples, one for each channel."	^ self basicNew: anInteger! !AlignmentMorph subclass: #SoundDemoMorph	instanceVariableNames: 'soundColumn '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!SoundDemoMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:10'!initialize	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ #spaceFill.	vResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self borderWidth: 2.	self addMorph: self makeControls.	soundColumn _ AlignmentMorph newColumn.	soundColumn openToDragNDrop: true.	self addMorphBack: soundColumn.	self extent: 118@150.! !!SoundDemoMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:10'!makeControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: 'V1';			actionSelector: #playV1).	r addMorphBack: (b fullCopy label: 'V2';			actionSelector: #playV2).	r addMorphBack: (b fullCopy label: 'V3';			actionSelector: #playV3).	r addMorphBack: (b fullCopy label: 'All';			actionSelector: #playAll).	r addMorphBack: (b fullCopy label: 'Stop';		actionSelector: #stopSound).	^ r! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 12/17/97 17:13'!playAll	| snd |	soundColumn submorphs size < 1 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 1).	snd _ SampledSound bachFugueVoice1On: SampledSound new.	soundColumn submorphs size >= 2 ifTrue: [		self setTimbreFromTile: (soundColumn submorphs at: 2).		snd _ snd + (AbstractSound bachFugueVoice2On: SampledSound new)].	soundColumn submorphs size >= 3 ifTrue: [		self setTimbreFromTile: (soundColumn submorphs at: 3).		snd _ snd + (AbstractSound bachFugueVoice3On: SampledSound new)].	snd play.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 2/19/98 15:53'!playV1	soundColumn submorphs size < 1 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 1).	(SampledSound bachFugueVoice1On: SampledSound new) play.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 2/19/98 15:54'!playV2	soundColumn submorphs size < 2 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 2).	(SampledSound bachFugueVoice2On: SampledSound new)		playSilentlyUntil: 4.8;		resumePlaying.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 2/19/98 15:55'!playV3	soundColumn submorphs size < 3 ifTrue: [^ self].	self setTimbreFromTile: (soundColumn submorphs at: 3).	(AbstractSound bachFugueVoice3On: SampledSound new)		playSilentlyUntil: 14.4;		resumePlaying.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!setTimbreFromTile: aSoundTile	SampledSound defaultSampleTable: aSoundTile sound samples.	SampledSound nominalSamplePitch: 400.! !!SoundDemoMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:09'!stopSound	SoundPlayer shutDown.! !RectangleMorph subclass: #SoundLoopMorph	instanceVariableNames: 'samplesUntilNextControl seqSound cursor controlIndex '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!addCursorMorph	self addMorph:		(cursor _ (RectangleMorph				newBounds: (self innerBounds topLeft extent: 1@self innerBounds height)				color: Color red)						borderWidth: 0)! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!allowSubmorphExtraction	^ true! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 1/5/98 17:31'!buildSound	"Build a compound sound for the next iteration of the loop."	| mixer soundMorphs startTime pan |	mixer _ MixedSound new.	mixer add: (RestSound dur: (self width - (2 * borderWidth)) / 128.0).	soundMorphs _ self submorphs select: [:m | m respondsTo: #sound].	soundMorphs do: [:m |		startTime _ (m position x - (self left + borderWidth)) / 128.0.		pan _ (m position y - (self top + borderWidth)) asFloat / (self height - (2 * borderWidth) - m height).		mixer add: ((RestSound dur: startTime), m sound copy) pan: pan].	^ mixer! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!extent: newExtent	super extent: (newExtent truncateTo: 128@128) + (self borderWidth*2)! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!initialize	super initialize.	borderWidth _ 1.	bounds _ 0@0 corner: (128@128) + (borderWidth*2).	color _ Color lightBlue.	controlIndex _ 0.	self addCursorMorph! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!play	"Play this sound to the sound ouput port in real time."	self reset.	SoundPlayer playSound: self.! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!stop	"Stop playing this sound."	SoundPlayer pauseSound: self.! !!SoundLoopMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:11'!wantsDroppedMorph: aMorph event: evt	^ aMorph respondsTo: #sound! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!controlRate	"Answer the number of control changes per second."	^ 32! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!doControl	seqSound doControl.	controlIndex _ controlIndex + 1.	controlIndex >= (self controlRate * (self innerBounds width // 128))		ifTrue: [controlIndex _ 0].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/5/98 13:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Repeatedly play my sounds."	| i count samplesNeeded |	i _ startIndex.	samplesNeeded _ n.	[samplesNeeded > 0] whileTrue: [		count _ seqSound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			self reset.			count _ seqSound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		seqSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i _ i + count.		samplesNeeded _ samplesNeeded - count].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/26/98 22:05'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just index of after last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!positionCursor	| x |	x _ controlIndex * 128 // self controlRate.	cursor position: self innerBounds topLeft + (x@0)! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!reset	"Reset my internal state for a replay."	seqSound _ self buildSound reset.	samplesUntilNextControl _ (self samplingRate // self controlRate).	controlIndex _ 0.	self positionCursor! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:11'!samplesRemaining	^ 1000000! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:11'!samplingRate	"Answer the sampling rate in samples per second."	^ SoundPlayer samplingRate! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!step	self positionCursor! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!stepTime	^ 50! !ImageMorph subclass: #SoundMorph	instanceVariableNames: 'sound '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!buildImage	| scale env h imageColor |	owner ifNil: [scale _ 128@128]  "Default is 128 pix/second, 128 pix fullscale"		ifNotNil: [scale _ owner soundScale].	env _ sound volumeEnvelopeScaledTo: scale.	self image: (ColorForm extent: env size @ env max).	1 to: image width do:		[:x | h _ env at: x.		image fillBlack: ((x-1)@(image height-h//2) extent: 1@h)].	imageColor _ #(black red orange green blue) atPin:						(sound pitch / 110.0) rounded highBit.	image colors: (Array with: Color transparent with: (Color perform: imageColor)).! !!SoundMorph methodsFor: 'all' stamp: 'jm 12/17/97 22:43'!initialize	super initialize.	self sound: (FMSound pitch: 880.0 dur: 0.2 loudness: 0.8).! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!justDroppedInto: aMorph event: anEvent	| relPosition |	relPosition _ self position - aMorph innerBounds topLeft.	relPosition _ (relPosition x roundTo: 8) @ relPosition y.	self position: aMorph innerBounds topLeft + relPosition.	sound copy play! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!reset	sound reset! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!sound	^ sound! !!SoundMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!sound: aSound	sound _ aSound copy.	sound reset.	self buildImage! !Object subclass: #SoundPlayer	instanceVariableNames: ''	classVariableNames: 'ActiveSounds Buffer BufferIndex BufferMSecs PlayerProcess PlayerSemaphore ReadyForBuffer ReverbState SamplingRate SoundJustStarted Stereo UseReadySemaphore UseReverb '	poolDictionaries: ''	category: 'System-Sound'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundPlayer class	instanceVariableNames: ''!!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 5/3/1998 10:12'!initialize	"SoundPlayer initialize"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothing, especially during other activities. If it is too high, there will be an overly long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. It is typically in the range 50-200."	"SoundPlayer initialize; shutDown; startUp"	SamplingRate _ 22050.	BufferMSecs _ 200.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 1/27/98 09:28'!reverbState	^ ReverbState! !!SoundPlayer class methodsFor: 'accessing'!samplingRate	^ SamplingRate! !!SoundPlayer class methodsFor: 'accessing'!stereo	^ Stereo! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 5/8/1998 18:48'!shutDown	"Stop player process, for example before snapshotting."	self stopPlayerProcess.	ReverbState _ nil.! !!SoundPlayer class methodsFor: 'snapshotting' stamp: 'jm 7/11/97 12:17'!startUp	"Start up the player process."	SoundPlayer initialize.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 5/22/1998 11:36'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	SoundRecorder canRecordWhilePlaying ifTrue: [^ true].	SoundRecorder allInstancesDo: [:rec | rec isActive ifTrue: [^ false]].	^ true! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 8/23/97 20:38'!pauseSound: aSound	"Stop playing the given sound. Playing can be resumed from this point later."	PlayerSemaphore critical: [		ActiveSounds remove: aSound ifAbsent: []].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:47'!playSound: aSound	"Reset and start playing the given sound from its beginning."	aSound reset.	self resumePlaying: aSound.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 2/1/98 20:10'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	| quickStart |	Preferences disableSounds ifTrue: [^ self].	quickStart _ true.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp. quickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [quickStart _ false]			ifFalse: [				quickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	quickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 1/27/98 09:47'!stopPlayingAll	"Stop playing all sounds."	PlayerSemaphore critical: [		ActiveSounds _ ActiveSounds species new].! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/13/97 19:49'!waitUntilDonePlaying: aSound	"Wait until the given sound is no longer playing."	[PlayerSemaphore critical: [ActiveSounds includes: aSound]]		whileTrue: [(Delay forMilliseconds: 100) wait].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/29/98 18:56'!isReverbOn	^ ReverbState ~~ nil! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/26/98 22:23'!oldStylePlayLoop	"This version of the play loop is used if the VM does not yet support sound primitives that signal a semaphore when a sound buffer becomes available."	| bytesPerSlice count |	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [(Delay forMilliseconds: 1) wait].		count _ count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted _ nil]].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/26/98 22:24'!playLoop	"The sound player process loop."	| bytesPerSlice count |	bytesPerSlice _ Stereo ifTrue: [4] ifFalse: [2].	[true] whileTrue: [		[(count _ self primSoundAvailableBytes // bytesPerSlice) > 100]			whileFalse: [ReadyForBuffer wait].		count _ count min: Buffer stereoSampleCount.		PlayerSemaphore critical: [			ActiveSounds _ ActiveSounds select: [:snd | snd samplesRemaining > 0].			ActiveSounds do: [:snd |				snd ~~ SoundJustStarted ifTrue: [					snd playSampleCount: count into: Buffer startingAt: 1]].			ReverbState == nil ifFalse: [				ReverbState applyReverbTo: Buffer startingAt: 1 count: count].			self primSoundPlaySamples: count from: Buffer startingAt: 1.			Buffer primFill: 0.			SoundJustStarted _ nil]].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/27/98 09:43'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	ActiveSounds _ OrderedCollection new.	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/27/98 09:42'!startReverb	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.15 0.09).! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 9/17/97 20:31'!stopPlayerProcess	"Stop the sound player process."	"SoundPlayer stopPlayerProcess"	PlayerProcess == nil ifFalse: [PlayerProcess terminate].	PlayerProcess _ nil.	self primSoundStop.	ActiveSounds _ OrderedCollection new.	Buffer _ nil.	PlayerSemaphore _ Semaphore forMutualExclusion.	ReadyForBuffer ifNotNil:		[Smalltalk unregisterExternalObject: ReadyForBuffer].	ReadyForBuffer _ nil.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 1/27/98 09:43'!stopReverb	UseReverb _ false.	ReverbState _ nil.! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/13/97 20:01'!boinkPitch: p dur: d loudness: l waveTable: waveTable pan: pan	"Play a decaying note on the given stream using the given wave table. Used for testing only."	| decay tableSize amplitude increment cycles i |	decay _ 0.96.	tableSize _ waveTable size.	amplitude _ l asInteger min: 1000.	increment _ ((p asFloat * tableSize asFloat) / SamplingRate asFloat) asInteger.	increment _ (increment max: 1) min: (tableSize // 2).	cycles _ (d * SamplingRate asFloat) asInteger.	i _ 1.	1 to: cycles do: [:cycle |		(cycle \\ 100) = 0			ifTrue: [amplitude _ (decay * amplitude asFloat) asInteger].		i _ (((i - 1) + increment) \\ tableSize) + 1.		self playTestSample: (amplitude * (waveTable at: i)) // 1000 pan: pan].! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 1/5/98 17:56'!boinkScale	"Tests the sound output primitives by playing a scale."	"SoundPlayer boinkScale"	| sineTable pan |	self shutDown.	SamplingRate _ 11025.	Stereo _ true.	sineTable _ self sineTable: 1000.	Buffer _ SoundBuffer newStereoSampleCount: 1000.	BufferIndex _ 1.	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: SamplingRate		stereo: Stereo.	pan _ 0.	#(261.626 293.665 329.628 349.229 391.996 440.001 493.884 523.252) do: [:p |		self boinkPitch: p dur: 0.3 loudness: 300 waveTable: sineTable pan: pan.		pan _ pan + 125].	self boinkPitch: 261.626 dur: 1.0 loudness: 300 waveTable: sineTable pan: 500.	self primSoundStop.	self shutDown.	SoundPlayer initialize.  "reset sampling rate, buffer size, and stereo flag"! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 12:55'!playTestSample: s pan: pan	"Append the given sample in the range [-32767..32767] to the output buffer, playing the output buffer when it is full. Used for testing only."	| sample leftSample |	BufferIndex >= Buffer size		ifTrue: [			"current buffer is full; play it"			[self primSoundAvailableBytes > 0]				whileFalse. "wait for space to be available"			self primSoundPlaySamples: Buffer stereoSampleCount from: Buffer startingAt: 1.			Buffer primFill: 0.			BufferIndex _ 1].	sample _ s.	sample >  32767 ifTrue: [ sample _  32767 ]. 	sample < -32767 ifTrue: [ sample _ -32767 ].	Stereo		ifTrue: [			leftSample _ (sample * pan) // 1000.			Buffer at: BufferIndex		put: sample - leftSample.			Buffer at: BufferIndex + 1	put: leftSample]		ifFalse: [			Buffer at: BufferIndex + 1 put: sample].	BufferIndex _ BufferIndex + 2.! !!SoundPlayer class methodsFor: 'primitive test' stamp: 'jm 9/17/97 20:06'!sineTable: size	"Compute a sine table of the given size. Used for testing only."	| radiansPerStep table |	table _ Array new: size.	radiansPerStep _ (2.0 * Float pi) / table size asFloat.	1 to: table size do: [:i |		table at: i put:			(32767.0 * (radiansPerStep * i) sin) asInteger].	^ table! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:11'!primSoundAvailableBytes	"Return the number of bytes of available space in the sound output buffer."	"Note: Squeak always uses buffers containing 4-bytes per sample (2 channels at 2 bytes per channel) regardless of the state of the Stereo flag."	<primitive: 173>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/17/97 16:55'!primSoundInsertSamples: count from: aSoundBuffer samplesOfLeadTime: anInteger	"Mix the given number of sample frames from the given sound buffer into the queue of samples that has already been submitted to the sound driver. This primitive is used to start a sound playing with minimum latency, even if large sound output buffers are being used to ensure smooth sound output. Returns the number of samples consumed, or zero if the primitive is not implemented or fails."	<primitive: 189>	^ 0! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:07'!primSoundPlaySamples: count from: aSampleBuffer startingAt: index	"Copy count bytes into the current sound output buffer from the given sample buffer starting at the given index."	<primitive: 174>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:05'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	<primitive: 170>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/18/97 16:21'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag semaIndex: anInteger	"Start double-buffered sound output with the given buffer size and sampling rate. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled when the sound driver is ready to accept another buffer of samples."	"Details: If this primitive fails, this method tries to use the older version instead."	<primitive: 171>	UseReadySemaphore _ false.	self primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag.! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 9/13/97 20:04'!primSoundStop	"Stop double-buffered sound output."	<primitive: 172>	^ self primitiveFailed! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 5/14/1998 09:37'!startPlayingImmediately: aSound	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."	| dontInsertSamples totalSamples buf n leftover src rest |	dontInsertSamples _ false.  "temporary, until insert samples primitive is ported"	dontInsertSamples ifTrue: [		ActiveSounds add: aSound.		^ self].	"first, fill a double-size buffer with samples"	"Note: The code below assumes that totalSamples contains two	 buffers worth of samples, and the insertSamples primitive is	 expected to consume at least one buffer's worth of these	 samples. The remaining samples are guaranteed to fit into	 a single buffer."	totalSamples _ Buffer stereoSampleCount * 2.  "two buffer's worth"	buf _ SoundBuffer newStereoSampleCount: totalSamples.	aSound playSampleCount: totalSamples into: buf startingAt: 1.	ReverbState == nil ifFalse: [		ReverbState applyReverbTo: buf startingAt: 1 count: totalSamples].	PlayerSemaphore critical: [		"insert as many samples as possible into the sound driver's buffers"		n _ self primSoundInsertSamples: totalSamples			from: buf			samplesOfLeadTime: 1024.		leftover _ totalSamples - n.		"copy the remainder of buf into Buffer"		"Note: the following loop iterates over 16-bit words, not two-word stereo slices"		"assert: 0 < leftover <= Buffer stereoSampleCount"		src _ 2 * n.		1 to: 2 * leftover do:			[:dst | Buffer at: dst put: (buf at: (src _ src + 1))].		"generate enough additional samples to finish filling Buffer"		rest _ Buffer stereoSampleCount - leftover.		aSound playSampleCount: rest into: Buffer startingAt: leftover + 1.		ReverbState == nil ifFalse: [			ReverbState applyReverbTo: Buffer startingAt: leftover + 1 count: rest].		"record the fact that this sound has already been played into Buffer so that we don't process it again this time around"		SoundJustStarted _ aSound.		ActiveSounds add: aSound].! !Object subclass: #SoundRecorder	instanceVariableNames: 'stereo samplingRate recordedBuffers recordProcess bufferAvailableSema paused meteringBuffer meterLevel soundPlaying currentBuffer nextIndex '	classVariableNames: 'CanRecordWhilePlaying '	poolDictionaries: ''	category: 'System-Sound'!!SoundRecorder methodsFor: 'initialization' stamp: 'jm 11/1/97 20:22'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'initialization' stamp: 'jhm 10/15/97 14:30'!initializeRecordingState	recordProcess _ nil.	bufferAvailableSema _ nil.	paused _ true.	meteringBuffer _ nil.	meterLevel _ 0.	soundPlaying _ nil.	currentBuffer _ nil.	nextIndex _ 1.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jj 10/20/97 15:30'!isActive	"Return true if I have a recordProcess running."	^ recordProcess ~~ nil! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/2/97 16:16'!isPaused	"Return true if recording is paused."	^ paused! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 9/18/97 19:19'!meterLevel	"Return the meter level, an integer in the range [0..100] where zero is silence and 100 represents the maximum signal level possible without clipping."	^ (100 * meterLevel) // 32768! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 11/4/97 08:25'!recordedSound	"Return the sound that was recorded."	| snd |	stereo ifTrue: [^ self condensedStereoSound].	snd _ SequentialSound new.	recordedBuffers do: [:buf |		snd add: (SampledSound new setSamples: buf samplingRate: samplingRate)].	^ snd! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 12/15/97 14:28'!samplingRate	^ samplingRate! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 9/18/97 14:10'!clearRecordedSound	"Clear the sound recorded thus far. Go into pause mode if currently recording."	paused _ true.	recordedBuffers _ OrderedCollection new: 1000.	self allocateBuffer.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 11/4/97 08:25'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [			recordedBuffers addLast: (currentBuffer copyFrom: 1 to: nextIndex - 1).			self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	CanRecordWhilePlaying ifFalse: [self stopRecording].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 10/17/97 14:53'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying _ self recordedSound.	soundPlaying play.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 9/17/97 19:47'!recordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	self primSetRecordLevel: anInteger.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jj 10/20/97 15:13'!resumeRecording	"Continue recording from the point at which it was last paused."	CanRecordWhilePlaying ifFalse: [self startRecording].	paused _ false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 11/4/97 08:25'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jhm 10/15/97 14:30'!stopRecording	"Stop the recording process and turn of the sound input driver."	recordProcess ifNotNil: [recordProcess terminate].	recordProcess _ nil.	self primStopRecording.	Smalltalk unregisterExternalObject: bufferAvailableSema.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [			recordedBuffers addLast: (currentBuffer copyFrom: 1 to: nextIndex - 1)].	self initializeRecordingState.! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/17/97 17:43'!copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset	"Return a new SoundBuffer containing the samples in the given range."	| startBufIndex startSampleIndex endBufIndex endSampleIndex	 count resultBuf j buf firstInBuf n |	startBufIndex _ startPlace at: 1.	startSampleIndex _ startPlace at: 2.	endBufIndex _ endPlace at: 1.	endSampleIndex _ endPlace at: 2.	startBufIndex = endBufIndex		ifTrue: [count _ endSampleIndex + 1 - startSampleIndex]		ifFalse: [			count _ ((recordedBuffers at: startBufIndex) size + 1 - startSampleIndex).  "first buffer"			count _ count + endSampleIndex.  "last buffer"			startBufIndex + 1 to: endBufIndex - 1 do:				[:i | count _ count + (recordedBuffers at: i) size]].  "middle buffers"	resultBuf _ SoundBuffer newMonoSampleCount: count.	j _ 1.  "next destination index in resultBuf"	startBufIndex to: endBufIndex do: [:i |		buf _ recordedBuffers at: i.		firstInBuf _ 1.	 	n _ buf size.		i = startBufIndex ifTrue: [			n _ (recordedBuffers at: startBufIndex) size + 1 - startSampleIndex.			firstInBuf _ startSampleIndex].		i = endBufIndex ifTrue: [			i = startBufIndex				ifTrue: [n _ endSampleIndex + 1 - startSampleIndex]				ifFalse: [n _ endSampleIndex]].		self copyTo: resultBuf from: j to: (j + n - 1)			from: buf startingAt: firstInBuf			normalize: nFactor dcOffset: dcOffset.		j _ j + n].	^ resultBuf! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:23'!copyTo: resultBuf from: startIndex to: endIndex from: buf startingAt: firstInBuf normalize: nFactor dcOffset: dcOffset	"Copy samples from buf to resultBuf removing the DC offset and normalizing their volume in the process."	| indexOffset |	indexOffset _ firstInBuf - startIndex.	startIndex to: endIndex do: [:i |		resultBuf at: i put: (((buf at: (i + indexOffset)) - dcOffset) * nFactor) // 1000].! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:22'!normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset	"Return a normalization factor for the range of sample values and DC offset. A normalization factor is a fixed-point number that will be divided by 1000 after multiplication with each sample value."	| peak factor |	peak _ (max - dcOffset) max: (min - dcOffset) negated.	peak = 0 ifTrue: [^ 1000].	factor _ (32767.0 * percentOfMaxVolume) / (100.0 * peak).	^ (factor * 1000.0) asInteger! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:16'!scanForEndThreshold: threshold dcOffset: dcOffset	"Return an array containing the (<buffer index>, <sample index in buffer>) of the last sample whose absolute value is over the given threshold after subtracting the given DC offset."	| extraSamples buf s |	extraSamples _ 1000.  "number of samples after triggering sample to include"	recordedBuffers size to: 1 by: -1 do: [:i |		buf _ recordedBuffers at: i.		buf size to: 1 by: -1 do: [:j |			s _ (buf at: j) - dcOffset.			s < 0 ifTrue: [s _ s negated].			s > threshold ifTrue: [  "found end"				(j + extraSamples) <= buf size					ifTrue: [^ Array with: i with: j + extraSamples]					ifFalse: [						i < recordedBuffers size							ifTrue: [^ Array with: i + 1 with: extraSamples - (buf size - j)]							ifFalse: [^ Array with: i with: buf size]]]]].	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'jj 10/20/97 15:43'!scanForStartThreshold: threshold dcOffset: dcOffset	"Return an array containing the (<buffer index>, <sample index in buffer>) of the first sample whose absolute value is over the given threshold after subtracting the given DC offset."	| extraSamples buf s |	extraSamples _ 350.  "number of samples before triggering sample to include"	1 to: recordedBuffers size do: [:i |		buf _ recordedBuffers at: i.		1 to: buf size do: [:j |			s _ (buf at: j) - dcOffset.			s < 0 ifTrue: [s _ s negated].			s > threshold ifTrue: [				"found start"				j > extraSamples					ifTrue: [^ Array with: i with: j - extraSamples]					ifFalse: [						i > 1							ifTrue: [^ Array with: i - 1 with: (recordedBuffers at: i - 1) size - (extraSamples - j)]							ifFalse: [^ Array with: i with: 1]]]]].	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 10/18/97 11:04'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers isEmpty ifTrue: [^ self].	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace _ self scanForStartThreshold: threshold dcOffset: dcOffset.	(((startPlace at: 1) = recordedBuffers size) and:	 [(startPlace at: 2) = recordedBuffers last size])		ifTrue: [  "no samples above threshold"			recordedBuffers _ recordedBuffers species new.			^ self].	endPlace _ self scanForEndThreshold: threshold dcOffset: dcOffset.	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedBuffers _ recordedBuffers species with: resultBuf.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 10/17/97 09:59'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	currentBuffer _ SoundBuffer newMonoSampleCount: 20000.	nextIndex _ 1.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 10/17/97 09:59'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedBuffers isEmpty ifTrue: [SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf _ SoundBuffer newMonoSampleCount: sz.	i _ 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i _ i + 1]].	^ newBuf! !!SoundRecorder methodsFor: 'private' stamp: 'jm 1/5/98 17:53'!condensedStereoSound	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."	| sz leftBuf rightBuf leftI rightI left |	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	leftBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	rightBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	leftI _ rightI _ 1.	left _ true.	recordedBuffers do: [:b |		1 to: b size do: [:j |			left				ifTrue: [leftBuf at: leftI put: (b at: j). leftI _ leftI + 1. left _ false]				ifFalse: [rightBuf at: rightI put: (b at: j). rightI _ rightI + 1. left _ true]]].	^ MixedSound new		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0! !!SoundRecorder methodsFor: 'private' stamp: 'jm 9/2/97 16:16'!meterFrom: start count: count in: buffer	"Update the meter level with the maximum signal level in the given range of the given buffer."	| last max sample |	count = 0 ifTrue: [^ self].  "no new samples"	last _ start + count - 1.	max _ 0.	start to: last do: [:i |		sample _ buffer at: i.		sample < 0 ifTrue: [sample _ sample negated].		sample > max ifTrue: [max _ sample]].	meterLevel _ max.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 9/18/97 14:43'!recordLoop	"Record process loop that records samples."	| n sampleCount |	n _ 0.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n _ self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex _ nextIndex + n.				stereo					ifTrue: [sampleCount _ currentBuffer stereoSampleCount]					ifFalse: [sampleCount _ currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						recordedBuffers addLast: currentBuffer.						self allocateBuffer]]].! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primGetActualRecordingSampleRate	"Return the actual sample rate being used for recording. This primitive fails unless sound recording is currently in progress."	<primitive: 192>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primRecordSamplesInto: aWordArray startingAt: index	"Record a sequence of 16-bit sound samples into the given array starting at the given sample index. Return the number of samples recorded, which may be zero if no samples are currently available."	<primitive: 193>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primSetRecordLevel: anInteger	"Set the desired recording level to the given value in the range 0-1000, where 0 is the lowest recording level and 1000 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	<primitive: 194>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/18/97 13:11'!primStartRecordingDesiredSampleRate: samplesPerSec stereo: stereoFlag semaIndex: anInteger	"Start sound recording with the given stereo setting. Use a sampling rate as close to the desired rate as the underlying platform will support. If the given semaphore index is > 0, it is taken to be the index of a Semaphore in the external objects array to be signalled every time a recording buffer is filled."	<primitive: 190>	self primitiveFailed! !!SoundRecorder methodsFor: 'primitives' stamp: 'jm 9/17/97 16:56'!primStopRecording	"Stop sound recording. Does nothing if recording is not currently in progress."	<primitive: 191>	self primitiveFailed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SoundRecorder class	instanceVariableNames: ''!!SoundRecorder class methodsFor: 'class initialization' stamp: 'jj 10/20/97 15:09'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying _ false.! !!SoundRecorder class methodsFor: 'instance creation' stamp: 'jm 8/24/97 01:20'!new	^ super new initialize! !!SoundRecorder class methodsFor: 'accessing' stamp: 'jj 10/20/97 15:32'!canRecordWhilePlaying	"Return true if this platform supports simultaneous sound recording and playback."	^ CanRecordWhilePlaying! !RectangleMorph subclass: #SoundSequencerMorph	instanceVariableNames: 'controlPanel '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Demo'!!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!initialize	super initialize.	self extent: 550@350.	self makeControlPanel.	self addMorph: controlPanel.	self addMorph: ((SoundLoopMorph newBounds: (10@40 extent: 128@128)) extent: 128@128).	self addMorph: ((SoundLoopMorph newBounds: (10@200 extent: 512@128)) extent: 512@128).! !!SoundSequencerMorph methodsFor: 'all' stamp: 'di 5/6/1998 21:08'!makeControlPanel	| b |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	controlPanel _ AlignmentMorph newRow.	controlPanel color: b color; borderWidth: 0; inset: 0.	controlPanel hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlPanel addMorphBack: (b fullCopy label: 'reset';	actionSelector: #reset).	controlPanel addMorphBack: (b fullCopy label: 'stop';		actionSelector: #stop).	controlPanel addMorphBack: (b fullCopy label: 'play';	actionSelector: #play).! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!play	self submorphsDo: [:m | m == controlPanel ifFalse: [m play]]! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:08'!reset	self submorphsDo: [:m | m == controlPanel ifFalse: [m reset]]! !!SoundSequencerMorph methodsFor: 'all' stamp: 'jm 11/14/97 11:21'!stop	self submorphsDo: [:m | m == controlPanel ifFalse: [m stop]].	SoundPlayer shutDown! !TileMorph subclass: #SoundTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!SoundTile methodsFor: 'all' stamp: 'sw 10/12/97 22:52'!initialize	super initialize.	self addArrows; setLiteral: 'croak'.	submorphs first useStringFormat! !!SoundTile methodsFor: 'all' stamp: 'jm 5/19/1998 09:57'!mouseDown: evt	| aPoint index isUp soundChoices adjustment |	upArrow ifNotNil: [((isUp _ upArrow containsPoint: (aPoint _ evt cursorPoint)) or:			[downArrow containsPoint: aPoint]) ifTrue: [		soundChoices _ #('silence').  "default, if no SampledSound class"		Smalltalk at: #SampledSound ifPresent:			[:sampledSound | soundChoices _ sampledSound soundNames].		index _ soundChoices indexOf: literal.		index > 0 ifTrue:			[adjustment _ isUp ifTrue: [1] ifFalse: [-1].			self literal: (soundChoices atWrap: (index + adjustment))].		self playSoundNamed: literal].		^ self].	super mouseMove: evt.! !!SoundTile methodsFor: 'all' stamp: 'sw 11/2/97 02:08'!mouseMove: evt	"overridden so as NOT to keep scrolling"! !!SoundTile methodsFor: 'all' stamp: 'sw 10/12/97 21:48'!resultType	^ #sound! !!SoundTile methodsFor: 'all' stamp: 'sw 11/3/97 02:11'!wantsKeyboardFocusFor: aSubmorph	^ false! !Path subclass: #Spline	instanceVariableNames: 'coefficients '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Paths'!!Spline commentStamp: 'di 5/22/1998 16:38' prior: 0!Spline comment:'I represent a collection of Points through which a cubic spline curve is fitted.'!!Spline methodsFor: 'accessing'!coefficients	"Answer an eight-element Array of Arrays each of which is the length 	of the receiver. The first four arrays are the values, first, second and 	third derivatives, respectively, for the parametric spline in x. The last 	four elements are for y."	^coefficients! !!Spline methodsFor: 'displaying'!computeCurve	"Compute an array for the coefficients."	| length extras |	length _ self size.	extras _ 0.	coefficients _ Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(self at: i) x asFloat]						ifFalse: [(self at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm 	"Display the receiver, a spline curve, approximated by straight line	segments."	| n line t x y x1 x2 x3 y1 y2 y3 |	collectionOfPoints size < 1 ifTrue: [self error: 'a spline must have at least one point'].	line _ Line new.	line form: self form.	line beginPoint: 		(x _ (coefficients at: 1) at: 1) rounded @ (y _ (coefficients at: 5) at: 1) rounded.	1 to: (coefficients at: 1) size - 1 do: 		[:i | 		"taylor series coefficients"		x1 _ (coefficients at: 2) at: i.		y1 _ (coefficients at: 6) at: i.		x2 _ ((coefficients at: 3) at: i) / 2.0.		y2 _ ((coefficients at: 7) at: i) / 2.0.		x3 _ ((coefficients at: 4) at: i) / 6.0.		y3 _ ((coefficients at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((coefficients at: 3)							at: i + 1) abs + ((coefficients at: 7)							at: i + 1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			line endPoint: 				(x3 * t + x2 * t + x1 * t + x) rounded 							@ (y3 * t + y2 * t + y1 * t + y) rounded.			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			line beginPoint: line endPoint].		line beginPoint: 				(x _ (coefficients at: 1) at: i + 1) rounded 					@ (y _ (coefficients at: 5) at: i + 1) rounded.		line			displayOn: aDisplayMedium			at: aPoint			clippingBox: clipRect			rule: anInteger			fillColor: aForm]! !!Spline methodsFor: 'displaying'!displayOn: aDisplayMedium transformation: aTransformation clippingBox: clipRect rule: anInteger fillColor: aForm 	"Get the scaled and translated path of newKnots."	| newKnots newSpline |	newKnots _ aTransformation applyTo: self.	newSpline _ Spline new.	newKnots do: [:knot | newSpline add: knot].	newSpline form: self form.	newSpline		displayOn: aDisplayMedium		at: 0 @ 0		clippingBox: clipRect		rule: anInteger		fillColor: aForm! !!Spline methodsFor: 'private'!derivs: a first: point1 second: point2 third: point3	"Compute the first, second and third derivitives (in coefficients) from	the Points in this Path (coefficients at: 1 and coefficients at: 5)."	| l v anArray |	l _ a size.	l < 2 ifTrue: [^self].	l > 2	  ifTrue:		[v _ Array new: l.		 v  at:  1 put: 4.0.		 anArray _ Array new: l.		 anArray  at:  1 put: (6.0 * ((a  at:  1) - ((a  at:  2) * 2.0) + (a  at:  3))).		 2 to: l - 2 do:			[:i | 			v  at:  i put: (4.0 - (1.0 / (v  at:  (i - 1)))).			anArray				at:  i 				put: (6.0 * ((a  at:  i) - ((a  at:  (i + 1)) * 2.0) + (a  at:  (i + 2)))						- ((anArray  at:  (i - 1)) / (v  at:  (i - 1))))].		 point2  at: (l - 1) put: ((anArray  at:  (l - 2)) / (v  at:  (l - 2))).		 l - 2 to: 2 by: 0-1 do: 			[:i | 			point2 				at: i 				put: ((anArray  at:  (i - 1)) - (point2  at:  (i + 1)) / (v  at:  (i - 1)))]].	point2 at: 1 put: (point2  at:  l put: 0.0).	1 to: l - 1 do:		[:i | point1 				at: i 				put: ((a at: (i + 1)) - (a  at:  i) - 						((point2  at:  i) * 2.0 + (point2  at:  (i + 1)) / 6.0)).		      point3 at: i put: ((point2  at:  (i + 1)) - (point2  at:  i))]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Spline class	instanceVariableNames: ''!!Spline class methodsFor: 'examples' stamp: '6/8/97 13:55 di'!example	"Designate points on the Path by clicking the red button. Terminate by	pressing any other button. A curve will be displayed, through the	selected points, using a long black form."	| splineCurve aForm flag|	aForm _ Form extent: 2@2.	aForm  fillBlack.	splineCurve _ Spline new.	splineCurve form: aForm.	flag _ true.	[flag] whileTrue:		[Sensor waitButton.		 Sensor redButtonPressed			ifTrue: 				[splineCurve add: Sensor waitButton. 				 Sensor waitNoButton.				 aForm displayOn: Display at: splineCurve last]			ifFalse: [flag_false]].	splineCurve computeCurve.	splineCurve isEmpty 		ifFalse: [splineCurve displayOn: Display.				Sensor waitNoButton]. 	"Spline example"! !FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1 sizeCache '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!StandardFileStream commentStamp: 'di 5/22/1998 16:38' prior: 0!StandardFileStream comment:'Provides a simple, platform-independent, interface to a file system.  This initial version ignores issues of Directories etc.  The instance-variable fallbackStream at the moment holds an instance of HFSMacFileStream, to bridge us to the new world while in the old.  The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 sw'!!StandardFileStream methodsFor: 'open/close' stamp: 'jm 3/27/98 15:10'!close	"Close the receiver."	closed ifTrue: [^ self].	self primClose: fileID.	closed _ true.! !!StandardFileStream methodsFor: 'open/close'!open	"For compatibility with a few existing things.  2/14/96 sw"	^ self reopen! !!StandardFileStream methodsFor: 'open/close'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be read-only.  2/12/96 sw"	fileID _ self primOpen: aFileName writable: writeMode.	fileID == nil ifTrue: [^ nil].	name _ aFileName.	rwmode _ writeMode.	buffer1 _ String new: 1.	closed _ false! !!StandardFileStream methodsFor: 'open/close'!openReadOnly	"Open the receiver as a read-only file.  1/31/96 sw"	^ self open: name forWrite: false! !!StandardFileStream methodsFor: 'open/close'!reopen	"Reopen the receiver, in the same mode as previously, first closing it if applicable.  1/31/96 sw"	closed ifFalse: [self close].	self open: name forWrite: rwmode! !!StandardFileStream methodsFor: 'open/close' stamp: 'tk 1/28/98 18:17'!reopenGently	"Forked processes may not get closed properly during a snapshot.  Reopen it allowing for the fact that the variable closed if false, but the file is really closed."	self primCloseGentle: fileID.	closed _ true.	self open: name forWrite: rwmode! !!StandardFileStream methodsFor: 'properties-setting'!ascii	"opposite of binary"	buffer1 _ String new: 1! !!StandardFileStream methodsFor: 'properties-setting'!asHtml	"Convert me in to an HtmlFileStream. 4/11/96 tk"	^ self as: HtmlFileStream ! !!StandardFileStream methodsFor: 'properties-setting'!binary	buffer1 _ ByteArray new: 1! !!StandardFileStream methodsFor: 'properties-setting'!insertLineFeeds	"(FileStream oldFileNamed: 'BBfix2.st') insertLineFeeds"	| s crLf f |	crLf _ String with: Character cr with: (Character value: 10).	s _ ReadStream on: (self next: self size).	self close.	f _ FileStream newFileNamed: self name.	[s atEnd] whileFalse: 		[f nextPutAll: (s upTo: Character cr); nextPutAll: crLf].	f close! !!StandardFileStream methodsFor: 'properties-setting'!isBinary	^ buffer1 class == ByteArray! !!StandardFileStream methodsFor: 'properties-setting'!readOnly	"Set the receiver to be read-only"	rwmode _ false! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 12/5/97 15:14'!setFileTypeToObject	"On the Macintosh, set the file type and creator of this file to be a Squeak object file. On other platforms, do nothing. Setting the file type allows Squeak object files to be sent as email attachments and launched by double-clicking. On other platforms, similar behavior is achieved by creating the file with the '.sqo' file name extension."	FileDirectory default		setMacFileNamed: self fullName		type: 'SOBJ'		creator: 'FAST'.! !!StandardFileStream methodsFor: 'properties-setting'!writing	"Answer whether the receiver is in the process of writing.  Probably obsolete -- only sender outside of HFS-specific code is in FileStream>>close, which is, in effect, abstract, and not actually reached now.  I THINK.  2/12/96 sw"	^ rwmode! !!StandardFileStream methodsFor: 'access' stamp: 'jm 1/5/98 20:17'!containingDirectory	"Return the directory containing this file."	^ FileDirectory on: (FileDirectory dirPathFor: self fullName)! !!StandardFileStream methodsFor: 'access' stamp: 'tk 1/6/98 11:37'!directory	"Return the directory I am in"	^ FileDirectory on: (FileDirectory dirPathFor: self fullName)! !!StandardFileStream methodsFor: 'access'!file	"Answer the object representing the receiver's file.  Need for compatibility with some calls -- check senders.  2/14/96 sw"	^ self! !!StandardFileStream methodsFor: 'access'!fileID	"Return the fileID that was handed returned by the file-opening primitive.  This id needs to be handed on to the other file-related primitives.  2/12/96 sw"	^ fileID! !!StandardFileStream methodsFor: 'access'!fullName	^ name! !!StandardFileStream methodsFor: 'access'!isDirectory	"Answer whether the receiver represents a directory.  For the post-transition case, uncertain what to do.  2/14/96 sw"	^ false! !!StandardFileStream methodsFor: 'access'!name	"Answer the receiver's name, which is the same as the formal filename on disk.  1/31/96 sw"	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'di 6/27/97 12:18'!peekFor: item 	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"	| next |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	(next _ self next) == nil ifTrue: [^ false].	item = next ifTrue: [^ true].	self skip: -1.	^ false! !!StandardFileStream methodsFor: 'access'!printOn: aStream	"Put a printed version of the receiver onto aStream.  1/31/96 sw"	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !!StandardFileStream methodsFor: 'access'!reset	^ self reopen! !!StandardFileStream methodsFor: 'access'!size	"Answer the size of the file in characters.  2/12/96 sw"	^ self primSize: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 2/12/96'!atEnd	"Answer whether the receiver is at its end.  "	^ self primAtEnd: fileID! !!StandardFileStream methodsFor: 'read, write, position'!flush	"In some OS's seeking to 0 and back will do a flush"	| p |	p _ self position.	self position: 0; position: p! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 2/12/96'!next	"Read the next object from the file. "	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^ buffer1 at: 1 ]		ifFalse: [ ^ nil ].! !!StandardFileStream methodsFor: 'read, write, position'!next: n	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"	^ self nextInto: (buffer1 class new: n)! !!StandardFileStream methodsFor: 'read, write, position'!nextInto: aString	"Fill aString, whose size dictates the size of the read, with characters from the receiver.  1/31/96 sw"	| count wanted |	count _ self primRead: fileID into: aString				startingAt: 1 count: (wanted _ aString size).	count < wanted ifTrue: [^ aString copyFrom: 1 to: count].	^ aString! !!StandardFileStream methodsFor: 'read, write, position'!nextPut: char	"Put char on the receiver stream.  2/12/96 sw"	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1		startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position'!nextPutAll: aString	"Write all the characters of aString into the receiver's file.  2/12/96 sw"	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'sw 1/31/96'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self next.	self position: self position - 1.	^ next! !!StandardFileStream methodsFor: 'read, write, position'!position	"Return the receiver's current file position.  2/12/96 sw"	^ self primGetPosition: fileID! !!StandardFileStream methodsFor: 'read, write, position'!position: pos	"Set the receiver's position as indicated.  2/12/96 sw"	^ self primSetPosition: fileID to: pos! !!StandardFileStream methodsFor: 'read, write, position'!readInto: byteArray startingAt: startIndex count: count	"Read into the given array as specified, and return the count	actually transferred.  index and count are in units of bytes or	longs depending on whether the array is Bitmap, String or ByteArray"	^ self primRead: fileID into: byteArray			startingAt: startIndex count: count! !!StandardFileStream methodsFor: 'read, write, position'!readOnlyCopy	^ StandardFileStream readOnlyFileNamed: self name! !!StandardFileStream methodsFor: 'read, write, position'!setToEnd	"Set the position of the receiver to the end of file.  1/31/96 sw"	self position: self size! !!StandardFileStream methodsFor: 'read, write, position'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file.  1/31/96 sw"	self position: self position + n! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'di 7/14/97 23:15'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	pos _ self position.	buffer _ self next: 2000.	(count _ buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'di 6/28/97 21:33'!verbatim: aString	"A copy of nextPutAll that can be called knowing it wont call nextPut: "	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'primitives'!primAtEnd: id	"Answer whether the receiver is currently at its end.  2/12/96 sw"	<primitive: 150>	^ self primitiveFailed! !!StandardFileStream methodsFor: 'primitives'!primClose: anID	"Primitive call to close the receiver.  2/12/96 sw"	<primitive: 151>	^ self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'tk 1/28/98 18:18'!primCloseGentle: anID	"Primitive call to close the receiver.  Don't complain if fails"	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives'!primGetPosition: id	"Get the receiver's current file position.  2/12/96 sw"	<primitive: 152>	^ self primitiveFailed! !!StandardFileStream methodsFor: 'primitives'!primOpen: fileName writable: aBoolean	"Open a file of the given name, and return the file id obtained.	If writable is true, then		if there is none with this name, then create one		else prepare to overwrite from the beginning	otherwise open readonly,		or return nil if there is no file with this name"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives'!primRead: id into: byteArray startingAt: startIndex count: count	"read from the receiver's file into the given area of storage, starting at the given index, as many as count bytes; return the number of bytes actually read.  2/12/96 sw"	<primitive: 154>	self halt: 'error reading file'! !!StandardFileStream methodsFor: 'primitives'!primSetPosition: id to: aNumber	"Set the receiver's file position to be a Number.  2/12/96 sw"	<primitive: 155>	^ self primitiveFailed! !!StandardFileStream methodsFor: 'primitives'!primSize: id	"Return the size of the receiver's file.  2/12/96 sw"	<primitive: 157>	^ self primitiveFailed! !!StandardFileStream methodsFor: 'primitives'!primWrite: id from: byteArray startingAt: startIndex count: count	"Write into the receiver's file from the given area of storage, starting at the given index, as many as count bytes; return the number of bytes actually written. 2/12/96 sw"	<primitive: 158>	closed ifTrue: [^ self halt: 'Write error: File not open'].	rwmode ifFalse: [^ self halt: 'Error-attempt to write to a read-only file.'].	self halt: 'File write error'! !!StandardFileStream methodsFor: 'added by paul' stamp: 'pm 9/22/97 15:39'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardFileStream class	instanceVariableNames: ''!!StandardFileStream class methodsFor: 'file creation'!fileNamed: aFileName  	"Open a file in the default directory (or in the directory contained	in the input arg); by default, it's available for writing.  2/12/96 sw	Prior contents will be overwritten, but not truncated on close.  3/18 di"	^ self new open: aFileName forWrite: true! !!StandardFileStream class methodsFor: 'file creation'!isAFileNamed: fName	| f |	f _ self new open: fName forWrite: false.	f == nil ifTrue: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'tk 4/4/98 10:34'!newFileNamed: aFileName 	"create a file in the default directory (or in the directory contained in the input arg), set for write access."	| selection |	(self isAFileNamed: aFileName) ifFalse:		[^ self new open: aFileName forWrite: true].	"File already exists..."	selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'already exists.'.	selection = 1 ifTrue:		[FileDirectory default			deleteFileNamed: aFileName			ifAbsent: [self error: 'Sorry, deletion failed'].		^ self new open: aFileName forWrite: true].	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: aFileName)].	"Return a dummy stream that will absorb all file messages and do nothing"	"^ RWBinaryOrTextStream on: (DummyStream on: nil)"	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 12/5/97 12:54'!oldFileNamed: aFileName  	"Open a file in the default directory (or in the directory contained	in the input arg); by default, it's available for reading.  2/12/96 sw	Prior contents will be overwritten, but not truncated on close.  3/18 di"	| selection |	(self isAFileNamed: aFileName) ifTrue:		[^ self new open: aFileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels: 'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: aFileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: aFileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 12/5/97 12:54'!readOnlyFileNamed: aFileName	"Open a file of the given name for read-only access.  1/31/96 sw"	| selection |	(self isAFileNamed: aFileName) ifTrue:		[^ self new open: aFileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: aFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: aFileName))].	self halt! !Object subclass: #StandardScriptingSystem	instanceVariableNames: ''	classVariableNames: 'FormDictionary HelpStrings SystemSlotDictionary '	poolDictionaries: ''	category: 'Morphic-Scripting'!!StandardScriptingSystem commentStamp: 'di 5/22/1998 16:38' prior: 0!An instance of this is installed as the value of the global variable "ScriptingSystem".  Client subclasses are invited, such as one used internally by squeak team for ongoing internal work.!!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/2/1998 14:26'!colorBehindTiles	^ Color r: 0.903 g: 1.0 b: 0.903! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/2/1998 14:28'!fontForNameEditingInScriptor	^ StrikeFont familyName: #ComicBold size: 18! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/2/1998 14:47'!fontForScriptorButtons	^ StrikeFont familyName: #ComicBold size: 18! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/2/1998 14:19'!fontForTiles	^ StrikeFont familyName: #ComicBold size: 18! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/6/1998 15:15'!statusColorSymbolFor: statusSymbol	#(	(normal				green)		(ticking				blue)		(paused				red)		(mouseDown			yellow)		(mouseStillDown		lightYellow)		(mouseUp			lightBlue)		(mouseEnter			lightBrown)		(mouseLeave		lightRed)		(keyStroke			lightGreen)) do:			[:pair | statusSymbol == pair first ifTrue: [^ pair second]].		^ #blue! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 5/2/1998 14:23'!uniformTileInteriorColor	^ Color r: 0.806 g: 1.0 b: 0.806! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 5/2/1998 14:00'!formAtKey: aKey	^ FormDictionary at: aKey ifAbsent: [nil]! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 5/2/1998 14:01'!formDictionary	^ FormDictionary! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 5/2/1998 14:13'!inspectFormDictionary	"ScriptingSystem inspectFormDictionary"	self formDictionary inspectFormsWithLabel: 'Standard Graphics'! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 5/2/1998 14:01'!readFormsFromFileNamed: aFileName	"Read the entire FormDictionary in from a designated file on disk"	| aReferenceStream |	aReferenceStream _ ReferenceStream fileNamed: aFileName.	FormDictionary _ aReferenceStream next.	aReferenceStream close	"ScriptingSystem readFormsFromFileNamed: 'EToyForms22Apr'"! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 5/6/1998 17:46'!saveFormsToFileNamed: aFileName	"Save the current state of form dictionary to disk for possible later retrieval"  	 (ReferenceStream fileNamed: aFileName) nextPut: FormDictionary; close	"ScriptingSystem saveFormsToFileNamed: 'SystemForms06May98.forms'"! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 5/3/1998 11:59'!helpStringFor: aSymbol	^ HelpStrings at: aSymbol ifAbsent: ['No help available']! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 5/21/1998 16:02'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(objectNameInHalo  control'Object''s name -- To change:click here; backspace over old name,type in new name; hit ENTER')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/19/1998 18:36'!maxPaintArea	"Answer the largest paintable area for new 'make new drawing'"	"ScriptingSystem maxPaintArea"	| anExtent |	anExtent _ self reasonablePaintingExtent.	^ anExtent x * anExtent y! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/19/1998 20:11'!reasonablePaintingExtent	"Answer a reasonable maximum extent for new 'make new drawing'"	^  240 @ 280! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/2/1998 14:17'!reclaimSpace	"Reclaim space from the scripting system, and report the result in an informer"	"ScriptingSystem reclaimSpace"	| reclaimed |	(reclaimed _ self spaceReclaimed)  > 0		ifTrue:	[self inform: reclaimed printString, ' bytes reclaimed']		ifFalse:	[self inform: 'Hmm...  Nothing gained this time.']! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/3/1998 19:14'!spaceReclaimed	"Reclaim space from the EToy system, and return the number of bytes reclaimed"	"ScriptingSystem spaceReclaimed"	| oldFree  |	oldFree _ Smalltalk garbageCollect.	ThumbnailMorph recursionReset.	MorphicModel removeUninstantiatedSubclassesSilently.	Player removeUninstantiatedSubclassesSilently.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	^ Smalltalk garbageCollect - oldFree.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/6/1998 14:49'!standardEventStati	^ #(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave keyStroke)! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/18/1998 17:53'!tryButtonFor: aPhraseTileMorph	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aPhraseTileMorph; actionSelector: #try; label: '!!' font: (StrikeFont familyName: #ComicBold size: 16); color: Color yellow; borderWidth: 0.	aButton actWhen: #whilePressed.	aButton balloonTextSelector: #try.	^ aButton! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/6/1998 13:41'!typeForSystemSlotNamed: aName	^ SystemSlotDictionary at: aName! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/2/1998 14:14'!wordingForAssignmentSuffix: aString	| toTest |	toTest _ aString asString.	#(	(':'					'_')		('Incr:'				'<+')		('Decr:'				'<-')		('Mult:'				'<*'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest	"ScriptingSystem wordingForAssignmentSuffix: 'Incr:'"! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 5/4/1998 00:23'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(max:					'max')		(min:					'min')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardScriptingSystem class	instanceVariableNames: ''!!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 5/21/1998 16:01'!initialize	"StandardScriptingSystem initialize"	self initializeSystemSlotDictionary.	self new initializeHelpStrings! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 5/19/1998 21:57'!initializeSystemSlotDictionary	"StandardScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !MouseMenuController subclass: #StandardSystemController	instanceVariableNames: 'status '	classVariableNames: 'HBorderCursor ScheduledBlueButtonMenu ScheduledBlueButtonMessages VBorderCursor '	poolDictionaries: ''	category: 'Interface-Support'!!StandardSystemController commentStamp: 'di 5/22/1998 16:38' prior: 0!StandardSystemController comment:'I am a controller for StandardSystemViews, that is, those views that are at the top level of a project in the system user interface. I am a kind of MouseMenuController that creates a blue button menu for moving, framing, collapsing, and closing ScheduledViews, and for selecting views under the view of my instance.'!!StandardSystemController methodsFor: 'initialize-release'!initialize	super initialize.	status _ #inactive.	self initializeBlueButtonMenu! !!StandardSystemController methodsFor: 'initialize-release'!initializeBlueButtonMenu	"Initialize the blue button pop-up menu and corresponding array of	messages for the receiver."	self blueButtonMenu: ScheduledBlueButtonMenu 		blueButtonMessages: ScheduledBlueButtonMessages! !!StandardSystemController methodsFor: 'control defaults'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'control defaults'!isControlActive	status == #active ifFalse: [^ false].	sensor anyButtonPressed ifFalse: [^ true].	self viewHasCursor		ifTrue: [^ true]		ifFalse: [ScheduledControllers noteNewTop.				^ false]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'tk 5/8/1998 16:17'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	sensor waitNoButton.	status _ #active.	view topView isCollapsed ifFalse: [model modelWakeUp].! !!StandardSystemController methodsFor: 'basic control sequence'!controlTerminate	status == #closed		ifTrue: 			[view ~~ nil ifTrue: [view release].			ScheduledControllers unschedule: self.			^self].	view deEmphasize; cacheBits! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 9/26/97 12:12'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame"	| box p |	p _ sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	sensor blueButtonPressed & self viewHasCursor 		ifTrue: [^ self blueButtonActivity].	((box _ view closeBoxFrame) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed: [self close. ^ self].				^ self].	((box _ view growBoxFrame) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed:					[Sensor controlKeyPressed ifTrue:						[^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].				^ self].	((box _ view labelTextRegion expandBy: 1) containsPoint: p)		ifTrue: [Utilities awaitMouseUpIn: box repeating: [] ifSucceed:					[^ self label].				^ self].	self move.! !!StandardSystemController methodsFor: 'menu messages'!chooseColor	"Allow the user to specify a new background color for the receiver's window.  5/6/96 sw.	 7/31/96 sw: use Color fromUser"	view backgroundColor: Color fromUser; uncacheBits; display! !!StandardSystemController methodsFor: 'menu messages'!close	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	model okToChange ifFalse: [^self].	status _ #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages'!collapse	"Get the receiver's view to change to a collapsed view on the screen."	view collapseToPoint: view chooseCollapsePoint! !!StandardSystemController methodsFor: 'menu messages'!expand	"The receiver's view was collapsed; open it again and ask the user to 	designate its rectangular area."	view expand; emphasize! !!StandardSystemController methodsFor: 'menu messages' stamp: 'sw 9/30/97 21:42'!forceClosed	"The receiver's view should be removed from the screen and from the 	collection of scheduled views."	status _ #closed.	view erase! !!StandardSystemController methodsFor: 'menu messages' stamp: 'jm 4/28/1998 06:57'!label	| newLabel |	newLabel _ FillInTheBlank		request: 'Edit the label, then type RETURN'		initialAnswer: view label.	newLabel isEmpty ifFalse: [view relabel: newLabel].! !!StandardSystemController methodsFor: 'menu messages'!menuMessageReceiver	"Answer the object that should receive the message corresponding to	a menu selection."	^self! !!StandardSystemController methodsFor: 'menu messages'!move	"Ask the user to designate a new origin position for the receiver's view.	6/10/96 sw: tell the view that it has moved"	| oldBox | 	oldBox _ view windowBox.	view uncacheBits.	view align: view windowBox topLeft		with: view chooseMoveRectangle topLeft.	view displayEmphasized.	view moved.  "In case its model wishes to take note."	(oldBox areasOutside: view windowBox) do:		[:rect | ScheduledControllers restore: rect]! !!StandardSystemController methodsFor: 'menu messages'!reframe	^ view reframeTo: view getFrame! !!StandardSystemController methodsFor: 'menu messages'!toggleTwoTone	(view isMemberOf: StandardSystemView) ifTrue:		[^ view become: (view as: ColorSystemView)].	(view isMemberOf: ColorSystemView) ifTrue:		[^ view become: (view as: StandardSystemView)].! !!StandardSystemController methodsFor: 'menu messages'!under	"Deactive the receiver's scheduled view and pass control to any view that 	might be positioned directly underneath it and the cursor."	status _ #inactive! !!StandardSystemController methodsFor: 'scheduling' stamp: 'sw 9/30/97 22:04'!closeAndUnschedule	"Erase the receiver's view and remove it from the collection of scheduled 	views."	status _ #closed.	view erase.	view release.	ScheduledControllers unschedule: self; searchForActiveController! !!StandardSystemController methodsFor: 'scheduling'!closeAndUnscheduleNoErase	"Remove the scheduled view from the collection of scheduled views. Set 	its status to closed but do not erase."	status _ #closed.	view release.	ScheduledControllers unschedule: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 3/18/98 19:21'!closeAndUnscheduleNoTerminate	"Erase the receiver's view and remove it from the collection of scheduled views, but do not terminate the current process."	status _ #closed.	view erase.	view release.	ScheduledControllers unschedule: self.! !!StandardSystemController methodsFor: 'scheduling'!open	"Create an area on the screen in which the receiver's scheduled view can 	be displayed. Make it the active view."	view resizeInitially.	status _ #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling'!openDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view."	view align: view viewport center with: aPoint.	view translateBy:		(view displayBox amountToTranslateWithin: Display boundingBox).	status _ #open.	ScheduledControllers scheduleActive: self! !!StandardSystemController methodsFor: 'scheduling' stamp: 'jm 10/22/97 08:16'!openNoTerminate	"Create an area in which the receiver's scheduled view can be displayed. 	Make it the active view. Do not terminate the currently active process."	view resizeInitially.	status _ #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!openNoTerminateDisplayAt: aPoint 	"Create an area with origin aPoint in which the receiver's scheduled 	view can be displayed. Make it the active view. Do not terminate the 	currently active process."	view resizeMinimumCenteredAt: aPoint.	status _ #open.	ScheduledControllers scheduleActiveNoTerminate: self! !!StandardSystemController methodsFor: 'scheduling'!status: aSymbol	status _ aSymbol! !!StandardSystemController methodsFor: 'borders'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side = #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]]]].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]].		]]]! !!StandardSystemController methodsFor: 'borders'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue.				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'borders'!checkForReframe	| cp |	view isCollapsed ifTrue: [^ self].	cp _ sensor cursorPoint.	((view closeBoxFrame expandBy: 2) containsPoint: cp)		| ((view growBoxFrame expandBy: 2) containsPoint: cp)		ifTrue: [^ self].  "Dont let reframe interfere with close/grow"	self adjustWindowCorners.	self cursorOnBorder ifFalse: [^ self].	((view insetDisplayBox insetBy: 2@2) containsPoint: cp)		ifFalse: [^ self adjustWindowBorders].	(view subviewWithLongestSide: [:s | ] near: cp) == nil		ifFalse: [^ self adjustPaneBorders].! !!StandardSystemController methodsFor: 'borders'!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp _ sensor cursorPoint.	((view labelDisplayBox insetBy: (0@2 corner: 0@-2)) containsPoint: cp)		ifTrue: [^ false].	(i _ view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box _ view windowBox]		ifFalse: [box _ (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !!StandardSystemController methodsFor: 'borders'!fullScreen	"Make the receiver's window occupy jes' about the full screen.  6/10/96 sw"	view fullScreen! !!StandardSystemController methodsFor: 'cursor'!labelHasCursor	"Answer true if the cursor is within the window's label"	^view labelContainsPoint: sensor cursorPoint! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardSystemController class	instanceVariableNames: ''!!StandardSystemController class methodsFor: 'class initialization'!initialize   "StandardSystemController initialize"	"Set up the menus for standard windows.  	 6/6/96 sw: added fullScreen"	ScheduledBlueButtonMenu _ PopUpMenu labels: 'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7).	ScheduledBlueButtonMessages _ #(label chooseColor toggleTwoTone move reframe fullScreen collapse close)."StandardSystemController initialize.ScheduledControllers scheduledWindowControllers		do: [:c | c initializeBlueButtonMenu]"	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !View subclass: #StandardSystemView	instanceVariableNames: 'labelFrame labelText isLabelComplemented savedSubViews minimumSize maximumSize collapsedViewport expandedViewport labelBits windowBits bitsValid '	classVariableNames: 'CacheBits LabelStyle '	poolDictionaries: ''	category: 'Interface-Support'!!StandardSystemView commentStamp: 'di 5/22/1998 16:38' prior: 0!StandardSystemView comment:'I represent a view that has a label above its top left corner. The text in the label identifies the kind of view. In addition to a label, I add control over the maximum and minimum size of the display box of my instance. My default controller is StandardSystemController. The elements of ScheduledControllers, the sole instance of ControlManager, are usually controllers for instances of me.'!!StandardSystemView methodsFor: 'initialize-release'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'initialize-release'!model: aModel	"Set the receiver's model.  For a Standard System View, we also at this time get the default background color set up.  7/30/96 sw"	super model: aModel.	self setDefaultBackgroundColor! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'di 6/24/97 14:05'!release	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release! !!StandardSystemView methodsFor: 'testing'!containsPoint: aPoint 	"Refer to the comment in View|containsPoint:."	^(super containsPoint: aPoint) | (self labelContainsPoint: aPoint)! !!StandardSystemView methodsFor: 'testing'!isCollapsed	"Answer whether the receiver is collapsed (true) or expanded (false)."	^savedSubViews ~~ nil! !!StandardSystemView methodsFor: 'testing'!labelContainsPoint: aPoint 	"Answer TRUE if aPoint is in the label box."	^self labelDisplayBox containsPoint: aPoint! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:30'!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 12:29'!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22@-5)) extent: (11@11)! !!StandardSystemView methodsFor: 'label access'!label	"Answer the string that appears in the receiver's label."	labelText isNil		ifTrue: [^ 'Untitled' copy]		ifFalse: [^ labelText asString]! !!StandardSystemView methodsFor: 'label access'!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: (TextFontChange fontNumber: 2)											with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access'!labelColor	"Answer the color to use as the background for the receiver's label.  By default, this is the same as the background color of the window, but need not be.  7/16/96 sw"	^ self backgroundColor! !!StandardSystemView methodsFor: 'label access'!labelDisplayBox	"Answer the rectangle that borders the visible parts of the receiver's label 	on the display screen."	^ labelFrame region		align: labelFrame topLeft		with: self windowOrigin! !!StandardSystemView methodsFor: 'label access'!labelFrame	^labelFrame! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/16/97 08:44'!labelHeight	^ (LabelStyle fontAt: 2) height + 4! !!StandardSystemView methodsFor: 'label access'!labelOffset	^ 0 @ (self labelHeight-2)! !!StandardSystemView methodsFor: 'label access'!labelTextRegion	labelText == nil ifTrue: [^ self labelDisplayBox center extent: 0@0].	^ (labelText boundingBox			align: labelText boundingBox center			with: self labelDisplayBox center)		intersect: (self labelDisplayBox insetBy: 35@0)! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 14:20'!noLabel	"A label of zero height indicates no label"	labelFrame height > 0		ifTrue: [labelFrame region: (labelFrame bottomLeft + (0@1) extent: labelFrame width@0).				labelFrame borderWidth: 0.				self uncacheBits]! !!StandardSystemView methodsFor: 'label access'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'di 10/3/97 13:35'!setLabelRegion	"Always follows view width"	labelFrame region: (0 @ 0 extent: self displayBox width @ self labelHeight).	labelFrame borderWidth: 2! !!StandardSystemView methodsFor: 'size'!maximumSize	"Answer a point representing the maximum width and height of the 	receiver."	^maximumSize! !!StandardSystemView methodsFor: 'size'!maximumSize: aPoint 	"Set the argument, aPoint, to be the maximum width and height of the 	receiver."	maximumSize _ aPoint! !!StandardSystemView methodsFor: 'size'!minimumSize	"Answer a point representing the minimum width and height of the 	receiver."	^minimumSize! !!StandardSystemView methodsFor: 'size'!minimumSize: aPoint 	"Set the argument, aPoint, to be the minimum width and height of the 	receiver."	minimumSize _ aPoint! !!StandardSystemView methodsFor: 'framing'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	collapsedViewport isNil ifTrue:		[^ RealEstateAgent assignCollapsePointFor: self].	labelForm slideFrom: self labelDisplayBox origin			to: (pt _ collapsedViewport topLeft) nSteps: 10.	^ pt! !!StandardSystemView methodsFor: 'framing'!chooseFrame	"Answer a new frame, depending on whether the view is currently 	collapsed or not."	| labelForm f |	self isCollapsed & expandedViewport notNil		ifTrue:			[labelForm _ bitsValid				ifTrue: [windowBits]				ifFalse: [Form fromDisplay: self labelDisplayBox].			bitsValid _ false.			self erase.			labelForm slideFrom: self labelDisplayBox origin					to: expandedViewport origin-self labelOffset					nSteps: 10.			^ expandedViewport]		ifFalse:			[f _ self getFrame.			bitsValid _ false.			self erase.			^ f topLeft + self labelOffset extent: f extent]! !!StandardSystemView methodsFor: 'framing'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset p |	offset _ Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | p _ Sensor cursorPoint + offset.					p _ (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | p _ Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 5/9/1998 00:21'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[(subViews ~~ nil and: [subViews size = 1 and: [subViews first isKindOf: MorphWorldView]])				ifTrue: [subViews first deEmphasizeView].			expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing'!collapsedFrame	"Answer the rectangle occupied by this window when collapsed."	^ collapsedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing'!collapseToPoint: collapsePoint	self collapse.	self align: self displayBox topLeft with: collapsePoint.	collapsedViewport _ self viewport.	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!constrainFrame: aRectangle	"Constrain aRectangle, to the minimum and maximum size	for this window"	^ aRectangle origin extent:		((aRectangle extent max: minimumSize) min: maximumSize)! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:51'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized]! !!StandardSystemView methodsFor: 'framing'!expandedFrame	"Answer the rectangle occupied by this window when expanded."	^ expandedViewport  "NOTE may be nil"! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 8/15/97 17:18'!fullScreen	"Expand the receiver to fill the screen.  Let the model decide how big is full -- allows for flop-out scrollbar on left if desired"	self isCollapsed ifFalse:		[self reframeTo: model fullScreenSize]! !!StandardSystemView methodsFor: 'framing'!getFrame	"Ask the user to designate a rectangular area in which	the receiver should be displayed."	| minFrame |	minFrame _ Cursor origin showWhile: 		[(Sensor cursorPoint extent: self minimumSize) newRectFrom:			[:f | Sensor cursorPoint extent: self minimumSize]].	self maximumSize <= self minimumSize ifTrue: [^ minFrame].	^ Cursor corner showWhile:		[minFrame newRectFrom:			[:f | self constrainFrame: (f origin corner: Sensor cursorPoint)]]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 1/22/96'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ model initialExtent min: maximumSize max: minimumSize! !!StandardSystemView methodsFor: 'framing'!initialFrame	"Find a plausible initial screen area for the receiver, taking into account user preference, the size needed, and other windows currently on the screen.  5/22/96 sw: let RealEstateAgent do it for us"	^ RealEstateAgent initialFrameFor: self! !!StandardSystemView methodsFor: 'framing'!moved	"The user has moved the receiver; after a new view rectangle is chosen, this method is called to allow certain views to take note of the change.  6/10/96 sw" ! !!StandardSystemView methodsFor: 'framing'!newDisplayBoxFor: subView adjoining: newRect along: side 	side = #left ifTrue: [^ subView displayBox withRight: newRect left].	side = #right ifTrue: [^ subView displayBox withLeft: newRect right].	side = #top ifTrue: [^ subView displayBox withBottom: newRect top].	side = #bottom ifTrue: [^ subView displayBox withTop: newRect bottom].! !!StandardSystemView methodsFor: 'framing'!newFrame: frameChangeBlock	self reframeTo: (self windowBox newRectFrom:		[:f | self constrainFrame: (frameChangeBlock value: f)])! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/20/1998 18:21'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim |	newRect _ aDisplayBox.	"First check that this won't make any pane smaller than 8 screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | self newDisplayBoxFor: sub adjoining: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < 8 ifTrue:		[delta _ minDim - 8.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ self newDisplayBoxFor: sub adjoining: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!reframeTo: newFrame	"Reframe the receiver to the given screen rectangle.  	Repaint difference after the change.  "	| oldBox newBox portRect |	self uncacheBits.	oldBox _ self windowBox.	portRect _ newFrame topLeft + self labelOffset				corner: newFrame corner.	self resizeTo: portRect.	self setLabelRegion.	newBox _ self windowBox.	(oldBox areasOutside: newBox) do:		[:rect | ScheduledControllers restore: rect].	self displayEmphasized! !!StandardSystemView methodsFor: 'framing'!resize	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	| f |	f _ self getFrame.	self resizeTo: (f topLeft + self labelOffset extent: f extent)! !!StandardSystemView methodsFor: 'framing'!resizeInitially	"Determine the rectangular area for the receiver, adjusted to the 	minimum and maximum sizes."	self resizeTo: self initialFrame! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:12'!resizeMinimumCenteredAt: aPoint 	"Determine the rectangular area for the receiver, adjusted so that it is 	centered a position, aPoint."	| aRectangle |	aRectangle _ 0 @ 0 extent: self minimumSize.	aRectangle _ aRectangle align: aRectangle center with: aPoint.	self resizeTo: aRectangle! !!StandardSystemView methodsFor: 'framing' stamp: 'di 4/6/98 15:29'!resizeTo: aRectangle	"Resize this view to aRectangle"	"First get scaling right inside borders"	self window: (self window insetBy: borderWidth)		viewport: (aRectangle insetBy: borderWidth).	"Then ensure window maps to aRectangle"	window _ transformation applyInverseTo: aRectangle! !!StandardSystemView methodsFor: 'framing'!standardWindowOffset	^ Preferences standardWindowOffset! !!StandardSystemView methodsFor: 'framing'!windowBox	^ self displayBox merge: self labelDisplayBox! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/3/97 14:19'!windowOrigin	^ (self isCollapsed or: [labelFrame height = 0  "no label"])		ifTrue: [self displayBox topLeft]		ifFalse: [self displayBox topLeft - self labelOffset]! !!StandardSystemView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StandardSystemController! !!StandardSystemView methodsFor: 'displaying'!cacheBits	| oldLabelState |	CacheBits ifFalse: [^ self uncacheBits].	(oldLabelState _ isLabelComplemented) ifTrue: [ self deEmphasize ].	self cacheBitsAsIs.	(isLabelComplemented _ oldLabelState) ifTrue: [ self emphasize ].! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsIs	CacheBits ifFalse: [^ self uncacheBits].	windowBits _ (self cacheBitsAsTwoTone and: [Display depth > 1])		ifTrue: [ColorForm					twoToneFromDisplay: self windowBox					using: windowBits					backgroundColor: self backgroundColor]		ifFalse: [Form fromDisplay: self windowBox using: windowBits].	bitsValid _ true.! !!StandardSystemView methodsFor: 'displaying'!cacheBitsAsTwoTone	^ true! !!StandardSystemView methodsFor: 'displaying'!deEmphasizeForDebugger	"Carefully de-emphasis this window because a debugger is being opened. Care must be taken to avoid invoking potentially buggy window display code that could cause a recursive chain of errors eventually resulting in a virtual machine crash. In particular, do not de-emphasize the subviews."	self deEmphasizeView.  "de-emphasize this top-level view"	self uncacheBits.	Smalltalk garbageCollectMost > 1000000 ifTrue: [		"if there is enough space, cache current window screen bits"		self cacheBitsAsIs].! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!deEmphasizeLabel	"Un-Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: false.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying'!display	isLabelComplemented		ifTrue: [self displayEmphasized]		ifFalse: [self displayDeEmphasized]! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 2/26/98 08:58'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	(bitsValid and: [controller ~~ ScheduledControllers activeController])		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [super display.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying'!displayEmphasized	"Display with label highlighted to indicate that it is active."	self displayDeEmphasized; emphasize.	isLabelComplemented _ true! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 5/15/1998 21:55'!displayLabelBackground: emphasized	"Clear or emphasize the inner region of the label"	| r1 r2 r3 c3 c2 c1 |	emphasized ifFalse:		["Just clear the label if not emphasized"		^ Display fill: (self labelDisplayBox insetBy: 2) fillColor: self labelColor].	r1 _ self labelDisplayBox insetBy: 2.	r2 _ r1 insetBy: 0@2.	r3 _ r2 insetBy: 0@3.	c3 _ self labelColor.	c2 _ c3 dansDarker.	c1 _ c2 dansDarker.	Display fill: r1 fillColor: c1.	Display fill: r2 fillColor: c2.	Display fill: r3 fillColor: c3. "	Here is the Mac racing stripe code	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)					with: (Form black pixelWordForDepth: Display depth).	self windowOrigin y even ifTrue: [stripes swap: 1 with: 2].	Display fill: (self labelDisplayBox insetBy: 3) fillColor: stripes."! !!StandardSystemView methodsFor: 'displaying'!displayLabelBoxes	"closeBox, growBox."	| aRect smallRect backColor |	aRect _ self closeBoxFrame.	backColor _ self labelColor.	Display fill: (aRect insetBy: -2) fillColor: backColor.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	aRect _ self growBoxFrame.	smallRect _ aRect origin extent: 7@7.	Display fill: (aRect insetBy: -2) fillColor: backColor.	aRect _ aRect insetOriginBy: 2@2 cornerBy: 0@0.	Display fillBlack: aRect.	Display fill: (aRect insetBy: 1) fillColor: backColor.	Display fillBlack: smallRect.	Display fill: (smallRect insetBy: 1) fillColor: backColor! !!StandardSystemView methodsFor: 'displaying'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/29/97 18:57'!displayOn: aPort	bitsValid ifFalse:		[^ Display clippingTo: aPort clipRect do: [super display]].	windowBits displayOnPort: aPort at: self windowOrigin! !!StandardSystemView methodsFor: 'displaying'!displayRacingStripes	"Display Racing Stripes in the label"	| labelDisplayBox stripes top bottom left box right |	labelDisplayBox _ self labelDisplayBox.	top _ labelDisplayBox top + 3.	bottom _ labelDisplayBox bottom - 3.	stripes _ Bitmap with: (self labelColor pixelWordForDepth: Display depth)			with: (Color black pixelWordForDepth: Display depth).	top even ifFalse: [stripes swap: 1 with: 2].	left _ labelDisplayBox left + 3.	box _ self closeBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self labelTextRegion.	right _ box left - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	box _ self growBoxFrame.	right _ box left - 2.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.	left _ box right + 2.	right _ labelDisplayBox right - 3.	Display fill: (Rectangle left: left right: right top: top bottom: bottom)			fillColor: stripes.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:14'!displayView	"Refer to the comment in View|displayView. "	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayBox width = labelFrame width ifFalse:		["recompute label width when window changes size"		self setLabelRegion].	(labelFrame align: labelFrame topLeft with: self windowOrigin)		insideColor: self labelColor;		displayOn: Display.	self displayLabelText! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 10/3/97 13:18'!emphasizeLabel	"Highlight the label."	labelFrame height = 0 ifTrue: [^ self].  "no label"	self displayLabelBackground: true.	self displayLabelBoxes.	self displayLabelText.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/30/97 11:07'!erase	"Clear the display box of the receiver to be gray, as the screen background."	| oldValid |	CacheBits		ifTrue:			[oldValid _ bitsValid.			bitsValid _ false.			ScheduledControllers restore: self windowBox without: self.			bitsValid _ oldValid]		ifFalse:			[ScheduledControllers restore: self windowBox without: self]! !!StandardSystemView methodsFor: 'displaying'!uncacheBits	windowBits _ nil.	bitsValid _ false.! !!StandardSystemView methodsFor: 'displaying'!windowBits	^ windowBits! !!StandardSystemView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	isLabelComplemented ifTrue:		[self deEmphasizeLabel.		isLabelComplemented _ false]! !!StandardSystemView methodsFor: 'deEmphasizing'!emphasizeView 	"Refer to the comment in View|emphasizeView."	self emphasizeLabel! !!StandardSystemView methodsFor: 'clipping box access'!clippingBox	"Answer the rectangular area in which the receiver can show its label."	^self isTopView		ifTrue: [self labelDisplayBox]		ifFalse: [super insetDisplayBox]! !!StandardSystemView methodsFor: 'private'!setTransformation: aTransformation 	"Override to support label size changes "	super setTransformation: aTransformation.	self label: self label! !!StandardSystemView methodsFor: 'private'!subviewWithLongestSide: sideBlock near: aPoint 	| region subs max rect side len theSub theSide |	region _ aPoint - (4@4) corner: aPoint + (4@4).	subs _ subViews select: [:sub | sub insetDisplayBox intersects: region].	subs isEmpty ifTrue: [sideBlock value: #none.  ^ nil].	max _ 0.	subs do:		[:sub | rect _ sub insetDisplayBox.		side _ rect sideNearestTo: aPoint.		len _ (side = #left) | (side = #right)			ifTrue: [rect height]			ifFalse: [rect width].		len > max ifTrue: [max _ len.  theSub _ sub.  theSide _ side]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView methodsFor: 'updating' stamp: 'tk 4/28/1998 08:36'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self relabel: model labelString].	^ super update: aSymbol! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StandardSystemView class	instanceVariableNames: ''!!StandardSystemView class methodsFor: 'class initialization'!cachingBits	^ CacheBits! !!StandardSystemView class methodsFor: 'class initialization'!doCacheBits	"StandardSystemView doCacheBits - Enable fast window repaint feature"	CacheBits _ true.	ScheduledControllers unCacheWindows.	ScheduledControllers restore! !!StandardSystemView class methodsFor: 'class initialization'!dontCacheBits	"StandardSystemView dontCacheBits - Disable fast window repaint feature.	Return true iff bits were cached, ie if space was been recovered"	CacheBits ifFalse: [^ false].	CacheBits _ false.	ScheduledControllers unCacheWindows.	^ true! !!StandardSystemView class methodsFor: 'class initialization'!initialize		"StandardSystemView initialize"	self doCacheBits.	(LabelStyle _ TextStyle default copy)		gridForFont: 2 withLead: 0! !PolygonMorph subclass: #StarMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!StarMorph methodsFor: 'all' stamp: 'tk 7/28/97 23:15'!addHandles	| handle strokeOrigin p |	handles ifNotNil: [handles do: [:hh | hh delete]].	strokeOrigin _ 0@0.	vertices do: [:each | strokeOrigin _ strokeOrigin + each].	strokeOrigin _ strokeOrigin // vertices size.	"average is the center"	handles _ Array new: 2.		handle _ EllipseMorph newBounds: (Rectangle center: strokeOrigin extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #center.		self addMorph: handle.	handles at: 1 put: handle.	"The center one!!!!"		p _ vertices at: 2.	"an outside one"		handle _ EllipseMorph newBounds: (Rectangle center: p + (borderWidth//2) extent: 8@8)				color: Color yellow.		handle on: #mouseStillDown send: #dragVertex:fromHandle:vertIndex:				to: self withValue: #outside.		self addMorph: handle.	handles at: 2 put: handle.	"The outside one!!!!"	self changed! !!StarMorph methodsFor: 'all' stamp: 'sw 8/11/97 22:44'!authoringPrototype	^ super authoringPrototype removeHandles! !!StarMorph methodsFor: 'all' stamp: 'tk 7/23/97 18:19'!dragVertex: evt fromHandle: handle vertIndex: label	| ext oldR pt strokeOrigin offset |label == #center ifTrue: [	offset _ evt cursorPoint - (handles at: 1) bounds center.	self position: self position + offset.	].label == #outside ifTrue: [	strokeOrigin _ (handles at: 1) bounds center.	pt _ strokeOrigin - evt cursorPoint - ((handles at: 2) extent // 2).	ext _ pt r.	oldR _ ext.	vertices _ (0 to: 359 by: (360//vertices size)) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext]) degrees: angle + pt degrees)			+ strokeOrigin].	(handles at: 2) position: evt cursorPoint.	].self computeBounds.! !!StarMorph methodsFor: 'all' stamp: 'tk 8/4/97 22:20'!initialize	| pt ext oldR points |	super initialize.	color _ Color lightBlue.	borderWidth _ 1.	borderColor _ Color black.	pt _ 10@10.	ext _ pt r.	oldR _ ext.	points _ 5.	vertices _ (0 to: 359 by: (360//points//2)) collect: [:angle |		(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse:[ext]) degrees: angle + pt degrees)			+ (45@45)].	self computeBounds! !!StarMorph methodsFor: 'all' stamp: 'di 9/26/97 11:11'!updateHandles! !SketchMorph subclass: #StickySketchMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Support'!!StickySketchMorph methodsFor: 'all' stamp: 'sw 4/16/1998 13:44'!mustBeBackmost	^ true! !!StickySketchMorph methodsFor: 'all'!rootForGrabOf: aMorph	"Be sticky."	^ nil! !!StickySketchMorph methodsFor: 'all' stamp: 'sw 9/18/97 15:37'!wantsHalo	^ false! !Object subclass: #Stream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!Stream commentStamp: 'di 5/22/1998 16:38' prior: 0!Stream comment:'I am an abstract class that represents an accessor for a sequence of objects. This sequence is referred to as my "contents".'!!Stream methodsFor: 'accessing'!contents	"Answer all of the contents of the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing'!next	"Answer the next object accessible by the receiver."	self subclassResponsibility! !!Stream methodsFor: 'accessing'!next: anInteger 	"Answer the next anInteger number of objects accessible by the receiver."	| aCollection |	aCollection _ OrderedCollection new.	anInteger timesRepeat: [aCollection addLast: self next].	^aCollection! !!Stream methodsFor: 'accessing'!next: anInteger put: anObject 	"Make anObject be the next anInteger number of objects accessible by the 	receiver. Answer anObject."	anInteger timesRepeat: [self nextPut: anObject].	^anObject! !!Stream methodsFor: 'accessing'!nextMatchAll: aColl    "Answer true if next N objects are the ones in aColl,     else false.  Advance stream of true, leave as was if false."    | save |    save _ self position.    aColl do: [:each |       (self next) = each ifFalse: [            self position: save.            ^ false]        ].    ^ true! !!Stream methodsFor: 'accessing'!nextMatchFor: anObject 	"Gobble the next object and answer whether it is equal to the argument, 	anObject."	^anObject = self next! !!Stream methodsFor: 'accessing'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	self subclassResponsibility! !!Stream methodsFor: 'accessing'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	aCollection do: [:v | self nextPut: v].	^aCollection! !!Stream methodsFor: 'testing'!atEnd	"Answer whether the receiver can access any more objects."	self subclassResponsibility! !!Stream methodsFor: 'enumerating'!do: aBlock 	"Evaluate aBlock for each of the objects accessible by receiver."	[self atEnd]		whileFalse: [aBlock value: self next]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Stream class	instanceVariableNames: ''!!Stream class methodsFor: 'instance creation'!new	self error: 'Streams are created with on: and with:'! !Object subclass: #StrikeFont	instanceVariableNames: 'xTable glyphs name stopConditions type minAscii maxAscii maxWidth strikeLength ascent descent xOffset raster subscript superscript emphasis derivativeFonts pointSize '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!StrikeFont commentStamp: 'di 5/22/1998 16:38' prior: 0!StrikeFont comment:'I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the characters.'!!StrikeFont methodsFor: 'accessing'!ascent	"Answer the receiver's maximum extent of characters above the baseline."	^ascent! !!StrikeFont methodsFor: 'accessing'!descent	"Answer the receiver's maximum extent of characters below the baseline."	^descent! !!StrikeFont methodsFor: 'accessing'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	| fontName firstDigit lastDigit |	fontName_ name asUppercase.	firstDigit _ fontName findFirst: [:char | char isDigit].	lastDigit _ fontName findLast: [:char | char isDigit].	^Array with: (fontName copyFrom: 1 to: firstDigit-1)		with: (Integer readFromString: (fontName copyFrom: firstDigit to: lastDigit))		with: (#('' 'B' 'I' 'BI') indexOf:					(fontName copyFrom: lastDigit+1 to: fontName size))	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'accessing'!glyphs	"Answer a Form containing the bits representing the characters of the 	receiver."	^glyphs! !!StrikeFont methodsFor: 'accessing'!height	"Answer the height of the receiver, total of maximum extents of 	characters above and below the baseline."	^self ascent + self descent! !!StrikeFont methodsFor: 'accessing'!lineGrid	^ ascent + descent! !!StrikeFont methodsFor: 'accessing'!maxAscii	"Answer the integer that is the last Ascii character value of the receiver."	^maxAscii! !!StrikeFont methodsFor: 'accessing'!maxWidth	"Answer the integer that is the width of the receiver's widest character."	^maxWidth! !!StrikeFont methodsFor: 'accessing'!minAscii	"Answer the integer that is the first Ascii character value of the receiver."	^minAscii! !!StrikeFont methodsFor: 'accessing'!name	"Answer the receiver's name."	^name! !!StrikeFont methodsFor: 'accessing'!name: aString	"Set the receiver's name."	name _ aString! !!StrikeFont methodsFor: 'accessing'!raster	"Answer an integer that specifies the layout of the glyphs' form."	^raster! !!StrikeFont methodsFor: 'accessing'!setGlyphs: newGlyphs	"Replace the glyphs form.  Used to make a synthetic bold or italic font quickly."	glyphs _ newGlyphs! !!StrikeFont methodsFor: 'accessing'!stopConditions	"Answer the array of selectors to be performed in scanning text made up 	of the receiver's characters."	^stopConditions! !!StrikeFont methodsFor: 'accessing'!subscript	"Answer an integer that is the further vertical offset relative to the 	baseline for positioning characters as subscripts."	^subscript! !!StrikeFont methodsFor: 'accessing'!superscript	"Answer an integer that is the further vertical offset relative to the 	baseline for positioning characters as superscripts."	^superscript! !!StrikeFont methodsFor: 'accessing'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ (aCharacter asciiValue min: maxAscii) max: minAscii.	^(xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'accessing'!xTable	"Answer an Array of the left x-coordinate of characters in glyphs."	^xTable! !!StrikeFont methodsFor: 'testing'!checkCharacter: character 	"Answer a Character that is within the ascii range of the receiver--either 	character or the last character in the receiver."	| ascii |  	ascii _ character asciiValue.	((ascii < minAscii) or: [ascii > maxAscii])			ifTrue: [^maxAscii asCharacter]			ifFalse:	[^character]! !!StrikeFont methodsFor: 'displaying'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint bb leftX rightX sourceRect |	destPoint _ aPoint.	bb _ BitBlt toForm: Display.	anInterval do: 		[:i | 		ascii _ (sourceString at: i) asciiValue.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii _ maxAscii].		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX)@0)].	^ destPoint! !!StrikeFont methodsFor: 'displaying'!composeWord: aTextLineInterval in: sourceString beginningAt: xInteger 	"Non-primitive composition of a word--add up widths of characters, add 	sum to beginning x and answer the resulting x. Similar to performance 	of scanning primitive, but without stop conditions."	| character resultX |	resultX _ xInteger.	aTextLineInterval do: 		[:i | 		character _ sourceString at: i.		resultX _ resultX + (self widthOf: character)].	^resultX! !!StrikeFont methodsFor: 'displaying'!displayLine: aString at: aPoint 	"Display the characters in aString, starting at position aPoint."	self characters: (1 to: aString size)		in: aString		displayAt: aPoint		clippedBy: Display boundingBox		rule: Form over		fillColor: nil! !!StrikeFont methodsFor: 'emphasis'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!StrikeFont methodsFor: 'emphasis'!emphasis	"Answer the integer code for synthetic bold, italic, underline, and 	strike-out."	^emphasis! !!StrikeFont methodsFor: 'emphasis'!emphasis: code 	"Set the integer code for synthetic bold, itallic, underline, and strike-out, 	where bold=1, italic=2, underlined=4, and struck out=8."	emphasis _ code! !!StrikeFont methodsFor: 'emphasis'!emphasized: code 	"Answer a copy of the receiver with emphasis set to include code."	| derivative addedEmphasis base g r safeCode |	code = 0 ifTrue: [^ self].	(derivativeFonts == nil or: [derivativeFonts size = 0]) ifTrue: [^ self].	derivative _ derivativeFonts at: (safeCode _ code min: derivativeFonts size).	derivative == nil ifFalse: [^ derivative].  "Already have this style"	"Dont have it -- derive from another with one with less emphasis"	addedEmphasis _ 1 bitShift: safeCode highBit - 1.	base _ self emphasized: safeCode - addedEmphasis.  "Order is Bold, Ital, Under, Narrow"	addedEmphasis = 1 ifTrue:   "Compute synthetic bold version of the font"		[derivative _ (base copy name: base name , 'B') makeBoldGlyphs].	addedEmphasis = 2 ifTrue:   "Compute synthetic italic version of the font"		[ derivative _ (base copy name: base name , 'I') makeItalicGlyphs].	addedEmphasis = 4 ifTrue:   "Compute underlined version of the font"		[derivative _ (base copy name: base name , 'U') makeUnderlinedGlyphs].	addedEmphasis = 8 ifTrue:   "Compute narrow version of the font"		[derivative _ (base copy name: base name , 'N') makeCondensedGlyphs].	addedEmphasis = 16 ifTrue:   "Compute struck-out version of the font"		[derivative _ (base copy name: base name , 'X') makeStruckOutGlyphs].	derivative emphasis: safeCode.	derivativeFonts at: safeCode put: derivative.	^ derivative! !!StrikeFont methodsFor: 'emphasis'!makeBoldGlyphs	"Make a bold set of glyphs with same widths by ORing 1 bit to the right		(requires at least 1 pixel of intercharacter space)"	| g bonkForm |	g _ glyphs deepCopy.	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.	self bonk: g with: bonkForm.	g copyBits: g boundingBox from: g at: (1@0)		clippingBox: g boundingBox rule: Form under fillColor: nil.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis' stamp: 'di 10/31/97 13:18'!makeCondensedGlyphs	"Make a condensed set of glyphs with same widths.	NOTE: this has been superceded by kerning -- should not get called"	| g newXTable x x1 w |	g _ glyphs deepCopy.	newXTable _ Array new: xTable size.	newXTable at: 1 put: (x _ xTable at: 1).	1 to: xTable size-1 do:		[:i | x1 _ xTable at: i.  w _ (xTable at: i+1) - x1.		w > 1 ifTrue: [w _ w-1].  "Shrink every character wider than 1"		g copy: (x@0 extent: w@g height) from: x1@0 in: glyphs rule: Form over.		newXTable at: i+1 put: (x _ x + w)].	xTable _ newXTable.	glyphs _ g"(TextStyle default fontAt: 1) copy makeCondensedGlyphs	displayLine: 'The quick brown fox jumps over the lazy dog'	at: Sensor cursorPoint"! !!StrikeFont methodsFor: 'emphasis'!makeItalicGlyphs	"Make an italic set of glyphs with same widths by skewing left and right		(may require more intercharacter space)"	| g r bonkForm bc |	g _ glyphs deepCopy.	"BonkForm will have bits where slanted characters overlap their neighbors."	bonkForm _ Form extent: (self height//4+2) @ self height.	bc _ self descent//4 + 1.  "Bonker x-coord corresponding to char boundary."	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color black.	4 to: self ascent-1 by: 4 do:		[:y | 		"Slide ascenders right..."		g copy: (1@0 extent: g width @ (self ascent - y))			from: 0@0 in: g rule: Form over.		bonkForm copy: (1@0 extent: bonkForm width @ (self ascent - y))			from: 0@0 in: bonkForm rule: Form over].	bonkForm fill: (0 @ 0 corner: (bc+1) @ self ascent) fillColor: Color white.	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color black.	self ascent to: self height-1 by: 4 do:		[:y | 		"Slide descenders left..."		g copy: (0@y extent: g width @ g height)			from: 1@y in: g rule: Form over.		bonkForm copy: (0@0 extent: bonkForm width @ bonkForm height)			from: 1@0 in: bonkForm rule: Form over].	bonkForm fill: (bc @ self ascent corner: bonkForm extent) fillColor: Color white.	"Now use bonkForm to erase at every character boundary in glyphs."	bonkForm offset: (0-bc) @ 0.	self bonk: g with: bonkForm.	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeStruckOutGlyphs	"Make a struck-out set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent - (self ascent//3)) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!makeUnderlinedGlyphs	"Make an underlined set of glyphs with same widths"	| g |	g _ glyphs deepCopy.	g fillBlack: (0 @ (self ascent+1) extent: g width @ 1).	glyphs _ g! !!StrikeFont methodsFor: 'emphasis'!reset	"Reset the cache of derivative emphasized fonts"	derivativeFonts _ Array new: 32! !!StrikeFont methodsFor: 'Mac reader'!aComment	"To read Mac font resources.  1) Use ResEdit in the Fonts folder in the System Folder.  Open the file of the Font you want.  (A screen font, not a TrueType outline font).2) Open the FOND resource and scroll down to the list of sizes and resource numbers. Note the resource number of the size you want.3) Open the NFNT resource.  Click on the number you have noted.4) Choose 'Open Using Hex Editor' from the resource editor.5) Copy all of the hex numbers and paste into a text editor.  Save the file into the Smalltalk folder under the name 'FontName 12 hex' (or other size).6) Enter the fileName below and execute: TextStyle default fontAt: 8 put: (StrikeFont new readMacFontHex: 'fileName').Select text and type Command-7 to change it to your new font.(There is some problem in the ParagraphEditor with the large size of Cairo 18.  Its line heights are not the right.)	"! !!StrikeFont methodsFor: 'Mac reader'!fixKerning: extraWidth	"Insert one pixel (extraWidth) between each character.  And add the bits for the space character"	"Create a space character Form.  Estimate width by ascent / 2 - 1"	| characterForm char leftX |	characterForm _ Form extent: (ascent//2 - 1) @ self height.	self characterFormAt: $  put: characterForm.	"Put one pixel of space after every character.  Mac fonts have no space in the bitmap."	extraWidth <= 0 ifTrue: [^ self].	minAscii to: maxAscii do: [:ascii |		char _ Character value: ascii.		leftX _ xTable at: ascii + 1.		characterForm _ Form extent: 			((self widthOf: char) + extraWidth) @ self height.		characterForm 			copy: (characterForm boundingBox extendBy: 				(0-extraWidth@0))			from: leftX@0 in: glyphs rule: Form over.		self characterFormAt: char put: characterForm.		].	! !!StrikeFont methodsFor: 'Mac reader'!readMacFontHex: fileName	"Read the hex version of a Mac FONT type resource.  See the method aComment for how to prepare the input file. 4/26/96 tk"	| file hh fRectWidth |	name _ fileName.	"Palatino 12"	file _ FileStream readOnlyFileNamed: fileName, ' hex'.	"See Inside Macintosh page IV-42 for this record"	"FontType _ " Number readFrom: (file next: 4) base: 16.	emphasis		_		0.	minAscii _ Number readFrom: (file next: 4) base: 16.	maxAscii _ Number readFrom: (file next: 4) base: 16.	maxWidth		_ Number readFrom: (file next: 4) base: 16.	"kernMax _ " Number readFrom: (file next: 4) base: 16.	"NDescent _ " Number readFrom: (file next: 4) base: 16.	fRectWidth _  Number readFrom: (file next: 4) base: 16.	hh _  Number readFrom: (file next: 4) base: 16.	"OWTLoc _ " Number readFrom: (file next: 4) base: 16.	ascent			_ Number readFrom: (file next: 4) base: 16.	descent			_ Number readFrom: (file next: 4) base: 16.	"leading _ " Number readFrom: (file next: 4) base: 16.	xOffset			_		0. 		raster			_ Number readFrom: (file next: 4) base: 16.	strikeLength	_		raster*16.	superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		self strikeFromHex: file width: raster height: hh.	self xTableFromHex: file.	file close.	"Insert one pixel between each character.  And add space character."	self fixKerning: (fRectWidth - maxWidth).		"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont]! !!StrikeFont methodsFor: 'Mac reader'!strikeFromHex: file width: w height: h	"read in just the raw strike bits from a hex file.  No spaces or returns.  W is in words (2 bytes), h in pixels." 	| newForm theBits offsetX offsetY str num cnt |	offsetX  _ 0.	offsetY _ 0.	offsetX > 32767 ifTrue: [offsetX _ offsetX - 65536]. "stored two's-complement"	offsetY > 32767 ifTrue: [offsetY _ offsetY - 65536]. "stored two's-complement"	newForm _ Form extent: strikeLength @ h offset: offsetX @ offsetY.	theBits _ newForm bits.	cnt _ 0.		"raster may be 16 bits, but theBits width is 32" 	1 to: theBits size do: [:i | 		(cnt _ cnt + 32) > strikeLength 		  ifTrue: [cnt _ 0.			num _ Number readFrom: (str _ file next: 4) base: 16]		  ifFalse: [			cnt = strikeLength ifTrue: [cnt _ 0].			num _ Number readFrom: (str _ file next: 8) base: 16].		theBits at: i put: num].	glyphs _ newForm.! !!StrikeFont methodsFor: 'Mac reader'!xTableFromHex: file	| strike num str wid |	strike _ file.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | 			num _ Number readFrom: (str _ strike next: 4) base: 16. 			xTable at: index put: num].	1 to: xTable size - 1 do: [:ind |		wid _ (xTable at: ind+1) - (xTable at: ind).		(wid < 0) | (wid > 40) ifTrue: [			file close.			self error: 'illegal character width']].! !!StrikeFont methodsFor: 'file in/out'!displayChar: ascii form: charForm	"Convenience utility used during conversion of BitFont files"	| m bigForm |	Display fillBlack: (0@0 extent: 20@14).	ascii printString displayAt: 0@2.	charForm width > 0 ifTrue:		[m _ 5.		bigForm _ charForm magnify: charForm boundingBox by: m@m.		Display border: ((bigForm boundingBox expandBy: m) translateBy: 50@2) width: m.		bigForm displayAt: 50@2.		Display fillBlack: ((50@2)+((m*charForm width)@0) extent: 1@(m*self height))].! !!StrikeFont methodsFor: 'file in/out'!newFromStrike: fileName	"Build an instance from the strike font file name. The '.strike' extension	is optional."	| strike startName raster16 |	name _ fileName copyUpTo: $..	"assumes extension (if any) is '.strike'".	strike _ FileStream oldFileNamed: name, '.strike.'.	strike binary.	strike readOnly.		"strip off direcory name if any"	startName _ name size.	[startName > 0 and: [((name at: startName) ~= $>) & ((name at: startName) ~= $])]]		whileTrue: [startName _ startName - 1].	name _ name copyFrom: startName+1 to: name size.	type			_		strike nextWord16.		"type is ignored now -- simplest												assumed.  Kept here to make												writing and consistency more												straightforward."	minAscii		_		strike nextWord16.	maxAscii		_		strike nextWord16.	maxWidth		_		strike nextWord16.	strikeLength	_		strike nextWord16.	ascent			_		strike nextWord16.	descent			_		strike nextWord16.	"xOffset			_"		strike nextWord16. 		raster16			_		strike nextWord16.		superscript		_		ascent - descent // 3.		subscript		_		descent - ascent // 3.		emphasis		_		0.	glyphs			_	Form extent: (raster16 * 16) @ (self height)  							offset: 0@0.		glyphs bits fromByteStream: strike.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: strike nextWord16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	strike close.	self setStopConditions ! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/97 14:16'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| known eval |	thisContext sender receiver class == ReferenceStream ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	known _ TextStyle default fontArray detect: [:x | x name sameAs: self name] ifNone: [nil]. 	known == self ifTrue: ["not modified"		eval _ 'TextStyle default fontNamed: ', self name printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval)			"We are expecting it to be there"].	^ self	"Special font.  Write me out"! !!StrikeFont methodsFor: 'file in/out'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name , ')'! !!StrikeFont methodsFor: 'file in/out'!readBFHeaderFrom: f	name _ self restOfLine: 'Font name = ' from: f.	ascent _ (self restOfLine: 'Ascent = ' from: f) asNumber.	descent _ (self restOfLine: 'Descent = ' from: f) asNumber.	maxWidth _ (self restOfLine: 'Maximum width = ' from: f) asNumber.	pointSize _ (self restOfLine: 'Font size = ' from: f) asNumber.	name _ (name copyWithout: Character space) ,				(pointSize < 10					ifTrue: ['0' , pointSize printString]					ifFalse: [pointSize printString]).	minAscii _ 258.	maxAscii _ 0.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ 0.	type _ 0.  "ignored for now"! !!StrikeFont methodsFor: 'file in/out' stamp: 'di 9/15/97 21:51'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f _ FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens _ (f upTo: Character cr)  findTokens: ' '.	iRect _ Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent _ iRect top.	descent _ iRect bottom negated.		tempGlyphs _ Form extent: (maxWidth*257) @ self height.	xTable _ (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii _ -1.	[charLine _ self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p _ f position.		rectLine _ f upTo: Character cr.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens _ rectLine findTokens: ' '.					left _ (tokens at: 5) asNumber. right _ (tokens at: 8) asNumber]			ifFalse: [left _ right _ 0. f position: p].		width_ (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii _ 256].		('x''*' match: charLine) ifTrue:			[ascii _ Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm _ Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line _ f upTo: Character cr.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm _ charForm deepCopy]				ifFalse:				[minAscii _ minAscii min: ascii.				maxAscii _ maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii _ ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs _ Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable _ xTable copyFrom: 1 to: maxAscii+3.	self setStopConditions! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2: fileName  "StrikeFont new readFromStrike2: 'Palatino14.sf2'"	"Build an instance from the strike font stored in strike2 format.	fileName is of the form: <family name><pointSize>.sf2"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "Drop filename extension"	file _ FileStream readOnlyFileNamed: fileName.	file binary.	self readFromStrike2Stream: file! !!StrikeFont methodsFor: 'file in/out'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	type _ file nextInt32.  type = 2 ifFalse: [file close. self halt "not strike2 format"].	minAscii _ file nextInt32.	maxAscii _ file nextInt32.	maxWidth _ file nextInt32.	ascent _ file nextInt32.	descent _ file nextInt32.	pointSize _ file nextInt32.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		emphasis _ file nextInt32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file nextInt32].	glyphs _ Form new readFrom: file.	file close.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	self setStopConditions! !!StrikeFont methodsFor: 'file in/out'!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line _ file upTo: Character cr.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'file in/out'!setStopConditions	"This has to do with scanning characters, not with the font"	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	1 to: (minAscii - 1) do:		[:index | stopConditions at: index put: #characterNotInFont].	(maxAscii + 3) to: stopConditions size do:		[:index | stopConditions at: index put: #characterNotInFont].	self reset! !!StrikeFont methodsFor: 'file in/out'!writeAsStrike2named: fileName	"Write me onto a file in strike2 format.	fileName should be of the form: <family name><pointSize>.sf2"	| file |	file _ FileStream fileNamed: fileName.	file binary.	file nextInt32Put: 2.	file nextInt32Put: minAscii.	file nextInt32Put: maxAscii.	file nextInt32Put: maxWidth.	file nextInt32Put: ascent.	file nextInt32Put: descent.	file nextInt32Put: pointSize.	superscript _ ascent - descent // 3.		subscript _ descent - ascent // 3.		file nextInt32Put: emphasis.	(minAscii + 1 to: maxAscii + 3) do:		[:index | file nextInt32Put: (xTable at: index)].	glyphs writeOn: file.	file close.! !!StrikeFont methodsFor: 'character shapes'!alter: char formBlock: formBlock	self characterFormAt: char 		put: (formBlock value: (self characterFormAt: char))! !!StrikeFont methodsFor: 'character shapes'!characterForm: char pixelValueAt: pt put: val	| f |	f _ self characterFormAt: char.	f pixelAt: pt put: val.	self characterFormAt: char put: val! !!StrikeFont methodsFor: 'character shapes'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont methodsFor: 'character shapes'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 corner: rightX @ self height)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'character shapes'!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm smallRect editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	bitEditor controller blueButtonMenu: nil blueButtonMessages: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !!StrikeFont methodsFor: 'character shapes'!widen: char by: delta	| newForm |	^ self alter: char formBlock:  "Make a new form, wider or narrower..."		[:charForm | newForm _ Form extent: charForm extent + (delta@0).		charForm displayOn: newForm.  "Copy this image into it"		newForm]    "and substitute it in the font"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StrikeFont class	instanceVariableNames: ''!!StrikeFont class methodsFor: 'instance creation' stamp: 'di 10/20/97 20:12'!familyName: aName size: aSize	| aStyle |	(aStyle _ TextStyle named: aName asSymbol)		ifNil: [self halt: 'Error: font ', aName, ' not found.'].	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'instance creation'!fromStrike: fileName 	"Read a font from disk in the old ST-80 'strike' format.	Note: this is an old format; use strike2 format instead"	^self new newFromStrike: fileName! !!StrikeFont class methodsFor: 'examples'!convertFontsNamed: familyName  " StrikeFont convertFontsNamed: 'NewYork' "	"This utility is for use after you have used BitFont to produce data files 	for the fonts you wish to use.  It will read the BitFont files and then 	write them out in strike2 (*.sf2) format which is much more compact,	and which can be read in again very quickly."	"For this utility to work as is, the BitFont data files must be named	'familyNN.BF', and must reside in the same directory as the image."	| f |	(FileDirectory default fileNamesMatching: familyName , '*.BF') do:		[:fname | Transcript cr; show: fname.		f _ StrikeFont new readFromBitFont: fname.		f writeAsStrike2named: f name , '.sf2']! !!StrikeFont class methodsFor: 'examples'!example	"Displays a line of text on the display screen at the location of the cursor.	Example depends on the strike font file, 'TimesRoman10.strike'. existing."	(StrikeFont new readFromStrike2: 'NewYork12.sf2')		displayLine: 'A line of 12-pt text in New York style' at: Sensor cursorPoint	 	"StrikeFont example."! !!StrikeFont class methodsFor: 'examples' stamp: 'di 2/15/98 14:05'!size: pointSize fromLiteral: aString	"This method allows a font set to be captured as sourcecode in a subclass.	The string literals will presumably be created by printing, eg,		(FileStream readOnlyFileNamed: 'Palatino24.sf2') contentsOfEntireFile,		and then pasting into a browser after a heading like, eg,size24	^ self size: 24 fromLiteral:	'--unreadable binary data--'	See the method hackDefaultStyle to see how this can be used"	^ (StrikeFont new readFromStrike2Stream:		(ReadWriteStream on: aString asByteArray from: 1 to: aString size))		name: self name , (pointSize < 10 ifTrue: ['0' , pointSize printString]										ifFalse: [pointSize printString])! !!StrikeFont class methodsFor: 'derivative font caching'!shutDown  "StrikeFont shutDown"	"Deallocate synthetically derived copies of base fonts to save space"	self allInstancesDo: [:sf | sf reset]! !ArrayedCollection variableByteSubclass: #String	instanceVariableNames: ''	classVariableNames: 'AsciiOrder CaseInsensitiveOrder '	poolDictionaries: ''	category: 'Collections-Text'!!String commentStamp: 'di 5/22/1998 16:38' prior: 0!A String is an indexed collection of Characters, compactly encoded as 8-bit bytes.String support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!]style[(269 13 2 18 72 24 2 43)f1,f1LString match:;,f1,f1LString contractTo:;,f1,f1LSequenceableCollection ,;,f1,f1LSequenceableCollection copyReplaceAll:with:;!!String methodsFor: 'accessing'!at: index 	"Primitive. Answer the Character stored in the field of the receiver	indexed by the argument. Fail if the index argument is not an Integer or	is out of bounds. Essential. See Object documentation whatIsAPrimitive."	<primitive: 63>	^Character value: (super at: index)! !!String methodsFor: 'accessing'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [self errorNonIntegerIndex]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'tk 6/18/96'!atWrap: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  "	<primitive: 63>	^(super atWrap: index) asCharacter! !!String methodsFor: 'accessing'!endsWithDigit	"Answer whether the receiver's final character represents a digit.  3/11/96 sw"	^ self size > 0 and: [self last isDigit]! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 11:09'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min ind |	min _ self size + 1.	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"		delim class == Character 			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind _ self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min _ min min: ind].	^ min! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 10:09'!findBetweenSubStrs: delimiters	"Answer the collection of tokens that result from parsing self.  Tokens are separated by substrings, as listed in the Array delimiters."	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing'!findDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."	start to: self size do: [:i |		delimiters do: [:delim | delim = (self at: i) ifTrue: [^ i]]].	^ self size + 1! !!String methodsFor: 'accessing'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^ self indexOfSubCollection: subString startingAt: start		ifAbsent: [0]! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 10:07'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Any character in the String delimiters marks a border.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.		keyStop _ self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 09:50'!findTokens: delimiters includes: subString	"Divide self into pieces using delimiters.  Return the piece that includes subString anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."^ (self findTokens: delimiters) 	detect: [:str | (str includesSubString: subString)] 	ifNone: [nil]! !!String methodsFor: 'accessing' stamp: 'tk 6/19/97 10:05'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens _ OrderedCollection new.	keyStop _ 1.	[keyStop <= self size] whileTrue:		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop _ self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'sw 8/12/97 12:37'!includesSubString: subString	^ (self findString: subString startingAt: 1) > 0! !!String methodsFor: 'accessing'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position.  1/15/96 sw:  Inefficient first stab at this"	| cr aChar answer |	cr _ Character cr.	answer _ ''.	1 to: self size do:		[:i | 			aChar _ self at: i.			aChar == cr				ifTrue:					[i > anIndex						ifTrue:							[^ answer]						ifFalse:							[answer _ '']]				ifFalse:					[answer _ answer copyWith: aChar]].	^ answer! !!String methodsFor: 'accessing'!lineCount	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"	| cr count |	cr _ Character cr.	count _ 1  min: self size..	1 to: self size do:		[:i | (self at: i) == cr ifTrue: [count _ count + 1]].	^ count"'FredtheBear' lineCount"! !!String methodsFor: 'accessing'!lineNumber: anIndex	"Answer a string containing the characters in the given line number.  5/10/96 sw"	| crString pos finalPos |	crString _ String with: Character cr.	pos _ 0.	1 to: anIndex - 1 do:		[:i | pos _ self findString: crString startingAt: pos + 1.			pos == 0 ifTrue: [^ nil]].	finalPos _ self findString: crString startingAt: pos + 1.	finalPos == 0 ifTrue: [finalPos _ self size + 1].	^ self copyFrom: pos + 1 to: finalPos - 1"'FredtheBear' lineNumber: 3"! !!String methodsFor: 'accessing'!size	"Primitive. Answer the number of indexable fields in the receiver. This	value is the same as the largest legal subscript. Essential. See Object	documentation whatIsAPrimitive."	<primitive: 62>	^self basicSize! !!String methodsFor: 'accessing' stamp: 'tk 12/26/97 11:37'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim class == Character 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					ind _ 0.					this _ true.					delim do: [:dd | 						dd == (self at: ii+ind) ifFalse: [this _ false].						ind _ ind + 1].					this ifTrue: [ii _ ii + delim size - 1.  any _ true]]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		delimiters detect: [:delim | delim = (self at: i)]				ifNone: [^ i]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'sw 4/23/1998 10:53'!startsWithDigit	"Answer whether the receiver's first character represents a digit"	^ self size > 0 and: [self first isDigit]! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:16'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 1! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:17'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:17'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 3! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:18'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) >= 2! !!String methodsFor: 'comparing'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize _ (j _ self size) min: (k _ aString size).	bonus _ (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i _ 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i _ i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j _ j - 1.  k _ k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:31'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	| prefixSize |	prefixSize _ prefix size.	self size < prefixSize ifTrue: [^ false].	1 to: prefixSize do:		[:index | (self at: index) = (prefix at: index) ifFalse: [^ false]].	^ true! !!String methodsFor: 'comparing'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString; return the index of the final character that matched exactly.  4/29/96 sw"	| count |	count _ self size min: aString size.	count == 0 ifTrue: [^ 0].	1 to: count do:		[:i | (self at: i) == (aString at: i) ifFalse: [^ i - 1]] .	^ count! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:41'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^ self compare: self with: aString collated: CaseInsensitiveOrder! !!String methodsFor: 'comparing' stamp: 'go 2/11/98 14:59'!crc16	"Compute a 16 bit cyclic redundancy check."	| crc |	crc := 0.	self do: [:c |		crc := (crc bitShift: -8) bitXor: (		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)			 at: ((crc bitXor: c asciiValue) bitAnd: 16rFF) + 1) ].	^crc! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:31'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| mySize |	(mySize _ self size) < suffix size ifTrue: [^ false].	^ (self copyFrom: (mySize - suffix size + 1) to: mySize) = suffix"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing'!hash	| l m |	(l _ m _ self size) <= 2	  ifTrue:		[l = 2		  ifTrue: [m _ 3]		  ifFalse:			[l = 1			  ifTrue: [^((self at: 1) asciiValue bitAnd: 127) * 106].			^21845]].	^(self at: 1) asciiValue * 48 + ((self at: (m - 1)) asciiValue + l)! !!String methodsFor: 'comparing'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!String methodsFor: 'comparing'!match: text 	"Answer whether text matches the pattern in the receiver. Matching 	ignores upper/lower case differences. Where the receiver contains #, 	text may contain any single character. Where the receiver contains *, 	text may contain any sequence of characters."	| pattern scanning p t back textStream startScan |	pattern _ ReadStream on: self.	textStream _ ReadStream on: text.	scanning _ false.	[pattern atEnd]		whileFalse: 			[p _ pattern next.			p = $*				ifTrue: 					[pattern atEnd ifTrue: [^true].					scanning _ true.					startScan _ pattern position]				ifFalse: 					[textStream atEnd ifTrue: [^false].					t _ textStream next.					(t asUppercase = p asUppercase or: [p = $#])						ifFalse: 							[scanning ifFalse: [^false].							back _ startScan - pattern position.							pattern skip: back.							textStream skip: back + 1]].			(scanning and: [pattern atEnd and: [textStream atEnd not]])				ifTrue: [back _ startScan - pattern position.						pattern skip: back.						textStream skip: back + 1]			].	^textStream atEnd	" Examples: 	'xyz' match: 'Xyz'  true	'x#z' match: 'x@z' true 	'x*z' match: 'x whyNot? z' true	'*x' match: 'xx' true	"! !!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:19'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^ (self compare: self with: aString collated: CaseInsensitiveOrder) = 2! !!String methodsFor: 'copying'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!String methodsFor: 'copying'!copyUpTo: aCharacter 	"Answer a copy of the receiver from index 1 to the first occurrence of 	aCharacter, not including aCharacter."	| index |	index _ self indexOf: aCharacter ifAbsent: [^self].	^self copyFrom: 1 to: index-1! !!String methodsFor: 'copying'!deepCopy	"DeepCopy would otherwise mean make a copy of the character;  since 	characters are unique, just return a shallowCopy."	^self shallowCopy! !!String methodsFor: 'copying' stamp: 'di 2/15/98 22:54'!padded: leftOrRight to: length with: char	leftOrRight = #left ifTrue:		[^ (String new: (length - self size max: 0) withAll: char) , self].	leftOrRight = #right ifTrue:		[^ self , (String new: (length - self size max: 0) withAll: char)].! !!String methodsFor: 'converting'!asByteArray	"Convert to a ByteArray with the ascii values of the string.	Fast code uses primitive that avoids character conversion"	^ (ByteArray new: self size) replaceFrom: 1 to: self size with: self! !!String methodsFor: 'converting' stamp: 'tk 1/24/98 11:22'!asDate	"Many allowed forms, see Date.readFrom:"	^ Date readFrom: (ReadStream on: self)! !!String methodsFor: 'converting'!asDisplayText	"Answer a DisplayText whose text string is the receiver."	^DisplayText text: self asText! !!String methodsFor: 'converting'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	^FileDirectory checkName: self fixErrors: true! !!String methodsFor: 'converting'!asHtml	"Do the basic character conversion for HTML.  Leave all original return and tabs in place, so can conver back by simply removing bracked things.	4/4/96 tk"	| temp |	temp _ self copyReplaceAll: '&' with: '&amp;'.	temp _ temp copyReplaceAll: '<' with: '&lt;'.	temp _ temp copyReplaceAll: '>' with: '&gt;'.	temp _ temp copyReplaceAll: '	' 			with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp _ temp copyReplaceAll: '' 			with: '<BR>'.	^ temp! !!String methodsFor: 'converting' stamp: 'sw 5/3/1998 23:19'!asLegalSelector	| toUse |	toUse _ ''.	self do:		[:char | char isAlphaNumeric ifTrue: [toUse _ toUse copyWith: char]].	(self size == 0 or: [self first isLetter not])		ifTrue:		[toUse _ 'v', toUse].	^ toUse withFirstCharacterDownshifted"'234znak 43 ) 2' asLegalSelector"! !!String methodsFor: 'converting' stamp: 'di 2/2/98 12:59'!askIfAddStyle: priorMethod req: requestor	^ self   "we are a string with no text style"! !!String methodsFor: 'converting'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	| aStream |	aStream _ WriteStream on: (String new: self size).	self do: [:aCharacter | aStream nextPut: aCharacter asLowercase].	^aStream contents! !!String methodsFor: 'converting'!asNumber 	"Answer the Number created by interpreting the receiver as the string 	representation of a number."	^Number readFromString: self! !!String methodsFor: 'converting'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack _ pack * 256 + next asInteger ].! !!String methodsFor: 'converting'!asParagraph	"Answer a Paragraph whose text string is the receiver."	^Paragraph withText: self asText! !!String methodsFor: 'converting' stamp: 'jm 5/14/1998 10:40'!asString	"Answer this string."	^ self! !!String methodsFor: 'converting'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^Symbol intern: self! !!String methodsFor: 'converting'!asText	"Answer a Text whose string is the receiver."	^Text fromString: self! !!String methodsFor: 'converting' stamp: 'tk 1/24/98 11:27'!asTime	"Many allowed forms, see Time.readFrom:"	^ Time readFrom: (ReadStream on: self)! !!String methodsFor: 'converting'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convert the characters &<> back to their real value.  Leave actual cr and tab as they were in text.  4/12/96 tk"	| in out char rest did |	in _ ReadStream on: self.	out _ WriteStream on: (String new: self size).	[in atEnd] whileFalse: [		in peek = $< ifTrue: [in unCommand].	"Absorb <...><...>"		(char _ in next) = $&			ifTrue: [				rest _ in upTo: $;.				did _ out position.				rest = 'lt' ifTrue: [out nextPut: $<].				rest = 'gt' ifTrue: [out nextPut: $>].				rest = 'amp' ifTrue: [out nextPut: $&].				did = out position ifTrue: [					self error: 'new HTML char encoding'.					"Please add it to this code"]]			ifFalse: [out nextPut: char].		].	^ out contents! !!String methodsFor: 'converting'!asUppercase	"Answer a String made up from the receiver whose characters are all 	uppercase."	| aStream |	aStream _ WriteStream on: (String new: self size).	self do: [:aCharacter | aStream nextPut: aCharacter asUppercase].	^aStream contents! !!String methodsFor: 'converting'!capitalized	"Return a copy with the first letter capitalized"	| cap |	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize start result ri c ts |	null _ Character value: 0.	str _ self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize _ str size.	tokens doWithIndex:		[:token :tIndex |		start _ 1.		[(start _ str findString: token startingAt: start) > 0]			whileTrue:			[ts _ token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts _ token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize _ finalSize - (ts - 1).			start _ start + ts]].	result _ String new: finalSize.	ri _ 0.	1 to: str size do:		[:i | (c _ str at: i) = null ifFalse: [result at: (ri _ ri+1) put: c]].	^ result! !!String methodsFor: 'converting' stamp: 'di 1/16/98 16:33'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize _ smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results _ self correctAgainst: wordList continuedFrom: nil.	results _ self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting'!correctAgainst: wordList continuedFrom: oldCollection	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."	^ wordList isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordList do: action ]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting'!correctAgainstDictionary: wordDict continuedFrom: oldCollection	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."	^ wordDict isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'sw 4/23/1998 11:05'!initialInteger	"Answer the integer that is represented by the receiver up until its first non-digit character"	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ self asNumber].		^ (self copyFrom: 1 to: (pos = 0 ifTrue: [self size] ifFalse: [pos - 1])) asNumber! !!String methodsFor: 'converting'!keywords	"Answer an array of the keywords that compose the receiver."	| result aStream char |	result _ WriteStream on: (Array new: 10).	aStream _ WriteStream on: (String new: 16).	1 to: self size do:		[:i |		aStream nextPut: (char _ self at: i).		char = $: ifTrue: 				[result nextPut: aStream contents.				aStream reset]].	aStream isEmpty ifFalse: [result nextPut: aStream contents].	^ result contents! !!String methodsFor: 'converting'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely _ self copyUpTo: $..	^ likely size == 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix.  6/7/96 sw"	| stem suffix position |	stem _ self.	suffix _ 0.	position _ 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix _  stem last digitValue * position + suffix.		position _ position * 10.		stem _ stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix"'Fred2305' stemAndNumericSuffix"! !!String methodsFor: 'converting'!substrings	"Answer an array of the substrings that compose the receiver."	| result aStream char |	result _ WriteStream on: (Array new: 10).	aStream _ WriteStream on: (String new: 16).	1 to: self size do: [:i |		((char _ self at: i) isSeparator)		 ifTrue: [aStream isEmpty ifFalse: [result nextPut: aStream contents. aStream reset]]		 ifFalse: [aStream nextPut: char]].	aStream isEmpty ifFalse: [result nextPut: aStream contents].	^ result contents! !!String methodsFor: 'converting' stamp: 'sw 11/25/96'!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  "	^ $' asString, self, $' asString! !!String methodsFor: 'converting'!truncateTo: smallSize	"return myself or a copy shortened to smallSize.  1/18/96 sw"	^ self size <= smallSize		ifTrue:			[self]		ifFalse:			[self copyFrom: 1 to: smallSize]! !!String methodsFor: 'converting' stamp: 'jm 5/14/1998 10:26'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first |	first _ self findFirst: [:c | c isSeparator not].	first = 0 ifTrue: [^ ''].  "no non-separator character"	^ self		copyFrom: first		to: (self findLast: [:c | c isSeparator not])	" ' abc  d   ' withBlanksTrimmed"! !!String methodsFor: 'converting' stamp: 'sw 4/26/1998 01:19'!withFirstCharacterDownshifted	"'MElViN' withFirstCharacterDownshifted"	^ self first asLowercase asString, (self copyFrom: 2 to: self size)! !!String methodsFor: 'displaying'!displayAt: aPoint 	"Show a representation of the receiver as a DisplayText at location aPoint 	on the display screen."	self asDisplayText displayAt: aPoint! !!String methodsFor: 'displaying'!displayOn: aDisplayMedium	"Display the receiver on the given DisplayMedium.  5/16/96 sw"	self displayOn: aDisplayMedium at: 0 @ 0! !!String methodsFor: 'displaying'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location	aPoint on aDisplayMedium."	self asDisplayText displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'jm 2/18/98 16:30'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	| delta savedArea captionText textFrame barFrame outerFrame result range lastW w |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: self asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame _ barFrame translateBy: delta.	textFrame _ textFrame translateBy: delta.	outerFrame _ outerFrame translateBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	lastW _ 0.	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		w _ ((barFrame width-4) asFloat * ((barVal-minVal) asFloat / range min: 1.0)) asInteger.		w ~= lastW ifTrue: [			Display fillGray: (barFrame topLeft + (2@2) extent: w@16).			lastW _ w]].	savedArea displayOn: Display at: outerFrame topLeft.	^ result! !!String methodsFor: 'printing' stamp: 'sw 4/25/1998 12:52'!basicType	"number string boolean player collection sound color etc"	^ #string! !!String methodsFor: 'printing'!isLiteral	^true! !!String methodsFor: 'printing'!printOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	^self storeOn: aStream! !!String methodsFor: 'printing'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x _ self at: i).		x == $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'printing'!stringRepresentation	"Answer a string that represents the receiver.  For most objects this is simply its printString, but for strings themselves, it's themselves, to avoid the superfluous extra pair of quotes.  6/12/96 sw"	^ self ! !!String methodsFor: 'private'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take abnother block and enumerate over some list with it."	| choices scoreMin results score |	scoreMin _ self size // 2 min: 3.	oldCollection isNil		ifTrue: [ choices _ SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices _ oldCollection ].	wordBlock isNil		ifTrue:			[ results _ OrderedCollection new.			1 to: (5 min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word |				(score _ self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= 5) ifTrue: [ scoreMin _ (choices at: 5) value] ] ].			results _ choices ].	^ results! !!String methodsFor: 'private'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!String methodsFor: 'private'!stringhash	^self hash! !!String methodsFor: 'system primitives' stamp: 'jm 2/15/98 18:07'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 235>	self var: #string1 declareC: 'unsigned char *string1'.	self var: #string2 declareC: 'unsigned char *string2'.	self var: #order declareC: 'unsigned char *order'.	len1 _ string1 size.	len2 _ string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 _ order at: (string1 basicAt: i) + 1.		c2 _ order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String methodsFor: 'system primitives'!numArgs	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons |	firstChar _ self at: 1.	firstChar isLetter ifTrue:		[ firstChar isUppercase ifTrue: [ ^ -1 ].		numColons _ 0. 		self do: [ :ch |			ch tokenish ifFalse: [ ^ -1 ].			(ch = $:) ifTrue: [numColons _ numColons + 1] ].		^ (self last = $:)			ifTrue: [ numColons > 0 ifTrue: [ numColons ] ifFalse: [ -1 ] ]			ifFalse: [ numColons > 0 ifTrue: [ -1 ] ifFalse: [ 0 ] ] ].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		self size > 2 ifTrue: [^ -1].		^ (self at: 2) isSpecial ifTrue: [1] ifFalse: [-1]].	self = #- ifTrue: [ ^ 1 ].	^ -1.! !!String methodsFor: 'Celeste'!includesSubstring: aString caseSensitive: caseSensitive	"Note: Although less general than the 'match:' method, this method was a factor of 10 faster on both successful and unsucessful finds of a short string in a 1116 byte mail message."		| first index i |	self isEmpty ifTrue: [^false].	caseSensitive ifTrue: [		first _ aString first.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) = first ifTrue: [				i _ 1.				[(self at: start + i - 1) = (aString at: i)] whileTrue: [					i = aString size ifTrue: [^true].					i _ i + 1.				].			].		].	] ifFalse: [		first _ aString first asLowercase.		1 to: self size - aString size + 1 do: [ :start |			(self at: start) asLowercase = first ifTrue: [				i _ 1.				[(self at: start + i - 1) asLowercase =				 (aString at: i) asLowercase] whileTrue: [					i = aString size ifTrue: [^ true].					i _ i + 1.				].			].		].	].	^ false! !!String methodsFor: 'Celeste'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!String class	instanceVariableNames: ''!!String class methodsFor: 'instance creation' stamp: 'jm 5/6/1998 18:39'!cr	"Answer a string containing a single carriage return character."	^ self with: Character cr! !!String class methodsFor: 'instance creation'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s |	s _ self new: 4.	s at: 1 put: (aLong digitAt: 4) asCharacter.	s at: 2 put: (aLong digitAt: 3) asCharacter.	s at: 3 put: (aLong digitAt: 2) asCharacter.	s at: 4 put: (aLong digitAt: 1) asCharacter.	^s"String fromPacked: 'TEXT' asPacked"! !!String class methodsFor: 'instance creation' stamp: 'di 1/14/98 10:26'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."		^ aString copyFrom: 1 to: aString size! !!String class methodsFor: 'instance creation'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream _ WriteStream on: (String new: 16).	"go to first quote"	inStream skipTo: $'.	done _ false.	[done or: [inStream atEnd]]		whileFalse: 			[char _ inStream next.			char = $'				ifTrue: 					[char _ inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done _ true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!String class methodsFor: 'examples'!example	"To see the string displayed at the cursor point, execute this expression	and select a point by pressing a mouse button."	'this is some text' displayOn: Display at: Sensor waitButton! !!String class methodsFor: 'initialization' stamp: 'di 2/12/98 13:06'!initialize  "String initialize"	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue				put: (CaseInsensitiveOrder at: c asUppercase asciiValue)]! !StringMorph subclass: #StringButtonMorph	instanceVariableNames: 'target actionSelector arguments actWhen oldColor '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!StringButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self color: Color black.	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	self contents: 'Flash'.! !!StringButtonMorph methodsFor: 'menu'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label' action: #setLabel.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].! !!StringButtonMorph methodsFor: 'menu'!setActionSelector	| newSel |	newSel _ FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed'		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!StringButtonMorph methodsFor: 'menu'!setActWhen	actWhen _ (SelectionMenu selections: #(buttonDown buttonUp whilePressed))		startUpWithCaption: 'Choose one of the following conditions'! !!StringButtonMorph methodsFor: 'menu'!setArguments	| s newArgs newArgsArray |	s _ WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs _ FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods'		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray _ Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!StringButtonMorph methodsFor: 'menu'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please type a new label for this button'		initialAnswer: self contents.	newLabel isEmpty ifFalse: [self contents: newLabel].! !!StringButtonMorph methodsFor: 'menu'!setTarget: evt	| rootMorphs |	rootMorphs _ self world rootMorphsAt: evt hand targetOffset.	rootMorphs size > 1		ifTrue: [target _ rootMorphs at: 2]		ifFalse: [target _ nil. ^ self].! !!StringButtonMorph methodsFor: 'accessing'!actionSelector	^ actionSelector! !!StringButtonMorph methodsFor: 'accessing'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!StringButtonMorph methodsFor: 'accessing'!actWhen: aSymbol	"Set the condition under which to invoke my action to one of: #buttonDown, #buttonUp, and #whilePressed."	actWhen _ aSymbol.! !!StringButtonMorph methodsFor: 'accessing'!arguments	^ arguments! !!StringButtonMorph methodsFor: 'accessing'!arguments: aCollection	arguments _ aCollection asArray copy.! !!StringButtonMorph methodsFor: 'accessing'!target	^ target! !!StringButtonMorph methodsFor: 'accessing'!target: anObject	target _ anObject! !!StringButtonMorph methodsFor: 'events'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!StringButtonMorph methodsFor: 'events'!handlesMouseDown: evt	^ true! !!StringButtonMorph methodsFor: 'events'!mouseDown: evt	oldColor _ color.	actWhen == #buttonDown		ifTrue: [self doButtonAction].! !!StringButtonMorph methodsFor: 'events'!mouseMove: evt	(self containsPoint: evt cursorPoint)		ifTrue: [			self color: (oldColor mixed: 1/2 with: Color white).			actWhen == #whilePressed ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !!StringButtonMorph methodsFor: 'events'!mouseUp: evt	self color: oldColor.	(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!StringButtonMorph methodsFor: 'copying' stamp: 'jm 7/28/97 11:55'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringButtonMorph class	instanceVariableNames: ''!!StringButtonMorph class methodsFor: 'all' stamp: 'sw 2/16/98 03:02'!defaultNameStemForInstances	^ 'SButton'! !Model subclass: #StringHolder	instanceVariableNames: 'contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!StringHolder commentStamp: 'di 5/22/1998 16:38' prior: 0!I am a kind of Model that includes a piece of text.  In some cases, the text can be edited, and in some the text is a method.Categories 'code pane menu' and 'message list menu' are messages that may be called by my menus when the text is a method, and when some pane is a list of methods.  Other of my subclasses may ignore these two catagories altogether.!!StringHolder methodsFor: 'initialize-release'!defaultBackgroundColor	^ #lightYellow! !!StringHolder methodsFor: 'initialize-release'!defaultContents	^''! !!StringHolder methodsFor: 'initialize-release' stamp: 'jm 3/24/98 17:56'!initialize	"Initialize the state of the receiver with its default contents."	contents _ self defaultContents.! !!StringHolder methodsFor: 'initialize-release' stamp: 'di 5/19/1998 15:34'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: nil)		frame: (0@0 corner: 1@1).	window openInWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'di 5/8/1998 22:32'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it."	| topView codeView |	World ifNotNil: [^ self openAsMorphLabel: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	topView controller open! !!StringHolder methodsFor: 'accessing' stamp: 'di 5/19/1998 15:34'!acceptContents: aString 	"Set aString to be the contents of the receiver.  Return true cuz happy"	self contents: aString.	^ true! !!StringHolder methodsFor: 'accessing'!contents	"Answer the contents that the receiver is holding--presumably a string."	^contents! !!StringHolder methodsFor: 'accessing' stamp: 'di 5/19/1998 15:32'!contents: aString 	"Set aString to be the contents of the receiver."	contents _ aString asString! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/3/98 22:50'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 14:59'!selectedClassName	"I may know what class is currently selected"	self selectedClass ifNotNil: [^ self selectedClass name].	^ nil! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:01'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:22'!selectedMessageName	^ nil! !!StringHolder methodsFor: 'evaluation'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!StringHolder methodsFor: 'evaluation'!doItReceiver	"Answer the object that should be informed of the result of evaluating a 	text selection."	^nil! !!StringHolder methodsFor: 'user edits' stamp: 'di 4/21/1998 11:30'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!StringHolder methodsFor: 'user edits' stamp: 'tk 4/13/1998 23:07'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!StringHolder methodsFor: 'code pane menu' stamp: 'tk 4/6/98 11:43'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override doMenuItem:, PluggableTextController will respond to all menu items in a text pane"| shiftMenu |^ shifted 	ifFalse: [aMenu 		labels: PluggableTextController yellowButtonMenu labelString 		lines: PluggableTextController yellowButtonMenu lineArray		selections: PluggableTextController yellowButtonMessages]	ifTrue: [shiftMenu _ PluggableTextController shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: PluggableTextController shiftedYellowButtonMessages]! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 4/11/98 11:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	(#(showBytecodes) includes: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'code pane menu' stamp: 'tk 4/6/98 11:43'!showBytecodes	"We don't know how to do this"	^ self changed: #flash! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 08:38'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aClass aName method filteredList |	(aName _ self selectedMessageName) ifNotNil: [		method _ (aClass _ self selectedClassOrMetaClass) compiledMethodAt: aName.		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		Smalltalk browseAllImplementorsOfList: filteredList asSortedCollection			 title: 'All messages sent in ', aClass name, '.', aName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 16:11'!browseClass	"Open an class browser on this class and method"	self selectedClassOrMetaClass ifNotNil: [		Browser newOnClass: self selectedClassOrMetaClass 			selector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 16:32'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk browseAllCallsOn: (Smalltalk associationAt: cls theNonMetaClass name)]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:02'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	(cls _ self selectedClass) ifNotNil: [cls browseClassVarRefs]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:02'!browseClassVariables	"Browse the class varialbes of the selected class.  2/5/96 sw"	| cls |	(cls _ self selectedClass) ifNotNil: [cls browseClassVariables]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:02'!browseInstVarDefs 	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [cls browseInstVarDefs]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:02'!browseInstVarRefs 	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [cls browseInstVarRefs]! !!StringHolder methodsFor: 'message list menu' stamp: 'wod 5/15/1998 00:54'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen.	Do nothing if no message is chosen."	self selectMessageAndEvaluate: [:selector | Smalltalk browseAllImplementorsOf: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 09:28'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'wod 5/15/1998 00:54'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen."	self selectMessageAndEvaluate: [:selector | Smalltalk browseAllCallsOn: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:03'!browseUnusedMethods	| classes unsent messageList cls |	(cls _ self selectedClass) ifNil: [^ self].	classes _ Array with: cls with: cls class.	unsent _ Set new.	classes do: [:c | unsent addAll: c selectors].	unsent _ Smalltalk allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asSortedCollection					do: [:sel | messageList add: c name , ' ' , sel]].	Smalltalk browseMessageList: messageList name: 'Unsent Methods in ', cls name! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 18:37'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		ChangeList			browseVersionsOf: (class compiledMethodAt: selector)			class: self selectedClass			meta: class isMeta			category: self selectedMessageCategoryName			selector: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 19:14'!buildMessageBrowser	"Create and schedule a message browser."	self selectedMessageName ifNil: [^ self].	Browser openMessageBrowserForClass: self selectedClassOrMetaClass 		selector: self selectedMessageName editString: nil! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 16:06'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	Utilities spawnHierarchyForClass: self selectedClassOrMetaClass "OK if nil"		selector: self selectedMessageName! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 18:15'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]! !!StringHolder methodsFor: 'message list menu' stamp: 'di 5/6/1998 17:03'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName _ self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 09:23'!inspectInstances	"Inspect all instances of the selected class."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[myClass theNonMetaClass inspectAllInstances]. ! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 09:00'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass theNonMetaClass inspectSubInstances].! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/18/1998 15:27'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	| sel class |	(sel _ self selectedMessageName) ifNil: [^ self arrowKey: aChar from: view].	aChar == $m ifTrue: [Smalltalk browseAllImplementorsOf: sel].	aChar == $n ifTrue: [Smalltalk browseAllCallsOn: sel].	aChar == $b ifTrue: [		(class _ self selectedClass) ifNotNil: [			Browser fullOnClass: class selector: sel]].	^ self arrowKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 07:57'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	Utilities methodHierarchyBrowserForClass: self selectedClassOrMetaClass 			selector: self selectedMessageName! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/28/1998 18:16'!printOutMessage	"Write a file with the text of the selected message, for printing by a web browser"	self selectedMessageName ifNotNil: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName							asHtml: true]! !!StringHolder methodsFor: 'message list menu' stamp: 'tk 4/21/1998 09:07'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'wod 5/15/1998 00:53'!selectMessageAndEvaluate: aBlock	"Present a menu of the currently selected message, as well as	all messages sent by it. Evalute aBlock with the selector of the 	message chosen. Do nothing if no message is chosen."	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ self selectedClassOrMetaClass 		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	Smalltalk 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringHolder class	instanceVariableNames: ''!!StringHolder class methodsFor: 'class initialization'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace _ StringHolder new"	"StringHolder initialize"! !!StringHolder class methodsFor: 'instance creation'!new	^super new initialize! !!StringHolder class methodsFor: 'instance creation' stamp: 'tk 5/4/1998 17:32'!open	(Smalltalk at: #Workspace) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!StringHolder class methodsFor: 'instance creation' stamp: 'tk 5/4/1998 16:41'!openLabel: aString	self new openLabel: aString! !!StringHolder class methodsFor: 'workspace constants'!originalWorkspaceContents 	^ self class firstCommentAt: #originalWorkspaceContents	"			 Smalltalk-80			 August 1st, 1985  Copyright (c) 1981, 1982 Xerox Corp. Copyright (c) 1985 Apple Computer, Inc.		   All rights reserved.Changes and FilesSmalltalk noChanges.Smalltalk condenseChangesDisplayScreen removeFromChanges.Smalltalk changes asSortedCollectionSmalltalk browseChangedMessages(FileStream fileNamed: 'changes.st') fileOutChanges.FileStream fileNamed: 'PenChanges.st') fileOutChangesFor: Pen.(FileStream oldFileNamed: 'Toothpaste.st') fileIn.(FileStream fileNamed: 'Hello') edit.FileDirectory filesMatching: '*.st'InquiryInputState browseAllAccessesTo: 'deltaTime'.Smalltalk browseAllCallsOn: #isEmpty.Smalltalk browseAllImplementorsOf: #includes:Smalltalk browseAllCallsOn:	(Smalltalk associationAt: #Mac)Smalltalk browseAllCallsOn:	(Cursor classPool associationAt: #ReadCursor).Smalltalk browseAllCallsOn:	(Undeclared associationAt: #Disk)Smalltalk browseAllMethodsInCategory: #examples(Smalltalk collectPointersTo: StrikeFont someInstance) inspect.Smalltalk garbageCollect.FileStream instanceCount 4FormView allInstances inspect.Smalltalk browse:  RandomHouseCleaningUndeclared _ Dictionary new.Undeclared keysUndeclared associationsDo:	[:assn | Smalltalk browseAllCallsOn: assn](Object classPool at: #DependentsFields) keys(Object classPool at: #DependentsFields) keysDo: 	[:each | (each isKindOf: DisplayText)		ifTrue: [each release]]Transcript clear.Smalltalk allBehaviorsDo: ""remove old do it code""	[:class | class removeSelector: #DoIt; 			removeSelector: #DoItIn:].Smalltalk removeKey: #GlobalName.Smalltalk declare: #GlobalName	from: Undeclared.GlobalsNames in Smalltalk other than Classes and Pools:	Display -- a DisplayScreen	Processor --  a ProcessorScheduler 	ScheduledControllers -- a ControlManager	Sensor -- an InputSensor	Transcript -- a TextCollector	SourceFiles -- Array of FileStreams	SystemOrganization -- a SystemOrganizer	StartUpList -- an OrderedCollection	ShutDownList -- an OrderedCollectionVariable Pools (Dictionaries)	Smalltalk 	FilePool	BitMaskPool	TextConstants	UndeclaredSystem FilesSourceFiles _ Array				""open source files""	with: (FileStream oldFileNamed:				Smalltalk sourcesName) readOnly	with: (FileStream oldFileNamed:				Smalltalk changesName).(SourceFiles at: 1) close.			""close source files""(SourceFiles at: 2) close.SourceFiles _ Array new: 2.MeasurementsSmalltalk spaceLeft '16381 objects, 104308 words.'Symbol instanceCount 3697BlockContext instanceCount 14Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop] 11504MessageTally spyOn: [Smalltalk allCallsOn: #asOop].Crash recoverySmalltalk recover: 5000.""This is the string found in the image, Feb 91"! !ParagraphEditor subclass: #StringHolderController	instanceVariableNames: ''	classVariableNames: 'CodeYellowButtonMenu CodeYellowButtonMessages '	poolDictionaries: ''	category: 'Interface-Support'!!StringHolderController commentStamp: 'di 5/22/1998 16:38' prior: 0!StringHolderController comment:'I represent a ParagraphEditor for a single paragraph of text, omitting alignment commands. I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.	doIt	evaluate the text selection as an expression	printIt	same as doIt but insert a description of the result after the selection	accept	store the contents of the StringHolder into the model	cancel	store the contents of the model into the StringHolder'!!StringHolderController methodsFor: 'accessing'!model: aModel	super model: aModel.	view displayContents == nil		ifFalse: [self changeParagraph: view displayContents]! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:09'!userHasEdited	"Note that the user has edited my text."	view hasUnacceptedEdits: true! !!StringHolderController methodsFor: 'edit flag' stamp: 'tk 4/13/1998 23:08'!userHasNotEdited	"Note that my text is free of user edits."	model clearUserEditFlag! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:53'!accept 	"Refer to the comment in ParagraphEditor|accept."	super accept.	model contents: paragraph string.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'jm 3/18/98 20:54'!cancel 	"Refer to the comment in ParagraphEditor|cancel."	super cancel.	self userHasNotEdited.! !!StringHolderController methodsFor: 'menu messages' stamp: 'sw 9/27/96'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self controlTerminate.	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or:	 [result == #failedDoit]) ifFalse: [		Smalltalk			browseAllObjectReferencesTo: result			except: #()			ifNone: [:obj | view topView flash. self controlInitialize]].! !!StringHolderController methodsFor: 'menu messages' stamp: 'tk 4/13/1998 23:14'!performMenuMessage: aSelector	"Intercept #again so the model does not get locked by keying the search text."	| hadEdits |	hadEdits _ view canDiscardEdits not.	super performMenuMessage: aSelector.	(hadEdits not and:	 [aSelector == #again and:	 [(UndoMessage sends: #undoAgain:andReselect:typedKey:) and:	 [UndoMessage arguments at: 3]]])		ifTrue: [self userHasNotEdited].! !!StringHolderController methodsFor: 'compiler access'!bindingOf: aString	^model bindingOf: aString! !!StringHolderController methodsFor: 'editing keys' stamp: 'tk 4/21/1998 09:23'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it.  2/7/96 sw.	2/29/96 sw: fixed erratic behavior in the cmd-key-down case -- was not always giving the 'select-line-first' behavior when the selection was empty."	sensor keyboard.  "consume enter key"	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self controlTerminate.			self accept.			self controlInitialize].	^ true! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:43'!closeTypeIn	"Note edit if something actually was typed."	beginTypeInBlock ~~ nil ifTrue: [self userHasEdited].	super closeTypeIn.! !!StringHolderController methodsFor: 'private'!initializeYellowButtonMenu	self yellowButtonMenu: CodeYellowButtonMenu 		yellowButtonMessages: CodeYellowButtonMessages! !!StringHolderController methodsFor: 'private' stamp: 'jm 3/18/98 20:45'!zapSelectionWith: aText	"Note edit except during typeIn, which notes edits at close."	super zapSelectionWith: aText.	beginTypeInBlock == nil ifTrue: [self userHasEdited].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringHolderController class	instanceVariableNames: ''!!StringHolderController class methodsFor: 'class initialization' stamp: 'sw 1/26/96'!initialize	"Initialize the yellow button pop-up menu and corresponding messages.	 1/12/96 sw: added senders of it, etc.  1/15/96 sw: explain	 1/22/96 sw: cmd keys detailed	 1/24/96 sw: added find; moved many items to shifted side etc.	 : made compatible with paragraph editor's version; I'm not clear on when/how this guy gets used (seemingly eg in a workspace) vs when the paragraph editor's does (seemingly in browsers)	 : correct cmd-key equivalent for do again, and add set-search-string"	CodeYellowButtonMenu _ 		PopUpMenu 			labels: 'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)do it (d)print it (p)inspect it (i)accept (s)cancel (l)show bytecodesmore...' 		lines: #(3 5 8 11 13 14).	CodeYellowButtonMessages _ 		#(find findAgain setSearchString again undo copySelection cut paste doIt printIt inspectIt accept cancel showBytecodes shiftedYellowButtonActivity)	"StringHolderController initialize"! !!StringHolderController class methodsFor: 'class initialization' stamp: 'tk 3/31/98 16:24'!yellowButtonMenu	^ CodeYellowButtonMenu! !!StringHolderController class methodsFor: 'class initialization' stamp: 'tk 3/31/98 16:24'!yellowButtonMessages	^ CodeYellowButtonMessages! !View subclass: #StringHolderView	instanceVariableNames: 'displayContents hasUnacceptedEdits askBeforeDiscardingEdits '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!StringHolderView commentStamp: 'di 5/22/1998 16:38' prior: 0!StringHolderView comment:'I am a View of a String that is an aspect of a more structured object. This String should not be changed by any editing unless the user issues the accept command. Thus my instances provide a working copy of the String. This copy is edited. When the user issues the accept command, the String is copied from the working version; or if the user issues the cancel command, the working version is restored from the String. StringHolderController is my default controller. It is initialized specially by passing the string viewed which is then converted to a Paragraph for editing.'!!StringHolderView methodsFor: 'initialize-release' stamp: 'jm 3/24/98 14:39'!initialize 	"Refer to the comment in View|initialize."	super initialize.	displayContents _ '' asParagraph.	hasUnacceptedEdits _ false.	askBeforeDiscardingEdits _ true.! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 14:38'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 17:49'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ hasUnacceptedEdits! !!StringHolderView methodsFor: 'updating' stamp: 'tk 4/13/1998 17:17'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value."	hasUnacceptedEdits _ aBoolean.! !!StringHolderView methodsFor: 'updating' stamp: 'jm 3/24/98 16:06'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?') ifTrue: [model clearUserEditFlag].		^ self].	stripes _ Form extent: 16@16 fromStipple: 16r36C9.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel _ self confirm: 'Changes have not been saved.Is it OK to cancel those changes?'.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView methodsFor: 'updating' stamp: 'di 4/21/1998 11:30'!update: aSymbol	"Refer to the comment in View|update:."	aSymbol == #wantToChange ifTrue: [^ self promptForCancel].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #flash ifTrue: [^ controller flash].	self updateDisplayContents! !!StringHolderView methodsFor: 'updating'!updateDisplayContents	"Make the text that is displayed be the contents of the receiver's model."	self editString: model contents.	self displayView! !!StringHolderView methodsFor: 'controller access'!defaultController 	"Refer to the comment in View|defaultController."	^self defaultControllerClass newParagraph: displayContents! !!StringHolderView methodsFor: 'controller access'!defaultControllerClass 	"Refer to the comment in View|defaultControllerClass."	^StringHolderController! !!StringHolderView methodsFor: 'controller access'!displayContents	^displayContents! !!StringHolderView methodsFor: 'displaying'!display 	"Refer to the comment in View.display."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super display! !!StringHolderView methodsFor: 'displaying'!displayView 	"Refer to the comment in View|displayView."	self clearInside.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller display]		ifFalse: [displayContents display]! !!StringHolderView methodsFor: 'displaying'!lock	"Refer to the comment in view|lock.  Must do at least what display would do to lock the view."	(self isUnlocked and: [self insetDisplayBox ~= displayContents clippingRectangle])		ifTrue:  "Recompose the text if the window changed"				[self positionDisplayContents. 				(self controller isKindOf: ParagraphEditor)					ifTrue: [controller recomputeSelection]].	super lock! !!StringHolderView methodsFor: 'displaying'!positionDisplayContents	"Presumably the text being displayed changed so that the wrapping box 	and clipping box should be reset."	displayContents 		wrappingBox: (self insetDisplayBox insetBy: 6 @ 0)		clippingBox: self insetDisplayBox! !!StringHolderView methodsFor: 'model access'!editString: aString 	"The paragraph to be displayed is created from the characters in aString."	displayContents _ Paragraph withText: aString asText		style: TextStyle default copy		compositionRectangle: (self insetDisplayBox insetBy: 6 @ 0)		clippingRectangle: self insetDisplayBox		foreColor: self foregroundColor backColor: self backgroundColor.	(self controller isKindOf: ParagraphEditor)		ifTrue: [controller changeParagraph: displayContents]! !!StringHolderView methodsFor: 'model access'!model: aLockedModel 	"Refer to the comment in View|model:." 	super model: aLockedModel.	self editString: model contents! !!StringHolderView methodsFor: 'deEmphasizing'!deEmphasizeView 	"Refer to the comment in View|deEmphasizeView."	(self controller isKindOf: ParagraphEditor)	 	ifTrue: [controller deselect]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringHolderView class	instanceVariableNames: ''!!StringHolderView class methodsFor: 'instance creation'!container	"Answer an instance of me with a new instance of StringHolder as the 	model."	^self container: StringHolder new! !!StringHolderView class methodsFor: 'instance creation'!container: aContainer 	"Answer an instance of me whose model is aContainer. Give it a 2-dot 	border."	| aCodeView |	aCodeView _ self new model: aContainer.	aCodeView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	^aCodeView! !!StringHolderView class methodsFor: 'instance creation'!open	"Create a standard system view of a workspace on the screen."	self open: Workspace new label: 'Workspace'! !!StringHolderView class methodsFor: 'instance creation'!open: aStringHolder 	"Create a standard system view of the argument, aStringHolder, as viewed 	by an instance of me. The view has label 'StringHolder'."	self open: aStringHolder label: 'StringHolder'! !!StringHolderView class methodsFor: 'instance creation' stamp: 'di 5/8/1998 22:32'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	World ifNotNil: [^ aStringHolder openAsMorphLabel: labelString].	aStringHolderView _ self container: aStringHolder.	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !Morph subclass: #StringMorph	instanceVariableNames: 'font contents hasFocus '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!StringMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color black.	font _ nil.	hasFocus _ false.	self contents: 'StringMorph'.! !!StringMorph methodsFor: 'initialization' stamp: '6/11/97 09:01 di'!initWithContents: aString font: aFont	super initialize.	color _ Color black.	font _ aFont.	hasFocus _ false.	self contents: aString.! !!StringMorph methodsFor: 'accessing'!contents	^ contents! !!StringMorph methodsFor: 'accessing'!contents: aString	contents = aString ifTrue: [^ self].  "no substantive change"	contents _ aString.	self fitContents.! !!StringMorph methodsFor: 'accessing'!contentsClipped: aString	"Change my text, but do not change my size as a result"	contents = aString ifTrue: [^ self].  "No substantive change"	contents _ aString.	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'di 11/14/97 11:29'!fitContents	| scanner |	scanner _ QuickPrint newOn: Display box: Display boundingBox font: font.	self extent: (scanner stringWidth: contents) @ (scanner lineHeight).	self changed! !!StringMorph methodsFor: 'accessing' stamp: '6/7/97 09:57 di'!font: aFont	font _ aFont.	self fitContents."in inspector say,	 self font: ((TextStyle default fontAt: 2) emphasized: 1)"! !!StringMorph methodsFor: 'accessing'!setWidth: width	| f |	f _ font ifNil: [TextStyle default fontAt: 1].	self extent: width @ f height.! !!StringMorph methodsFor: 'drawing'!drawOn: aCanvas	hasFocus ifTrue: [aCanvas fillRectangle: self bounds color: Color yellow].	aCanvas text: contents bounds: bounds font: font color: color.! !!StringMorph methodsFor: 'editing'!acceptContents	"The message is sent when the user hits enter or Cmd-S. Accept the current contents and end editing. This default implementation does nothing."! !!StringMorph methodsFor: 'editing' stamp: 'sw 11/5/97 14:30'!handlesMouseDown: evt	^ (evt shiftPressed and: [owner wantsKeyboardFocusFor: self])		ifTrue: [self uncoveredAt: evt cursorPoint]		ifFalse: [super handlesMouseDown: evt].! !!StringMorph methodsFor: 'editing'!keyboardFocusChange: aBoolean	hasFocus _ aBoolean.	self changed.! !!StringMorph methodsFor: 'editing'!keyStroke: evt	"Handle a keystroke event."	| ch |	ch _ evt keyCharacter.	ch = Character backspace ifTrue: [  "backspace"		contents size > 0 ifTrue: [			self contents: (contents copyFrom: 1 to: contents size - 1)].		^ self].	(ch = $x and: [evt commandKeyPressed]) ifTrue: [  "cut"		Smalltalk clipboardText: contents.		^ self contents: ''].	(ch = $c and: [evt commandKeyPressed]) ifTrue: [  "copy"		Smalltalk clipboardText: contents.		^ self].	(ch = $v and: [evt commandKeyPressed]) ifTrue: [  "paste"		^ self contents: Smalltalk clipboardText].	((evt keyCharacter = Character enter) or:	 [(evt keyCharacter = Character cr) or:	 [evt keyCharacter = $s and: [evt commandKeyPressed]]]) ifTrue: [  "accept"		self acceptContents.		evt hand newKeyboardFocus: evt hand world.		^ self].	self contents: (contents copyWith: ch).  "append the character"! !!StringMorph methodsFor: 'editing'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	evt shiftPressed		ifTrue: [evt hand newKeyboardFocus: self]		ifFalse: [super mouseDown: evt].! !!StringMorph methodsFor: 'editing' stamp: 'sw 5/6/1998 15:45'!wouldAcceptKeyboardFocus	^ self isLocked not! !!StringMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') contents: '; print: contents! !!StringMorph methodsFor: 'printing' stamp: 'jm 11/3/97 16:52'!printOn: aStream	super printOn: aStream.	aStream print: contents.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringMorph class	instanceVariableNames: ''!!StringMorph class methodsFor: 'instance creation' stamp: 'sw 5/6/1998 14:00'!authoringPrototype	^ super authoringPrototype contents: 'String'! !!StringMorph class methodsFor: 'instance creation' stamp: 'sw 8/22/97 22:19'!contents: aString	" 'StringMorph contents: str' is faster than 'StringMorph new contents: str' "	^ self contents: aString font: nil! !!StringMorph class methodsFor: 'instance creation' stamp: 'sw 8/22/97 22:19'!contents: aString font: aFont	^ self basicNew initWithContents: aString font: aFont! !!StringMorph class methodsFor: 'testing' stamp: 'di 5/6/1998 21:07'!test	"Return a morph with lots of strings for testing display speed."	| c |	c _ AlignmentMorph newColumn.	SystemOrganization categories do:		[:cat | c addMorph: (StringMorph new contents: cat)].	^ c! !!StringMorph class methodsFor: 'testing' stamp: 'di 5/6/1998 21:08'!test2	"Return a morph with lots of strings for testing display speed."	| c r |	c _ AlignmentMorph newColumn.	SystemOrganization categories reverseDo:		[:cat | c addMorph: (StringMorph new contents: cat)].	r _ RectangleMorph new extent: c fullBounds extent.	c submorphsDo: [:m | r addMorph: m].	^ r! !TileMorph subclass: #StringReadoutTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!StringReadoutTile methodsFor: 'all' stamp: 'sw 11/1/97 13:15'!literal: anObject	literal _ anObject.	self updateLiteralLabel.	submorphs last informTarget! !!StringReadoutTile methodsFor: 'all' stamp: 'sw 11/1/97 13:15'!literal: anObject width: w	literal _ anObject.	self updateLiteralLabelClipped.	submorphs last		setWidth: w;		informTarget.	self updateLiteralLabelClipped! !!StringReadoutTile methodsFor: 'all' stamp: 'sw 10/31/97 13:05'!setLiteralTo: anObject width: w	"like literal:width: but does not inform the target"	literal _ anObject.	self updateLiteralLabelClipped.	submorphs last		setWidth: w.	self updateLiteralLabelClipped! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StringReadoutTile class	instanceVariableNames: ''!!StringReadoutTile class methodsFor: 'all' stamp: 'sw 10/3/97 13:59'!defaultW	^ 26! !ServerAction subclass: #SwikiAction	instanceVariableNames: 'urlmap source name lastPageMethod formatters '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!SwikiAction commentStamp: 'di 5/22/1998 16:38' prior: 0!SwikiAction is the action to implement a Swiki, a collaborative website.  This is a web server in Squeak.  The pages may be viewed from any web browser, and the URL is http://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swiki area.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an example focused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by Ward Cunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or the Squeak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do not snapshot the image during normal server operation.  Restart the server by loading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of the folder is the name of the Wiki, Each page is a file.  (Inefficient on Macs because of large minimum page size, but that's an OS problem.)  All versions of all pages are kept.  Each page contains chunks, just like a changes file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text: 'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytes from just in front of the number to the start of the chunk.  This allows back-chaining to old versions.  On startup, the chunk is executed explicitly using evaluate:for:logged:.  It supplies the page name to a SwikiPage and installs it in the URLmap.  By doing this for all files in the folder, the map (url->page) is built.  During operation, the chunk is not executed.  Instead, take the file directly, look at 'back:' at the end, jump back to the start of the chunk, scan for 'text:' and read the text. The looks of the pages served are controlled by templates.  They live in the 'swiki' folder in the 'Server' folder.  Beware that templates are cached by HTMLformatter.  If you change a template, you will not see the effect until you reload the Swiki.!]style[(531 20 1481)f1,f1LPWS class howToStart;,f1!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!map	"Answer the receiver's 'urlmap'."	^urlmap! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:23'!map: anObject	"Set the receiver's instance variable 'urlmap' to be anObject."	urlmap := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!name	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'tk 1/15/98 13:38'!path	"A complete file path name to the directory where my page data is stored"	^ (ServerAction serverDirectory) , name, (ServerAction pathSeparator)! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!source	"Answer the receiver's 'source'."	^source! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!source: anObject	"Set the receiver's instance variable 'source' to be anObject."	source := anObject! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!urlmap	"Answer the receiver's 'urlmap'."	^urlmap! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:22'!urlmap: anObject	"Set the receiver's instance variable 'urlmap' to be anObject."	urlmap := anObject! !!SwikiAction methodsFor: 'save and restore' stamp: 'tk 1/26/98 14:56'!convert	"Make all my pages obey the new format -- all versions in one file, file name is just a single number."	| old new nn |	urlmap pages do: [:page |		old _ page file.   nn _ old size.		(old at: nn) isDigit & ((old at: nn-1) == $.)			ifFalse: [self error: 'May not be an old style page']			ifTrue: [new _ old copyFrom: 1 to: nn-2.	"knock off .4"				page file: new.				page text: (FileStream oldFileNamed: old) contentsOfEntireFile]].	! !!SwikiAction methodsFor: 'save and restore' stamp: 'tk 5/21/1998 12:51'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| map page folder dir rep templateFolder |	map _ URLmap new.	self map: map.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,(ServerAction pathSeparator),fName action: self.			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 12/23/97 09:32'!restoreFrom: filename	|f|	f _ ReferenceStream fileNamed: filename.	self map: f next.	self map action: self.	f close.! !!SwikiAction methodsFor: 'save and restore' stamp: 'tk 1/28/98 15:17'!rollBack: aDate at: aTime	"Roll back the entire server to a previous state.  This does not erase data, just moves an older page to the end."	| folder dir rep page |	folder _ (ServerAction serverDirectory), name.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ urlmap atID: fName.			page rollBack: aDate at: aTime]].! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 11/28/97 10:33'!saveTo: filename	|f|	f _ ReferenceStream fileNamed: filename.	f nextPut: self map.	f close.! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 5/1/98 11:07'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new]).			"format using the cached formatter"	request reply: ((self formatterFor: 'page') format: formattedPage). ! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 2/9/98 12:05'!edit: pageRef from: request	request reply: (HTMLformatter evalEmbedded: 							(self fileContents: source , 'edit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 4/18/98 18:05'!inputFrom: request        "Take user's input and respond with a searchresult or store the edit"        | coreRef page |        coreRef _ request message size < 2                ifTrue: ['1']                ifFalse: [request message at: 2].        coreRef = 'searchresult' ifTrue: [                "If contains search string, do search"                request reply: PWS crlf,                         ((self formatterFor: 'recent') format:                                (urlmap searchFor: (request fields at: 'searchFor' ifAbsent: ['nothing']))).                ^ #return].        (request fields includesKey: 'text') ifTrue: ["It's a response from an edit, so store the page"                page _ urlmap                        storeID: coreRef                        text: (request fields at: 'text' ifAbsent: ['blank text'])                        from: request peerName.                page user: request userID.  "Address is machine, user only if logged in"                ^ self].        "return self means do serve the edited page afterwards"        "oops, a new kind!!"        Transcript show: 'Unknown data from client. '; show: request fields printString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 1/12/98 15:35'!log: request	| logfile |	logfile _ FileStream fileNamed: name , '-log.txt'.	logfile isNil		ifTrue: [request log: 'Failed logging on ' , name]		ifFalse:			[logfile setToEnd.			request peerName isNil			ifTrue: [logfile nextPutAll: 'UnknownPeer' , '-' ,				request url , '-' , Time now printString , '-' ,				Date today printString.]			ifFalse: [logfile nextPutAll: request peerName , '-' ,				request url , '-' , Time now printString , '-' ,				Date today printString.].			logfile nextPut: Character cr.			logfile close]! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 5/21/1998 13:05'!process: request 	"URLs are of the form:	 	{swikiname} to browse Front Page	 	{swikiname}.{coreID} to browse the page	 	{swikiname}.{coreID}.edit  to edit the page 	{swikiname}.{coreID}.all  displays the page and all its references 	{swikiname}.searchresult  conducts the search and displays the result 	{swikiname}.recent  to bring up the recent changes list 	{swikiname}.{coreID}.searchresult  returns a search for references to 	coreID's key 	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, html upper or lower case) return 	the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success; 		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields		ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue: 			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: 			["SearchResult, All, or Edit"			command _ request message at: 3.			command = 'edit'				ifTrue: 					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'searchresult'				ifTrue: 					[request reply: ((self formatterFor: 'results') 							format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all'				ifTrue: 					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 5/21/1998 13:10'!process: request MIMEtype: imageGif	"See if there is a .gif file on my disk of this name, and send it out."	| fName |	fName _ ServerAction serverDirectory, (request message at: 1), 		(ServerAction pathSeparator), (request message at: 2).	3 to: request message size do: [:part |		fName _ fName, '.', (request message at: part)].	Transcript show: fName; cr.	(FileDirectory default fileExists: fName) 		ifTrue: ["maybe send out content-length?"			request reply: (PWS success),(PWS content: imageGif), PWS crlf.			request reply: (FileStream oldFileNamed: fName) contentsOfEntireFile]		ifFalse: [			request reply: ( 'HTTP/1.0 400 Bad Request', PWS crlfcrlf, 'file not found')].! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 4/18/98 18:41'!formatterFor: formatterName	"get the formatter for the given name.  uses lazy initialization.  Could eventually check whether the on-disk file has been updated."			"first, create the dictionary of formatters if it isn't already"	formatters == nil ifTrue: [		formatters _ Dictionary new. ].	"create the formatter if necessary"	^formatters at: formatterName ifAbsent: [		formatters at: formatterName put: 			(HTMLformatter forEvaluatingEmbedded: (self fileContents: (source, formatterName, '.html'))).	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SwikiAction class	instanceVariableNames: ''!!SwikiAction class methodsFor: 'initialization' stamp: 'tk 5/21/1998 12:52'!mapClass	"The class of my pages"	^ URLmap! !!SwikiAction class methodsFor: 'initialization' stamp: 'tk 5/14/1998 18:22'!pageClass	"The class of my pages"	^ SwikiPage! !!SwikiAction class methodsFor: 'initialization' stamp: 'tk 2/3/98 15:45'!restore: actionName from: filename	"Obsolete.  For old format pages only!!!!!!  Get all the info about a Swiki from its folder."	| action |	action _ SwikiAction new.	action name: actionName.	action source: 'swiki:'.	action restoreFrom: filename.	action map pages do: [:each |		each file: (ServerAction serverDirectory),actionName,(ServerActionpathSeparator),			((each file findTokens: (ServerAction pathSeparator)) last)].	PWS link: actionName to: action.! !!SwikiAction class methodsFor: 'initialization' stamp: 'mjg 11/25/97 16:35'!setUp	self setUp: 'myswiki'! !!SwikiAction class methodsFor: 'initialization' stamp: 'tk 5/22/1998 10:04'!setUp: actionName	"Set up a named Swiki"	| action map page dir |	action _ self new.	map _ self mapClass new.	"URLmap or PURLmap"	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName. 	dir _ FileDirectory on: (ServerAction serverDirectory).	(dir directoryNames includes: actionName) ifFalse: [		^ self inform: 'You need to create a folder in Server called ', actionName].		"A directory in the ServerDirectory for storing pages."	page _ map newpage: 'Front Page' from: 'Beginning'.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerAction serverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage') contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerAction serverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules') contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.	^action! !Object subclass: #SwikiPage	instanceVariableNames: 'url map formatted address file date coreID name user editReqDate editReqTime '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!address	"Answer the receiver's 'address'."	^address! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!address: anObject	"Set the receiver's instance variable 'address' to be anObject."	address := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!coreID	"Answer the receiver's 'coreID'."	^coreID! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!coreID: anObject	"Set the receiver's instance variable 'coreID' to be anObject."	coreID := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!date	"Answer the receiver's 'date'."	^date! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."	date := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!file	"Answer the receiver's 'file'."	^file! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!file: anObject	"Set the receiver's instance variable 'file' to be anObject."	file := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:01'!formatted	^formatted! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:01'!formatted: aString	"Never set this except on a copy"	formatted _ aString! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 4/29/98 10:26'!lastEditTime	"Describe when this page was edited last"	| timeOfAccept tt timeOfReq |	timeOfAccept _ (tt _ self timeOfAccept) asSeconds + date asSeconds.	editReqDate ifNotNil: [		timeOfReq _ editReqTime asSeconds + editReqDate asSeconds.		(timeOfAccept < timeOfReq) ifTrue: [			(Time now asSeconds + Date today asSeconds - (60*60)) < timeOfReq ifTrue: [				^ '<b>Someone is editing this page!!</b>  They started ', 					(Time now subtractTime: editReqTime) intervalString, ' ago']]].	^ 'Last edited: ', date printString, ' at ', tt printString! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!map	"Answer the receiver's 'map'."	^map! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!map: anObject	"Set the receiver's instance variable 'map' to be anObject."	map := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!name	"Answer the receiver's 'name'."	^name! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 1/27/98 18:44'!noteEditRequest	editReqDate _ Date today.	editReqTime _ Time now.! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 2/3/98 18:13'!text	| theFile theText real bb gotTo |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	bb _ self backupAChunk: theFile.	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.		theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Remove double !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 2/16/98 10:50'!text: aString	"Add onto the end of the file"	| this aFile start end |	this _ String streamContents: [:ss | 		ss nextPutAll: self chunk1.		aString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 4/29/98 10:26'!timeOfAccept	"return the Time when the text was written on the file"	| theFile pp theReturn |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	pp _ self backupAChunk: theFile.	pp _ pp - 5.		"before the back:"	theFile upTo: $'; skip: -1.		"name"	theFile nextDelimited: $'.	theFile upTo: $'; skip: -1.		"date"	theFile nextDelimited: $'.	theFile upTo: $'; skip: -1.		"time"	theReturn := (theFile nextDelimited: $') asTime.	theFile close.	^theReturn! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!url	"Answer the receiver's 'url'."	^url! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 11/25/97 15:02'!url: anObject	"Set the receiver's instance variable 'url' to be anObject."	url := anObject! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 1/27/98 18:28'!user	^ user! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 1/27/98 18:30'!user: aString	aString class == String 		ifFalse: [user _ aString printString]		ifTrue: [user _ aString]! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 1/27/98 08:07'!backupAChunk: aFile	"We are positioned at the end of a chunk.  Read the size of this chunk from its end.  Back up one chunk.  Return the position of the space before the back number."	| back pp |	aFile skip: -2.	[aFile next isDigit] whileFalse: [aFile skip: -2].	aFile skip: -2.	[pp _ aFile position + 1. aFile next isDigit] whileTrue: [		aFile skip: -2].	back  _ (aFile upTo: $!!) asNumber.	aFile position: pp; skip: 0-back.	^ pp "now positioned at the end"! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 2/3/98 16:58'!chunk1		| who |	^ String streamContents: [:ss | 		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  Time now print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].	"must be a string!!!!"		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' text: ']! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 1/28/98 15:09'!condenseChanges	"Save only the most recent version of this page"	| theFile recentChunk newFile |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	self backupAChunk: theFile.	recentChunk _ theFile nextChunk.	theFile close. 	FileDirectory deleteFilePath: file.	newFile _ FileStream newFileNamed: file.	newFile nextChunkPut: recentChunk; cr; close.! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 1/26/98 22:57'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	self scanFrom: theFile.	"name, date"	address _ ''.		"should be page that points at it, but how get that?"! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 1/25/95 07:27'!name: pageName date: dateString time: timeString by: who text: theString back: bytes	"Record the name of this page during startup.  When reading the page in order to serve it, this is NOT executed.  The text is read from the file explicitly."		name _ pageName.	date _ dateString asDate.! !!SwikiPage methodsFor: 'save & restore' stamp: 'tk 1/28/98 18:03'!rollBack: aDate at: aTime	"Roll back tthis page to a previous state.  This does not erase data, just moves an older version to the end."	| theFile pp dd tt recentChunk page |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	[theFile position < 8 "beginning"] whileFalse: [		self backupAChunk: theFile.		pp _ theFile position.		theFile upTo: $'; skip: -1.		"name"		theFile nextDelimited: $'.		theFile upTo: $'; skip: -1.		"date"		dd _ (theFile nextDelimited: $') asDate.		theFile upTo: $'; skip: -1.		"time"		tt _ theFile nextDelimited: $'.		theFile position: pp.		(dd < aDate) | ((dd = aDate) & (tt asTime < aTime)) ifTrue: [			recentChunk _ theFile nextChunk.			theFile setToEnd.			theFile nextChunkPut: recentChunk; cr; close.			date _ dd.	"That's my date now"			^ self]].	"none that early, store out a blank page"	theFile close.	page _ map		storeID: coreID		text: 'blank text (but prevous versions do exist)'		from: self peerName.	page user: 'unknown user' "oldPage userID".! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 2/9/98 11:27'!scanFrom: aFile	"Read my name off the file for this page.  Other pages contain a ref to me like *myName* "	aFile setToEnd.	self backupAChunk: aFile.	"extract the name"	Compiler evaluate: (aFile nextChunk) for: self logged: false.	map at: name asLowercase put: self.	aFile close.! !Model subclass: #Switch	instanceVariableNames: 'on onAction offAction '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Menus'!!Switch commentStamp: 'di 5/22/1998 16:38' prior: 0!Switch comment:'I represent a selection setting and actions to take depending on a change in the setting. An instance has three attributes: state, which is either on or off; on action; and off action. The on and off actions are blocks of code that execute whenever the instance changes state. I am typically used as a menu item in conjunction with a SwitchView and a SwitchController.1/24/96 sw: made this a subclass of Model, for faster dependents handling'!!Switch methodsFor: 'state'!clear	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent. The receiver's off action is 	NOT executed."	self isOn		ifTrue: 			[on _ false.			self changed]! !!Switch methodsFor: 'state'!isOff	"Answer whether the receiver is set off or not."	^on not! !!Switch methodsFor: 'state'!isOn	"Answer whether the receiver is set on or not."	^on! !!Switch methodsFor: 'state'!set	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent. The receiver's on action is 	NOT executed."	self isOff		ifTrue: 			[on _ true.			self changed]! !!Switch methodsFor: 'state'!switch	"Change the state of the receiver from 'on' to 'off' or from 'off' to 'on' (see 	Switch|turnOn, Switch|turnOff)."	self isOn		ifTrue: [self turnOff]		ifFalse: [self turnOn]! !!Switch methodsFor: 'state'!turnOff	"Set the state of the receiver to 'off'. If the state of the receiver was 	previously 'on', then 'self change' is sent and the receiver's off action is 	executed."	self isOn		ifTrue: 			[on _ false.			self changed.			self doAction: offAction]! !!Switch methodsFor: 'state'!turnOn	"Set the state of the receiver to 'on'. If the state of the receiver was 	previously 'off', then 'self change' is sent and the receiver's on action is 	executed."	self isOff		ifTrue: 			[on _ true.			self changed.			self doAction: onAction]! !!Switch methodsFor: 'action'!doAction: anAction 	"Execute anAction if it is non-nil."	anAction == nil ifFalse: [anAction value]! !!Switch methodsFor: 'action'!offAction: anAction 	"Set the off action of the receiver to anAction."	offAction _ anAction fixTemps! !!Switch methodsFor: 'action'!onAction: anAction 	"Set the on action of the receiver to anAction."	onAction _ anAction fixTemps! !!Switch methodsFor: 'private'!initializeOff	on _ false. 	onAction _ nil.	offAction _ nil! !!Switch methodsFor: 'private'!initializeOn	on _ true. 	onAction _ nil.	offAction _ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Switch class	instanceVariableNames: ''!!Switch class methodsFor: 'instance creation'!new	"Answer an instance of me such that the on and off actions are set to nil	('no action'), and the state is set to 'off'."	^self newOff! !!Switch class methodsFor: 'instance creation'!newOff	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'off'."	^super new initializeOff! !!Switch class methodsFor: 'instance creation'!newOn	"Answer an instance of me such that the on and off actions are set to nil 	('no action'), and the state is set to 'on'."	^super new initializeOn! !String variableByteSubclass: #Symbol	instanceVariableNames: ''	classVariableNames: 'OtherTable SelectorTables SingleCharSymbols '	poolDictionaries: ''	category: 'Collections-Text'!!Symbol commentStamp: 'di 5/22/1998 16:38' prior: 0!Symbol comment:'I represent Strings that are created uniquely. Thus, someString asSymbol == someString asSymbol.'!!Symbol methodsFor: 'accessing'!at: anInteger put: anObject 	"You cannot modify the receiver."	self errorNoModification! !!Symbol methodsFor: 'accessing'!replaceFrom: start to: stop with: replacement startingAt: repStart	self errorNoModification! !!Symbol methodsFor: 'comparing'!= anObject	^self == anObject! !!Symbol methodsFor: 'comparing'!hash	"Primitive. Answer with a SmallInteger whose value is half of the	receiver's object pointer (interpreting object pointers as 16-bit signed	quantities). Essential. See Object documentation whatIsAPrimitive."	<primitive: 75>	^self! !!Symbol methodsFor: 'comparing' stamp: 'pm 9/23/97 09:36'!hashMappedBy: map	"Answer what my hash would be if oops changed according to map."	^map newHashFor: self! !!Symbol methodsFor: 'copying'!copy	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying'!shallowCopy	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'converting'!asString 	"Refer to the comment in String|asString."	| newString |	newString _ String new: self size.	1 to: self size do: [:index | newString at: index put: (self at: index)].	^newString! !!Symbol methodsFor: 'converting'!asSymbol 	"Refer to the comment in String|asSymbol."! !!Symbol methodsFor: 'converting' stamp: 'sw 1/28/98 18:18'!capitalized	^ self asString capitalized asSymbol! !!Symbol methodsFor: 'printing'!isLiteral	^Scanner isLiteralSymbol: self! !!Symbol methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self! !!Symbol methodsFor: 'printing'!storeOn: aStream	self isLiteral		ifTrue:			[aStream nextPut: $#.			aStream nextPutAll: self]		ifFalse:			[super storeOn: aStream.			aStream nextPutAll: ' asSymbol']! !!Symbol methodsFor: 'system primitives' stamp: 'ikp 1/1/98 00:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector in its method lookup cache, if it has one.  This primitive must be called whenever a method is redefined.	Essential.  See Object documentation whatIsAPrimitive."	<primitive: 119>	Object flushCache.	"<primitive: 89>"	"self primitiveFailed"! !!Symbol methodsFor: 'system primitives'!isInfix	"Answer whether the receiver is an infix message selector."	^(self at: 1) isLetter not! !!Symbol methodsFor: 'system primitives'!isKeyword	"Answer whether the receiver is a message keyword, i.e., ends with 	colon."	self size <= 1 ifTrue: [^false].	^(self at: self size) = $:! !!Symbol methodsFor: 'system primitives'!isPvtSelector | prefix prefixSize |	"Answer whether the receiver is a private message selector, that is, begins with 'pvt' followed by an uppercase letter, e.g. pvtStringhash."	prefix _ 'pvt'.	prefixSize _ prefix size.	self size <= prefixSize ifTrue: [^false].	1 to: prefixSize do:		[:index | (self at: index) = (prefix at: index) ifFalse: [^false]].	^(self at: prefixSize + 1) isUppercase! !!Symbol methodsFor: 'private'!errorNoModification	self error: 'symbols can not be modified.'! !!Symbol methodsFor: 'private'!species	^String! !!Symbol methodsFor: 'private'!string: aString	1 to: aString size do: [:j | super at: j put: (aString at: j)].	^self  ! !!Symbol methodsFor: 'private'!stringhash	^super hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Symbol class	instanceVariableNames: ''!!Symbol class methodsFor: 'class initialization'!initialize	| a v |	"make up table of 1-char atoms"	v _ Array new: 128.	a _ String new: 1.	1 to: 128 do: 		[:i | 		a at: 1 put: i - 1.		v at: i put: a asSymbol].	SingleCharSymbols _ v		"Symbol initialize"! !!Symbol class methodsFor: 'instance creation'!intern: aString 	"Answer a unique Symbol whose characters are those of aString."	| ascii table mainTable index sym numArgs |	ascii _ (aString at: 1) asciiValue.	aString size = 1 ifTrue: [ascii < 128 ifTrue: 		[^ SingleCharSymbols at: ascii + 1]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(mainTable _ SelectorTables									at: (numArgs + 1 min: SelectorTables size))						at: (index _ ascii - "($a asciiValue - 1)" 96)]			ifFalse: [(mainTable _ OtherTable)						at: (index _ aString stringhash \\ OtherTable size + 1)].	1 to: table size do: [:i |		aString size = (table at: i) size ifTrue: [aString = (table at: i) ifTrue: [^ table at: i]]	].	sym _ (aString isMemberOf: Symbol)		ifTrue: [aString]	"putting old symbol in new table"		ifFalse: [(Symbol new: aString size) string: aString]. "create a new one"	mainTable at: index put: (table copyWith: sym).	^sym! !!Symbol class methodsFor: 'instance creation'!internCharacter: aCharacter	"Answer a unique Symbol of one character, the argument, aCharacter."	| ascii |	(ascii _ aCharacter asciiValue) < 128		ifTrue: [^SingleCharSymbols at: ascii + 1].	^self intern: (String with: aCharacter)! !!Symbol class methodsFor: 'instance creation'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ (aCollection as: String) asSymbol"	Symbol newFrom: {$P. $e. $n}	{$P. $e. $n} as: Symbol"! !!Symbol class methodsFor: 'private'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol), 	otherwise supply the symbol to symBlock and return true."	| table ascii numArgs |	ascii _ (aString at: 1) asciiValue.	aString size = 1 ifTrue: [ascii < 128 ifTrue: 		[symBlock value: (SingleCharSymbols at: ascii + 1).		^true]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(SelectorTables at: (numArgs + 1 min: SelectorTables size))						at: ascii - "($a asciiValue - 1)" 96]			ifFalse: [OtherTable at: aString stringhash \\ OtherTable size + 1].	1 to: table size do: [:i | 		aString size = (table at: i) size ifTrue: [aString = (table at: i) ifTrue: [			symBlock value: (table at: i).			^true]]	].	^false! !!Symbol class methodsFor: 'private'!rehash		"Symbol rehash"	"Rebuild the hash table, reclaiming unreferenced Symbols."	| count oldCount |	SelectorTables _ (1 to: 6) collect: [ :i | (1 to: 26) collect: [ :j | Array new: 0 ] ].	OtherTable _ (1 to: 51) collect: [:k | Array new: 0].	oldCount _ Symbol instanceCount.	count _ 0.	'Rebuilding Symbol Tables...'		displayProgressAt: Sensor cursorPoint		from: 0 to: oldCount		during:			[:bar |			Smalltalk garbageCollect.			Symbol allInstancesDo:				[ :sym |				self intern: sym.				bar value: (count _ count + 1)]].	^ (oldCount - count) printString , ' reclaimed'! !!Symbol class methodsFor: 'access'!morePossibleSelectorsFor: misspelled	"Like possible SelectorsFor, but over hunts over a greater range of selectors."	| numArgs results tables skip |	numArgs _ misspelled numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	skip _ misspelled first asciiValue - $a asciiValue + 1.	tables _ SelectorTables at: (numArgs + 1 min: SelectorTables size).	1 to: tables size do: [ :index |		index ~= skip ifTrue:			[ results _ misspelled correctAgainst: (tables at: index)								continuedFrom: results ] ].	^ misspelled correctAgainst: nil continuedFrom: results.! !!Symbol class methodsFor: 'access'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	^ lookupString correctAgainst: table.! !!Symbol class methodsFor: 'access'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive.	 1/15/96 sw.  This is an extremely slow, sledge-hammer approach at present, taking around 30 seconds to execute on an FX.  A variety of speedups is conceivable -- improvements invited."	| key size table candidate selectorList selectorTable |	key _ aString asLowercase.	selectorList _ OrderedCollection new.	size _ key size.	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate asLowercase findString: key startingAt: 1) > 0)						ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon' OrderedCollection (includesController: selectorsContaining: codeThisContext conversionNotesContents isControlWanted isControlActive isConstantNumber isConnectionSet thisContext )"! !!Symbol class methodsFor: 'access'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with aKeyword and		starts with a lower-case letter. Ignore case in aKeyword.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Ctrl-s routines."	| key size index table candidate i skip firstTable |	key _ leadingCharacters asLowercase.	((index _ (key at: 1) asciiValue - "($a asciiValue - 1)" 96) between: 0 and: 25)		ifFalse: [^nil].	size _ key size.	skip _ skipSym ~~ nil.	firstTable _ skip		ifTrue: [skipSym numArgs + 1 min: SelectorTables size] "can't be in a later table"		ifFalse: [SelectorTables size]. "could be in any table; favor longer identifiers"	(firstTable to: 1 by: -1) do:		[:j |		table _ (SelectorTables at: j) at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil or:					[skip and: [skip _ candidate ~~ skipSym. true]]) ifFalse:				[candidate size >= size ifTrue:					[i _ size. "test last character first"					 [i > 1 and: [(candidate at: i) asLowercase == (key at: i)]]						whileTrue: [i _ i - 1].					 i = 1 ifTrue: "don't need to compare first character"						[^candidate]]]]].	^nil"Symbol thatStarts: 'sf' skipping: nil""Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""Symbol thatStarts: 'candidate' skipping: nil"! !StringHolder subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Debugger'!!SyntaxError commentStamp: 'di 5/22/1998 16:38' prior: 0!I represent syntax error report for syntax errors encountered when filing in class descriptions from a non-interactive source such as an external file. As a StringHolder, the string to be viewed is the method code or expression containing the error.The user may fix the error and accept the method to continue the fileIn.!!SyntaxError methodsFor: 'initialization' stamp: 'jm 5/3/1998 14:36'!category: aSymbol	"Record the message category of method being compiled. This is used when the user corrects the error and accepts."	category _ aSymbol.! !!SyntaxError methodsFor: 'initialization' stamp: 'jm 5/3/1998 13:08'!setClass: aClass code: aString debugger: aDebugger	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	contents _ aString.	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].! !!SyntaxError methodsFor: 'message list' stamp: 'jm 5/3/1998 13:05'!list	"Answer an array of one element made up of the class name, message category, and message selector in which the syntax error was found. This is the single item in the message list of a view/browser on the receiver."	^ Array with: (class name, '  ', category, '  ', selector)! !!SyntaxError methodsFor: 'message list' stamp: 'jm 5/3/1998 13:48'!listIndex	"There is always exactly one element in my list and it is always selected."	^ 1! !!SyntaxError methodsFor: 'menu' stamp: 'jm 5/3/1998 14:07'!debug	"Show the stack of the process leading to this syntax editor, typically showing the stack of the compiler as called from fileIn."	debugger openFullNoSuspendLabel: 'Stack of the Syntax Error'.	Processor terminateActive.! !!SyntaxError methodsFor: 'menu' stamp: 'jm 5/3/1998 14:22'!listMenu: aMenu	^ aMenu labels:'proceeddebug calling processbrowse full'	lines: #()	selections: #(proceed debug browseMethodFull)! !!SyntaxError methodsFor: 'menu' stamp: 'di 5/5/1998 00:06'!proceed	"The user has has edited and presumably fixed the syntax error and the filein can now proceed."	debugger proceed: self topView.! !!SyntaxError methodsFor: 'other' stamp: 'jm 5/3/1998 13:12'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	(class compile: aString classified: category notifying: aController)		ifNil: [^ false]		ifNotNil: [self proceed].! !!SyntaxError methodsFor: 'other' stamp: 'jm 5/3/1998 14:32'!notify: error at: location in: source	"Open a syntax error view, inserting the given error message into the given source at the given location. This message is sent to the 'requestor' when the parser or compiler finds a syntax error."	| aClass aString |	aClass _ thisContext sender receiver encoder classEncoding.	aString _		source contents			copyReplaceFrom: location			to: location - 1			with: error.	self setClass: aClass		code: aString		debugger: (Debugger context: thisContext).	self class open: self.! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:15'!selectedClass	"Answer the class in which the syntax error occurred."	^ class! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:33'!selectedClassOrMetaClass	"Answer the class of the method being compiled."	^ class! !!SyntaxError methodsFor: 'text menu support' stamp: 'jm 5/3/1998 14:17'!selectedMessageName	"Answer the selector of the method being compiled."	^ selector! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SyntaxError class	instanceVariableNames: ''!!SyntaxError class methodsFor: 'instance creation' stamp: 'di 5/6/1998 20:58'!buildMVCViewOn: aSyntaxError	"Answer an MVC view on the given SyntaxError."	| topView aListView aCodeView |	topView _ StandardSystemView new		model: aSyntaxError;		label: 'Syntax Error';		minimumSize: 380@220.	aListView _ PluggableListView on: aSyntaxError		list: #list		selected: #listIndex		changeSelected: nil		menu: #listMenu:.	aListView window: (0@0 extent: 380@20).	topView addSubView: aListView.	aCodeView _ PluggableTextView on: aSyntaxError		text: #contents		accept: #contents:notifying:		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	aCodeView window: (0@0 extent: 380@200).	topView addSubView: aCodeView below: aListView.	^ topView! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jm 5/3/1998 13:27'!errorInClass: aClass withCode: codeString	"Open a view whose model is a syntax error. The error occurred when trying to add the given method code to the given class."	self open:		(self new setClass: aClass			code: codeString			debugger: (Debugger context: thisContext)).! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jm 5/3/1998 13:24'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !Dictionary subclass: #SystemDictionary	instanceVariableNames: ''	classVariableNames: 'CachedClassNames LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore SpecialSelectors SystemChanges '	poolDictionaries: ''	category: 'System-Support'!!SystemDictionary commentStamp: 'di 5/22/1998 16:38' prior: 0!NewSystemDictionary comment:'I represent a special dictionary that supports protocol for asking questions about the structure of the system. Other than class names, I contain (print this)...	Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Class) not]			thenCollect: [:k | k -> (Smalltalk at: k) class]!!SystemDictionary methodsFor: 'dictionary access'!at: aKey put: anObject 	"Override from Dictionary to check Undeclared and fix up	references to undeclared variables."	| index element |	(self includesKey: aKey) ifFalse: 		[self declare: aKey from: Undeclared.		self flushClassNameCache].	super at: aKey put: anObject.	^ anObject! !!SystemDictionary methodsFor: 'dictionary access'!printOn: aStream	aStream nextPutAll: 'a SystemDictionary'.	(self == Smalltalk)		ifTrue: [ aStream nextPutAll: ' (all the globals)' ].! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 9/5/97 16:05'!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to	aLiteral. For example, Smalltalk browseAllCallsOn: #open:label:."	(aLiteral isKindOf: LookupKey)		ifTrue: [self browseMessageList: (self allCallsOn: aLiteral) asSortedCollection					name: 'Users of ' , aLiteral key					autoSelect: aLiteral key]		ifFalse: [self browseMessageList: (self allCallsOn: aLiteral) asSortedCollection					name: 'Senders of ' , aLiteral					autoSelect: aLiteral keywords first]! !!SystemDictionary methodsFor: 'browsing'!browseAllCallsOn: literal1 and: literal2 	"Create and schedule a message browser on each method that calls on the 	two Symbols, literal1 and literal2. For example, Smalltalk 	browseAllCallsOn: #at: and: #at:put:."	^self 		browseMessageList: (self allCallsOn: literal1 and: literal2)		name: literal1 printString , ' -and- ' , literal2 printString! !!SystemDictionary methodsFor: 'browsing'!browseAllImplementorsOf: selector	"Create and schedule a message browser on each method that implements 	the message whose selector is the argument, selector. For example, 	Smalltalk browseAllImplementorsOf: #at:put:."	^self browseMessageList: (self allImplementorsOf: selector) name: 'Implementors of ' , selector! !!SystemDictionary methodsFor: 'browsing'!browseAllImplementorsOfList: selectorList	"Create and schedule a message browser on each method that implements 	the message whose selector is in the argument selectorList. For example, 	Smalltalk browseAllImplementorsOf: #(at:put: size).	1/16/96 sw: defer to the titled version"	self browseAllImplementorsOfList: selectorList title: 'Implementors of all'! !!SystemDictionary methodsFor: 'browsing'!browseAllImplementorsOfList: selectorList title: aTitle	"Create and schedule a message browser on each method that implements the message whose selector is in the argument selectorList. For example,  Smalltalk browseAllImplementorsOf: #(at:put: size).	1/16/96 sw: this variant adds the title argument.	1/24/96 sw: use a SortedCollection	2/1/96 sw: show normal cursor"	| implementorLists flattenedList |	implementorLists _ selectorList collect: [:each | self allImplementorsOf: each].	flattenedList _ SortedCollection new.	implementorLists do: [:each | flattenedList addAll: each].	Cursor normal show.	^ self browseMessageList: flattenedList name: aTitle! !!SystemDictionary methodsFor: 'browsing'!browseAllMethodsInCategory: category 	^self browseMessageList: (self allMethodsInCategory: category)		name: category! !!SystemDictionary methodsFor: 'browsing' stamp: 'tk 4/13/1998 10:29'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject. If there are none, then evaluate aBlock on anObject.  "	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ anObject name.	shortName size > 12 ifTrue: [		shortName _ (shortName truncateTo: 12), '...'.	].	OrderedCollectionInspector openOn: aList withEvalPane: false		withLabel: 'Objects pointing to ', shortName.! !!SystemDictionary methodsFor: 'browsing'!browseAllSelect: aBlock	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result. For example, 	Smalltalk browseAllSelect: [:method | method numLiterals > 10]."	^self browseMessageList: (self allSelect: aBlock) name: 'selected messages'! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/15/97 15:32'!browseAllSelect: aBlock name: aName autoSelect: autoSelectString	"Create and schedule a message browser on each method that, when used 	as the block argument to aBlock gives a true result.   Do not return an #DoIt traces."	"Smalltalk browseAllSelect: [:method | method numLiterals > 10] name: 'Methods with more than 10 literals' autoSelect: 'isDigit'"	^ self browseMessageList: (self allSelectNoDoits: aBlock) name: aName autoSelect: autoSelectString! !!SystemDictionary methodsFor: 'browsing'!browseAllUnimplementedCalls	"Create and schedule a message browser on each method that includes a 	message that is not implemented in any object in the system."	^self browseMessageList: self allUnimplementedCalls name: 'Unimplemented calls'! !!SystemDictionary methodsFor: 'browsing'!browseAllUnSentMessages	"Create and schedule a message browser on each method whose message is 	not sent in any method in the system."	^self browseMessageList: self allUnSentMessages name: 'UnSent Messages'! !!SystemDictionary methodsFor: 'browsing'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	ChangedMessageSet openFor: SystemChanges! !!SystemDictionary methodsFor: 'browsing'!browseMessageList: messageList name: label 	"Create and schedule a MessageSet browser on messageList."	^ self browseMessageList: messageList name: label autoSelect: nil! !!SystemDictionary methodsFor: 'browsing'!browseMessageList: messageList name: labelString autoSelect: autoSelectString	"Create and schedule a MessageSet browser on the  message list.	1/22/96 sw: add message count to title.	1/24/96 sw: don't put the msg count in 'there-are-no' msg"	messageList size = 0 ifTrue: 		[^ (PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no' , labelString].	MessageSet openMessageList: messageList name: (labelString, ' [', messageList size printString, ']') autoSelect: autoSelectString! !!SystemDictionary methodsFor: 'browsing'!browseMethodsWhoseNamesContain: aString	"Launch a browser on all methods whose names contain the given string; case-insensitive.  This takes a long time right now.  1/16/96 sw"	| aList |	aList _ Symbol selectorsContaining: aString.	aList size > 0 ifTrue: 		[self browseAllImplementorsOfList: aList asSortedCollection title: 'Methods whose names contain ''', aString, '''']! !!SystemDictionary methodsFor: 'browsing'!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring.  The search is case-sensitive. This takes a long time right now.  7/23/96 di	 1/16/97 sw: set up the autoSelect: string"	^ self browseMessageList: (self allMethodsWithSourceString: aString)		name: 'Methods containing ' , aString printString autoSelect: aString! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/15/97 13:56'!browseMethodsWithString: aString	"Launch a browser on all methods which contain string literals that have aString as a substring.  The search is case-sensitive, unless the option key is pressed, in which case the search is case-insensitive (and consequently somewhat slower)"	| caseBlind testString suffix |	(caseBlind _ Sensor optionKeyPressed)		ifTrue:			[testString _ aString asLowercase.			suffix _ ' (case-blind)']		ifFalse:			[testString _ aString.			suffix _ '-'].	self browseAllSelect:		[:method |  method  hasLiteralSuchThat:				[:lit | lit class == String and:					[lit includesSubstring: testString caseSensitive: caseBlind not]]]				name:  'Methods with string ''', aString, '''', suffix				autoSelect: aString! !!SystemDictionary methodsFor: 'browsing'!browseObsoleteReferences   "Smalltalk browseObsoleteReferences"	| references |	references _ OrderedCollection new.	(Association allInstances select:		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:		['AnOb*' match: x value class name]]) 		do: [:x | references addAll: (Smalltalk allCallsOn: x)].	Smalltalk browseMessageList: references name: 'References to Obsolete Classes'! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 4/15/98 09:41'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock	"Show a sorted menu of the given selectors, preceded by firstItem, and all	abbreviated to 40 characters.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList |	sortedList _ selectorCollection asSortedCollection.	menuLabels _ String streamContents: 		[:strm | strm nextPutAll: (firstItem contractTo: 40).		sortedList do: [:sel | strm cr; nextPutAll: (sel contractTo: 40)]].	index _ (PopUpMenu labels: menuLabels lines: #(1)) startUp.	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index-1)]! !!SystemDictionary methodsFor: 'retrieving'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system 	(that is, Object and its subclasses)."	aBlock value: Object.	Object allSubclassesDo: aBlock! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 9/5/97 16:22'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList |	#(23 48 'fred' (new open:label:)) size.    "For testing!!"	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:byte ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: special byte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte: byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving'!allCallsOn: firstLiteral and: secondLiteral	"Answer a SortedCollection of all the methods that call on both aLiteral 	and secondLiteral."	| aCollection secondArray firstSpecial secondSpecial |	aCollection _ SortedCollection new.	firstSpecial _ self hasSpecialSelector: firstLiteral ifTrueSetByte: [:firstByte].	secondSpecial _ self hasSpecialSelector: secondLiteral ifTrueSetByte: [:secondByte].	Cursor wait showWhile:		[self allBehaviorsDo:			[:class |			secondArray _ class whichSelectorsReferTo: secondLiteral special: secondSpecial byte: secondByte.			((class whichSelectorsReferTo: firstLiteral special: firstSpecial byte: firstByte) select:				[:aSel | (secondArray includes: aSel)]) do:						[:sel | aCollection add: class name , ' ' , sel]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving'!allClasses  "Smalltalk allClasses"	^ self classNames collect: [:name | Smalltalk at: name]! !!SystemDictionary methodsFor: 'retrieving'!allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	(self classNames collect: [:name | Smalltalk at: name]) do: aBlock! !!SystemDictionary methodsFor: 'retrieving'!allClassesImplementing: aSelector  	"Answer an Array of all classes that implement the message aSelector."	| aCollection |	aCollection _ ReadWriteStream on: Array new.	self allBehaviorsDo:		[:class | (class includesSelector: aSelector)			ifTrue: [aCollection nextPut: class]].	^ aCollection contents! !!SystemDictionary methodsFor: 'retrieving'!allImplementedMessages	"Answer a Set of all the messages that are sent by a method in the system 	but are not implemented."	| aSet |	aSet _ Set new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | aSet add: aSelector]]].	^aSet! !!SystemDictionary methodsFor: 'retrieving'!allImplementorsOf: aSelector  	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| aCollection |	aCollection _ SortedCollection new.	Cursor wait showWhile:		[self allBehaviorsDo:			[:class |			(class includesSelector: aSelector)				ifTrue: [aCollection add: class name, ' ', aSelector]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving'!allMethodsInCategory: category 	| aCollection |	aCollection _ SortedCollection new.	Cursor wait showWhile:		[self allBehaviorsDo:			[:x | (x organization listAtCategoryNamed: category) do:				[:sel | aCollection add: x name , ' ' , sel]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving'!allMethodsWithSourceString: aString 	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  The search is case-sensitive.  7/23/96 di."	| list classCount |	list _ Set new.'Searching all source code...'displayProgressAt: Sensor cursorPointfrom: 0 to: Smalltalk classNames sizeduring:	[:bar | classCount _ 0.	Smalltalk allClassesDo:		[:class | bar value: (classCount _ classCount + 1).		(Array with: class with: class class) do:			[:cl | cl selectorsDo:				[:sel | 				((cl sourceCodeAt: sel) findString: aString startingAt: 1) > 0					ifTrue:					[sel == #DoIt ifFalse: [list add: cl name , ' ' , sel]]]]]].	^ list asSortedCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 8/12/97 20:57'!allMethodsWithString: aString 	"Answer a SortedCollection of all the methods that contain, in a string literal, aString as a substring.  2/1/96 sw.  The search is case-sensitive, and does not dive into complex literals, confining itself to string constants.	5/2/96 sw: fixed so that duplicate occurrences of aString in the same method don't result in duplicated entries in the browser"	| aStringSize list lits |	aStringSize _ aString size.	list _ Set new.	Cursor wait showWhile: [self allBehaviorsDo: 		[:class | class selectorsDo:			[:sel | sel ~~ #DoIt ifTrue:				[lits _ (class compiledMethodAt: sel) literals.				lits do:					[:aLiteral | ((aLiteral isMemberOf: String) and:						[aLiteral size >= aStringSize])							ifTrue:								[(aLiteral findString: aString startingAt: 1)  > 0 ifTrue:									[list add: class name , ' ' , sel]]]]]]].	^ list asSortedCollection! !!SystemDictionary methodsFor: 'retrieving'!allObjectsDo: aBlock 	"Evaluate the argument, aBlock, for each object in the system	 excluding SmallIntegers."	| object |	object _ self someObject.	[0 == object] whileFalse: [		aBlock value: object.		object _ object nextObject.	].! !!SystemDictionary methodsFor: 'retrieving'!allPrimitiveMessages	"Answer an OrderedCollection of all the methods that are implemented by 	primitives."	| aColl aSelector method | 	aColl _ OrderedCollection new: 200.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:class | class selectorsDo: 				[:sel | 				method _ class compiledMethodAt: sel.				method primitive ~= 0					ifTrue: [aColl addLast: class name , ' ' , sel 									, ' ' , method primitive printString]]]].	^aColl! !!SystemDictionary methodsFor: 'retrieving'!allPrimitiveMethodsInCategories: aList	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"	| aColl aSelector method | 	aColl _ OrderedCollection new: 200.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:aClass | (aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asString) asString)				ifTrue: [aClass selectorsDo: 					[:sel | 						method _ aClass compiledMethodAt: sel.						method primitive ~= 0							ifTrue: [aColl addLast: aClass name , ' ' , sel 									, ' ' , method primitive printString]]]]].	^ aColl"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !!SystemDictionary methodsFor: 'retrieving'!allSelect: aBlock 	"Answer a SortedCollection of each method that, when used as the block 	argument to aBlock, gives a true result."	| aCollection |	aCollection _ SortedCollection new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:class | class selectorsDo: 				[:sel | (aBlock value: (class compiledMethodAt: sel))					ifTrue: [aCollection add: class name , ' ' , sel]]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 8/15/97 15:31'!allSelectNoDoits: aBlock 	"Like allSelect:, but strip out Doits"	| aCollection |	aCollection _ SortedCollection new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:class | class selectorsDo: 				[:sel | ((sel ~~ #DoIt) and: [(aBlock value: (class compiledMethodAt: sel))])					ifTrue: [aCollection add: class name , ' ' , sel]]]].	^aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 11/4/97 20:11'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	| sent |	sent _ Set new.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | "Include all sels, but not if sent by self"			(cl compiledMethodAt: sel) literals do: 				[:m | 				(m isMemberOf: Symbol) ifTrue:  "might be sent"					[m == sel ifFalse: [sent add: m]].				(m isMemberOf: Array) ifTrue:  "might be performed"					[m do: [:x | (x isMemberOf: Symbol) ifTrue:						[x == sel ifFalse: [sent add: x]]]]]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	^ sent! !!SystemDictionary methodsFor: 'retrieving'!allUnimplementedCalls 	"Answer an Array of each message that is sent by an expression in a 	method but is not implemented by any object in the system."	| aStream secondStream all  |	all _ self allImplementedMessages.	aStream _ WriteStream on: (Array new: 50).	Cursor execute showWhile:		[self allBehaviorsDo:			[:cl |			 cl selectorsDo:				[:sel |				 secondStream _ WriteStream on: (String new: 5).				(cl compiledMethodAt: sel) messages do:					[:m | (all includes: m) ifFalse: [secondStream nextPutAll: m; space]].				secondStream position = 0 ifFalse:					[aStream nextPut: cl name , ' ' , sel , ' calls: ', secondStream contents]]]].	^aStream contents! !!SystemDictionary methodsFor: 'retrieving'!allUnSentMessages   "Smalltalk allUnSentMessages"	"Answer the set of selectors that are implemented by some object	in the system but not sent by any."	| sent unsent |	sent _ self allSentMessages.	unsent _ Set new.	self allImplementedMessages do:		[:sel | (sent includes: sel) ifFalse: [unsent add: sel]].	^ unsent" | f cl lastClass |f _ FileStream newFileNamed: 'UnsentMessages.txt'.lastClass _ 'xx'.methods _ SortedCollection new.Smalltalk allUnSentMessages do:	[:sel | methods addAll: (Smalltalk allImplementorsOf: sel)].methods do:	[:m | cl _ m copyUpTo: $ . 	cl = lastClass		ifTrue: [f nextPutAll: (m copyFrom: lastClass size+1 to: m size)]		ifFalse: [f cr; cr; nextPutAll: m.  lastClass _ cl]].f close."! !!SystemDictionary methodsFor: 'retrieving' stamp: 'sw 5/8/96'!allUnSentMessagesIn: selectorSet	"Answer the subset of selectorSet which are not sent anywhere in the system.	Factored out from#allUnSentMessages "	|  all |	all _ selectorSet copy.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:m |					(m isMemberOf: Symbol)  "might be sent"						ifTrue: [all remove: m ifAbsent: []].					(m isMemberOf: Array)  "might be performed"						ifTrue: [m do: [:x | all remove: x ifAbsent: []]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			all remove: (self specialSelectorAt: index) ifAbsent: []]].	^ all! !!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject	"Find all occurrences in the system of pointers to the argument anObject."	"(Smalltalk pointersTo: Browser) inspect."	^ self pointersTo: anObject except: #()! !!SystemDictionary methodsFor: 'retrieving'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ objectsToExclude) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]]])				 ifTrue: [ results add: anObj ].		].		anObj _ anObj nextObject.	].	objectsToExclude do: [ :obj | results removeAllSuchThat: [ :el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'retrieving'!pointersToItem: index of: anArray	"Find all occurrences in the system of pointers to the given element of the given array. This is useful for tracing up a pointer chain from an inspector on the results of a previous call of pointersTo:. To find out who points to the second element of the results, one would evaluate:	Smalltalk pointersToItem: 2 of: selfin the inspector."	^ self pointersTo: (anArray at: index) except: (Array with: anArray)! !!SystemDictionary methodsFor: 'class names'!classNamed: className 	"className is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names.	8/91 sw chgd so returns nil if class not found, to correct failures in Change Sorter across class renames"	| meta baseName baseClass length |	length _ className size.	(length > 6 and: 			[(className copyFrom: length - 5 to: length) = ' class'])		ifTrue: 			[meta _ true.			baseName _ className copyFrom: 1 to: length - 6]		ifFalse: 			[meta _ false.			baseName _ className].	baseClass _ Smalltalk at: baseName asSymbol ifAbsent: [nil].	baseClass isNil ifTrue: [^ nil].	meta		ifTrue: [^baseClass class]		ifFalse: [^baseClass]! !!SystemDictionary methodsFor: 'class names'!classNames	"Answer a SortedCollection of all class names."	| names |	CachedClassNames == nil ifTrue:		[names _ OrderedCollection new: self size.		self do: 			[:cl | (cl isKindOf: Class) ifTrue: [names add: cl name]].		CachedClassNames _ names asSortedCollection].	^ CachedClassNames! !!SystemDictionary methodsFor: 'class names'!flushClassNameCache	"This is an implementation efficiency: the collection of class names is 	saved as a class variable and recomputed whenever the collection is 	needed but has been previously flushed (set to nil).  Last touched sw 8/91"	"Smalltalk flushClassNameCache"	CachedClassNames _ nil! !!SystemDictionary methodsFor: 'class names'!hasClassNamed: aString	"Answer whether there is a class of the given name, but don't intern aString if it's not alrady interned.  4/29/96 sw"	Symbol hasInterned: aString ifTrue: 		[:aSymbol | ^ (self at: aSymbol ifAbsent: [nil]) isKindOf: Class].	^ false! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 2/28/98 21:57'!removeClassFromSystem: aClass	"Delete the class, aClass, from the system."	aClass wantsChangeSetLogging ifTrue:		[SystemChanges noteRemovalOf: aClass].	aClass acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange:  'Smalltalk removeClassNamed: #', aClass name].	SystemOrganization removeElement: aClass name.	self removeKey: aClass name.	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 9/5/97 18:30'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!SystemDictionary methodsFor: 'class names'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	| oldref |	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	SystemChanges renameClass: aClass as: newName.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	self flushClassNameCache! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 10/28/96'!renameClassNamed: oldName as: newName	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass _ self at: oldName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.			^ self].	oldClass rename: newName! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 11/4/97 20:11'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk condenseChanges.	Smalltalk allBehaviorsDo: [: b | b zapOrganization]."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/16/1998 10:18'!discardMIDI	"Discard support the MIDI score player and the underlying MIDI support."	Smalltalk removeClassNamed: #ScorePlayerMorph.	SystemOrganization removeCategoriesMatching: 'Music-Scores'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/16/1998 10:07'!discardMVC	"Discard MVC."	self halt: 'not yet implemented'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/16/1998 09:38'!discardMorphic	"Discard Morphic."	self halt: 'not yet complete; leaves many obsolete classes'.	SystemOrganization removeCategoriesMatching: 'User Objects'.	SystemOrganization removeCategoriesMatching: '*EToy*'.	SystemOrganization removeCategoriesMatching: 'Morphic*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/16/1998 09:13'!discardNetworking	"Discard the support for TCP/IP networking."	Smalltalk discardPluggableWebServer.	SystemOrganization removeCategoriesMatching: 'System-Network'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/15/1998 17:49'!discardPluggableWebServer	"Discard the Pluggable Web Server."	SystemOrganization removeCategoriesMatching: 'PluggableWebServer'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/15/1998 17:50'!discardSerialPort	"Discard the serial port interface."	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/19/1998 10:44'!discardSoundSynthesis	"Discard the sound synthesis facilities, and the methods and classes that use it. This also discards MIDI."	Smalltalk discardMIDI.	Smalltalk removeClassNamed: #EnvelopeLineMorph.	Smalltalk removeClassNamed: #EnvelopeEditorMorph.	Smalltalk removeClassNamed: #SoundSequencerMorph.	Smalltalk removeClassNamed: #SoundMorph.	Smalltalk removeClassNamed: #SoundLoopMorph.	Smalltalk removeClassNamed: #InterimSoundMorph.	Smalltalk removeClassNamed: #RecordingControlsMorph.	Smalltalk removeClassNamed: #SoundDemoMorph.	Smalltalk at: #GraphMorph ifPresent: [:graphMorph |		#(loadCoffeeCupClink play playBach playOnce		  readDataFromFile registerWaveform stopPlaying)			do: [:sel | graphMorph removeSelector: sel]].	Smalltalk at: #TrashCanMorph ifPresent: [:trashMorph |		trashMorph class removeSelector: #samplesForDelete.		trashMorph class removeSelector: #samplesForMouseEnter.		trashMorph class removeSelector: #samplesForMouseLeave].	SystemOrganization removeCategoriesMatching: 'System-Sound'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/19/1998 13:34'!discardVMConstructionClasses	"Discard the virtual machine construction classes and the Smalltalk-to-C translator. These are only needed by those wishing to build or study the Squeak virtual machine, or by those wishing to construct new primitives via Smalltalk-to-C translation."	"remove the code for virtual machines"	Smalltalk removeKey: #InterpreterLog ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Squeak-Jitter'.	SystemOrganization removeCategoriesMatching: 'Squeak-Interpreter'.	"remove the Smalltalk-to-C translator"	Smalltalk at: #CCodeGenerator ifPresent: [:codeGen | codeGen removeCompilerMethods].	SystemOrganization removeCategoriesMatching: 'Squeak-Translation to C'.	Smalltalk removeClassNamed: #SystemTracer.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/24/97 11:42'!lastRemoval  "Smalltalk lastRemoval"	#(abandonSources printSpaceAnalysis cleanOutUndeclared browseObsoleteReferences obsoleteClasses lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 5/21/1998 12:16'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around 600k in size."	self minorShrink.	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewGIFImports.	"Now delete lots of classes.."	(SystemOrganization categories select: [:c | 'Morphic*' match: c]) reverseDo:		[:c | SystemOrganization removeSystemCategory: c].	SystemOrganization removeSystemCategory: 'System-Network'.	SystemOrganization removeSystemCategory: 'System-Monitoring'.	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'Object Storage'.	SystemOrganization removeSystemCategory: 'System-Sound'.	Smalltalk removeClassNamed: #Circle.	Smalltalk removeClassNamed: #Arc.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	Smalltalk removeClassNamed: #BitEditor.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	TextConstants removeKey: #ClairVaux ifAbsent: [].  "deletes a couple of fonts"	TextStyle allInstancesDo:		[:ts | (ts instVarAt: 1) size > 2 ifTrue:  "Only need two fonts"			[ts instVarAt: 1 put: ((ts instVarAt: 1) copyFrom: 1 to: 2)]].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/20/1998 19:33'!minorShrink	"This method throws out lots of the system that is not needed, although not quite as much as majorShrink. In particular, it retains Morphic, Sound, graphics file readers, and the networking classes."	"Smalltalk minorShrink"	(Smalltalk confirm:'About to delete some infrequently used classes andmethods from your image; do you wish to continue?')		ifFalse: [^ self].	"virtual machine construction and Smalltalk-to-C translator:"	Smalltalk discardVMConstructionClasses.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	(Smalltalk includesKey: #FormView) ifTrue: [		(Smalltalk at: #FormView)			compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewGIFImports.	ScreenController removeSelector: #viewGIFImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	(Smalltalk includesKey: #FormEditor)		ifTrue: [(Smalltalk at: #FormEditor) removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FFT.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SharedQueue.	Smalltalk removeClassNamed: #SystemMonitor.	(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [(Smalltalk at: #SampledSound) initialize].	"post-removal cleanups"	Smalltalk removeEmptyMessageCategories.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 2/28/98 12:07'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ self printSpaceAnalysis: 0! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 2/28/98 12:07'!printSpaceAnalysis: threshold	"Smalltalk printSpaceAnalysis: 1000"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: 'STspace.text'.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s1 :s2 | s1 fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 10/3/97 11:13'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 5/15/1998 08:43'!unusedClasses	"Warning: Slow!! Enumerates all classes in the system and returns a list of those that are apparently unused. A class is considered in use if it (a) has subclasses (b) has instances or (c) is referred to by some method. Obsolete classes are not included in this list."	"Smalltalk unusedClasses"	| unused c |	unused _ SortedCollection new.	Metaclass allInstancesDo: [:meta |		c _ meta soleInstance.		((c ~~ nil) and:		 [('AnOb*' match: c name asString) not]) ifTrue: [			((c subclasses size = 0) and:			 [(c instanceCount = 0) and:			 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0]])				ifTrue: [unused add: c name]]].	^ unused asArray! !!SystemDictionary methodsFor: 'memory space'!bytesLeft	"Answer the number of bytes of space available. Does a full garbage collection."	^ self garbageCollect! !!SystemDictionary methodsFor: 'memory space'!createStackOverflow	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; createStackOverflow"	self createStackOverflow.  "infinite recursion"! !!SystemDictionary methodsFor: 'memory space'!garbageCollect	"Primitive. Reclaims all garbage and answers the number of bytes of available space."	<primitive: 130>	^ self primBytesLeft! !!SystemDictionary methodsFor: 'memory space'!garbageCollectMost	"Primitive. Reclaims recently created garbage (which is usually most of it) fairly quickly and answers the number of bytes of available space."	<primitive: 131>	^ self primBytesLeft! !!SystemDictionary methodsFor: 'memory space'!installLowSpaceWatcher	"Start a process to watch for low-space conditions."	"Smalltalk installLowSpaceWatcher"	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"	LowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].	LowSpaceProcess _ [self lowSpaceWatcher] newProcess.	LowSpaceProcess priority: Processor lowIOPriority.	LowSpaceProcess resume.! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 1/15/98 10:44'!lowSpaceThreshold	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	thisContext isPseudoContext		ifTrue: [^ 300000  "Allow for translated methods"]		ifFalse: [^  80000  "Enough for interpreter"]! !!SystemDictionary methodsFor: 'memory space'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	ScheduledControllers interruptName: 'Space is low'.! !!SystemDictionary methodsFor: 'memory space'!okayToProceedEvenIfSpaceIsLow	"Return true if either there is enough memory to do so safely or if the user gives permission after being given fair warning."	self garbageCollectMost > self lowSpaceThreshold ifTrue: [^ true].  "quick"	self garbageCollect > self lowSpaceThreshold ifTrue: [^ true].  "work harder"	^ self confirm:'WARNING: There is not enough space to start the low space watcher.If you proceed, you will not be warned again, and the system mayrun out of memory and crash. If you do proceed, you can start thelow space notifier when more space becomes available simply byopening and then closing a debugger (e.g., by hitting Cmd-period.)Do you want to proceed?'! !!SystemDictionary methodsFor: 'memory space'!primBytesLeft	"Primitive. Answer the number of bytes available for new object data.	Not accurate unless preceded by		Smalltalk garbageCollectMost (for reasonable accuracy), or		Smalltalk garbageCollect (for real accuracy).	See Object documentation whatIsAPrimitive."	<primitive: 112>	^ 0! !!SystemDictionary methodsFor: 'memory space'!primLowSpaceSemaphore: aSemaphore	"Primitive. Register the given Semaphore to be signalled when the	number of free bytes drops below some threshold. Disable low-space	interrupts if the argument is nil."	<primitive: 124>	self primitiveFailed! !!SystemDictionary methodsFor: 'memory space'!primSignalAtBytesLeft: numBytes	"Tell the interpreter the low-space threshold in bytes. When the free	space falls below this threshold, the interpreter will signal the low-space	semaphore, if one has been registered.  Disable low-space interrupts if the	argument is zero.  Fail if numBytes is not an Integer."	<primitive: 125>	self primitiveFailed! !!SystemDictionary methodsFor: 'memory space'!signalLowSpace	"Signal the low-space semaphore to alert the user that space is running low."	LowSpaceSemaphore signal.! !!SystemDictionary methodsFor: 'memory space'!useUpMemory	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemory"	| lst |	lst _ nil.	[true] whileTrue: [		lst _ Link new nextLink: lst; yourself.	].! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 9/11/97 11:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	"Smalltalk clearExternalObjects"	Smalltalk specialObjectsArray at: 39 put: Array new.! !!SystemDictionary methodsFor: 'special objects'!compactClassesArray  "Smalltalk compactClassesArray"	"Return the array of 31 classes whose instances may be	represented compactly"	^ Smalltalk specialObjectsArray at: 29! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 9/15/97 16:09'!externalObjects	"Return an array of objects that have been registered for use in non-Smalltalk code. Smalltalk objects should be referrenced by external code only via indirection through this array, thus allowing the objects to move during compaction. This array can be cleared when the VM re-starts, since variables in external code do not survive snapshots. Note that external code should not attempt to access a Smalltalk object, even via this mechanism, while garbage collection is in progress."	"Smalltalk externalObjects"	^ Smalltalk specialObjectsArray at: 39! !!SystemDictionary methodsFor: 'special objects'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	1 to: self specialSelectorSize do:		[:index | 		(self specialSelectorAt: index) == aLiteral			ifTrue: [aBlock value: index + 16rAF. ^true]].	^false! !!SystemDictionary methodsFor: 'special objects' stamp: 'ikp 1/1/98 23:43'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the	Smalltalk virtual machine.  Its contents are critical and unchecked,	so don't even think of playing here unless you know what you are doing."	| newArray smallFrameSize largeFrameSize |	newArray _ Array new: 41.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	smallFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: 0 nLits: 0 primitive: 0) frameSize.	largeFrameSize _ (CompiledMethod newBytes: 0 nArgs: 0 nTemps: 0						nStack: smallFrameSize+1 nLits: 0 primitive: 0) frameSize.	newArray at: 35 put: (MethodContext new: smallFrameSize).	newArray at: 36 put: (MethodContext new: largeFrameSize).	newArray at: 37 put: (BlockContext new: smallFrameSize).	newArray at: 38 put: (BlockContext new: largeFrameSize).	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 8/22/97 12:09'!registerExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	| objects firstEmptyIndex obj sz newObjects |	objects _ self specialObjectsArray at: 39.	"find the first empty slot"	firstEmptyIndex _ 0.	1 to: objects size do: [:i |		obj _ objects at: i.		obj == anObject ifTrue: [^ i].  "object already there, just return its index"		(obj == nil and: [firstEmptyIndex = 0]) ifTrue: [firstEmptyIndex _ i]].	"if no empty slots, expand the array"	firstEmptyIndex = 0 ifTrue: [		sz _ objects size.		newObjects _ objects species new: sz + 20.  "grow linearly"		newObjects replaceFrom: 1 to: sz with: objects startingAt: 1.		firstEmptyIndex _ sz + 1.		Smalltalk specialObjectsArray at: 39 put: newObjects.		objects _ newObjects].	objects at: firstEmptyIndex put: anObject.	^ firstEmptyIndex! !!SystemDictionary methodsFor: 'special objects'!specialNargsAt: anInteger 	"Answer the number of arguments for the special selector at: anInteger."	^ (self specialObjectsArray at: 24) at: anInteger * 2! !!SystemDictionary methodsFor: 'special objects'!specialObjectsArray  "Smalltalk specialObjectsArray at: 1"	<primitive: 129>	^ self primitiveFailed! !!SystemDictionary methodsFor: 'special objects'!specialSelectorAt: anInteger 	"Answer the special message selector from the interleaved specialSelectors array."	^ (self specialObjectsArray at: 24) at: anInteger * 2 - 1! !!SystemDictionary methodsFor: 'special objects'!specialSelectors	"Used by SystemTracer only."	^SpecialSelectors! !!SystemDictionary methodsFor: 'special objects'!specialSelectorSize	"Answer the number of special selectors in the system."	^ (self specialObjectsArray at: 24) size // 2! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 8/24/97 01:16'!unregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered."	| objects |	anObject ifNil: [^ self].	objects _ self specialObjectsArray at: 39.	1 to: objects size do: [:i |		(objects at: i) == anObject ifTrue: [objects at: i put: nil]].! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 3/27/98 08:20'!changesName	"Answer the local name for the changes file corresponding to the image file name."	"Smalltalk changesName"	| imName |	imName _ FileDirectory baseNameFor:		(FileDirectory localNameFor: self imageName).	^ imName, FileDirectory dot, 'changes'! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 3/27/98 08:35'!fileNameEnds	"Answer the appropriate suffixes for image and changes files."	| pairs |	pairs _ #(		('image' 'changes')		('image.IMA' 'changes.CHA')		('IMA' 'CHA')).	pairs do: [:pair |		(self imageName endsWith: pair first) ifTrue: [^ pair]].	self error:'The image file must end with one of' , (pairs collect: [:pair | pair first]) printString! !!SystemDictionary methodsFor: 'image, changes name'!imageName	"Answer the full path name for the current image."	"Smalltalk imageName"	<primitive: 121>	self primitiveFailed! !!SystemDictionary methodsFor: 'image, changes name'!imageName: newName	"Set the the full path name for the current image.  All further snapshots will use this."	<primitive: 121>	^ self primitiveFailed! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'jm 12/4/97 22:25'!imagePath	"Answer the path for the directory containing the image file."	"Smalltalk imagePath"	^ FileDirectory dirPathFor: self imageName! !!SystemDictionary methodsFor: 'image, changes name' stamp: 'di 5/22/1998 15:51'!sourcesName	"Answer the full path to the version-stable source code"	^ self vmPath , 'SqueakV2' , FileDirectory dot , 'sources'! !!SystemDictionary methodsFor: 'image, changes name'!vmPath	"Answer the path for the directory containing the Smalltalk virtual machine. Return the empty string if this primitive is not implemented."	"Smalltalk vmPath"	<primitive: 142>	^ ''! !!SystemDictionary methodsFor: 'sources, change log'!changes	"Answer the current system ChangeSet."	^SystemChanges! !!SystemDictionary methodsFor: 'sources, change log'!closeSourceFiles	"Shut down the source files if appropriate.  1/29/96 sw: changed so that the closing and nilification only take place if the entry was a FileStream, thus allowing stringified sources to remain in the saved image file"	1 to: 2 do: [:i |		((SourceFiles at: i) isKindOf: FileStream)			ifTrue:				[(SourceFiles at: i) close.				SourceFiles at: i put: nil]]! !!SystemDictionary methodsFor: 'sources, change log'!copyright	"The Smalltalk copyright."	^'Copyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 17:51'!externalizeSources   	"Write the sources and changes streams onto external files." 	"Smalltalk externalizeSources"	| sourcesName changesName aFile |	sourcesName _ self sourcesName.	(FileDirectory default fileExists: sourcesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', sourcesName].	changesName _ self changesName.	(FileDirectory default fileExists: changesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', changesName].	aFile _  FileStream newFileNamed: sourcesName.	aFile nextPutAll: SourceFiles first originalContents.	aFile close.	SourceFiles at: 1 put: (FileStream readOnlyFileNamed: sourcesName).	aFile _ FileStream newFileNamed: self changesName.	aFile nextPutAll: SourceFiles last contents.	aFile close.	SourceFiles at: 2 put: (FileStream oldFileNamed: changesName).	self inform: 'Sources successfully externalized'.! !!SystemDictionary methodsFor: 'sources, change log'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile _ SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		changesFile close.		changesFile open: changesFile name forWrite: true.		changesFile setToEnd.	].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 15:30'!internalizeChangeLog    		"Smalltalk internalizeChangeLog"	"Bring the changes file into a memory-resident filestream, for faster access and freedom from external file system.  1/31/96 sw"	| reply aName aFile |	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName _ self changesName.	(aFile _ SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, changes file internalized'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/5/97 15:30'!internalizeSources    		"Smalltalk internalizeSources"	"Bring the sources and changes files into memory-resident filestreams, for faster access and freedom from file-system interface.  1/29/96 sw"	| reply aName aFile |	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName _ self sourcesName.	(aFile _ SourceFiles first) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 1 put: (ReadWriteStream with: aFile contentsOfEntireFile).	aName _ self changesName.	(aFile _ SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile _ FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, sources internalized'! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'tk 12/12/97 10:43'!logChange: aStringOrText	"Write the argument, aString, onto the changes file."	| aString |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^self].	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'cant log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^self].  "null doits confuse replay"	(SourceFiles at: 2) setToEnd;			cr; cr; nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'sources, change log'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet."	SystemChanges _ aChangeSet! !!SystemDictionary methodsFor: 'sources, change log'!noChanges 	"Initialize the system ChangeSet."	SystemChanges initialize! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'dhhi 11/6/97 16:50'!openSourceFiles	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName _ self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName! !!SystemDictionary methodsFor: 'sources, change log'!recover: nCharacters	"Schedule an editable text view on the last n characters of changes."	| changes |	changes _ SourceFiles at: 2.	changes setToEnd; skip: nCharacters negated.	(FileStream newFileNamed: 'st80.recent') nextPutAll: (changes next: nCharacters); close; open; edit! !!SystemDictionary methodsFor: 'sources, change log'!timeStamp: aStream 	"Writes system version and current time on stream aStream."	| dateTime |	dateTime _ Time dateAndTimeNow.	aStream nextPutAll: 'From ', Smalltalk version, ' on ', (dateTime at: 1) printString,						' at ', (dateTime at: 2) printString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 5/22/1998 16:15'!version	"Answer the version of this release."	^ 'Squeak 2.0 of May 22, 1998'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 5/11/1998 15:14'!isMorphic	"Return true if the user interface is running in Morphic rathern than MVC.	By convention the gloabl variable World is set to nil when MVC is running.	ScheduledControllers could be set to nil when Morphic is running, but	this symmetry is not yet in effect."	^ World ~~ nil! !!SystemDictionary methodsFor: 'snapshot and quit'!lastQuitLogPosition	^ LastQuitLogPosition! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 5/16/1998 12:45'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 5/11/1998 15:32'!processStartUpList	"Call the startUp method on each object that needs to gracefully restart itself after a snapshot."	DisplayScreen startUp.	FileDirectory startUp.	Cursor startUp.	Smalltalk installLowSpaceWatcher.	InputSensor startUp.	ProcessorScheduler startUp.	Delay startUp.	Smalltalk startUp.	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [ControlManager startUp].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 10/16/97 10:30'!processUpdates	"Process update files from a well-known update server."	| choice |	(Preferences valueOfFlag: #updateFromServer) ifTrue: [		choice _ (PopUpMenu labels: 'Yes, Update\No, Not now' withCRs)			startUpWithCaption: 'Shall I look for new code\updates on the server?' withCRs.		choice = 1 ifTrue: [Utilities absorbUpdatesFromServer]].! !!SystemDictionary methodsFor: 'snapshot and quit'!quitPrimitive	"Primitive. Exit to another operating system on the host machine, if one	exists. All state changes in the object space since the last snapshot are lost.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 113>	self primitiveFailed! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 5/8/1998 11:18'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [(Smalltalk at: #EToySystem) openImagineeringStudio]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 3/27/98 08:42'!saveAs	| dir imageSuffix changesSuffix newName newImageName newChangesName |	dir _ FileDirectory default.	imageSuffix _ self fileNameEnds first.	changesSuffix _ self fileNameEnds last.	newName _ (FillInTheBlank		request: 'New File Name?'		initialAnswer: 'NewImageName') asFileName.	((newName endsWith: imageSuffix) and:	 [newName size > imageSuffix size]) ifTrue: [		newName _ newName copyFrom: 1 to: newName size - imageSuffix size - 1].	newImageName _ newName, FileDirectory dot, imageSuffix.	newChangesName _ newName, FileDirectory dot, changesSuffix.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'snapshot and quit'!shutDown	^ self closeSourceFiles! !!SystemDictionary methodsFor: 'snapshot and quit'!shutDownSound	(self at: #SoundPlayer ifAbsent: [^ self]) shutDown! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 5/11/1998 15:17'!snapshot: save andQuit: quit	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList.	Smalltalk isMorphic ifFalse: [Cursor write show].	save		ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Smalltalk isMorphic ifFalse: [Cursor normal show].	self processStartUpList.	resuming ifTrue: [		self clearExternalObjects.		self readDocumentFile].! !!SystemDictionary methodsFor: 'snapshot and quit'!snapshotPrimitive	"Primitive. Write the current state of the object memory on a file in the	same format as the Smalltalk-80 release. The file can later be resumed,	returning you to this exact state. Return normally after writing the file.	Essential. See Object documentation whatIsAPrimitive."	<primitive: 97>	self primitiveFailed! !!SystemDictionary methodsFor: 'snapshot and quit'!startUp	"Open the files for sources and changes."	self openSourceFiles.! !!SystemDictionary methodsFor: 'housekeeping'!cleanOutUndeclared 	Undeclared removeUnreferencedKeys! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 11/4/97 20:11'!condenseChanges		"Smalltalk condenseChanges"	"Move all the changes onto a compacted sources file."	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old'.	FileDirectory default rename: oldChanges name						toBe: oldChanges name , '.old'.	FileDirectory default rename: f name						toBe: oldChanges name.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name).! !!SystemDictionary methodsFor: 'housekeeping'!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f name oldChanges classCount dir |	dir _ FileDirectory default.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName , '.temp'.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	dir rename: self sourcesName		toBe: self sourcesName , '.old'.	dir rename: self sourcesName , '.temp'		toBe: self sourcesName.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 11/4/97 20:11'!forgetDoIts	"Smalltalk forgetDoIts"	Smalltalk allBehaviorsDo: "get rid of old DoIt methods"		[:cl | cl removeSelectorSimply: #DoIt; removeSelectorSimply: #DoItIn:]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 5/22/1998 16:24'!makeExternalRelease		"Smalltalk makeExternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	self obsoleteClasses isEmpty ifFalse: [self halt].	Display newDepth: 8.	Project allInstancesDo: [:p | p displayDepth: 8].	EToySystem prepareForExternalReleaseNamed: 'Squeak2.0'.	Utilities removeDisney.	EToySystem class removeSelector: #serverUrls.	Utilities removeDisney.	#(Helvetica Palatino ComicAll) do:		[:k | TextConstants removeKey: k].	EToySystem class removeSelector: #serverUrls.	SystemDictionary removeSelector: #makeExternalRelease.	Symbol rehash.	self halt: 'Ready to condense sources'.	Smalltalk condenseSources! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 9/21/97 01:14'!makeInternalRelease		"Smalltalk makeInternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	self obsoleteClasses isEmpty ifFalse: [self halt].	Symbol rehash.	self halt: 'Ready to condense changes'.	Smalltalk condenseChanges! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'jm 5/22/1998 11:37'!obsoleteClasses   "Smalltalk obsoleteClasses inspect"	"NOTE:  Also try inspecting comments below"	| obs c |	obs _ OrderedCollection new.  Smalltalk garbageCollect.	Metaclass allInstancesDo:		[:m | c _ m soleInstance.		(c ~~ nil and: ['AnOb*' match: c name asString])			ifTrue: [obs add: c]].	^ obs asArray"Likely in a ClassDict or Pool...(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray""Obsolete class refs or super pointer in last lit of a method...| n l found |Smalltalk browseAllSelect:	[:m | found _ false.	1 to: m numLiterals do:		[:i | (((l _ m literalAt: i) isMemberOf: Association)				and: [(l value isKindOf: Behavior)				and: ['AnOb*' match: l value name]])			ifTrue: [found _ true]].	found]"! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 6/20/97 10:51'!reclaimDependents		"Smalltalk reclaimDependents"	"Reclaim unused entries in DependentsFields (DF)..."	"NOTE:  if <object>addDependent: is ever used to add something		other than a view, this process will fail to reinstate that		thing after clearing out DependentsFields.  DF was only		intended to be used as part of the MVC architecture."	Object classPool at: #DependentsFields  "Remove all entries from DF"				put: IdentityDictionary new.	Smalltalk garbageCollect.  "If that was the only reference, they will go away"	"Now if any views of non-models remain,		they should be reinstated as dependent views..."	View allSubInstancesDo:		[:v | (v model==nil or: [v model isKindOf: Model])				ifFalse: [v model addDependent: v]]	! !!SystemDictionary methodsFor: 'housekeeping'!recompileAllFrom: firstName 	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	self allClassesDo: 		[:class | class name >= firstName			ifTrue: 				[Transcript show: class name; cr.				class compileAll]]	"Smalltalk recompileAllFrom: 'Aardvark'."! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 10/4/97 09:11'!removeEmptyMessageCategories	"Smalltalk removeEmptyMessageCategories"	Smalltalk garbageCollect.	ClassOrganizer allInstances , (Array with: SystemOrganization) do:		[:org | org categories do: 			[:cat | (org listAtCategoryNamed: cat) isEmpty				ifTrue: [org removeCategory: cat]]]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 7/13/97 11:56'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	Smalltalk allBehaviorsDo:		[:cls |  Transcript cr; show: cls name.		cls selectors do:			[:selector |			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].	^ badOnes! !!SystemDictionary methodsFor: 'housekeeping'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod badOnes |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.	Smalltalk allBehaviorsDo:		[:cls |  Transcript cr; show: cls name.		cls selectors do:			[:selector |			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].	^ badOnes! !!SystemDictionary methodsFor: 'housekeeping'!verifyChanges		"Smalltalk verifyChanges"	"Recompile all methods in the changes file."	Smalltalk allBehaviorsDo: [:class | class recompileChanges].! !!SystemDictionary methodsFor: 'miscellaneous'!beep	"Emit a short alert sound."	<primitive: 140>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous'!clipboardText	"Get the current clipboard text. Return the empty string if the primitive fails."	<primitive: 141>	^ ''! !!SystemDictionary methodsFor: 'miscellaneous'!clipboardText: aString	"Set the current clipboard text to the given string."	<primitive: 141>	^ self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous'!exitToDebugger	"Primitive. Enter the machine language debugger, if one exists. Essential.	See Object documentation whatIsAPrimitive."	<primitive: 114>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 5/21/1998 23:49'!forceDisplayUpdate	"Obsolete. Send this message to Display instead of Smalltalk."	Display forceDisplayUpdate.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 3/10/98 21:43'!fullScreenMode: aBoolean	"On platforms that support it, set full-screen mode to the value of the argument. (Note: you'll need to restore the Display after calling this primitive."	"Smalltalk fullScreenMode: true. Display newDepth: Display depth"	<primitive: 233>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 5/8/1998 11:41'!getSystemAttribute: attributeID	"Optional. Answer the string for the system attribute with the given integer ID. Answer nil if the given attribute is not defined on this platform. On platforms that support invoking programs from command lines (e.g., Unix), this mechanism can be used to pass command line arguments to programs written in Squeak. By convention, the first command line argument that is not a VM configuration option is considered a 'document' to be filed in. Such a document can add methods and classes, can contain a serialized object, can include code to be executed, or any combination of these.	Currently defined attributes include:	-1000...-1 - command line arguments that specify VM options	0 - the full path name for currently executing VM		(or, on some platforms, just the path name of the VM's directory)	1 - full path name of this image	2 - a Squeak document to open, if any	3...1000 - command line arguments for Squeak programs	1001 - this platform's operating system	1002 - operating system version	1003 - this platform's processor type" 	<primitive: 149>	^ nil! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!getVMParameters	"Smalltalk getVMParameters"	"Answer an Array containing the current values of the VM's internal	parameter/metric registers.  Each value is stored in the array at the	index corresponding to its VM register.  (See #vmParameterAt: and	#vmParameterAt:put:.)"	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous'!gifImports	"Answer the global dictionary of gif imports, creating it if necessary.  7/24/96 sw"	"Smalltalk viewGIFImports"	(self includesKey: #GIFImports)		ifFalse:			[self at: #GIFImports put: Dictionary new].	^ self at: #GIFImports! !!SystemDictionary methodsFor: 'miscellaneous'!gifReaderClass	"Answer, if present, a class to handle the importing of GIF files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #GIFReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous'!viewGIFImports	"Open up a special Form inspector on the dictionary of GIF imports.  7/24/96 sw"	self gifImports inspectFormsWithLabel: 'GIF Imports'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!vmParameterAt: parameterIndex	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Answer with the current value of that register.	Fail if parameterIndex has no corresponding register."	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:29'!vmParameterAt: parameterIndex put: newValue	"parameterIndex is a positive integer corresponding to one of the VM's internal	parameter/metric registers.  Store newValue (a positive integer) into that	register and answer with the previous value that was stored there.	Fail if newValue is out of range, if parameterIndex has no corresponding	register, or if the corresponding register is read-only."	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ikp 1/2/98 20:30'!vmTable: tableIndex at: index	"tableIndex is a negative integer corresponding to one of the VM's internal tables.	Answer with the value in the table at the given index (counting from 1).  Index 0	'contains' the size (i.e. largest legal index) of the table."	<primitive: 254>	self primitiveFailed! !!SystemDictionary methodsFor: 'profiling'!clearProfile	"Clear the profile database."	<primitive: 250>! !!SystemDictionary methodsFor: 'profiling'!dumpProfile	"Dump the profile database to a file."	<primitive: 251>! !!SystemDictionary methodsFor: 'profiling'!profile: aBlock	"Make a virtual machine profile of the given block."	"Note: Profiling support is provided so that VM implementors	 can better understand and improve the efficiency of the virtual	 machine. To use it, you must be running a version of the	 virtual machine compiled with profiling enabled (which	 makes it much slower than normal even when not profiling).	 You will also need the CodeWarrior profile reader application."	self stopProfiling.	self clearProfile.	self startProfiling.	aBlock value.	self stopProfiling.	self dumpProfile.! !!SystemDictionary methodsFor: 'profiling'!startProfiling	"Start profiling the virtual machine."	<primitive: 252>! !!SystemDictionary methodsFor: 'profiling'!stopProfiling	"Stop profiling the virtual machine."	<primitive: 253>! !Object subclass: #SystemMonitor	instanceVariableNames: 'window labels valSelectors baselineSkip minValues maxValues vmParameters gcLowWaterMark gcHighWaterMark prevAllocCount prevAllocRate prevFullGC prevDeltaFullGC prevIncrGC prevDeltaIncrGC prevMsClock prevMcMiss prevMcHit prevIcHit '	classVariableNames: 'ActiveClock ActiveMonitor BackgroundColor BarBackgroundColor BarBorderColor BarBorderWidth BarColors BarForegroundColor BarWidth BorderColor BorderWidth DefaultBarHeight ForegroundColor Inset MonitorDelay '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!SystemMonitor methodsFor: 'initialize-release' stamp: 'di 11/4/97 20:03'!labels: labelArray selectors: selectorArray	| labelHeight labelWidth topLeft bottomRight |	self readVMParameters.	minValues _ selectorArray collect: [:str | self perform: (str , 'Min') asSymbol].	maxValues _ selectorArray collect: [:str | self perform: (str , 'Max') asSymbol].	valSelectors _ selectorArray collect: [:str | (str , 'Val') asSymbol].	labels _ labelArray collect: [:str |		(DisplayText text: str asText)			foregroundColor: ForegroundColor			backgroundColor: BackgroundColor].	baselineSkip _ (labels at: 1) height.	baselineSkip = 0		ifTrue:	"empty lables: use a completely undecorated display, flush-bottom/left"			[baselineSkip _ DefaultBarHeight.			labelHeight _ baselineSkip * labels size.			topLeft _ 0@(Display height - labelHeight + BarBorderWidth).			bottomRight _ BarWidth@(Display height).			window _ topLeft corner: bottomRight]		ifFalse:			[labelHeight _ baselineSkip * labels size.			labelWidth _ (labels inject: 0 into: [:max :lbl | max max: lbl width]) + (Inset * 2) + BarBorderWidth.			topLeft _ 0@(Display height - labelHeight - (Inset * 2)).			bottomRight _ (labelWidth + (2*Inset) + BarWidth)@(Display height).			window _ (topLeft corner: bottomRight) insetBy: Inset.			"window _ window translateBy: (BorderWidth negated)@BorderWidth."			self displayBordersAndLabels]! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!display	| barOrigin delta curVal minVal maxVal |	self readVMParameters.	barOrigin _ window topRight translateBy: (BarWidth negated - BarBorderWidth)@BarBorderWidth.	delta _ 0@baselineSkip.	1 to: valSelectors size do: [:index |		curVal _ self perform: (valSelectors at: index).		minVal _ minValues at: index.		maxVal _ maxValues at: index.		curVal class == Array			ifTrue:				["implicitly trust the system to return sensible values"				self displayBars: curVal from: minVal to: maxVal					in: (barOrigin extent: BarWidth@(baselineSkip - (BarBorderWidth * 2)))]			ifFalse:				["adjust the bounds if necessary"				minVal > curVal ifTrue: [minValues at: index put: (minVal _ curVal)].				maxVal < curVal ifTrue: [maxValues at: index put: (maxVal _ curVal)].				self displayBar: curVal from: minVal to: maxVal					in: (barOrigin extent: BarWidth@(baselineSkip - (BarBorderWidth * 2)))].		barOrigin _ barOrigin translateBy: delta].! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBar: val from: min to: max in: barRect	| break |	break _ barRect left + (((val - min) / (max - min)) * barRect width) asInteger.	Display fill: (barRect withRight: break) fillColor: (BarColors at: 1).	Display fill: (barRect withLeft: break) fillColor: BarBackgroundColor.! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBars: vals from: min to: max in: barRect	| break prevBreak |	prevBreak _ barRect left.	vals doWithIndex: [:val :index |		break _ barRect left + (((val - min) / (max - min)) * barRect width) asInteger.		Display fill: ((barRect withLeft: prevBreak) withRight: break) fillColor: (BarColors at: index).		prevBreak _ break].	Display fill: (barRect withLeft: prevBreak) fillColor: BarBackgroundColor.! !!SystemMonitor methodsFor: 'displaying' stamp: 'di 11/4/97 20:03'!displayBordersAndLabels	| labelOrigin barOrigin delta |	Display fill: (window insetBy: Inset negated) fillColor: BorderColor.	Display fill: (window insetBy: BorderWidth - Inset) fillColor: BackgroundColor.	barOrigin _ window topRight translateBy: (BarWidth negated - (2 * BarBorderWidth))@0.	labelOrigin _ barOrigin translateBy: (Inset negated)@"0"(BorderWidth - Inset).	delta _ 0@baselineSkip.	1 to: labels size do: [:index |		(labels at: index) displayOn: Display at: (labelOrigin translateBy: ((labels at: index) width negated)@0).		Display fill: (barOrigin extent: (BarWidth + (2 * BarBorderWidth))@baselineSkip)			fillColor: BarBorderColor.		labelOrigin _ labelOrigin translateBy: delta.		barOrigin _ barOrigin translateBy: delta].! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateMax	^1! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateMin	prevAllocCount _ 0.	prevAllocRate _ 0.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!allocationRateVal	| rate allocCount |	allocCount _ vmParameters at: 4.	rate _ allocCount < prevAllocCount		ifTrue: [prevAllocRate]		ifFalse: [allocCount - prevAllocCount].	prevAllocCount _ allocCount.	prevAllocRate _ (prevAllocRate // 2) + (rate // 2).	^prevAllocRate! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:54'!cacheMax	^100! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 01:00'!cacheMin	prevMcMiss _ vmParameters at: 15.	prevMcHit _ vmParameters at: 16.	prevIcHit _ vmParameters at: 17.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 01:02'!cacheVal	| icHit mcHit mcMiss total deltaMcMiss deltaMcHit deltaIcHit |	mcMiss _ vmParameters at: 15.	deltaMcMiss _ mcMiss - prevMcMiss.	prevMcMiss _ mcMiss.	mcHit _ vmParameters at: 16.	deltaMcHit _ mcHit - prevMcHit.	prevMcHit _ mcHit.	icHit _ vmParameters at: 17.	deltaIcHit _ icHit - prevIcHit.	prevIcHit _ icHit.	total _ deltaMcMiss + deltaMcHit + deltaIcHit.	deltaMcMiss _ (deltaMcMiss * 100 / total asInteger).	deltaMcHit _ (deltaMcHit * 100 / total asInteger).	^Array		with: deltaMcMiss		with: deltaMcMiss + deltaMcHit! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:11'!gcMax	^100! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:23'!gcMin	prevMsClock _ Time millisecondClockValue.	prevFullGC _ vmParameters at: 8.	prevDeltaFullGC _ 0.	prevIncrGC _ vmParameters at: 10.	prevDeltaIncrGC _ 0.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'ikp 1/13/98 00:22'!gcVal	| ms fullGC incrGC deltaMs deltaFull deltaIncr max |	ms _ Time millisecondClockValue.	fullGC _ (vmParameters at: 8).	incrGC _ (vmParameters at: 10).	deltaMs _ ms - prevMsClock.	deltaFull _ fullGC - prevFullGC.	deltaIncr _ incrGC - prevIncrGC.	prevMsClock _ ms.	prevFullGC _ fullGC.	prevIncrGC _ incrGC.	prevDeltaFullGC _ prevDeltaFullGC + deltaFull / 2.	prevDeltaIncrGC _ prevDeltaIncrGC + deltaIncr / 2.	max _ deltaMs * 2.	^Array		with: (prevDeltaFullGC * 100 / max) asInteger		with: (prevDeltaIncrGC * 100 / max) asInteger! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryMax	^vmParameters at: 3! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryMin	"Setup the gc low/high water marks at the same time"	gcLowWaterMark _ vmParameters at: 1.	gcHighWaterMark _ vmParameters at: 1.	^0! !!SystemMonitor methodsFor: 'system parameters' stamp: 'di 11/4/97 20:03'!memoryVal	"If youngStart is below the highWaterMark then a full collection has happened."	| youngStart |	youngStart _ vmParameters at: 1.	youngStart < gcHighWaterMark ifTrue: [gcLowWaterMark _ gcHighWaterMark _ youngStart].	youngStart > gcHighWaterMark ifTrue: [gcHighWaterMark _ youngStart].	^Array		with: gcLowWaterMark		with: gcHighWaterMark		with: (vmParameters at: 2)! !!SystemMonitor methodsFor: 'private' stamp: 'di 11/4/97 20:03'!readVMParameters	vmParameters _ Smalltalk getVMParameters.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemMonitor class	instanceVariableNames: ''!!SystemMonitor class methodsFor: 'class initialization' stamp: 'ikp 1/13/98 01:18'!initialize	"SystemMonitor initialize"	MonitorDelay _ 1000.								"milliseconds between updates"	Inset _ 2.										"inset from monitor border (outside) to bars and labels"	BorderWidth _ 1.									"width of border around entire monitor"	BorderColor _ Color black.						"colour of border around entire monitor"	BackgroundColor _ Color gray.		"background colour for monitor area"	ForegroundColor _ Color black.					"foreground colour for bar labels"	DefaultBarHeight _ 8.							"height of bar for undecorated display (no labels)"	BarWidth _ 200.									"horizontal (long-axis) size of each bar"	BarBorderWidth _ 1.								"width of border around each bar"	BarBorderColor _ Color black.					"colour of border around each bar"	BarBackgroundColor _ Color veryLightGray.		"background colour (inactive region) of bar"	BarColors _ Array		with: Color darkGray						"colour of first bar segment"		with: Color lightRed						"colour of second bar segment"		with: Color lightBlue							"colour of third bar segment"		with: Color lightGreen.						"colour of fourth bar segment"! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:52'!cache	^super new		labels: #(cache)		selectors: #(cache).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!cacheUndecorated	^super new labels: #('') selectors: #(cache).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!default	^super new		labels: #(cache memory gc)		selectors: #(cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!defaultUndecorated	^super new labels: #('' '' '') selectors: #(cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!full	^super new		labels: #('alloc' cache mem gc)		selectors: #(allocationRate cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/13/98 00:53'!fullUndecorated	^super new		labels: #('' '' '' '')		selectors: #(allocationRate cache memory gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/12/98 23:51'!gc	^super new		labels: #(gc)		selectors: #(gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/12/98 23:51'!gcUndecorated	^super new labels: #('') selectors: #(gc).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/14/98 02:25'!memory	^super new		labels: #(memory)		selectors: #(memory).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'ikp 1/14/98 02:25'!memoryUndecorated	^super new		labels: #('')		selectors: #(memory).! !!SystemMonitor class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:03'!new	^self default! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!restore		"SystemMonitor restore"	ActiveMonitor = nil ifFalse: [ActiveMonitor displayBordersAndLabels; display]! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!start		"SystemMonitor start"	self startDefault! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/13/98 00:54'!startCache		"SystemMonitor startCache"	self start: self cache! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/13/98 00:54'!startCacheUndecorated		"SystemMonitor startCacheUndecorated"	self start: self cacheUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startDefault		"SystemMonitor startDefault"	self start: self default! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startDefaultUndecorated		"SystemMonitor startDefaultUndecorated"	self start: self defaultUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startFull		"SystemMonitor startFull"	self start: self full! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startFullUndecorated		"SystemMonitor startFullUndecorated"	self start: self fullUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/12/98 23:52'!startGC		"SystemMonitor startGC"	self start: self gc! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/12/98 23:52'!startGCUndecorated		"SystemMonitor startGCUndecorated"	self start: self gcUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/14/98 02:25'!startMemory		"SystemMonitor startMemory"	self start: self memory! !!SystemMonitor class methodsFor: 'public access' stamp: 'ikp 1/14/98 02:26'!startMemoryUndecorated		"SystemMonitor startMemoryUndecorated"	self start: self memoryUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!startUndecorated		"SystemMonitor startUndecorated"	self startDefaultUndecorated! !!SystemMonitor class methodsFor: 'public access' stamp: 'di 11/4/97 20:03'!stop		"SystemMonitor stop"	ActiveClock = nil		ifFalse:			[ActiveClock terminate.			ActiveClock _ nil].	ActiveMonitor = nil ifFalse: [ActiveMonitor _ nil].! !!SystemMonitor class methodsFor: 'scheduling' stamp: 'ikp 1/13/98 01:28'!start: aMonitor	self stop.	ActiveMonitor _ aMonitor.	ActiveClock _		[[true] whileTrue:			[ActiveMonitor display.			(Delay forMilliseconds: MonitorDelay) wait]] newProcess.	ActiveClock priority: Processor lowIOPriority.	ActiveClock resume! !ClassOrganizer subclass: #SystemOrganizer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Support'!!SystemOrganizer commentStamp: 'di 5/22/1998 16:38' prior: 0!SystemOrganizer comment:'My instances provide an organization for the classes in the system, just as a ClassOrganizer organizes the messages within a class. The only difference is the methods for fileIn/Out.'!!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 19:01'!fileOutCategory: category 	"Store on the file named category (a string) concatenated with '.st' all the 	classes associated with the category."	^ self fileOutCategory: category asHtml: false! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 6/28/97 19:00'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: category , '.html') asHtml]		ifFalse: [FileStream newFileNamed: category , '.st'].	self fileOutCategory: category on: fileStream.	fileStream close! !!SystemOrganizer methodsFor: 'fileIn/Out'!fileOutCategory: category on: aFileStream 	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."	| first poolSet tempClass classes |	classes _ (self superclassOrder: category).	poolSet _ Set new.	classes do: 		[:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue:		[tempClass _ Class new.		tempClass shouldFileOutPools ifTrue:			[poolSet _ poolSet select: [:aPool | tempClass shouldFileOutPool: (Smalltalk keyAtValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first _ true.	classes do: 		[:class | 		first			ifTrue: [first _ false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		class			fileOutOn: aFileStream			moveSource: false			toFile: 0]! !!SystemOrganizer methodsFor: 'fileIn/Out'!superclassOrder: category 	"Answer an OrderedCollection containing references to the classes in the 	category whose name is the argument, category (a string). The classes 	are ordered with superclasses first so they can be filed in."	| list |	list _ 		(self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	^ChangeSet superclassOrder: list! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 1/9/98 12:37'!removeCategoriesMatching: matchString	"Remove all matching categories with their classes"	(self categories select: [:c | matchString match: c]) do:		[:c | self removeSystemCategory: c]! !!SystemOrganizer methodsFor: 'remove' stamp: 'jm 5/20/1998 19:38'!removeMissingClasses	"Remove any class names that are no longer in the Smalltalk dictionary. Used for cleaning up after garbage collecting user-generated classes."	"SystemOrganization removeMissingClasses"	elementArray copy do: [:el |		(Smalltalk includesKey: el) ifFalse: [self removeElement: el]].! !!SystemOrganizer methodsFor: 'remove'!removeSystemCategory: category	"remove all the classes associated with the category"	(self superclassOrder: category) do: [:class | class removeFromSystem].	self removeEmptyCategories! !Object subclass: #SystemTracer	instanceVariableNames: 'oopMap map file writeDict maxOop specialObjects initialProcess hashGenerator imageHeaderSize cleaningUp compactClasses '	classVariableNames: 'Clamped NewNil UnassignedOop '	poolDictionaries: ''	category: 'Squeak-Interpreter'!!SystemTracer commentStamp: 'di 5/22/1998 16:38' prior: 0!SystemTracer comment:'NOTE:  The SystemTracer was invented by Ted Kaehler.  It has gone through many variations.  I have simplified it and adapted it to work with Squeak''s limited Object hashing.  It has written runnable Mac images on a Mac.  Some changes may be needed for it to produce runnables image on a bigEndian machine.  -- Dan I. 9/29/97The SystemTracer runs through the system tracing every accessible object, and writing a copy of each object onto a disk image. It does this carefully enough that the resulting clone can be started up and run, just like a snapshot.  Great care must also be taken that the tracer never sees (due to clamping) any of the structures created dynamically while writing the clone.  If this happens an infinite recursion can result.	The tracer has built-in support for clamping unwanted (or unneeded) objects out of the system. It also allows fundamental changes to, eg, object header format, compiledMethod format, number formats, etc.  The current version is fairly simple, as it just copies what is already in the system. This version does, however, reassign object hashes in order to illustrate how one must remap all the hashed structures accordingly.Squeak currently only has 12 bits of object hash.  A normal dictionary, used to map from old oop to new oop, would bog down in a system of, say, 50k objects.  This tracer has a special structure that is optimized for this purpose.  See the comment in initOopMap.  If we ever extend the object hash, this structure could be replaced by a simple IdentityDictionary.When you first start up the cloned image, you will probably get a "cannotReturn" error, a vestige of the old tracing process.  This can simply be closed (or maybe you can figure out how to fix the tracers so it doens''t happen ;-).  '!!SystemTracer methodsFor: 'initialization' stamp: 'di 9/28/97 16:13'!doit  "SystemTracer writeClone"	"(StandardFileStream allInstances select:		[:f | f name endsWith: 'clone.image']) do: [:f | f close]."	| time1 time2 ctxt n |	ctxt _ thisContext sender.	ctxt push: nil.	self init: ctxt.	cleaningUp _ false.	"true means rewriting special objects in writeSpecial2"	Transcript show: 'Tracing . . . '.	time1 _ Time millisecondClockValue.	file _ FileStream fileNamed: 'clone.image'.	file binary.	n _ self writeImage: (Array with: Smalltalk).	time2 _ Time millisecondClockValue.	Transcript cr; show: n printString , ' bytes written in '			, (time2 - time1 //1000) printString , ' seconds.'.	"ctxt pop" "So we can resume"! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/27/97 22:27'!init: aContext	initialProcess _ Process forContext: aContext priority: Processor activePriority.	self initOopMap.	hashGenerator _ Random new.	self clamp: self.	self clamp: aContext sender.	self initDict! !!SystemTracer methodsFor: 'initialization' stamp: 'di 12/15/97 21:35'!initCompactClasses	| c |	c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: PseudoContext.	compactClasses _ c.	"Leave 16 to 31 for user defined compact classes."	"Attempt to correctly write contextCace image.."	compactClasses _ Smalltalk compactClassesArray! !!SystemTracer methodsFor: 'initialization' stamp: 'ikp 12/17/97 00:08'!initDict	writeDict _ Dictionary new: 256.	Smalltalk allClassesDo: 		[:class | 		class isBits 			ifTrue: 			[writeDict at: class put: (class isBytes ifTrue: [#writeBytes:]												ifFalse: [#writeWords:])]			ifFalse:			[writeDict at: class put: #writePointers:.			(class inheritsFrom: Set) | (class == Set) ifTrue:				[writeDict at: class put: #writeSet:].			(class inheritsFrom: IdentitySet) | (class == IdentitySet) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: IdentityDictionary) | (class == IdentityDictionary) ifTrue:				[writeDict at: class put: #writeIdentitySet:].			(class inheritsFrom: MethodDictionary) | (class == MethodDictionary) ifTrue:				[writeDict at: class put: #writeMethodDictionary:]].				].	Smalltalk allBehaviorsDo: 		[:class | writeDict at: class class put: #writeBehavior:].	(ObjectTracer withAllSubclasses) do: 		[:class | writeDict at: class class put: #writeBehavior:].	writeDict at: PseudoContext class put: #writeBehavior:.	writeDict at: SmallInteger put: #writeClamped:.	writeDict at: CompiledMethod put: #writeMethod:.	writeDict at: Process put: #writeProcess:.	writeDict at: MethodContext put: #writeContext:.	writeDict at: BlockContext put: #writeContext:.! !!SystemTracer methodsFor: 'initialization' stamp: 'di 1/2/98 11:15'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	file setType: 'STim' creator: 'FAST'; close! !!SystemTracer methodsFor: 'initialization' stamp: 'di 10/3/97 16:13'!writeImage: roots 	imageHeaderSize _ 64.	"16 longs"	file position: imageHeaderSize.  "Skip header section"	maxOop _ 0.  "Starting oop"	self initCompactClasses.	specialObjects _ Smalltalk specialObjectsArray copy.	specialObjects at: 29 put: compactClasses.	"New oop of nil is needed before we find out from the trace."	NewNil _ maxOop + ((self headersFor: nil withHash: 0) size-1*4).	self trace: nil.  "In fact, this traverses the system by the time it's done!!"	self trace: specialObjects.	roots do: [:root | self trace: root].	self writeFileHeader.	^ Array with: maxOop! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/29/97 08:21'!clamp: obj	self mapAt: obj put: Clamped with: nil! !!SystemTracer methodsFor: 'mapping oops'!hasClamped: obj	"See if obj will be a SmallInteger in the new system."	obj class == SmallInteger ifTrue: [^ true].	^ (self mapAt: obj) = Clamped! !!SystemTracer methodsFor: 'mapping oops'!initOopMap	"oopMap is an array 4096 long indexed by basicHash.	Each element a subarray of object/newOop/hash triplets.	The subarrrays must be linearly searched.	Access to an object causes it to be promoted in the subarray,		so that frequently accessed objects can be found quickly."	oopMap _ (1 to: 4096) collect: [:i | Array new].! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/27/97 20:26'!mapAt: obj	"Return the new oop for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i)			ifTrue: ["Promote this entry for rapid access"					i > 1 ifTrue: [1 to: 3 do: [:j | bucket swap: j with: i-1+j]].					^ bucket at: 2]].	^ UnassignedOop! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 9/27/97 20:26'!mapAt: obj put: oop with: hash	"Assign the new oop for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	"Check for multiple writes (debug only)""	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [self halt]]."	oopMap at: obj identityHash+1 put: (Array with: obj with: oop with: hash) , bucket! !!SystemTracer methodsFor: 'mapping oops' stamp: 'di 12/15/97 19:31'!mapHashAt: obj	"Return the new hash for this object"	| bucket |	bucket _ oopMap at: obj identityHash+1.	1 to: bucket size by: 3 do: 		[:i | obj == (bucket at: i) ifTrue: [^ bucket at: i+2]].	self halt! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/29/97 09:05'!new: obj class: class length: length trace: traceBlock write: writeBlock	| oop objpos headers type hash |	"We assign file space for an object.	Only does something when object has not been assigned a new oop yet.  	Length is the instance vars and variable portion in longs.	Class is not included in length.	Special objects come here for an oop, and do no tracing or writing.	To trace and write their fields later, do NOT use this method."  	oop_ self mapAt: obj.	oop = UnassignedOop ifFalse:		["Has already been assigned a new oop or clamped."		^ self].	"Write header and remember new oop in map"	hash _ (hashGenerator next * 16rFFF asFloat) asInteger.	headers _ self headersFor: obj withHash: hash.	file position: maxOop + imageHeaderSize.	headers do: [:h | self write4Bytes: h].	maxOop _ maxOop + (headers size-1*4).		"New oop points at header word"	self mapAt: obj put: maxOop with: hash.	objpos _ maxOop + imageHeaderSize.		"file position"length > 20 ifTrue: [maxOop printString, ' ' displayAt: 0@0].	"Write blank data, advancing to next object position"	maxOop _ maxOop + (length+1*4).	"ready for next object"	file nextPutAll: (ByteArray new: length*4 withAll: 0).	traceBlock notNil ifTrue: [self trace: class.  traceBlock value].	(headers size > 1 and: [(headers at: headers size-1) < 0])		ifTrue: ["rewrite class word if not known before"				file position: objpos-4.				type _ (headers at: headers size-1) bitAnd: 3.				self write4Bytes: (self mapAt: class) + type.				self write4Bytes: (headers at: headers size) "faster to write than skip"]		ifFalse: ["Had no class header, or was already valid"				file position: objpos+4].	"Now positioned after header, before data..."	writeBlock value.	"No allocation of new oops is allowed in here!!"	"Consistency check"	file position = (objpos + (length+1*4)) ifFalse:		["writeBlock did not leave us at end of object"		self halt.		"Maybe copied an object without putting it in holder,		so it got freed and became something else of a different size"]! !!SystemTracer methodsFor: 'tracing and writing'!trace: obj	(self hasClamped: obj) ifTrue: [^ self].	self perform: (writeDict at: obj class ifAbsent: [#writeClamped:])			"May be some classes not in Smalltalk dict, let them through"		with: obj.! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 14:40'!writeBehavior: obj	| length |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: 2 do: [:i | self writePointerField: (obj instVarAt: i)].			self writePointerField: (self formatOfCls: obj).			4 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeBytes: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: 			[1 to: obj size do: [:i | file nextPut: (obj at: i) asInteger].			file padToNextLongPut: 0]! !!SystemTracer methodsFor: 'tracing and writing'!writeClamped: obj	^false! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 01:33'!writeContext: obj	"Nil out any garbage above the stack pointer to avoid a crash."	obj stackPtr == nil ifFalse:		[obj stackPtr+1 to: obj size do: [:ind | obj at: ind put: nil]].	^ self writePointers: obj	"Normal Case"! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:20'!writeHashArray: obj permutedBy: perm	"Elements of a Set's hashed array need to be reordered according to perm."	| length |	self new: obj class: obj class length: (length _ self sizeInWordsOf: obj)		trace:	[1 to: length do:					[:i | self trace: (obj basicAt: i)]]		write:	[1 to: length do:					[:i | self writePointerField: ((perm at: i) == nil										ifTrue: [nil]										ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:15'!writeHashArrayPermuted: obj useIdentity: useIdentity	"Elements of a Set's hashed array need to be reordered according to new oops."	| length perm |	self new: obj class: obj class length: (length _ self sizeInWordsOf: obj)		trace:	[1 to: length do: [:i | self trace: (obj basicAt: i)].				"Now get permutation based on new oops"				perm _ self permutationFor: obj useIdentity: useIdentity]		write:	[1 to: length do:					[:i | self writePointerField: ((perm at: i) == nil										ifTrue: [nil]										ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/27/97 20:44'!writeIdentitySet: obj 	"Elements of a Set need to be reordered owing to new oops."	^ self writeSet: obj useIdentity: true! !!SystemTracer methodsFor: 'tracing and writing'!writeMethod: obj	| nptrs |	nptrs _ obj numLiterals + 1.	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: [2 to: nptrs do: [:i | self trace: (obj objectAt: i)]]		write: 			[self writePointerField: (self methodHeader: obj).			2 to: nptrs do: [:i | self writePointerField: (obj objectAt: i)].			nptrs * 4 + 1 to: obj size do: [:i | file nextPut: (obj at: i)].			file padToNextLongPut: 0]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:22'!writeMethodDictionary: obj	"Elements of a Set need to be reordered according to new oops."	| perm |	self new: obj class: obj class length: (self sizeInWordsOf: obj)		trace:	["First need to map the indexable fields (selectors)"				1 to: obj basicSize do: [:i | self trace: (obj basicAt: i)].				"Now get permutation based on new oops"				perm _ self permutationFor: obj useIdentity: true.				"Map named inst vars *assuming* 2nd is the hash array"				1 to: obj class instSize do:					[:i | i=2 ifTrue: ["Permute the hash array and note its permutation"									self writeHashArray: (obj instVarAt: i) permutedBy: perm]							ifFalse: ["Other fields get traced normally"									self trace: (obj instVarAt: i)]]]		write:	[1 to: obj class instSize do:					[:i | self writePointerField: (obj instVarAt: i)].				1 to: obj basicSize do:					[:i | self writePointerField: ((perm at: i) == nil											ifTrue: [nil]											ifFalse: [obj basicAt: (perm at: i)])]]! !!SystemTracer methodsFor: 'tracing and writing'!writePointers: obj	| length |	self new: obj		class: obj class		length: (length _ self sizeInWordsOf: obj)		trace: [1 to: length do: [:i | self trace: (obj instVarAt: i)]]		write: [1 to: length do: [:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeProcess: obj 	"Substitute new initialProcess for current."	| newObj instSize |	newObj _ obj == Processor activeProcess			ifTrue: [initialProcess]			ifFalse: [obj].	self new: obj		class: newObj class		length: (instSize _ newObj class instSize)		trace: [1 to: instSize do:				[:i | self trace: (newObj instVarAt: i)]]		write: [1 to: instSize do:				[:i | self writePointerField: (newObj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/27/97 20:43'!writeSet: obj 	"Elements of a Set need to be reordered owing to new oops."	^ self writeSet: obj useIdentity: false! !!SystemTracer methodsFor: 'tracing and writing' stamp: 'di 9/28/97 00:01'!writeSet: obj useIdentity: useIdentity	"Elements of a Set need to be reordered according to new oops."	| |	self basicSize > 0 ifTrue: [self halt. "Not clear how to permute this kind of set"].	self new: obj class: obj class length: (self sizeInWordsOf: obj)		trace: 			["Map named inst vars *assuming* 2nd is the hash array"			1 to: obj class instSize do:				[:i | i=2 ifTrue: ["Permute the hash array and note its permutation"								self writeHashArrayPermuted: (obj instVarAt: i)											useIdentity: useIdentity]						ifFalse: ["Other fields get traced normally"								self trace: (obj instVarAt: i)]]]		write: 			[1 to: obj class instSize do:				[:i | self writePointerField: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'tracing and writing'!writeWords: obj	self new: obj		class: obj class		length: (self sizeInWordsOf: obj)		trace: []		write: [1 to: obj basicSize do: [:i | self write4Bytes: (obj instVarAt: i)]]! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:46'!formatOf: obj	"Make the code that tells the format of this object.	It is like the class's instSpec, but with added low bits for byte size""       0=      No pointer fields        1=      Fixed pointer fields only        2=      Var pointer fields only        3=      Fixed and var pointer fields         4=      unused        5=      unused        6=      var long (bit) fields only        7=      unused         8-11=   var byte fields only                low 2 bits are low 2 bits of size **        12-15   methods -- ie #literals in header, followed by var bytes                same interpretation of low 2 bits"	| class spec |	class _ obj class.	spec _ class instSpec.    "just use what's there"	spec < 8 ifTrue: [^ spec]			ifFalse: ["For byte objects, size = wordSize - spec.lowBits"					^ spec + (3 - (obj size+3 bitAnd: 3))]! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:46'!formatOfCls: class	"Return the full word value that encodes instSize, bits, bytes, and variable."	"See the comment in Behavior format:variable:words:pointers:"	^ class format    "just use what's there"! !!SystemTracer methodsFor: 'private' stamp: 'di 9/29/97 08:48'!headersFor: obj withHash: hash	"Create three header words for this object.  Length, class, header bits."	"Three possibilities:		Length, class, header bits		0, class, header bits		0,0, header bits"	| header3 header2 header1 cix sizeFld |	"3 gc bits"	header1 _ 0.  "Mark, old, dirty"	header1 _ header1 bitShift: 12.	"next fld is 12 bits"	header1 _ header1 + (hash bitAnd: 16rFFF).	header1 _ header1 bitShift: 5.	sizeFld _ (self sizeInWordsOf: obj) + 1.	"size in long words, incl hdr0"	cix _ compactClasses indexOf: obj class.	"0 means need full word"	header2 _ self mapAt: obj class.	header1 _ header1 + (cix bitAnd: 16r1F).	header1 _ header1 bitShift: 4.	header1 _ header1 + (self formatOf: obj).	"Class characteristics"	header1 _ header1 bitShift: 6.	sizeFld > 16r3F		ifTrue: [header3 _ sizeFld bitShift: 2.				sizeFld _ 0]		ifFalse: [header3 _ 0].	header1 _ header1 + sizeFld.	header1 _ header1 bitShift: 2.	header3 > 0 ifTrue:		["3-word: type=0"		^ Array with: header3+0 with: header2+0 with: header1+0].	cix = 0 ifTrue:		[ "2-word: type=1"		^ Array with: header2+1 with: header1+1].	"1-word: type=3"	^ Array with: header1+3! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:45'!methodHeader: obj	"Return the integer encoding the attributes of this method"	"See the comment in CompiledMethod newBytes:nArgs:nTemps:nStack:nLits:primitive:"	^ obj header  "just use what's there"! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 14:47'!newHashFor: obj	"If an object has a hash derived from its value, it will override on the way here.	This object can use anything as a hash.  Derive one from its oop."	(self mapAt: obj) = UnassignedOop		ifTrue: [self halt]		ifFalse: [^ self mapHashAt: obj]  ! !!SystemTracer methodsFor: 'private' stamp: 'di 9/27/97 20:40'!permutationFor: array useIdentity: useIdentity	"Return an inverse permutation for an array to permute it according to	the mapped oop values. The keys in array MUST have been mapped."	| len perm key hash |	len _ array basicSize.  	perm _ Array new: len.	1 to: len do:		[:i | key _ array basicAt: i.		(key == nil or: [self hasClamped: key])		  ifFalse:			[hash _ useIdentity					ifTrue: [key identityHashMappedBy: self]					ifFalse: [key hashMappedBy: self].			hash _ hash \\ len + 1.			[(perm at: hash) == nil] 				whileFalse:				[hash _ (hash = len ifTrue: [1] ifFalse: [hash + 1])].			perm at: hash put: i]].	^ perm! !!SystemTracer methodsFor: 'private'!sizeInWordsOf: anObject"NOTE: This is the new length of the object in LONG WORDS.		Does not include the class (header) word."	| class |	class _ anObject class.	class isBytes ifTrue: [^ anObject basicSize+3 // 4].	class isBits ifTrue: [^ anObject basicSize].	"in two byte chunks"	class isVariable ifTrue: [^ class instSize + anObject basicSize].	^ class instSize! !!SystemTracer methodsFor: 'private' stamp: 'di 4/22/1998 14:56'!write4Bytes: bits 	"Avoid overhead of large integers and nextWord:put:."	| posBits bytes |	bits >= 0		ifTrue: [posBits _ bits]		ifFalse: ["Change rep to twos complement."				posBits _ 16rFFFFFFFF+(bits+1)].	bytes _ ByteArray new: 4.	bytes at: 1 put: (posBits digitAt: 4).	bytes at: 2 put: (posBits digitAt: 3).	bytes at: 3 put: (posBits digitAt: 2).	bytes at: 4 put: (posBits digitAt: 1).	file nextPutAll: bytes! !!SystemTracer methodsFor: 'private' stamp: 'di 9/28/97 12:03'!writePointerField: obj 	| newOop |	obj class == SmallInteger ifTrue: 		[obj >= 0 ifTrue: [newOop _ obj * 2 + 1]				ifFalse: [newOop _ (16r80000000 + obj) * 2 + 1].		self write4Bytes: newOop.		^ obj].			"normal pointers"	(newOop _ self mapAt: obj) = Clamped		ifTrue: ["If object in this field is not being traced, put out nil."				self write4Bytes: NewNil]		ifFalse: [self write4Bytes: newOop]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemTracer class	instanceVariableNames: ''!!SystemTracer class methodsFor: 'instance creation' stamp: 'di 9/27/97 14:01'!initialize    "SystemTracer initialize"	"These consts are negative, so they will not match any oop.	It is important, though, that UnassignedOop, at least, have	zero in its low-order 2 bits, (like all oops) so that the use of +	to merge the header type bits (happens in new:class:...) will	not do weird things."	Clamped _ -4.  "Flag clamped objects in oopMap"		UnassignedOop _ -8.  "Flag unassigned oops in oopMap"! !!SystemTracer class methodsFor: 'instance creation' stamp: 'di 9/27/97 12:30'!writeClone  "SystemTracer writeClone"	| tracer |	tracer _ self new.	"Delay shutDown."  "part of Smalltalk processShutDownList."	tracer doit.   " <-- execution in clone resumes after this send"	tracer == nil "will be nil in clone, since it is clamped"		ifTrue: [Smalltalk processStartUpList].	^ tracer! !MorphicModel subclass: #SystemWindow	instanceVariableNames: 'labelString stripes label closeBox collapseBox activeOnlyOnTop paneMorphs paneRects collapsedFrame fullFrame isCollapsed '	classVariableNames: 'TopWindow '	poolDictionaries: ''	category: 'Morphic-Windows'!!SystemWindow commentStamp: 'di 5/22/1998 16:38' prior: 0!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!SystemWindow methodsFor: 'initialization' stamp: 'di 5/19/1998 15:54'!initialize	| aFont |	super initialize.	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences fontForScriptorButtons.	stripes _ Array with: (RectangleMorph newBounds: bounds)  "see extent:"				with: (RectangleMorph newBounds: bounds).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: ((TextStyle default fontAt: 2) emphasized: 1)).	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: aFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 16@16).	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 16@16).	self extent: 300@200! !!SystemWindow methodsFor: 'initialization' stamp: 'di 5/18/1998 15:50'!updateIfOld  "SystemWindow allInstancesDo: [:w | w updateIfOld]"	| panelRect |	stripes ifNil:		[stripes _ Array with: (RectangleMorph newBounds: bounds)				with: (RectangleMorph newBounds: bounds).		submorphs _ submorphs , stripes reversed].	paneMorphs _ submorphs copyFrom: 1 to: submorphs size-5.	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | (m bounds translateBy: panelRect topLeft negated)				scaleBy: (1.0/panelRect width)@(1.0/panelRect height)].	collapseBox actionSelector: #collapseOrExpand.	fullFrame _ self bounds.	isCollapsed _ false.	self extent: self extent.  "Cause layout of stripes etc."! !!SystemWindow methodsFor: 'geometry' stamp: 'di 5/18/1998 13:43'!extent: newExtent	| inner panelRect labelRect paneColor |	self removeHandles.	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ inner withHeight: self labelHeight.	panelRect _ self panelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	paneMorphs with: paneRects do:		[:m :frame |  m color: paneColor.		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated].	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].	self isActive ifTrue: [self addHandles]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 5/16/1998 16:26'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [self position: ((self position max: 0@0) grid: 8@8).				collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 5/22/1998 13:24'!position: newPos	super position: newPos.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].! !!SystemWindow methodsFor: 'label' stamp: 'di 5/4/1998 23:42'!label	^ labelString! !!SystemWindow methodsFor: 'label' stamp: 'di 4/8/98 14:52'!labelHeight	^ label height + 1 max: closeBox height! !!SystemWindow methodsFor: 'label' stamp: 'sw 4/23/1998 18:03'!setLabel: aString	labelString _ aString.	label ifNotNil: [label contents: aString]! !!SystemWindow methodsFor: 'label' stamp: 'di 5/18/1998 09:33'!setStripeColorsFrom: paneColor	self isActive		ifTrue: [stripes second color: paneColor;					borderColor: stripes second color darker.				stripes first color: stripes second borderColor darker;					borderColor: stripes first color darker]		ifFalse: ["This could be much faster"				stripes second color: paneColor; borderColor: paneColor.				stripes first color: paneColor; borderColor: paneColor].! !!SystemWindow methodsFor: 'label' stamp: 'di 5/17/1998 14:05'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self setLabel: model labelString].! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/20/1998 21:35'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model breakDependents.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/20/1998 09:14'!initialExtent	^ model initialExtent! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/20/1998 09:14'!openInMVC	^ self openInMVCExtent: self initialExtent! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/13/1998 21:28'!openInMVCExtent: extent	Smalltalk isMorphic ifTrue: [^ self openInWorldExtent: extent].	self bounds: (16@0 extent: extent).  "Room on left for scroll bars"	MorphWorldView openWorldWith: self labelled: labelString! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/20/1998 09:28'!openInWorld	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVC].	self bounds: (RealEstateAgent initialFrameFor: self).	World addMorph: self.	self activate! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/20/1998 09:28'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self position: (RealEstateAgent initialFrameFor: self) topLeft; extent: extent.	World addMorph: self.	self activate! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/18/1998 15:33'!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color gray; extent: (i<=6 ifTrue: [2@20] ifFalse: [20@2]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorph: handle].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/20/1998 08:52'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		paneMorphs reverseDo: [:m | self addMorph: m].		super bounds: fullFrame.		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		paneMorphs do: [:m | m delete; releaseCachedState].		collapsedFrame			ifNil:	[self extent: (label width + 50) @ (self labelHeight + 2).					self position: (RealEstateAgent assignCollapsePointFor: self)]			ifNotNil: [super bounds: collapsedFrame]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/20/1998 08:25'!collapsedFrame	^ collapsedFrame! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/21/1998 23:23'!enterHandle: event morph: handle pointName: ptName	"The mouse has entered reframing mark.  Start a reframe operation."	| resizer b |	event anyButtonPressed		ifTrue: [^ self  "Don't activate resizer if button down"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	resizer _ NewHandleMorph new followHand: event hand		forEachPointDo:			[:p | b _ self bounds.			ptName = #topCenter ifTrue: [self bounds: (b withTop: p y)].			ptName = #bottomCenter ifTrue: [self bounds: (b withBottom: p y)].			ptName = #leftCenter ifTrue: [self bounds: (b withLeft: p x)].			ptName = #rightCenter ifTrue: [self bounds: (b withRight: p x)].			ptName = #topLeft ifTrue: [self bounds: (b bottomRight rect: p)].			ptName = #bottomRight ifTrue: [self bounds: (b topLeft rect: p)].			ptName = #bottomLeft ifTrue: [self bounds: (b topRight rect: p)].			ptName = #topRight ifTrue: [self bounds: (b bottomLeft rect: p)]]		lastPointDo: [:lastPoint | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/20/1998 08:25'!fullFrame	^ fullFrame! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/19/1998 09:34'!isCollapsed	^ isCollapsed! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/18/1998 15:54'!mouseLeaveEvent: event fromPane: pane	"For backward compatibility only.  Not used by any newly created window"	(pane isKindOf: ScrollPane) ifTrue: [pane mouseLeave].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 5/18/1998 15:19'!removeHandles	(self submorphs select: [:m | m isMemberOf: Morph])		do: [:m | m delete]! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/19/1998 15:54'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	owner firstSubmorph == self ifFalse: [owner addMorphFront: self].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self addHandles! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 11:49'!activeOnlyOnTop	^ activeOnlyOnTop ifNil: [false]! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 12:38'!activeOnlyOnTop: trueOrFalse	activeOnlyOnTop _ trueOrFalse! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 11:50'!handlesMouseDown: evt	"If I am not the topWindow, then my mouseDown action dominates"	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 11:55'!isActive	self activeOnlyOnTop ifTrue: [^ self == TopWindow].	^ true! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 09:23'!mouseDown: evt	self activate! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/18/1998 12:31'!passivate	"Make me unable to respond to mouse and keyboard"	self submorphsDo: [:m | m lock].	self setStripeColorsFrom: self paneColor.	self removeHandles! !!SystemWindow methodsFor: 'panes' stamp: 'di 5/18/1998 15:43'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	aMorph borderWidth: 1;		color: (Color perform: model defaultBackgroundColor);		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'di 5/18/1998 09:40'!paneColor	^ Color perform: model defaultBackgroundColor! !!SystemWindow methodsFor: 'panes' stamp: 'di 5/15/1998 13:32'!panelRect	"Return the area below title bar, devoted to panes"	^self innerBounds topLeft + (0@(self labelHeight))					corner: self innerBounds bottomRight! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 5/11/1998 16:58'!step	model ifNotNil: [model step]! !!SystemWindow methodsFor: 'stepping' stamp: 'di 4/17/1998 09:18'!stepTime	^ 200 "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'di 5/8/1998 20:59'!wantsSteps	"Return true if the model responds to step (except if it is a debugger)."	| c |	c _ model class.	[c == nil] whileFalse:		[(c includesSelector: #step) ifTrue: [^ c ~= Debugger].		c _ c superclass].	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SystemWindow class	instanceVariableNames: ''!!SystemWindow class methodsFor: 'instance creation' stamp: 'di 2/3/98 11:54'!includeInNewMorphMenu	"Include my subclasses but not me"	^ self ~~ SystemWindow! !!SystemWindow class methodsFor: 'instance creation' stamp: 'di 6/18/97 05:31'!labelled: labelString	^ (self basicNew setLabel: labelString) initialize! !!SystemWindow class methodsFor: 'top window' stamp: 'jm 5/22/1998 13:26'!noteTopWindowIn: aWorld	"TopWindow must be nil or point to the top window in this project."	TopWindow _ nil.	aWorld ifNil: [^ self].	aWorld submorphsDo:		[:m | ((m isKindOf: SystemWindow) and: [m activeOnlyOnTop])			ifTrue: [^ m activate]]! !!SystemWindow class methodsFor: 'top window' stamp: 'di 5/19/1998 09:09'!windowsIn: aWorld satisfying: windowBlock	^ aWorld submorphs select:		[:m | (m isKindOf: SystemWindow) and: [windowBlock value: m]]! !TParseNode subclass: #TAssignmentNode	instanceVariableNames: 'variable expression '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TAssignmentNode methodsFor: 'all'!bindVariablesIn: aDictionary	variable _ variable bindVariablesIn: aDictionary.	expression _ expression bindVariablesIn: aDictionary.! !!TAssignmentNode methodsFor: 'all'!copyTree	^self class new		setVariable: variable copyTree		expression: expression copyTree! !!TAssignmentNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	| sel |	self isVariableUpdatingAssignment ifTrue: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		sel _ expression selector.		sel = #+			ifTrue: [aStream nextPutAll: ' += ']			ifFalse: [aStream nextPutAll: ' -= '].			expression args first emitCCodeOn: aStream level: level generator: aCodeGen.	] ifFalse: [		variable emitCCodeOn: aStream level: level generator: aCodeGen.		aStream nextPutAll: ' = '.		expression emitCCodeOn: aStream level: level generator: aCodeGen.	].! !!TAssignmentNode methodsFor: 'all'!expression	^expression! !!TAssignmentNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	variable inlineMethodsUsing: aDictionary.	expression inlineMethodsUsing: aDictionary.! !!TAssignmentNode methodsFor: 'all'!isAssignment	^true! !!TAssignmentNode methodsFor: 'all'!isVariableUpdatingAssignment	"Return true if this assignment statement is of one of the forms:		var = var + ...		var = var - ...	Such assignments statements can exploit the C updating assignment operators. For example, 'x += 4' can be generated instead of 'x = x + 4'. This produces better code under some C compilers, most notably the CodeWarrior 68K compiler."	| sel |	(expression isSend and: [expression receiver isVariable]) ifFalse: [^ false].	sel _ expression selector.	^ (expression receiver name = variable name) and: [(sel = #+) or: [sel = #-]]! !!TAssignmentNode methodsFor: 'all'!nodesDo: aBlock	variable nodesDo: aBlock.	expression nodesDo: aBlock.	aBlock value: self.! !!TAssignmentNode methodsFor: 'all'!printOn: aStream level: level	variable printOn: aStream level: level.	aStream nextPutAll: ' _ '.	expression printOn: aStream level: level + 2.! !!TAssignmentNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions! !!TAssignmentNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		variable _ variable replaceNodesIn: aDictionary.		expression _ expression replaceNodesIn: aDictionary.		self]! !!TAssignmentNode methodsFor: 'all'!setVariable: varNode expression: expressionNode	variable _ varNode.	expression _ expressionNode.! !!TAssignmentNode methodsFor: 'all'!variable	^variable! !TParseNode subclass: #TCaseStmtNode	instanceVariableNames: 'expression firsts lasts cases '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TCaseStmtNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.	cases _ cases collect: [ :c | c bindVariablesIn: aDictionary ].! !!TCaseStmtNode methodsFor: 'all'!cases	^cases! !!TCaseStmtNode methodsFor: 'all'!copyTree	^self class new		setExpression: expression copyTree		firsts: firsts copy		lasts: lasts copy		cases: (cases collect: [ :case | case copyTree ])! !!TCaseStmtNode methodsFor: 'all'!customizeCase: caseParseTree forVar: varName from: firstIndex to: lastIndex	"Return a collection of copies of the given parse tree, each of which has the value of the case index substituted for the given variable."	| newCases dict newCase |	newCases _ OrderedCollection new.	firstIndex to: lastIndex do: [ :caseIndex |		dict _ Dictionary new.		dict at: varName put: (TConstantNode new setValue: caseIndex).		newCase _ caseParseTree copyTree bindVariablesIn: dict.		self fixSharedCodeBlocksForCase: caseIndex in: newCase.		newCases addLast: newCase.	].	^ newCases! !!TCaseStmtNode methodsFor: 'all'!customizeShortCasesForDispatchVar: varName	"Make customized versions of a short bytecode methods, substituting a constant having the case index value for the given variable. This produces better code for short bytecodes such as instance variable pushes that encode the index of the instance variable in the bytecode."	| newFirsts newLasts newCases l f case expanded |	newFirsts _ OrderedCollection new.	newLasts _ OrderedCollection new.	newCases _ OrderedCollection new.	1 to: cases size do: [ :i |		l _ lasts at: i.		f _ firsts at: i.		case _ cases at: i.		expanded _ false.		(l - f) > 1 ifTrue: [  "case code covers multiple cases"			case nodeCount < 45 ifTrue: [				newFirsts addAll: (f to: l) asArray.				newLasts addAll: (f to: l) asArray.				newCases addAll: (self customizeCase: case forVar: varName from: f to: l).				expanded _ true.			].		].		expanded ifFalse: [			self fixSharedCodeBlocksForCase: f in: case.			newFirsts addLast: f.			newLasts addLast: l.			newCases addLast: case.		].	].	firsts _ newFirsts asArray.	lasts _ newLasts asArray.	cases _ newCases asArray.! !!TCaseStmtNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	| indent |	indent _ (String new: level) collect: [ :ch | Character tab ].	aStream nextPutAll: 'switch ('.	expression emitCCodeOn: aStream level: level generator: aCodeGen.	aStream nextPutAll: ') {'; cr.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream nextPutAll: indent, 'case ', caseIndex printString, ':'; cr.		].		(cases at: i) emitCCodeOn: aStream level: level + 1 generator: aCodeGen.		aStream nextPutAll: indent; tab; nextPutAll: 'break;'.		aStream cr.	].	level timesRepeat: [ aStream tab ].	aStream nextPutAll: '}'.! !!TCaseStmtNode methodsFor: 'all'!expression	^expression! !!TCaseStmtNode methodsFor: 'all' stamp: 'ikp 1/2/98 23:45'!fixSharedCodeBlocksForCase: caseIndex in: caseParseTree	"Process 'sharedCode' directives in the given parse tree. The sharedCode directive allows code replicated in different arms of a case statement to be shared. The replicated code must be the final code of the case so that it ends with a break out of the case statement. The replicated code will be generated in exactly one arm of the case statement; other instances of the shared code will be replaced by branches to that single instance of the code."	| copying oldStmts newStmts stmt codeBlockName |	caseParseTree  nodesDo: [ :node |		node isStmtList ifTrue: [			copying _ true.			oldStmts _ node statements asArray.			newStmts _ nil.  "becomes an OrderedCollection if sharedCode block is found"			1 to: oldStmts size do: [ :i |				copying ifTrue: [					stmt _ oldStmts at: i.					(stmt isSend and: [stmt selector = #sharedCodeNamed:inCase:]) ifTrue: [						newStmts _ (oldStmts copyFrom: 1 to: i - 1) asOrderedCollection.						codeBlockName _ stmt args first value.						(stmt args last value = caseIndex) ifTrue: [							newStmts add: 								(TLabeledCommentNode new setLabel: codeBlockName comment: '').						] ifFalse: [							newStmts add: (TGoToNode new setLabel: codeBlockName).							copying _ false.  "don't copy remaining statements"						].					] ifFalse: [						newStmts = nil ifFalse: [newStmts add: stmt].					].				] ifFalse: [	"ikp: this permits explicit returns before 'goto aSharedCodeLabel'"					stmt _ oldStmts at: i.					(stmt isLabel and: [stmt label ~= nil]) ifTrue: [newStmts add: stmt].				].			].			newStmts = nil ifFalse: [node setStatements: newStmts].		].	].! !!TCaseStmtNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	expression inlineMethodsUsing: aDictionary.	cases do: [ :c | c inlineMethodsUsing: aDictionary ].! !!TCaseStmtNode methodsFor: 'all'!isCaseStmt	^true! !!TCaseStmtNode methodsFor: 'all'!nodesDo: aBlock	expression nodesDo: aBlock.	cases do: [ :c | c nodesDo: aBlock ].	aBlock value: self.! !!TCaseStmtNode methodsFor: 'all'!printOn: aStream level: level	aStream crtab: level.	aStream nextPutAll: 'select '.	expression printOn: aStream level: level.	aStream nextPutAll: ' in'.	1 to: cases size do: [ :i |		(firsts at: i) to: (lasts at: i) do: [ :caseIndex |			aStream crtab: level.			aStream nextPutAll: 'case ', caseIndex printString, ':'.		].		aStream crtab: level + 1.		(cases at: i) printOn: aStream level: level + 1.	].	aStream crtab: level.	aStream nextPutAll: 'end select'.! !!TCaseStmtNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions.	cases do: [ :case | case removeAssertions ].! !!TCaseStmtNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		cases _ cases collect: [ :c | c replaceNodesIn: aDictionary ].		self]! !!TCaseStmtNode methodsFor: 'all'!setExpression: aNode firsts: firstsList lasts: lastsList cases: caseList	expression _ aNode.	firsts _ firstsList.	lasts _ lastsList.	cases _ caseList.! !!TCaseStmtNode methodsFor: 'all'!setExpression: aNode selectors: selectorList	"Initialize the node from the given set of selectors."	"Note: Each case is a statement list with containing one statement, a send to self of a selector from the given selector list. Having statement list nodes makes inlining easier later."	| selfNode stmt lastSel firstInRun sel |	expression _ aNode.	selfNode _ TVariableNode new setName: 'self'.	firsts _ OrderedCollection new: 400.	lasts _ OrderedCollection new: 400.	cases _ OrderedCollection new: 400.	lastSel _ selectorList first.	firstInRun _ 0.	1 to: selectorList size do: [ :i |		sel _ selectorList at: i.		sel ~= lastSel ifTrue: [			firsts add: firstInRun.			lasts add: i - 2.			stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().			cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).			lastSel _ sel.			firstInRun _ i - 1.		].	].	firsts add: firstInRun.	lasts add: selectorList size - 1.	stmt _ TSendNode new setSelector: lastSel receiver: selfNode arguments: #().	cases add: (TStmtListNode new setArguments: #() statements: (Array with: stmt)).! !TParseNode subclass: #TConstantNode	instanceVariableNames: 'value '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TConstantNode methodsFor: 'all'!copyTree	^self class new		setValue: value! !!TConstantNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C literal."	aStream nextPutAll: (aCodeGen cLiteralFor: value).! !!TConstantNode methodsFor: 'all'!isConstant	^true! !!TConstantNode methodsFor: 'all'!isLeaf	^true! !!TConstantNode methodsFor: 'all'!printOn: aStream level: level	value storeOn: aStream.! !!TConstantNode methodsFor: 'all'!setValue: anObject	value _ anObject.! !!TConstantNode methodsFor: 'all'!value	^value! !TParseNode subclass: #TGoToNode	instanceVariableNames: 'label '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TGoToNode methodsFor: 'all'!copyTree	^self class new setLabel: label! !!TGoToNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C goto statement."	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.! !!TGoToNode methodsFor: 'all'!isGoTo	^true! !!TGoToNode methodsFor: 'all'!label	^label! !!TGoToNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPutAll: 'goto '.	aStream nextPutAll: label.! !!TGoToNode methodsFor: 'all'!setLabel: aString	label _ aString.! !TParseNode subclass: #TLabeledCommentNode	instanceVariableNames: 'label comment '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TLabeledCommentNode methodsFor: 'all'!copyTree	^self class new		setLabel: label		comment: comment! !!TLabeledCommentNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"Emit a C comment with optional label."	self printOptionalLabelOn: aStream.	aStream nextPutAll: '/* '.	aStream nextPutAll: comment.	aStream nextPutAll: ' */'.! !!TLabeledCommentNode methodsFor: 'all'!isComment	"Answer true if the receiver is just a comment (i.e., it has no label)."	^label = nil! !!TLabeledCommentNode methodsFor: 'all'!isLabel	^true! !!TLabeledCommentNode methodsFor: 'all'!isLeaf	^true! !!TLabeledCommentNode methodsFor: 'all'!label	^label! !!TLabeledCommentNode methodsFor: 'all'!printOn: aStream level: level	self printOptionalLabelOn: aStream.	aStream nextPut: $".	aStream nextPutAll: comment.	aStream nextPut: $".! !!TLabeledCommentNode methodsFor: 'all'!printOptionalLabelOn: aStream	label ~= nil ifTrue: [		self unindentOneTab: aStream.		aStream nextPutAll: label.		aStream nextPut: $:.		aStream tab.		].! !!TLabeledCommentNode methodsFor: 'all'!setComment: commentString	label _ nil.	comment _ commentString.! !!TLabeledCommentNode methodsFor: 'all'!setLabel: labelString	label _ labelString.! !!TLabeledCommentNode methodsFor: 'all'!setLabel: labelString comment: commentString	label _ labelString.	comment _ commentString.! !!TLabeledCommentNode methodsFor: 'all'!unindentOneTab: aStream	"Remove the last tab from the given stream if possible."	(aStream isKindOf: ReadWriteStream) ifFalse: [ ^self ].	aStream position > 0 ifTrue: [		aStream position: aStream position - 1.		"restore stream position if previous char was not a tab"		aStream peek = Character tab ifFalse: [ aStream next ].	].! !Object subclass: #TMethod	instanceVariableNames: 'selector returnType args locals declarations primitive parseTree labels possibleSideEffectsCache complete '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TMethod methodsFor: 'initialization' stamp: 'jm 2/12/98 11:54'!setSelector: sel args: argList locals: localList block: aBlockNode primitive: aNumber	"Initialize this method using the given information."	selector _ sel.	returnType _ 'int'. 	 "assume return type is int for now"	args _ argList asOrderedCollection collect: [:arg | arg key].	locals _ localList asOrderedCollection collect: [:arg | arg key].	declarations _ Dictionary new.	primitive _ aNumber.	parseTree _ aBlockNode asTranslatorNode.	labels _ OrderedCollection new.	complete _ false.  "set to true when all possible inlining has been done"	self removeFinalSelfReturn.	self recordDeclarations.! !!TMethod methodsFor: 'initialization' stamp: 'jm 2/12/98 11:55'!setSelector: sel returnType: retType args: argList locals: localList declarations: decls primitive: primNumber parseTree: aNode labels: labelList complete: completeFlag	"Initialize this method using the given information. Used for copying."	selector _ sel.	returnType _ retType.	args _ argList.	locals _ localList.	declarations _ decls.	primitive _ primNumber.	parseTree _ aNode.	labels _ labelList.	complete _ completeFlag.! !!TMethod methodsFor: 'accessing'!args	"The arguments of this method."	^args! !!TMethod methodsFor: 'accessing'!declarations	"The type declaration dictionary of this method."	^declarations! !!TMethod methodsFor: 'accessing'!isComplete	"A method is 'complete' if it does not contain any more inline-able calls."	^complete! !!TMethod methodsFor: 'accessing'!labels	^labels! !!TMethod methodsFor: 'accessing'!locals	"The local variables of this method."	^locals! !!TMethod methodsFor: 'accessing'!parseTree	"The parse tree of this method."	^parseTree! !!TMethod methodsFor: 'accessing'!parseTree: aNode	"Set the parse tree of this method."	parseTree _ aNode.! !!TMethod methodsFor: 'accessing' stamp: 'jm 2/12/98 11:56'!primitive	"The primitive number of this method; zero if not a primitive."	^ primitive! !!TMethod methodsFor: 'accessing'!returnType	"The type of the values returned by this method. This string will be used in the C declaration of this function."	^returnType! !!TMethod methodsFor: 'accessing'!selector	"The Smalltalk selector of this method."	^selector! !!TMethod methodsFor: 'accessing'!selector: newSelector	selector _ newSelector.! !!TMethod methodsFor: 'accessing'!statements	parseTree isStmtList		ifFalse: [ self error: 'expected method parse tree to be a TStmtListNode' ].	((parseTree args = nil) or: [parseTree args isEmpty])		ifFalse: [ self error: 'expected method parse tree to have no args' ].	^parseTree statements! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/15/98 16:39'!argConversionExprFor: varName stackIndex: stackIndex	"Return the parse tree for an expression that fetches and converts the primitive argument at the given stack offset."	| exprList expr decl stmtList |	exprList _ OrderedCollection new.	expr _ '(self stackValue: ( ', stackIndex printString, '))'.	(declarations includesKey: varName) ifTrue: [  "array"		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [			exprList add: (varName, ' _ self arrayValueOf: ', expr).			exprList add: (varName, ' _ ', varName, ' - 1').		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add: (varName, ' _ self floatValueOf: ', expr).		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add: (varName, ' _ self checkedIntegerValueOf: ', expr).	].	stmtList _ OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!TMethod methodsFor: 'primitive compilation'!checkSuccessExpr	"Return the parse tree for an expression that aborts the primitive if the successFlag is not true."	| expr |	expr _ 'successFlag ifFalse: [^ nil ]'.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/15/98 16:48'!covertToZeroBasedArrayReferences	"Replace the index expressions in at: and at:put: messages with (<expr> - 1), since C uses zero-based array indexing."	"Note: Up through release 1.31, generated primitives used the convention that array variables pointed to the first element. That meant that Smalltalk one-based index expressions had to have one subtracted to yield a zero-based index. Later, we decided to adjust the base address by -1 once in the primitive prolog rather on every array access. This resulted in a five percent performance increase for the bitmap compress/decompress primitives. This method is retained as documentation and in case we choose to revert the the previous scheme."	| oldIndexExpr newIndexExpr |	parseTree nodesDo: [ :n |		(n isSend and: [(n selector = #at:) or: [ n selector = #at:put: ]]) ifTrue: [			oldIndexExpr _ n args first.			oldIndexExpr isConstant ifTrue: [				"index expression is a constant: decrement the constant now"				newIndexExpr _ TConstantNode new setValue: (n args first value - 1).			] ifFalse: [				"index expression is complex: build an expression to decrement result at runtime"				newIndexExpr _ TSendNode new					setSelector: #-					receiver: oldIndexExpr					arguments: (Array with: (TConstantNode new setValue: 1)).			].			n args at: 1 put: newIndexExpr.		].	].! !!TMethod methodsFor: 'primitive compilation' stamp: 'ikp 1/4/98 00:01'!fetchRcvrExpr	"Return the parse tree for an expression that fetches the receiver from the stack."	| expr |	expr _ 'rcvr _ self stackValue: (', args size printString, ')'.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/20/98 11:08'!fixUpReturns: argCount postlog: postlog	"Replace each return statement in this method with (a) the given postlog, (b) code to pop the receiver and the given number of arguments, and (c) code to push the integer result and return."	| newStmts |	parseTree nodesDo: [:node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [:stmt |				stmt isReturn					ifTrue: [						(stmt expression isSend and:						 ['primitiveFail' = stmt expression selector])							ifTrue: [  "failure return"								newStmts addLast: stmt expression.								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]							ifFalse: [  "normal return"								newStmts addAll: postlog.								newStmts addAll: (self popArgsExpr: argCount + 1).								newStmts addLast: (TSendNode new									setSelector: #pushInteger:									receiver: (TVariableNode new setName: 'self')									arguments: (Array with: stmt expression)).								newStmts addLast: (TReturnNode new									setExpression: (TVariableNode new setName: 'null'))]]					ifFalse: [						newStmts addLast: stmt]].			node setStatements: newStmts asArray]].! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/15/98 16:39'!instVarGetExprFor: varName offset: instIndex	"Return the parse tree for an expression that fetches and converts the value of the instance variable at the given offset."	| exprList decl stmtList |	exprList _ OrderedCollection new.	(declarations includesKey: varName) ifTrue: [		decl _ declarations at: varName.		(decl includes: $*) ifTrue: [  "array"			exprList add:				(varName, ' _ self fetchArray: ', instIndex printString, ' ofObject: rcvr').			exprList add: (varName, ' _ ', varName, ' - 1').		] ifFalse: [  "must be a double"			((decl findString: 'double' startingAt: 1) = 0)				ifTrue: [ self error: 'unsupported type declaration in a primitive method' ].			exprList add:				(varName, ' _ self fetchFloat: ', instIndex printString, ' ofObject: rcvr').		].	] ifFalse: [  "undeclared variables are taken to be integer"		exprList add:			(varName, ' _ self fetchInteger: ', instIndex printString, ' ofObject: rcvr').	].	stmtList _ OrderedCollection new.	exprList do: [:e | stmtList addAll: (self statementsFor: e varName: varName)].	^ stmtList! !!TMethod methodsFor: 'primitive compilation'!instVarPutExprFor: varName offset: instIndex	"Return the parse tree for an expression that saves the value of the integer instance variable at the given offset."	| expr |	(declarations includesKey: varName) ifTrue: [		self error: 'a primitive method can only modify integer instance variables'.	].	expr _ 'self storeInteger: ', instIndex printString, ' ofObject: rcvr withValue: ', varName.	^ self statementsFor: expr varName: varName! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/12/98 14:42'!popArgsExpr: argCount	"Return the parse tree for an expression that pops the given number of arguments from the stack."	| expr |	expr _ 'self pop: ', argCount printString.	^ self statementsFor: expr varName: ''! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/12/98 16:05'!preparePrimitiveInClass: aClass	"Add a prolog and postlog to a primitive method. The prolog copies any instance variables referenced by this primitive method into local variables. The postlog copies values of assigned-to variables back into the instance. The names of the new locals are added to the local variables list.The declarations dictionary defines the types of any non-integer variables (locals, arguments, or instance variables). In particular, it may specify the types:	int *		-- an array of 32-bit values (e.g., a BitMap)	short *		-- an array of 16-bit values (e.g., a SoundBuffer)	char *		-- an array of unsigned bytes (e.g., a String)	double		-- a double precision floating point number (e.g., 3.14159)Undeclared variables are taken to be integers and will be converted from Smalltalk to C ints.""Current restrictions:	o method must not contain message sends	o method must not allocate objects	o method must not manipulate raw oops	o method cannot access class variables	o method can only return an integer"	| prolog postlog instVarsUsed varsAssignedTo instVarList primArgCount varName endsWithReturn |	prolog _ OrderedCollection new.	postlog _ OrderedCollection new.	instVarsUsed _ self freeVariableReferences asSet.	varsAssignedTo _ self variablesAssignedTo asSet.	instVarList _ aClass allInstVarNames.	primArgCount _ args size.	"add receiver fetch and arg conversions to prolog"	prolog addAll: self fetchRcvrExpr.	1 to: args size do: [:argIndex |		varName _ args at: argIndex.		prolog addAll:			(self argConversionExprFor: varName stackIndex: args size - argIndex)].	"add success check to postlog"	postlog addAll: self checkSuccessExpr.	"add instance variable fetches to prolog and instance variable stores to postlog"	1 to: instVarList size do: [:varIndex |		varName _ instVarList at: varIndex.		(instVarsUsed includes: varName) ifTrue: [			locals add: varName.			prolog addAll: (self instVarGetExprFor: varName offset: varIndex - 1).			(varsAssignedTo includes: varName) ifTrue: [				postlog addAll: (self instVarPutExprFor: varName offset: varIndex - 1)]]].	prolog addAll: self checkSuccessExpr.	locals addAllFirst: args.	locals addFirst: 'rcvr'.	args _ args class new.	locals asSet size = locals size		ifFalse: [self error: 'local name conflicts with instance variable name'].	endsWithReturn _ self endsWithReturn.	self fixUpReturns: primArgCount postlog: postlog.	selector _ 'prim', aClass name, selector.	endsWithReturn		ifTrue: [parseTree setStatements: prolog, parseTree statements]		ifFalse: [			postlog addAll: (self popArgsExpr: primArgCount).			parseTree setStatements: prolog, parseTree statements, postlog].! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/12/98 15:30'!pushIntegerResultExpr: valueExpr	"Return an expression to push an integer valued result."	| conversionExpr |	conversionExpr _		TSendNode new			setSelector: #pushInteger:			receiver: #self			arguments: valueExpr.	^ TSendNode new		setSelector: #push:		receiver: #self		arguments: conversionExpr! !!TMethod methodsFor: 'primitive compilation' stamp: 'jm 2/15/98 17:06'!replaceSizeMessages	"Replace sends of the message 'size' with calls to sizeOfSTArrayFromCPrimitive."	| argExpr |	parseTree nodesDo: [:n |		(n isSend and: [n selector = #size]) ifTrue: [			argExpr _ TSendNode new				setSelector: #+				receiver: n receiver				arguments: (Array with: (TConstantNode new setValue: 1)).			n				setSelector: #sizeOfSTArrayFromCPrimitive:				receiver: (TVariableNode new setName: 'self')				arguments: (Array with: argExpr)]].! !!TMethod methodsFor: 'primitive compilation'!statementsFor: sourceText varName: varName	"Return the parse tree for the given expression. The result is the statements list of the method parsed from the given source text."	"Details: Various variables are declared as locals to avoid Undeclared warnings from the parser."	| s |	s _ WriteStream on: ''.	s nextPutAll: 'temp'; cr; cr; tab.	s nextPutAll: '| rcvr stackPointer successFlag ', varName,' |'; cr.	s nextPutAll: sourceText.	^ ((Compiler new parse: s contents in: Object notifying: nil)			asTMethodFromClass: Object) statements! !!TMethod methodsFor: 'transformations'!bindClassVariablesIn: constantDictionary	"Class variables are used as constants. This method replaces all references to class variables in the body of this method with the corresponding constant looked up in the class pool dictionary of the source class. The source class class variables should be initialized before this method is called."	parseTree _ parseTree bindVariablesIn: constantDictionary.! !!TMethod methodsFor: 'transformations'!buildCaseStmt: aSendNode	"Build a case statement node for the given send of dispatchOn:in:."	"Note: the first argument is the variable to be dispatched on. The second argument is a constant node holding an array of unary selectors, which will be turned into sends to self."	((aSendNode args size = 2) and:	 [aSendNode args last isConstant and:	 [aSendNode args last value class = Array]]) ifFalse: [		self error: 'wrong node structure for a case statement'.	].	^TCaseStmtNode new		setExpression: aSendNode args first		selectors: aSendNode args last value! !!TMethod methodsFor: 'transformations'!prepareMethodIn: aCodeGen	"Record sends of builtin operators and replace sends of the special selector dispatchOn:in: with case statement nodes."	"Note: Only replaces top-level sends of dispatchOn:in:. Case statements must be top-level statements; they cannot appear in expressions."	| stmts stmt |	parseTree nodesDo: [ :node |		node isSend ifTrue: [			"record sends of builtin operators"			(aCodeGen builtin: node selector) ifTrue: [ node isBuiltinOperator: true ].		].		node isStmtList ifTrue: [			"replace dispatchOn:in: with case statement node"			stmts _ node statements.			1 to: stmts size do: [ :i |				stmt _ stmts at: i.				(stmt isSend and: [stmt selector = #dispatchOn:in:]) ifTrue: [					stmts at: i put: (self buildCaseStmt: stmt).				].			].		].	].! !!TMethod methodsFor: 'transformations'!recordDeclarations	"Record C type declarations of the forms		self returnTypeC: 'float'.		self var: #foo declareC: 'float foo'	 and remove the declarations from the method body."	| newStatements isDeclaration |	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		isDeclaration _ false.		stmt isSend ifTrue: [			stmt selector = #var:declareC: ifTrue: [				isDeclaration _ true.				declarations at: stmt args first value asString put: stmt args last value.			].			stmt selector = #returnTypeC: ifTrue: [				isDeclaration _ true.				returnType _ stmt args last value.			].		].		isDeclaration ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.! !!TMethod methodsFor: 'transformations' stamp: 'ikp 9/26/97 14:50'!removeAssertions	parseTree removeAssertions! !!TMethod methodsFor: 'transformations'!removeFinalSelfReturn	"The Smalltalk parser automatically adds the statement '^self' to the end of methods without explicit returns. This method removes such statements, since the generated code has no notion of 'self' anyway."	| stmtList lastStmt |	stmtList _ parseTree statements asOrderedCollection.	lastStmt _ stmtList last.	((lastStmt isReturn) and:	 [(lastStmt expression isVariable) and:	 [lastStmt expression name = 'self']]) ifTrue: [		stmtList removeLast.		parseTree setStatements: stmtList.	].! !!TMethod methodsFor: 'utilities'!allCalls	"Answer a collection of selectors for the messages sent by this method."	^parseTree allCalls! !!TMethod methodsFor: 'utilities' stamp: 'jm 2/12/98 11:55'!copy	"Make a deep copy of this TMethod."	^ self class basicNew		setSelector: selector		returnType: returnType		args: args copy		locals: locals copy		declarations: declarations copy		primitive: primitive		parseTree: parseTree copyTree		labels: labels copy		complete: complete! !!TMethod methodsFor: 'utilities'!freeVariableReferences	"Answer a collection of variables referenced this method, excluding locals, arguments, and pseudovariables."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isVariable ifTrue: [ refs add: node name asString ].	].	args do: [ :var | refs remove: var asString ifAbsent: [] ].	locals do: [ :var | refs remove: var asString ifAbsent: [] ].	#('self' 'nil' 'true' 'false') do: [ :var | refs remove: var ifAbsent: [] ].	^ refs asSortedCollection! !!TMethod methodsFor: 'utilities'!hasNoCCode	"Answer true if the receiver does not use inlined C or C declarations, which are not currently renamed properly by the the inliner."	declarations isEmpty ifFalse: [ ^ false ].	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node selector = #cCode: ifTrue: [ ^ false ].		].	].	^ true! !!TMethod methodsFor: 'utilities'!nodeCount	"Answer the number of nodes in this method's parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	parseTree nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt! !!TMethod methodsFor: 'utilities'!variablesAssignedTo	"Answer a collection of variables assigned to by this method."	| refs |	refs _ Set new.	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [ refs add: node variable name ].	].	^ refs! !!TMethod methodsFor: 'inlining'!argAssignmentsFor: meth args: argList in: aCodeGen	"Return a collection of assignment nodes that assign the given argument expressions to the formal parameter variables of the given method."	"Optimization: If the actual parameters are either constants or local variables in the target method (the receiver), substitute them directly into the body of meth. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	| stmtList substitutionDict |	stmtList _ OrderedCollection new: 16.	substitutionDict _ Dictionary new.	meth args with: argList do: [ :argName :exprNode |		(self isSubstitutableNode: exprNode intoMethod: meth in: aCodeGen) ifTrue: [			substitutionDict at: argName asSymbol put: exprNode.			locals remove: argName.		] ifFalse: [			stmtList add: (TAssignmentNode new				setVariable: (TVariableNode new setName: argName)				expression: exprNode copyTree).		].	].	meth parseTree: (meth parseTree bindVariablesIn: substitutionDict).	^stmtList! !!TMethod methodsFor: 'inlining'!checkForCompleteness: stmtLists in: aCodeGen	"Set the complete flag if none of the given statement list nodes contains further candidates for inlining."	complete _ true.	stmtLists do: [ :stmtList |		stmtList statements do: [ :node |			(self inlineableSend: node in: aCodeGen) ifTrue: [				complete _ false.  "more inlining to do"				^self			].		].	].	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			complete _ false.  "more inlining to do"			^self		].	].! !!TMethod methodsFor: 'inlining'!exitVar: exitVar label: exitLabel	"Replace each return statement in this method with an assignment to the exit variable followed by a goto to the given label. Return true if a goto was generated."	"Optimization: If exitVar is nil, the return value of the inlined method is not being used, so don't add the assignment statement."	| newStmts labelUsed |	labelUsed _ false.	parseTree nodesDo: [ :node |		node isStmtList ifTrue: [			newStmts _ OrderedCollection new: 100.			node statements do: [ :stmt |				(stmt isReturn) ifTrue: [					exitVar = nil ifTrue: [						stmt expression isLeaf ifFalse: [							"evaluate return expression even though value isn't used"							newStmts add: stmt expression.						].					] ifFalse: [						"assign return expression to exit variable"						newStmts add:							(TAssignmentNode new								setVariable: (TVariableNode new setName: exitVar)								expression: stmt expression).					].					(stmt == parseTree statements last) ifFalse: [						"generate a goto (this return is NOT the last statement in the method)"						newStmts add: (TGoToNode new setLabel: exitLabel).						labelUsed _ true.					].				] ifFalse: [					newStmts addLast: stmt.				].			].			node setStatements: newStmts asArray.		].	].	^labelUsed! !!TMethod methodsFor: 'inlining'!inlineableFunctionCall: aNode in: aCodeGen	"Answer true if the given send node is a call to a 'functional' method--a method whose body is a single return statement of some expression and whose actual parameters can all be directly substituted."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	((m ~= nil) and: [m isFunctional and: [aCodeGen mayInline: m selector]]) ifTrue: [		aNode args do: [ :a | (self isSubstitutableNode: a intoMethod: m in: aCodeGen) ifFalse: [ ^false ]].		^true	] ifFalse: [		^false	].! !!TMethod methodsFor: 'inlining'!inlineableSend: aNode in: aCodeGen	"Answer true if the given send node is a call to a method that can be inlined."	| m |	aNode isSend ifFalse: [ ^false ].	m _ aCodeGen methodNamed: aNode selector.  "nil if builtin or external function"	^(m ~= nil) and: [m isComplete and: [aCodeGen mayInline: m selector]]! !!TMethod methodsFor: 'inlining'!inlineCaseStatementBranchesIn: aCodeGen localizingVars: varsList	| stmt sel meth newStatements maxTemp usedVars exitLabel v |	maxTemp _ 0.	parseTree nodesDo: [ :n |		n isCaseStmt ifTrue: [			n cases do: [ :stmtNode |				stmt _ stmtNode statements first.				stmt isSend ifTrue: [					sel _ stmt selector.					meth _ aCodeGen methodNamed: sel.					((meth ~= nil) and:					 [meth hasNoCCode and:					 [meth args size = 0]]) ifTrue: [						meth _ meth copy.						maxTemp _ maxTemp max: (meth renameVarsForCaseStmt).						meth hasReturn ifTrue: [							exitLabel _ self unusedLabelForInliningInto: self.							meth exitVar: nil label: exitLabel.							labels add: exitLabel.						] ifFalse: [ exitLabel _ nil ].						meth renameLabelsForInliningInto: self.						meth labels do: [ :label | labels add: label ].						newStatements _ stmtNode statements asOrderedCollection.						newStatements removeFirst.						exitLabel ~= nil ifTrue: [							newStatements addFirst:								(TLabeledCommentNode new									setLabel: exitLabel comment: 'end case').						].						newStatements addAllFirst: meth statements.						newStatements addFirst:							(TLabeledCommentNode new setComment: meth selector).						stmtNode setStatements: newStatements.					].				].			].		].	].	usedVars _ (locals, args) asSet.	1 to: maxTemp do: [ :i |		v _ ('t', i printString).		(usedVars includes: v) ifTrue: [ self error: 'temp variable name conflicts with an existing local or arg' ].		locals addLast: v.	].	"make local versions of the given globals"	varsList do: [ :var |		(usedVars includes: var) ifFalse: [ locals addFirst: var asString ].	].! !!TMethod methodsFor: 'inlining'!inlineCodeOrNilForStatement: aNode in: aCodeGen	"If the given statement node can be inlined, answer the statements that replace it. Otherwise, answer nil."	| stmts |	aNode isReturn ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			stmts _ self inlineSend: aNode expression				directReturn: true exitVar: nil in: aCodeGen.			^stmts		].	].	aNode isAssignment ifTrue: [		(self inlineableSend: aNode expression in: aCodeGen) ifTrue: [			^self inlineSend: aNode expression				directReturn: false exitVar: aNode variable name in: aCodeGen		].	].	aNode isSend ifTrue: [		(self inlineableSend: aNode in: aCodeGen) ifTrue: [			^self inlineSend: aNode				directReturn: false exitVar: nil in: aCodeGen		].	].	^nil! !!TMethod methodsFor: 'inlining'!inlineFunctionCall: aSendNode in: aCodeGen	"Answer the body of the called function, substituting the actual parameters for the formal argument variables in the method body."	"Assume caller has established that:		1. the method arguments are all substitutable nodes, and		2. the method to be inlined contains no additional embedded returns."	| sel meth substitutionDict |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	substitutionDict _ Dictionary new.	meth args with: aSendNode args do: [ :argName :exprNode |		substitutionDict at: argName asSymbol put: exprNode.		locals remove: argName.	].	meth parseTree bindVariablesIn: substitutionDict.	^meth statements first expression! !!TMethod methodsFor: 'inlining'!inlineSend: aSendNode directReturn: directReturn exitVar: exitVar in: aCodeGen	"Answer a collection of statments to replace the given send. directReturn indicates that the send is the expression of a return statement, so returns can be left in the body of the inlined method. If exitVar is nil, the value returned by the send is not used; thus, returns need not assign to the output variable."	| sel meth exitLabel labelUsed inlineStmts |	sel _ aSendNode selector.	meth _ (aCodeGen methodNamed: sel) copy.	meth renameVarsForInliningInto: self in: aCodeGen.	meth renameLabelsForInliningInto: self.	self addVarsDeclarationsAndLabelsOf: meth.	meth hasReturn ifTrue: [		directReturn ifTrue: [			"propagate the return type, if necessary"			returnType = meth returnType ifFalse: [ self halt ].  "caller's return type should be declared by user"			returnType _ meth returnType.		] ifFalse: [			exitLabel _ self unusedLabelForInliningInto: self.			labelUsed _ meth exitVar: exitVar label: exitLabel.			labelUsed				ifTrue: [ labels add: exitLabel ]				ifFalse: [ exitLabel _ nil ].		].		"propagate type info if necessary"		((exitVar ~= nil) and: [meth returnType ~= 'int']) ifTrue: [			declarations at: exitVar put: meth returnType, ' ', exitVar.		].	].	inlineStmts _ OrderedCollection new: 100.	inlineStmts add: (TLabeledCommentNode new setComment: 'begin ', sel).	inlineStmts addAll:		(self argAssignmentsFor: meth args: aSendNode args in: aCodeGen).	inlineStmts addAll: meth statements.  "method body"	(directReturn and: [meth endsWithReturn not]) ifTrue: [		inlineStmts add: (TReturnNode new setExpression: (TVariableNode new setName: 'nil')).	].	exitLabel ~= nil ifTrue: [		inlineStmts add:			(TLabeledCommentNode new				setLabel: exitLabel comment: 'end ', meth selector).	].	^inlineStmts! !!TMethod methodsFor: 'inlining'!isFunctional	"Answer true if the receiver is a functional method. That is, if it consists of a single return statement of an expression that contains no other returns."	(parseTree statements size = 1 and:	 [parseTree statements last isReturn]) ifFalse: [ ^false ].	parseTree statements last expression nodesDo: [ :n | n isReturn ifTrue: [ ^false ]].	^true! !!TMethod methodsFor: 'inlining'!isSubstitutableNode: aNode	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted because the inlined method might depend on the exact ordering of side effects to the globals."	aNode isConstant ifTrue: [ ^true ].	^aNode isVariable and:		[(locals includes: aNode name) or:		[args includes: aNode name]]! !!TMethod methodsFor: 'inlining'!isSubstitutableNode: aNode intoMethod: targetMeth in: aCodeGen	"Answer true if the given parameter node is either a constant, a local variable, or a formal parameter of the receiver. Such parameter nodes may be substituted directly into the body of the method during inlining. Note that global variables cannot be subsituted into methods with possible side effects (i.e., methods that may assign to global variables) because the inlined method might depend on having the value of the global variable captured when it is passed in as an argument."	| var |	aNode isConstant ifTrue: [ ^ true ].	aNode isVariable ifTrue: [		var _ aNode name.		((locals includes: var) or: [args includes: var]) ifTrue: [ ^ true ].		(#(self true false nil) includes: var) ifTrue: [ ^ true ].		(targetMeth maySubstituteGlobal: var in: aCodeGen) ifTrue: [ ^ true ].	].	"scan expression tree; must contain only constants, builtin ops, and inlineable vars"	aNode nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^false ].		].		node isVariable ifTrue: [			var _ node name.			((locals includes: var) or:			 [(args includes: var) or:			 [(#(self true false nil) includes: var) or:			 [targetMeth maySubstituteGlobal: var in: aCodeGen]]]) ifFalse: [ ^ false ].		].		(node isConstant or: [node isVariable or: [node isSend]]) ifFalse: [ ^false ].	].	^ true! !!TMethod methodsFor: 'inlining'!statementsListsForInlining	"Answer a collection of statement list nodes that are candidates for inlining. Currently, we cannot inline into the argument blocks of and: and or: messages."	| stmtLists |	stmtLists _ OrderedCollection new: 10.	parseTree nodesDo: [ :node | 		node isStmtList ifTrue: [ stmtLists add: node ].	].	parseTree nodesDo: [ :node | 		node isSend ifTrue: [			((node selector = #and:) or: [node selector = #or:]) ifTrue: [				"Note: the PP 2.3 compiler produces two arg nodes for these selectors"				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: node args last ifAbsent: [].			].			((node selector = #ifTrue:) or: [node selector = #ifFalse:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #ifTrue:ifFalse:) or: [node selector = #ifFalse:ifTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			((node selector = #whileFalse:) or: [node selector = #whileTrue:]) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].			].			(node selector = #to:do) ifTrue: [				stmtLists remove: node receiver ifAbsent: [].				stmtLists remove: node args first ifAbsent: [].				stmtLists remove: (node args at: 2) ifAbsent: [].			].		].		node isCaseStmt ifTrue: [			"don't inline cases"			node cases do: [: case | stmtLists remove: case ifAbsent: [] ].		].	].	^stmtLists! !!TMethod methodsFor: 'inlining'!tryToInlineMethodsIn: aCodeGen	"Expand any (complete) inline methods called by this method. Set the complete bit when all inlining has been done. Return true if something was inlined."	| stmtLists didSomething newStatements inlinedStmts sendsToInline |	didSomething _ false.	sendsToInline _ Dictionary new.	parseTree nodesDo: [ :n |		(self inlineableFunctionCall: n in: aCodeGen) ifTrue: [			sendsToInline at: n put: (self inlineFunctionCall: n in: aCodeGen).		].	].	sendsToInline isEmpty ifFalse: [		didSomething _ true.		parseTree _ parseTree replaceNodesIn: sendsToInline.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	stmtLists _ self statementsListsForInlining.	stmtLists do: [ :stmtList | 		newStatements _ OrderedCollection new: 100.		stmtList statements do: [ :stmt |			inlinedStmts _ self inlineCodeOrNilForStatement: stmt in: aCodeGen.			(inlinedStmts = nil) ifTrue: [				newStatements addLast: stmt.			] ifFalse: [				didSomething _ true.				newStatements addAllLast: inlinedStmts.			].		].		stmtList setStatements: newStatements asArray.	].	didSomething ifTrue: [		possibleSideEffectsCache _ nil.		^didSomething	].	complete ifFalse: [		self checkForCompleteness: stmtLists in: aCodeGen.		complete ifTrue: [ didSomething _ true ].  "marking a method complete is progress"	].	^didSomething! !!TMethod methodsFor: 'inlining'!unusedLabelForInliningInto: targetMethod	| usedLabels |	usedLabels _ labels asSet.	usedLabels addAll: targetMethod labels.	^self unusedNamePrefixedBy: 'l' avoiding: usedLabels! !!TMethod methodsFor: 'inlining support'!addVarsDeclarationsAndLabelsOf: methodToBeInlined	"Prepare to inline the body of the given method into the receiver by making the args and locals of the argument to the receiver be locals of the receiver. Record any type declarations for these variables. Record labels. Assumes that the variables have already be renamed to avoid name clashes."	methodToBeInlined args, methodToBeInlined locals do: [ :v |		(locals includes: v) ifFalse: [ locals addLast: v ].	].	methodToBeInlined declarations associationsDo: [ :assoc |		declarations add: assoc.	].	methodToBeInlined labels do: [ :label |		labels add: label.	].! !!TMethod methodsFor: 'inlining support'!computePossibleSideEffectsIn: aCodeGen	"Answer true if this method may have side effects. It has side effects if it assigns to a global variable. It may have side effects if it calls a non-built-in method."	parseTree nodesDo: [ :node |		node isSend ifTrue: [			node isBuiltinOperator ifFalse: [ ^true ].		].	].	^ false! !!TMethod methodsFor: 'inlining support'!endsWithReturn	"Answer true if the last statement of this method is a return."	^ parseTree statements last isReturn! !!TMethod methodsFor: 'inlining support'!extractInlineDirective	"Scan the top-level statements for an inlining directive of the form:		self inline: <boolean>	 and remove the directive from the method body. Return the argument of the directive or #dontCare if there is no inlining directive."	| result newStatements |	result _ #dontCare.	newStatements _ OrderedCollection new: parseTree statements size.	parseTree statements do: [ :stmt |		(stmt isSend and: [stmt selector = #inline:]) ifTrue: [			result _ stmt args first name = 'true'.		] ifFalse: [			newStatements add: stmt.		].	].	parseTree setStatements: newStatements asArray.	^ result! !!TMethod methodsFor: 'inlining support'!hasReturn	"Answer true if this method contains a return statement."	parseTree nodesDo: [ :n | n isReturn ifTrue: [ ^ true ]].	^ false! !!TMethod methodsFor: 'inlining support' stamp: 'ikp 9/26/97 14:50'!isAssertion	^(selector beginsWith: 'assert') or: [selector beginsWith: 'verify']! !!TMethod methodsFor: 'inlining support'!maySubstituteGlobal: globalVar in: aCodeGen	"Answer true if this method does or may have side effects on the given global variable."	possibleSideEffectsCache = nil ifTrue: [		"see if this calls any other method and record the result"		possibleSideEffectsCache _ self computePossibleSideEffectsIn: aCodeGen.	].	possibleSideEffectsCache ifTrue: [ ^ false ].	parseTree nodesDo: [ :node |		node isAssignment ifTrue: [			node variable name = globalVar ifTrue: [ ^ false ].		].	].	"if we get here, receiver calls no other method	 and does not itself assign to the given global variable"	^ true! !!TMethod methodsFor: 'inlining support'!renameLabelsForInliningInto: destMethod	"Rename any labels that would clash with those of the destination method."	| destLabels usedLabels labelMap newLabelName |	destLabels _ destMethod labels asSet.	usedLabels _ destLabels copy.  "usedLabels keeps track of labels in use"	usedLabels addAll: labels.	labelMap _ Dictionary new.	self labels do: [ :l |		(destLabels includes: l) ifTrue: [			newLabelName _ self unusedNamePrefixedBy: 'l' avoiding: usedLabels.			labelMap at: l put: newLabelName.		].	].	self renameLabelsUsing: labelMap.! !!TMethod methodsFor: 'inlining support'!renameLabelsUsing: aDictionary	"Rename all labels according to the old->new mappings of the given dictionary."	labels _ labels collect: [ :label |		(aDictionary includesKey: label) ifTrue: [ aDictionary at: label ] ifFalse: [ label ].	].	parseTree nodesDo: [ :node |		(node isGoTo and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].		(node isLabel and: [aDictionary includesKey: node label]) ifTrue: [			node setLabel: (aDictionary at: node label).		].	].! !!TMethod methodsFor: 'inlining support'!renameVariablesUsing: aDictionary	"Rename all variables according to old->new mappings of the given dictionary."	| newDecls |	"map args and locals"	args _ args collect: [ :arg |		(aDictionary includesKey: arg) ifTrue: [ aDictionary at: arg ] ifFalse: [ arg ].	].	locals _ locals collect: [ :v |		(aDictionary includesKey: v) ifTrue: [ aDictionary at: v ] ifFalse: [ v ].	].	"map declarations"	newDecls _ declarations species new.	declarations associationsDo: [ :assoc |		(aDictionary includesKey: assoc key)			ifTrue: [ newDecls at: (aDictionary at: assoc key) put: assoc value ]			ifFalse: [ newDecls add: assoc ].	].	declarations _ newDecls.	"map variable names in parse tree"	parseTree nodesDo: [ :node |		(node isVariable and:		 [aDictionary includesKey: node name]) ifTrue: [			node setName: (aDictionary at: node name).		].		(node isStmtList and: [node args size > 0]) ifTrue: [			node setArguments:				(node args collect: [ :arg |					(aDictionary includesKey: arg)						ifTrue: [ aDictionary at: arg ]						ifFalse: [ arg ].				]).		].	].! !!TMethod methodsFor: 'inlining support'!renameVarsForCaseStmt	"Rename the arguments and locals of this method with names like t1, t2, t3, etc. Return the number of variable names assigned. This is done to allow registers to be shared among the cases."	| i varMap |	i _ 1.	varMap _ Dictionary new.	args, locals do: [ :v |		varMap at: v put: ('t', i printString) asSymbol.		i _ i + 1.	].	self renameVariablesUsing: varMap.	^ i - 1! !!TMethod methodsFor: 'inlining support'!renameVarsForInliningInto: destMethod in: aCodeGen	"Rename any variables that would clash with those of the destination method."	| destVars usedVars varMap newVarName |	destVars _ aCodeGen globalsAsSet copy.	destVars addAll: destMethod locals.	destVars addAll: destMethod args.	usedVars _ destVars copy.  "keeps track of names in use"	usedVars addAll: args; addAll: locals.	varMap _ Dictionary new.	args, locals do: [ :v |		(destVars includes: v) ifTrue: [			newVarName _ self unusedNamePrefixedBy: v avoiding: usedVars.			varMap at: v put: newVarName.		].	].	self renameVariablesUsing: varMap.! !!TMethod methodsFor: 'inlining support'!unusedNamePrefixedBy: aString avoiding: usedNames	"Choose a unique variable or label name with the given string as a prefix, avoiding the names in the given collection. The selected name is added to usedNames."	| n newVarName |	n _ 1.	newVarName _ aString, n printString.	[usedNames includes: newVarName] whileTrue: [		n _ n + 1.		newVarName _ aString, n printString.	].	usedNames add: newVarName.	^ newVarName! !!TMethod methodsFor: 'C code generation'!emitCCodeOn: aStream generator: aCodeGen	"Emit C code for this method onto the given stream. All calls to inlined methods should already have been expanded."	self emitCHeaderOn: aStream generator: aCodeGen.	parseTree emitCCodeOn: aStream level: 1 generator: aCodeGen.	aStream nextPutAll: '}'; cr.! !!TMethod methodsFor: 'C code generation'!emitCFunctionPrototype: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	| arg |	aStream nextPutAll: returnType; space.	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	args isEmpty ifTrue: [ aStream nextPutAll: 'void' ].	1 to: args size do: [ :i |		arg _ args at: i.		(declarations includesKey: arg) ifTrue: [			aStream nextPutAll: (declarations at: arg).		] ifFalse: [			aStream nextPutAll: 'int ', (args at: i).		].		i < args size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TMethod methodsFor: 'C code generation'!emitCHeaderOn: aStream generator: aCodeGen	"Emit a C function header for this method onto the given stream."	aStream cr.	self emitCFunctionPrototype: aStream generator: aCodeGen.	aStream nextPutAll: ' {'; cr.	locals do: [ :var |		aStream nextPutAll: '    '.		aStream nextPutAll: (declarations at: var ifAbsent: [ 'int ', var]), ';'; cr.	].	locals isEmpty ifFalse: [ aStream cr ].! !!TMethod methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'TMethod(', selector, ')'.! !Object subclass: #TParseNode	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TParseNode methodsFor: 'all'!allCalls	"Answer a collection of selectors for the messages sent in this parse tree."	| calls |	calls _ Set new: 100.	self nodesDo: [ :node |		node isSend ifTrue: [ calls add: node selector ].	].	^calls! !!TParseNode methodsFor: 'all'!bindVariablesIn: aDictionary	^self! !!TParseNode methodsFor: 'all'!hasExplicitReturn	self nodesDo: [ :node |		node isReturn ifTrue: [ ^true ].	].	^false! !!TParseNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	self! !!TParseNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!isAssertion	^false! !!TParseNode methodsFor: 'all'!isAssignment	^false! !!TParseNode methodsFor: 'all'!isCaseStmt	^false! !!TParseNode methodsFor: 'all'!isComment	^false! !!TParseNode methodsFor: 'all'!isConstant	^false! !!TParseNode methodsFor: 'all'!isGoTo	^false! !!TParseNode methodsFor: 'all'!isLabel	^false! !!TParseNode methodsFor: 'all'!isLeaf	"Answer true if the receiver is a variable or a constant node."	^false! !!TParseNode methodsFor: 'all'!isReturn	^false! !!TParseNode methodsFor: 'all'!isSend	^false! !!TParseNode methodsFor: 'all'!isStmtList	^false! !!TParseNode methodsFor: 'all'!isVariable	^false! !!TParseNode methodsFor: 'all'!nodeCount	"Answer the number of nodes in this parseTree (a rough measure of its size)."	| cnt |	cnt _ 0.	self nodesDo: [ :n | cnt _ cnt + 1 ].	^cnt! !!TParseNode methodsFor: 'all'!nodesDo: aBlock	aBlock value: self.! !!TParseNode methodsFor: 'all'!printOn: aStream 	"Append a description of the receiver onto the given stream."	self printOn: aStream level: 0.! !!TParseNode methodsFor: 'all'!printOn: aStream level: anInteger 	"Typically overridden. If control actually gets here, avoid recursion loop by sending to super."	super printOn: aStream.! !!TParseNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	"default: do nothing"! !!TParseNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [self]! !TParseNode subclass: #TReturnNode	instanceVariableNames: 'expression '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TReturnNode methodsFor: 'all'!bindVariablesIn: aDictionary	expression _ expression bindVariablesIn: aDictionary.! !!TReturnNode methodsFor: 'all'!copyTree	^self class new		setExpression: expression copyTree! !!TReturnNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	aStream nextPutAll: 'return '.	expression emitCCodeOn: aStream level: level generator: aCodeGen.! !!TReturnNode methodsFor: 'all'!expression	^expression! !!TReturnNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	expression _ expression inlineMethodsUsing: aDictionary.! !!TReturnNode methodsFor: 'all'!isReturn	^true! !!TReturnNode methodsFor: 'all'!nodesDo: aBlock	expression nodesDo: aBlock.	aBlock value: self.! !!TReturnNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPut: $^.	expression printOn: aStream level: level.! !!TReturnNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	expression removeAssertions! !!TReturnNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		expression _ expression replaceNodesIn: aDictionary.		self]! !!TReturnNode methodsFor: 'all'!setExpression: aNode	expression _ aNode.! !TParseNode subclass: #TSendNode	instanceVariableNames: 'selector receiver arguments isBuiltinOperator '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TSendNode methodsFor: 'all'!args	^arguments! !!TSendNode methodsFor: 'all'!bindVariablesIn: aDictionary	receiver _ receiver bindVariablesIn: aDictionary.	arguments _ arguments collect: [ :a | a bindVariablesIn: aDictionary ].! !!TSendNode methodsFor: 'all'!copyTree	^self class new		setSelector: selector		receiver: receiver copyTree		arguments: (arguments collect: [ :arg | arg copyTree ])		isBuiltInOp: isBuiltinOperator! !!TSendNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	"If the selector is a built-in construct, translate it and return"	(aCodeGen emitBuiltinConstructFor: self on: aStream level: level) ifTrue: [ ^self ].	"Translate this message send into a C function call."	aStream nextPutAll: (aCodeGen cFunctionNameFor: selector), '('.	(receiver isVariable and:	 [(receiver name = 'self') or: [receiver name = 'interpreterProxy']]) ifFalse: [		"self is omitted from the arguments list of the generated call"		"Note: special case for translated BitBltSimulator--also omit		 the receiver if this is a send to the variable 'interpreterProxy'"		receiver emitCCodeOn: aStream level: level generator: aCodeGen.		arguments isEmpty ifFalse: [ aStream nextPutAll: ', ' ].	].	1 to: arguments size do: [ :i |		(arguments at: i) emitCCodeOn: aStream level: level generator: aCodeGen.		i < arguments size ifTrue: [ aStream nextPutAll: ', ' ].	].	aStream nextPutAll: ')'.! !!TSendNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	arguments _ arguments collect: [ :arg |		arg inlineMethodsUsing: aDictionary.	].	"xxx inline this message if it is in the dictionary xxx"! !!TSendNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!isAssertion	^(selector beginsWith: 'assert') or: [selector beginsWith: 'verify']! !!TSendNode methodsFor: 'all'!isBuiltinOperator	^ isBuiltinOperator! !!TSendNode methodsFor: 'all'!isBuiltinOperator: builtinFlag	isBuiltinOperator _ builtinFlag.! !!TSendNode methodsFor: 'all'!isSend	^true! !!TSendNode methodsFor: 'all'!nodesDo: aBlock	receiver nodesDo: aBlock.	arguments do: [ :arg | arg nodesDo: aBlock ].	aBlock value: self.! !!TSendNode methodsFor: 'all'!printOn: aStream level: level	| keywords |	receiver printOn: aStream level: level.	arguments size = 0 ifTrue: [		aStream space; nextPutAll: selector.		^self	].	keywords _ selector keywords.	1 to: keywords size do: [ :i |		aStream space.		aStream nextPutAll: (keywords at: i); space.		(arguments at: i) printOn: aStream level: level + 1.	].! !!TSendNode methodsFor: 'all'!receiver	^receiver! !!TSendNode methodsFor: 'all'!receiver: aNode	receiver _ aNode.! !!TSendNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	receiver removeAssertions.	arguments do: [:arg | arg removeAssertions].! !!TSendNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		receiver _ receiver replaceNodesIn: aDictionary.		arguments _ arguments collect: [ :a | a replaceNodesIn: aDictionary ].		self]! !!TSendNode methodsFor: 'all'!selector	^selector! !!TSendNode methodsFor: 'all'!setSelector: aSymbol receiver: rcvrNode arguments: argList	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ false.! !!TSendNode methodsFor: 'all'!setSelector: aSymbol receiver: rcvrNode arguments: argList isBuiltInOp: builtinFlag	selector _ aSymbol.	receiver _ rcvrNode.	arguments _ argList asArray.	isBuiltinOperator _ builtinFlag.! !TParseNode subclass: #TStmtListNode	instanceVariableNames: 'arguments statements '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TStmtListNode methodsFor: 'all'!args	^arguments! !!TStmtListNode methodsFor: 'all'!bindVariablesIn: aDictionary	statements _ statements collect: [ :s | s bindVariablesIn: aDictionary ].! !!TStmtListNode methodsFor: 'all'!copyTree	^self class new		setArguments: arguments copy		statements: (statements collect: [ :s | s copyTree ])! !!TStmtListNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	statements do: [ :s |		level timesRepeat: [ aStream tab ].		s emitCCodeOn: aStream level: level generator: aCodeGen.		((self endsWithCloseBracket: aStream) or: [s isComment]) ifFalse: [ aStream nextPut: $; ].		aStream cr.	].! !!TStmtListNode methodsFor: 'all'!endsWithCloseBracket: aStream	"Answer true if the given stream ends in with $} character."	| ch pos |	(pos _ aStream position) > 0 ifTrue: [		aStream position: pos - 1.		ch _ aStream next.		aStream position: pos.	].	^ ch = $}" *** There's something wrong with File positioning.  If you execute the following code, it will print '(hello));;' , but it will give an error if you remove the line the says	f position: f position. | f c p1 p2 p3 | f _ FileStream fileNamed: 'test'.f nextPutAll: '(hello))'.f position: (p1 _ f position)-1.p2 _ f position.c _ f next.p3 _ f position.f position: f position.f nextPut: $;; nextPut: $;.f close.(FileStream fileNamed: 'test') contentsOfEntireFile"! !!TStmtListNode methodsFor: 'all'!inlineMethodsUsing: aDictionary	statements do: [ :s | s inlineMethodsUsing: aDictionary ].! !!TStmtListNode methodsFor: 'all'!isStmtList	^true! !!TStmtListNode methodsFor: 'all'!nodesDo: aBlock	statements do: [ :s | s nodesDo: aBlock ].		aBlock value: self.! !!TStmtListNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPut: $[.	arguments size > 0 ifTrue: [		arguments do: [ :arg | aStream nextPutAll: ' :', arg ].		aStream nextPutAll: ' | '.	].	self printStatementsOn: aStream level: level.	aStream nextPut: $].! !!TStmtListNode methodsFor: 'all'!printStatementsOn: aStream level: level	statements size > 1 ifTrue: [ aStream crtab: level + 1 ].	1 to: statements size do: [ :i |		(statements at: i) printOn: aStream level: level.		i = statements size ifTrue: [			(statements size > 1) ifTrue: [				aStream crtab: level.			].		] ifFalse: [			aStream nextPut: $.; crtab: level + 1.		].	].! !!TStmtListNode methodsFor: 'all' stamp: 'ikp 9/26/97 14:50'!removeAssertions	| newStatements |	newStatements _ OrderedCollection new: statements size.	statements do: [ :stmt |		stmt isAssertion ifFalse: [			newStatements add: (stmt removeAssertions; yourself).		]	].	self setStatements: newStatements asArray! !!TStmtListNode methodsFor: 'all'!replaceNodesIn: aDictionary	^aDictionary at: self ifAbsent: [		statements _ statements collect: [ :s | s replaceNodesIn: aDictionary ].		self]! !!TStmtListNode methodsFor: 'all'!setArguments: argList	arguments _ argList.! !!TStmtListNode methodsFor: 'all'!setArguments: argList statements: statementList	"Initialize this method using the given information."	arguments _ argList.	statements _ statementList.! !!TStmtListNode methodsFor: 'all'!setStatements: stmtList	statements _ stmtList asOrderedCollection.! !!TStmtListNode methodsFor: 'all'!statements	^statements! !TParseNode subclass: #TVariableNode	instanceVariableNames: 'name '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TVariableNode methodsFor: 'all'!bindVariablesIn: aDictionary	| newNode |	newNode _ aDictionary at: name asSymbol ifAbsent: [ ^self ].	^newNode copyTree! !!TVariableNode methodsFor: 'all'!copyTree	^self class new setName: name! !!TVariableNode methodsFor: 'all'!emitCCodeOn: aStream level: level generator: aCodeGen	name = 'nil'		ifTrue: [ aStream nextPutAll: (aCodeGen cLiteralFor: nil) ]		ifFalse: [ aStream nextPutAll: name ].! !!TVariableNode methodsFor: 'all'!isLeaf	^true! !!TVariableNode methodsFor: 'all'!isVariable	^true! !!TVariableNode methodsFor: 'all'!name	^name! !!TVariableNode methodsFor: 'all'!printOn: aStream level: level	aStream nextPutAll: name.! !!TVariableNode methodsFor: 'all'!setName: aString	name _ aString.! !BookMorph subclass: #TabbedPaletteComplex	instanceVariableNames: 'tabsMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-EToy-Support'!!TabbedPaletteComplex methodsFor: 'disk-file load/store' stamp: 'tk 3/13/98 23:02'!clobberContentsOfTabNamed: aName	"For the purposes of trimming down save-file size, offer to substitute an empty place-holder of the same name."	| aBook |	(self objectAtTab: aName) ifNil: [^ self].	aBook _ BookMorph new.	aBook insertPageShowingString: 'nulled out' usingFont: nil.	^ aBook! !!TabbedPaletteComplex methodsFor: 'miscellaneous' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ openToDragNDrop not! !!TabbedPaletteComplex methodsFor: 'miscellaneous' stamp: 'sw 9/30/97 10:10'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'sw 10/1/97 00:18'!configureForKids	self openToDragNDrop: false.	super configureForKids! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'sw 9/20/97 20:31'!defaultPageSize	^ 166@200! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'sw 9/20/97 21:01'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	tabsMorph _ TabsMorph new.	self addMorph: tabsMorph! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'tk 9/23/97 07:19'!replaceBook: aName with: newBook	"replace the old book with a new book.  Great for bringing Alan's scaffolding in""Inspect the new bookMorph.  In it, set 	AA _ self.Inspect the TabbedPaletteComplex.  Execute:	self replaceBook: 'Toy' with: AA." 	newBook setProperty: #name toValue: 'Toy'.	self selectTabNamed: aName.	currentPage delete.	self addMorph: newBook.	pages add: newBook after: currentPage.	pages remove: currentPage.	newBook position: currentPage position.	currentPage _ newBook.	self changed.! !!TabbedPaletteComplex methodsFor: 'initialization' stamp: 'sw 9/14/97 01:12'!setInitialState	super setInitialState.	inset _ 0.	pageSize _ 156 @ 232! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'jm 9/22/97 11:56'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	aCustomMenu add: 'add tab' action: #insertTab.	aCustomMenu add: 'delete selected tab' action: #deleteTab.! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 5/13/1998 16:21'!deleteTab	self notYetImplemented! !!TabbedPaletteComplex methodsFor: 'menu' stamp: 'sw 9/13/97 23:30'!insertTab	| aString aColor |	aString _ FillInTheBlank request: 'Tab Name?' initialAnswer: 'New Tab'.	aString size == 0 ifTrue: [^ self].	aColor _ Color fromUser.	self addTabNamed: aString color: aColor atIndex: (pages indexOf: currentPage)! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 9/12/97 14:51'!addNewTab	| aString aColor |	aString _ FillInTheBlank request: 'Tab Name?' initialAnswer: 'New Tab'.	aString size == 0 ifTrue: [^ self].	aColor _ Color fromUser.	self addTabNamed: aString color: aColor atIndex: nil! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 9/21/97 00:08'!addTabNamed: aString color: saturatedColor atIndex: anIndex	| aName paleColor but aBookMorph |	self flag: #deferred.  "Check to see if former bug that Tabs are somehow not added in requested position is fixed"	aName _ aString withBlanksTrimmed.	paleColor _ saturatedColor muchLighter.	but _ tabsMorph addButtonShowing: aString named: aName selector: #selectTabNamed: arguments: (Array with: aName) atIndex: anIndex.	but buttonOnColor: saturatedColor.	but buttonOffColor: paleColor.	aBookMorph _ BookMorph new pageSize: pageSize.	aBookMorph removeEverything; color: paleColor; setNameTo: aName; addDressing; insertPageColored: paleColor.	self insertPage: aBookMorph pageSize: nil atIndex: anIndex.	^ aBookMorph! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'tk 2/13/98 09:37'!objectAtTab: aName	"This has to be so contorted!!!!  The correspondence between names in ONLY stored in the tabs stringButtons contents vs. its first argument!!!!"	tabsMorph submorphsDo: [:button |		button contents = aName ifTrue: [			^ pages detect: [:p | p externalName = button arguments first] ifNone: [nil]]].	^ nil! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'sw 8/8/97 18:55'!selectTabNamed: aName	tabsMorph selectTabNamed: aName! !!TabbedPaletteComplex methodsFor: 'tabs' stamp: 'jm 11/16/97 17:59'!tabsMorph	^ tabsMorph! !AlignmentMorph subclass: #TabsMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Experimental-EToy-Support'!!TabsMorph commentStamp: 'di 5/22/1998 16:38' prior: 0!TabsMorph comment:'Used in conjunction wi[th a TabedPaletteComplex.  Every TabedPaletteComplex has a TabsMorph as one of its submorphs, which lives at the top of its area.  Every submorph of a TabsMorph is a TabMorph which corresponds to one of the palette-pages of the PalettesWithTabs.  When you click on one of the tab, the existing palette gets replaced by the new one, and tab highlighting takes place accordingly.'!!TabsMorph methodsFor: 'all' stamp: 'sw 9/17/97 14:45'!addButtonShowing: aString named: aName selector: aSymbol arguments: argList atIndex: anIndex	| b indexToUse |	b _ StringButtonMorph new.	b	contents: aString;		color: self buttonOffColor;		target: self;		actionSelector: aSymbol.	argList ifNotNil: [b arguments: argList].	b setNameTo: aName.	indexToUse _ anIndex == nil ifTrue: [submorphs size + 1] ifFalse: [anIndex].	self privateAddMorph: b atIndex: indexToUse.	^ b! !!TabsMorph methodsFor: 'all' stamp: 'sw 10/1/97 21:42'!highlightTabName: aString	| theOne |	self stringButtonSubmorphs do: [:m |		(m isKindOf: StringButtonMorph) ifTrue:			[(m contents beginsWith: aString)				ifTrue: [m color: m buttonOnColor.  theOne _ m]				ifFalse: [m color: m buttonOffColor]]].	^ theOne! !!TabsMorph methodsFor: 'all' stamp: 'sw 8/7/97 22:14'!initialize	super initialize.	color _ Color r: 0.0 g: 0.6 b: 0.6! !!TabsMorph methodsFor: 'all' stamp: 'sw 8/8/97 18:24'!selectTabNamed: aString	self world abandonAllHalos.	self highlightTabName: aString.	owner goToPageMorphNamed: aString! !!TabsMorph methodsFor: 'all' stamp: 'sw 10/1/97 21:39'!stringButtonSubmorphs	^ submorphs select: [:s | s isKindOf: StringButtonMorph]! !VariableNode subclass: #TempVariableNode	instanceVariableNames: 'isAnArg hasRefs hasDefs scope '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!TempVariableNode commentStamp: 'di 5/22/1998 16:38' prior: 0!TempVariableNode comment:'I am a parse tree leaf representing a temporary variable'!!TempVariableNode methodsFor: 'initialize-release'!isArg: aBoolean	isAnArg _ aBoolean.	isAnArg ifTrue: [hasDefs _ true]! !!TempVariableNode methodsFor: 'initialize-release'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	name _ varName.	self key: varName		index: i		type: type.	isAnArg _ hasDefs _ hasRefs _ false.	scope _ level! !!TempVariableNode methodsFor: 'initialize-release'!nowHasDef	hasDefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!nowHasRef	hasRefs _ true! !!TempVariableNode methodsFor: 'initialize-release'!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope _ level! !!TempVariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	isAnArg ifTrue: [^ location]			ifFalse: [^ -1]! !!TempVariableNode methodsFor: 'testing'!isArg	^ isAnArg! !!TempVariableNode methodsFor: 'testing'!isTemp	^ true! !!TempVariableNode methodsFor: 'testing'!isUndefTemp	^ hasDefs not! !!TempVariableNode methodsFor: 'testing'!isUnusedTemp	^ hasRefs not! !!TempVariableNode methodsFor: 'testing'!scope	^ scope! !!TempVariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream withAttribute: (TextColor color: Color blue)			do: [aStream nextPutAll: name]! !AbstractScoreEvent subclass: #TempoEvent	instanceVariableNames: 'tempo '	classVariableNames: ''	poolDictionaries: ''	category: 'Music-Scores'!!TempoEvent commentStamp: 'di 5/22/1998 16:38' prior: 0!Represents a tempo change in a MIDI score.!!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:10'!isTempoEvent	^ true! !!TempoEvent methodsFor: 'all' stamp: 'jm 1/3/98 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:09'!tempo	^ tempo! !!TempoEvent methodsFor: 'all' stamp: 'jm 12/30/97 10:09'!tempo: anInteger	tempo _ anInteger.! !Object subclass: #TestCClass1	instanceVariableNames: 'x y '	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TestCClass1 methodsFor: 'all'!arg1: a arg2: b	"CCodeGenerator new initialize addClass: TestCClass1"	| i j k |	self var: #i declareC: 'char *i'.	i _ 'abc'.	j _ 2.	k _ 3.! !!TestCClass1 methodsFor: 'all'!ifTests	true ifTrue: [		self print: 'true case'	].	true ifFalse: [		self print: 'false case'	].	true ifTrue: [		self print: 'true case'	] ifFalse: [		self print: 'false case'	].	true ifFalse: [		self print: 'false case'	] ifTrue: [		self print: 'true case'	].! !!TestCClass1 methodsFor: 'all'!isIntegerValue: intValue	"Copied from ObjectMemory."	^ (intValue bitXor: (intValue << 1)) >= 0! !!TestCClass1 methodsFor: 'all'!loopTests	| v |	v _ 0.	[v < 10] whileTrue: [ self printNum: v.  v _ v + 1 ].	self print: ''.	[v < 1] whileFalse: [ self printNum: v.  v _ v - 1 ].	self print: ''.	1 to: 10 do: [ :i | self printNum: i ].	self print: ''.	1 to: 10 by: 2 do: [ :i | self printNum: i ].	self print: ''.! !!TestCClass1 methodsFor: 'all'!method1	"(CCodeGenerator new initialize addClass: TestCClass1) codeString"	x & y ifTrue: [		x _ 10.		y _ 20.	].	y _ nil + 3.	x = nil ifTrue: [ x _ 18 ].	^nil! !!TestCClass1 methodsFor: 'all'!method2	self method1; method8: 0; setX: 10 Y: 20.! !!TestCClass1 methodsFor: 'all'!method3	x > 0 ifTrue: [ ^x ] ifFalse: [ ^y ].! !!TestCClass1 methodsFor: 'all'!method4	x _ 0.	y _ 0.	[x < 100] whileTrue: [		y _ y + x.		x _ x + 1.	].	^y! !!TestCClass1 methodsFor: 'all'!method5	self inline: true.	x & y.	x | y.	x and: [y].	x or: [y].	x not.	x + y.	x - y.	x * y.	x // y.	x \\ y.	x min: y.	x max: y.	x bitAnd: y.	x bitOr: y.	x bitXor: y.	x bitInvert32.	x bitShift: y.	x >> y.	x << y.	x < y.	x <= y.	x = y.	x >= y.	x > y.	x ~= y.	x == y.	x isNil.	x notNil.	[x > y] whileTrue: [ x _ x + 1 ].	[x > y] whileFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ].	x > y ifFalse: [ x _ x + 1 ].	x > y ifTrue: [ x _ x - 1 ] ifFalse: [ x _ x + 1 ].	x > y ifFalse: [ x _ x + 1 ] ifTrue: [ x _ x - 1 ].	x at: 3.	x at: 3 put: y.	self integerValueOf: x.	self integerObjectOf: x.	(self isIntegerObject: x) ifTrue: [ x _ x - 1 ].	(self isIntegerValue: x) ifTrue: [ x _ x - 1 ].	self cCoerce: x * (y - 1) to: 'int'.	x _ x + 1.	x _ x - 1.	x preDecrement.	y preIncrement > 0 ifTrue: [ x _ x + 1 ].! !!TestCClass1 methodsFor: 'all'!method6	self dispatchOn: x in: #(f1 f2 f3 f4 f5).! !!TestCClass1 methodsFor: 'all'!method7	| t1 |	self method1.	self method2.	t1 _ self method3.	self method4.	self method5.! !!TestCClass1 methodsFor: 'all'!method8: arg	| a |	self returnTypeC: 'float'.	self var: #a    declareC: 'float a = 0'.	self var: #arg declareC: 'float arg'.	self cCode: 'a = arg * 3.14159'.	^a! !!TestCClass1 methodsFor: 'all'!print: val	self cCode: 'printf("%d\n", val)'.! !!TestCClass1 methodsFor: 'all'!printNum: i	self cCode: 'printf("%d ", i)'.! !!TestCClass1 methodsFor: 'all'!setX: newX Y: newY	x _ newX min: newY.	y _ newY.! !Object subclass: #TestCClass2	instanceVariableNames: 'vect '	classVariableNames: 'VectSize '	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TestCClass2 methodsFor: 'all'!atAllPut	| i |	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: 5.		i _ i - 1.	].	(vect at: 1) ~= 5 ifTrue: [ self error: 'AtAllPutBenchmark' ].! !!TestCClass2 methodsFor: 'all'!error: s	"Print an error message and exit."	self print: 'Error in %s\n' f: s.	self exit: -1.! !!TestCClass2 methodsFor: 'all'!incrementAll	| oldVal i |	oldVal _ vect at: 1.	i _ VectSize.	[i > 0] whileTrue: [		vect at: i put: ((vect at: i) + 1).		i _ i - 1.	].	(vect at: 1) ~= (oldVal + 1) ifTrue: [ self error: 'IncrementAllBenchmark' ].! !!TestCClass2 methodsFor: 'all'!initialize	VectSize _ 10000.	vect _ Array new: VectSize.! !!TestCClass2 methodsFor: 'all'!main	| startTicks ticks |	self printf: 'atAllPut: '.	startTicks _ self clock.	self atAllPut.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'incrementAll: '.	self incrementAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'nestedWhileLoop: '.	self nestedWhileLoop.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sieve: '.	self sieve.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumAll: '.	self sumAll.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.	self printf: 'sumFromTo: '.	self sumFromTo.	ticks _ self clock - startTicks.	self print: '%ld\n' f: ticks.! !!TestCClass2 methodsFor: 'all'!nestedWhileLoop	| sum i j |	sum _ 0.	i _ 1000.	[i > 0] whileTrue: [		j _ 100.		[j > 0] whileTrue: [			sum _ sum + 1.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 100000 ifTrue: [ self error: 'NestedWhileBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sieve	| flagsSize flags primeCount i k |	flagsSize _ 8190.	flags _ Array new: flagsSize.	i _ flagsSize.	[i > 0] whileTrue: [		flags at: i put: true.		i _ i - 1.	].	primeCount _ 0.	i _ 2.	[i <= flagsSize] whileTrue: [		(flags at: i) ifTrue: [			primeCount _ primeCount + 1. "i is a prime"			k _ i + i.			[k <= flagsSize] whileTrue: [				flags at: k put: false. "k is not a prime; it is a multiple of i"				k _ k + i.			].		].		i _ i + 1.	].	primeCount ~= 1027 ifTrue: [ self error: 'SieveBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sumAll	| elementVal sum i |	elementVal _ vect at: 1.	sum _ 0.	i _ VectSize.	[i > 0] whileTrue: [		sum _ sum + (vect at: i).		i _ i - 1.	].	sum ~= (VectSize * elementVal) ifTrue: [ self error: 'SumAllBenchmark' ].! !!TestCClass2 methodsFor: 'all'!sumFromTo	| sum i j |	i _ 10.	[i > 0] whileTrue: [		sum _ 0.		j _ 10000.		[j > 0] whileTrue: [			sum _ sum + j.			j _ j - 1.		].		i _ i - 1.	].	sum ~= 50005000 ifTrue: [ self error: 'SumFromToBenchmark' ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TestCClass2 class	instanceVariableNames: ''!!TestCClass2 class methodsFor: 'testing'!test	"TestCClass2 test"	"(CCodeGenerator new initialize addClass: TestCClass2) codeString"	| bm |	bm _ self new initialize.	Transcript show: 'atAllPut: '.	Transcript show: (Time millisecondsToRun: [bm atAllPut]) printString; cr.	Transcript show: 'incrementAll: '.	Transcript show: (Time millisecondsToRun: [bm incrementAll]) printString; cr.	Transcript show: 'nestedWhileLoop: '.	Transcript show: (Time millisecondsToRun: [bm nestedWhileLoop]) printString; cr.	Transcript show: 'sieve: '.	Transcript show: (Time millisecondsToRun: [bm sieve]) printString; cr.	Transcript show: 'sumAll: '.	Transcript show: (Time millisecondsToRun: [bm sumAll]) printString; cr.	Transcript show: 'sumFromTo: '.	Transcript show: (Time millisecondsToRun: [bm sumFromTo]) printString; cr.! !Object subclass: #TestCClass3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Translation to C'!!TestCClass3 methodsFor: 'all'!dispatchOn: currentBytecode in: selectorArray	"Simulate a case statement via selector table lookup. The given integer must be between 0 and (selectorArray size - 1), inclusive. Send the selector at (currentBytecode + 1) in selectorArray to the receiver. For speed, no extra range test is done, since it is done by the at: operation."	"Note: Delete this method from the generated code."	"assert: (currentBytecode >= 0) | (currentBytecode < selectorArray size)"	self perform: (selectorArray at: (currentBytecode + 1)).! !!TestCClass3 methodsFor: 'all'!f1	| local r |	local _ self functionWithLabel: 1.	r _ 7.	self print: 'f1'.! !!TestCClass3 methodsFor: 'all'!f2	| local i |	local _ 2.	i _ self functionWithLabel: -2.	i > 0 ifTrue: [ ^ -1 ].	self print: 'f2'.! !!TestCClass3 methodsFor: 'all'!f3	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f3'.! !!TestCClass3 methodsFor: 'all'!f4	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f4'.! !!TestCClass3 methodsFor: 'all'!f5	self sharedCodeNamed: 'sharedCode' inCase: 5.	self print: 'f5'.! !!TestCClass3 methodsFor: 'all'!functionWithLabel: arg	arg > 0 ifTrue: [ ^1 ] ifFalse: [ ^-1 ].! !!TestCClass3 methodsFor: 'all'!interpret	"TestCClass3 new main"	"(CCodeGenerator new initialize addClass: TestCClass3) codeString"	0 to: 9 do: [ :currentBytecode |		self dispatchOn: currentBytecode in: #(f1 f2 f2 f3 f3 f3 f4 f4 f5 f2).	].! !!TestCClass3 methodsFor: 'all'!print: s	self var: #s declareC: 'char *s'.	self cCode: 'printf("%s", s)'.! !ArrayedCollection subclass: #Text	instanceVariableNames: 'string runs '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Collections-Text'!!Text commentStamp: 'di 5/22/1998 16:38' prior: 0!I represent a character string that has been marked with abstract changes in character appearance. Actual display is performed in the presence of a TextStyle which indicates, for each abstract code, an actual font to be used.  A Text associates a set of TextAttributes with each character in its character string.  These attributes may be font numbers, emphases such as bold or italic, or hyperling actions.  Font numbers are interpreted relative to whatever textStyle appears, along with the text, in a Paragraph.  Since most characters have the same attributes as their neighbors, the attributes are stored in a RunArray for efficiency.  Each of my instances has	string		a String	runs		a RunArray!]style[(148 9 97 13 237 9 163 6 10 8)f1,f1LTextStyle Comment;,f1,f1LTextAttribute Hierarchy;,f1,f1LParagraph Comment;,f1,f1LString Comment;,f1,f1LRunArray Comment;!!Text methodsFor: 'accessing'!at: index	^string at: index! !!Text methodsFor: 'accessing'!at: index put: character	^string at: index put: character! !!Text methodsFor: 'accessing'!atPin: index	^string atPin: index! !!Text methodsFor: 'accessing'!atWrap: index	^string atWrap: index! !!Text methodsFor: 'accessing'!findString: aString startingAt: start 	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start! !!Text methodsFor: 'accessing' stamp: 'di 11/10/97 12:53'!rangeOf: attribute startingAt: index	"This is stupid, slow code, but it works"	| start stop |	start _ index.	[start > 1 and: [(self attributesAt: start-1) includes: attribute]]		whileTrue: [start _ start - 1].	stop _ index-1.	[stop < self size and: [(self attributesAt: stop+1) includes: attribute]]		whileTrue: [stop _ stop + 1].	^ start to: stop! !!Text methodsFor: 'accessing' stamp: 'tk 12/30/97 07:17'!replaceFrom: start to: stop with: aText	| txt |	txt _ aText asText.	"might be a string"	string _ string copyReplaceFrom: start to: stop with: txt string.	runs _ runs copyReplaceFrom: start to: stop with: txt runs! !!Text methodsFor: 'accessing'!size	^string size! !!Text methodsFor: 'accessing'!string	"Answer the string representation of the receiver."	^string! !!Text methodsFor: 'comparing'!= other	^ other isText		ifTrue:	[string = other string and: [runs = other asText runs]]		ifFalse: [false]! !!Text methodsFor: 'comparing'!isText	^ true! !!Text methodsFor: 'copying'!copy	^ self class new setString: string copy setRuns: runs copy! !!Text methodsFor: 'copying'!copyFrom: start to: stop 	"Answer a copied subrange of the receiver."	| realStart realStop |	stop > self size		ifTrue: [realStop _ self size]		"handle selection at end of string"		ifFalse: [realStop _ stop].	start < 1		ifTrue: [realStart _ 1]			"handle selection before start of string"		ifFalse: [realStart _ start].	^Text 		string: (string copyFrom: realStart to: realStop)		runs: (runs copyFrom: realStart to: realStop)! !!Text methodsFor: 'copying'!copyReplaceFrom: start to: stop with: aText	^self shallowCopy replaceFrom: start to: stop with: aText! !!Text methodsFor: 'copying' stamp: 'tk 1/7/98 10:58'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!Text methodsFor: 'copying' stamp: 'di 11/9/97 17:13'!deepCopy	^ self copy "Both string and runs are assumed to be read-only"! !!Text methodsFor: 'converting'!asDisplayText	"Answer a DisplayText whose text is the receiver."	^DisplayText text: self! !!Text methodsFor: 'converting'!asNumber	"Answer the number created by interpreting the receiver as the textual 	representation of a number."	^string asNumber! !!Text methodsFor: 'converting'!asParagraph	"Answer a Paragraph whose text is the receiver."	^Paragraph withText: self! !!Text methodsFor: 'converting'!asString	"Answer a String representation of the textual receiver."	^string! !!Text methodsFor: 'converting'!asText		"Answer the receiver itself."	^self! !!Text methodsFor: 'emphasis'!addAttribute: att 	^ self addAttribute: att from: 1 to: self size! !!Text methodsFor: 'emphasis'!addAttribute: att from: start to: stop 	"Set the attribute for characters in the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | Text addAttribute: att toArray: attributes])! !!Text methodsFor: 'emphasis'!allBold 	"Force this whole text to be bold."	string size = 0 ifTrue: [^self].	self makeBoldFrom: 1 to: string size! !!Text methodsFor: 'emphasis'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes	! !!Text methodsFor: 'emphasis' stamp: 'di 11/10/97 13:36'!find: attribute	"Return the first interval over which this attribute applies"	| begin end |	begin _ 0.	runs withStartStopAndValueDo:		[:start :stop :attributes |		(attributes includes: attribute)			ifTrue: [begin = 0 ifTrue: [begin _ start].					end _ stop]			ifFalse: [begin > 0 ifTrue: [^ begin to: end]]].	begin > 0 ifTrue: [^ begin to: end].	^ nil! !!Text methodsFor: 'emphasis' stamp: 'di 11/9/97 17:41'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle fontAt: 1].	"null text tolerates access"	attributes _ runs at: characterIndex.	attributes do:		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font	! !!Text methodsFor: 'emphasis'!fontNumberAt: characterIndex 	"Answer the fontNumber for characters in the run beginning at characterIndex."	| attributes fontNumber |	self size = 0 ifTrue: [^1].	"null text tolerates access"	attributes _ runs at: characterIndex.	fontNumber _ 1.	attributes do: [:att | (att isMemberOf: TextFontChange) ifTrue: [fontNumber _ att fontNumber]].	^ fontNumber	! !!Text methodsFor: 'emphasis'!makeBoldFrom: start to: stop	^ self addAttribute: TextEmphasis bold from: start to: stop! !!Text methodsFor: 'emphasis' stamp: 'di 2/4/98 08:44'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	string first isLetter ifFalse: [^ self].	(parser _ aClass parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'emphasis'!removeAttribute: att from: start to: stop 	"Remove the attribute over the interval start to stop."	runs _  runs copyReplaceFrom: start to: stop			with: ((runs copyFrom: start to: stop)				mapValues:				[:attributes | attributes copyWithout: att])! !!Text methodsFor: 'emphasis'!runLengthFor: characterIndex 	"Answer the count of characters remaining in run beginning with 	characterIndex."	^runs runLengthAt: characterIndex! !!Text methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'Text for '.	string printOn: aStream! !!Text methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Text string: ';		store: string;		nextPutAll: ' runs: ';		store: runs;		nextPut: $)! !!Text methodsFor: 'private'!runs	^runs! !!Text methodsFor: 'private'!setString: aString setRuns: anArray	string _ aString.	runs _ anArray! !!Text methodsFor: 'private' stamp: 'tk 12/16/97 14:14'!setString: aString setRunsChecking: aRunArray	"Check runs and do the best you can to make them fit..."	string _ aString.	"check the runs"	aRunArray ifNil: [^ aString asText].	(aRunArray isKindOf: RunArray) ifFalse: [^ aString asText].	aRunArray runs size = aRunArray values size ifFalse: [^ aString asText].	(aRunArray values includes: #()) ifTrue: [^ aString asText].	"not allowed?"	aRunArray size = aString size ifFalse: [^ aString asText].		runs _ aRunArray.! !!Text methodsFor: 'attributes' stamp: 'sw 1/29/98 02:59'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old _ priorMethod getSourceFromFile].	(old == nil or: [old unembellished]) ifTrue: [		tell _ 'This method contains style (i.e. bold) for the first time.Do you really want to save the style info?'.		answ _ (PopUpMenu labels: 'Save method with styleSave method simply') startUpWithCaption: tell. 		answ = 2 ifTrue: [ 			"Dan, here is where to tell it to display self asString" "requestor model changed." 			^ self asString]].	"^ self		keep my style"! !!Text methodsFor: 'attributes' stamp: 'di 2/2/98 13:20'!unembellished 	"Return true if the only emphases are font-1 and bold"	| font1 bold |	font1 _ TextFontChange font1.	bold _ TextEmphasis bold.	Preferences ignoreStyleIfOnlyBold ifFalse:		["Ignore font1 only or font1-bold followed by font1-plain"		^ (runs values = (Array with: (Array with: font1)))		or: [runs values = (Array with: (Array with: font1 with: bold) 								with: (Array with: font1))]].	"If preference is set, then ignore any combo of font1 and bold"	runs withStartStopAndValueDo:		[:start :stop :emphArray |		emphArray do:			[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Text class	instanceVariableNames: ''!!Text class methodsFor: 'class initialization'!initialize	"Text initialize"	"Initialize constants shared by classes associated with text display."	TextConstants at: #CaretForm put:				(Form extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -3@0).	self initTextConstants! !!Text class methodsFor: 'class initialization'!initTextConstants 	"Initialize constants shared by classes associated with text display, e.g., 	Space, Tab, Cr, Bs, ESC."		"1/24/96 sw: in exasperation and confusion, changed cmd-g mapping from 231 to 232 to see if I could gain any relief?!!"	| letter varAndValue tempArray width |	"CtrlA..CtrlZ, Ctrla..Ctrlz"	letter _ $A. 	#(		212 230 228 196 194 226 241 243 214 229 200 217 246 			245 216 202 210 239 211 240 197 198 209 215 242 231	 		1 166 228 132 130 12 232 179 150 165 136 153 182 			14 15 138 17 18 19 11 21 134 145 151 178 167 ) do:		[:kbd |		TextConstants at: ('Ctrl', letter asSymbol) asSymbol put: kbd asCharacter.		letter _ letter == $Z ifTrue: [$a] ifFalse: [(letter asciiValue + 1) asCharacter]].	varAndValue _ #(		Space	32		Tab		9		CR		13		Enter	3		BS		8		BS2		158		ESC		160		Clear 	173	).	varAndValue size odd ifTrue: [self notify: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i) asCharacter].	varAndValue _ #(		CtrlDigits 			(159 144 143 128 127 129 131 180 149 135)		CtrlOpenBrackets	(201 7 218 249 219 15)			"lparen gottn by ctrl-_ = 201; should be 213 but can't type that on Mac"			"location of non-character stop conditions"		EndOfRun	257		CrossedX	258			"values for alignment"		LeftFlush	0		RightFlush	1		Centered	2		Justified	3			"subscripts for a marginTabsArray tuple"		LeftMarginTab	1		RightMarginTab	2			"font faces"		Basal	0		Bold	1		Italic	2			"in case font doesn't have a width for space character"			"some plausible numbers-- are they the right ones?"		DefaultSpace			4		DefaultTab				24		DefaultLineGrid			16		DefaultBaseline			12		DefaultFontFamilySize	3	"basal, bold, italic"	).	varAndValue size odd ifTrue: [self notify: 'unpaired text constant'].	(2 to: varAndValue size by: 2) do:		[:i | TextConstants at: (varAndValue at: i - 1) put: (varAndValue at: i)].	TextConstants at: #DefaultRule	put: Form over.	TextConstants at: #DefaultMask	put: Color black.	width _ Display width max: 720.	tempArray _ Array new: width // DefaultTab.	1 to: tempArray size do:		[:i | tempArray at: i put: DefaultTab * i].	TextConstants at: #DefaultTabsArray put: tempArray.	tempArray _ Array new: (width // DefaultTab) // 2.	1 to: tempArray size do:		[:i | tempArray at: i put: (Array with: (DefaultTab*i) with: (DefaultTab*i))].	TextConstants at: #DefaultMarginTabsArray put: tempArray."Text initTextConstants "! !!Text class methodsFor: 'instance creation'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, 	aString."	^self string: aString attribute: (TextFontChange fontNumber: 1)! !!Text class methodsFor: 'instance creation' stamp: 'jm 4/28/1998 06:54'!fromUser	"Answer an instance of me obtained by requesting the user to type a string."	"Text fromUser"	^ self fromString:		(FillInTheBlank request: 'Enter text followed by carriage return')! !!Text class methodsFor: 'instance creation'!new: stringSize	^self fromString: (String new: stringSize)! !!Text class methodsFor: 'instance creation'!streamContents: blockWithArg 	| stream |	stream _ TextStream on: (self new: 400).	blockWithArg value: stream.	^ stream contents! !!Text class methodsFor: 'instance creation'!string: aString attribute: att	"Answer an instance of me whose characters are aString.	att is a TextAttribute."	^self string: aString attributes: (Array with: att)! !!Text class methodsFor: 'instance creation'!string: aString attributes: atts	"Answer an instance of me whose characters are those of aString.	atts is an array of TextAttributes."	^self string: aString runs: (RunArray new: aString size withAll: atts)! !!Text class methodsFor: 'instance creation'!string: aString emphasis: emphasis	"This is an old method that is mainly used by old applications"	emphasis isNumber ifTrue:		[self halt: 'Numeric emphasis is not supported in Squeak'.		"But if you proceed, we will do our best to give you what you want..."		^ self string: aString runs: (RunArray new: aString size withAll: 			(Array with: (TextFontChange new fontNumber: emphasis)))].	^ self string: aString attributes: emphasis! !!Text class methodsFor: 'private' stamp: 'di 10/31/97 11:22'!addAttribute: att toArray: others 	"Add a new text attribute to an existing set"	"NOTE: The use of reset and set in this code is a specific	hack for merging TextKerns."	att reset.	^ Array streamContents:		[:strm | others do:			[:other | (att dominates: other) ifFalse: [strm nextPut: other]].		att set ifTrue: [strm nextPut: att]]! !!Text class methodsFor: 'private'!string: aString runs: anArray 	^self basicNew setString: aString setRuns: anArray! !TextAttribute subclass: #TextAction	instanceVariableNames: ''	classVariableNames: 'Purple '	poolDictionaries: ''	category: 'Collections-Text'!!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44'!analyze: aString	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:3+4<3+4>Click Here<3+4><3+4>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim param show |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		param _ self validate: aString.		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] ifFalse: [param]]			ifFalse: ["at the front"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				param _ self validate: (aString copyFrom: b1+1 to: b2-1).				show _ param size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				show _ nil]].	^ Array with: param with: show! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off active text"	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: Purple! !!TextAction methodsFor: 'as yet unclassified'!mayActOnClick	^ true! !!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:48'!validate: aString	"any format is OK with me"	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextAction class	instanceVariableNames: ''!!TextAction class methodsFor: 'as yet unclassified' stamp: 'di 1/14/98 09:30'!initialize   "TextAction initialize"	Purple _ Color r: 0.4 g: 0 b: 1.0! !TextAttribute subclass: #TextAnchor	instanceVariableNames: 'anchoredMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextAnchor commentStamp: 'di 5/22/1998 16:38' prior: 0!TextAnchor comment:'TextAnchors support anchoring of images in text.  A TextAnchor exists as an attribute of text emphasis, and it gets control like a FontReference, through the emphasizeScanner: message.  Depending on whether its anchoredMorph is a Morph or a Form, it repositions the morph, or displays the form respectively.  The coordination between composition, display and selection can best be understood by browsing the various implementations of placeEmbeddedObject:.In the morphic world, simply embed any morph in text.  In the old world, you can create an image reference using code such as the following.	ParagraphEditor new clipboardTextPut:		(Text string: ''*''			attribute: (TextAnchor new anchoredMorph: Form fromUser))In this case you select a piece of the screen, and it gets anchored to a one-character text in the editor''s past buffer.  If you then paste into some other text, you will see the image as an embedded image.'!!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 13:21'!= other 	^ (other class == self class) 		and: [other anchoredMorph = anchoredMorph]! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 13:21'!anchoredMorph	^ anchoredMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 10:47'!anchoredMorph: aMorph 	anchoredMorph _ aMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 14:34'!emphasizeScanner: scanner	scanner placeEmbeddedObject: anchoredMorph! !!TextAnchor methodsFor: 'all' stamp: 'di 11/10/97 14:08'!mayBeExtended	"A textAnchor is designed to modify only a single character, and therefore must not be extended by the ParagraphEditor's emphasisHere facility"	^ false! !Object subclass: #TextAttribute	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextAttribute commentStamp: 'di 5/22/1998 16:38' prior: 0!TextAttribute comment:'Tells a piece of text to be a certain way.Select text, press Command-6, choose a attribute.  If selected text is of the form 	Hi There<Smalltalk beep>the part in angle brackets is saved for action, and the Hi There appears in the paragraph.  If selection has no angle brackets, use the whole thing as both the text and the action.TextDoIt  --  eval as a Smalltalk expression (the part in angle brackets)TextLink -- Show a method, class comment, class hierarchy, or class defintion.	<Point extent:>, <Point Comment>, <Point Hierarchy>, or <Point Defintion> are what you type.TextURL -- Show the web page. <www.disney.com>These attributes of text need to be stored on the disk in a regular file-out.  It is done in this form: 	(ascii 2)<!!do Smalltalk beep(ascii 3)>Hi There(ascii 3)<!!>	(ascii 2)<!!li Point extent:(ascii 3)>Click here to see the extent: method(ascii 3)<!!>The brackets are for people to see in fileOuts.  The wierd ascii are for the scanner to pick up easily.'!!TextAttribute methodsFor: 'as yet unclassified'!actOnClickFor: model	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:09'!dominatedByCmd0	"Subclasses may override if cmd-0 should turn them off"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!dominates: another	"Subclasses may override condense multiple attributes"	^ false! !!TextAttribute methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Subclasses may override to set, eg, font, color, etc"! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	"No action is the default.  Overridden by font specs"! !!TextAttribute methodsFor: 'as yet unclassified'!mayActOnClick	"Subclasses may override to provide, eg, hot-spot actions"	^ false! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 11/10/97 14:05'!mayBeExtended	"A quality that may be overridden by subclasses, such as TextAnchors, that really only apply to a single character"	^ true! !!TextAttribute methodsFor: 'as yet unclassified'!oldEmphasisCode: default	"Allows running thorugh possibly multiple attributes	and getting the emphasis out of any that has an emphasis (font number)"	^ default! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:03'!reset	"Allow subclasses to prepare themselves for merging attributes"! !!TextAttribute methodsFor: 'as yet unclassified'!set	"Respond true to include this attribute (as opposed to, eg, a bold	emphasizer that is clearing the property"	^ true! !TextAttribute subclass: #TextColor	instanceVariableNames: 'color '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextColor commentStamp: 'di 5/22/1998 16:38' prior: 0!TextColor comment:'A TextColor encodes a text color change applicable over a given range of text.'!!TextColor methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:19'!= other 	^ (other class == self class) 		and: [other color = color]! !!TextColor methodsFor: 'as yet unclassified'!color	^ color! !!TextColor methodsFor: 'as yet unclassified'!color: aColor	color _ aColor! !!TextColor methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextColor methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the emphasis for text display"	scanner textColor: color! !!TextColor methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: color! !!TextColor methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:47'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn str |	strm nextPut: $c.	(nn _ color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		str _ '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextColor class	instanceVariableNames: ''!!TextColor class methodsFor: 'as yet unclassified'!black	^ self new color: Color black! !!TextColor class methodsFor: 'as yet unclassified'!blue	^ self new color: Color blue! !!TextColor class methodsFor: 'as yet unclassified'!color: aColor	^ self new color: aColor! !!TextColor class methodsFor: 'as yet unclassified'!cyan	^ self new color: Color cyan! !!TextColor class methodsFor: 'as yet unclassified'!green	^ self new color: Color green! !!TextColor class methodsFor: 'as yet unclassified'!magenta	^ self new color: Color magenta! !!TextColor class methodsFor: 'as yet unclassified'!red	^ self new color: Color red! !!TextColor class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:50'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit ifTrue: [		r _ (strm next: 3) asNumber.		g _ (strm next: 3) asNumber.		b _ (strm next: 3) asNumber.		^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !!TextColor class methodsFor: 'as yet unclassified'!yellow	^ self new color: Color yellow! !PluggableTextMorph subclass: #TextComponent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Components'!!TextComponent methodsFor: 'all' stamp: 'di 5/3/1998 20:24'!initComponentIn: aLayout	super initComponentIn: aLayout.	self setText: self getText! !!TextComponent methodsFor: 'all' stamp: 'di 5/1/1998 23:19'!initFromPinSpecs	| ioPin |	ioPin _ pinSpecs first.	ioPin isInput ifTrue: [getTextSelector _ ioPin modelReadSelector]					ifFalse: [getTextSelector _ nil].	ioPin isOutput ifTrue: [setTextSelector _ ioPin modelWriteSelector]					ifFalse: [setTextSelector _ nil].! !!TextComponent methodsFor: 'all' stamp: 'di 5/1/1998 13:39'!initPinSpecs 	pinSpecs _ Array		with: (PinSpec new pinName: 'text' direction: #inputOutput				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getTextSelector modelWriteSelector: setTextSelector				defaultValue: 'some text' pinLoc: 1.5)! !!TextComponent methodsFor: 'all' stamp: 'di 5/3/1998 13:37'!initialize	super initialize.	self extent: 144@32! !Object subclass: #TextContainer	instanceVariableNames: 'textMorph shadowForm vertProfile minWidth rectangleCache fillsOwner avoidsOcclusions '	classVariableNames: 'OuterMargin '	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextContainer commentStamp: 'di 5/22/1998 16:38' prior: 0!TextContainer comment:'A TextContainer models the shape of an ownerMorph, possibly occluded by one or more occludingMorphs, and scans this shape to provide a list of rectangles suitable for layout of text.  It does this by displaying the shadow of the ownerMorph in black, and any occludingMorphs in white, on its shadowForm.  It then scans horizontal strips of appropriate height to find unbroken intervals of black, greater than minWidth in extent.  Conputation of the rectangles is done on demand, and results are cached so that text can be redisplayed without having to recompute the rectangles.'!!TextContainer methodsFor: 'access' stamp: 'di 11/4/97 14:05'!avoidsOcclusions	^ avoidsOcclusions ifNil: [false]! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!avoidsOcclusions: aBoolean	avoidsOcclusions _ aBoolean.	self releaseCachedState! !!TextContainer methodsFor: 'access' stamp: 'di 11/4/97 14:05'!fillsOwner	^ fillsOwner ifNil: [true]! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!fillsOwner: aBoolean	fillsOwner _ aBoolean.	self releaseCachedState! !!TextContainer methodsFor: 'access' stamp: 'jm 11/19/97 19:28'!paragraphClass	^ NewParagraph! !!TextContainer methodsFor: 'access' stamp: 'di 11/16/97 09:39'!releaseCachedState	shadowForm _ nil.	vertProfile _ nil.	rectangleCache _ Dictionary new.! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/27/97 23:09'!bottom	"Note we should really check for contiguous pixels here"	^ (self vertProfile findLast: [:count | count >= minWidth])		+ shadowForm offset y! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:33'!left 	^ textMorph owner left! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/17/97 11:35'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ self shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/16/97 09:33'!top	"Note we should really check for contiguous pixels here"	| outerWidth |	outerWidth _ minWidth + (2*OuterMargin).	^ (self vertProfile findFirst: [:count | count >= outerWidth]) - 1		+ shadowForm offset y! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:33'!topLeft  "for compatibility"	^ textMorph owner topLeft! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/7/97 12:01'!translateBy: delta	self releaseCachedState! !!TextContainer methodsFor: 'container protocol' stamp: 'di 10/28/97 18:32'!width  "for compatibility"	^ textMorph owner width! !!TextContainer methodsFor: 'private' stamp: 'di 3/1/98 11:42'!bounds	| bounds |	self fillsOwner ifFalse: [^ textMorph textBounds].	bounds _ textMorph owner bounds.	textMorph owner submorphsBehind: textMorph do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'di 11/16/97 15:15'!computeShadow	| canvas back bounds |	bounds _ self bounds.	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fillsOwner		ifTrue: [(textMorph owner copyWithoutSubmorph: textMorph) fullDrawOn: canvas]		ifFalse: [canvas fillRectangle: textMorph bounds color: Color black].	self avoidsOcclusions ifTrue:		[back _ canvas form deepCopy.		canvas form fillWhite.		textMorph owner submorphsInFrontOf: textMorph do:			[:m | (textMorph isLinkedTo: m)				ifTrue: []				ifFalse: [m fullDrawOn: canvas]].		back displayOn: canvas form at: 0@0 rule: Form reverse].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextContainer methodsFor: 'private' stamp: 'di 11/4/97 14:06'!for: aTextMorph minWidth: wid	textMorph _ aTextMorph.	minWidth _ wid.	fillsOwner _ true.	avoidsOcclusions _ false.! !!TextContainer methodsFor: 'private' stamp: 'di 10/27/97 23:09'!shadowForm	shadowForm ifNil: [self computeShadow].	^ shadowForm! !!TextContainer methodsFor: 'private' stamp: 'di 10/27/97 23:08'!vertProfile	vertProfile ifNil: [self computeShadow].	^ vertProfile! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextContainer class	instanceVariableNames: ''!!TextContainer class methodsFor: 'initialization' stamp: 'di 11/16/97 09:25'!initialize    "TextContainer initialize"	OuterMargin _ 2! !TextAction subclass: #TextDoIt	instanceVariableNames: 'evalString '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!actOnClickFor: anObject	"Note: evalString gets evaluated IN THE CONTEXT OF anObject	 -- meaning that self and all instVars are accessible"	Compiler evaluate: evalString for: anObject logged: false.	^ true ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:46'!analyze: aString	| list |	list _ super analyze: aString.	evalString _ list at: 1.	^ list at: 2! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:01'!evalString: str	evalString _ str ! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ evalString! !!TextDoIt methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:46'!writeScanOn: strm	strm nextPut: $d; nextPutAll: evalString; nextPutAll: ';;'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextDoIt class	instanceVariableNames: ''!!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 20:28'!evalString: str	^ self new evalString: str! !!TextDoIt class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:06'!scanFrom: strm	"read a doit in the funny format used by Text styles on files. d10 factorial;;  end with two semicolons"	| pos end doit |	pos _ strm position.	[strm skipTo: $;. strm peek == $;] whileFalse.	end _ strm position - 1.	strm position: pos.	doit _ strm next: end-pos.	strm skip: 2.  ";;"	^ self evalString: doit! !TextAttribute subclass: #TextEmphasis	instanceVariableNames: 'emphasisCode setMode '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextEmphasis commentStamp: 'di 5/22/1998 16:38' prior: 0!TextEmphasis comment:'A TextEmphasis, encodes a characteristic applicable to all fonts.  The encoding is as follows:	1	bold	2	itallic	4	underlined	8	narrow	16	struck out'!!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other emphasisCode = emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:11'!dominatedByCmd0	"Cmd-0 should turn off emphasis"	^ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:13'!dominates: other	(emphasisCode = 0 and: [other dominatedByCmd0]) ifTrue: [^ true].	^ (other class == self class)		and: [emphasisCode = other emphasisCode]! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode	^ emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!emphasisCode: int	emphasisCode _ int.	setMode _ true! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:57'!emphasizeScanner: scanner	"Set the emphasist for text scanning"	scanner addEmphasis: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' code: '; print: emphasisCode! !!TextEmphasis methodsFor: 'as yet unclassified'!set	^ setMode and: [emphasisCode ~= 0]! !!TextEmphasis methodsFor: 'as yet unclassified'!turnOff	setMode _ false! !!TextEmphasis methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:28'!writeScanOn: strm	emphasisCode = 1 ifTrue: [strm nextPut: $b].	emphasisCode = 2 ifTrue: [strm nextPut: $i].	emphasisCode = 0 ifTrue: [strm nextPut: $n].	emphasisCode = 16 ifTrue: [strm nextPut: $=].	emphasisCode = 4 ifTrue: [strm nextPut: $u].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextEmphasis class	instanceVariableNames: ''!!TextEmphasis class methodsFor: 'as yet unclassified'!bold	^ self new emphasisCode: 1! !!TextEmphasis class methodsFor: 'as yet unclassified'!italic	^ self new emphasisCode: 2! !!TextEmphasis class methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:05'!narrow	^ TextKern kern: -1! !!TextEmphasis class methodsFor: 'as yet unclassified'!normal	^ self new emphasisCode: 0! !!TextEmphasis class methodsFor: 'as yet unclassified'!struckOut	^ self new emphasisCode: 16! !!TextEmphasis class methodsFor: 'as yet unclassified'!underlined	^ self new emphasisCode: 4! !TextAttribute subclass: #TextFontChange	instanceVariableNames: 'fontNumber '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextFontChange commentStamp: 'di 5/22/1998 16:38' prior: 0!TextFontChange comment:'A TextFontChange encodes a font change applicable over a given range of text.  The font number is interpreted relative to the textStyle governing display of this text.'!!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other fontNumber = fontNumber]! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:20'!dominates: other	^ other class == self class! !!TextFontChange methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the font for text display"	scanner setFont: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber	^ fontNumber! !!TextFontChange methodsFor: 'as yet unclassified'!fontNumber: int	fontNumber _ int! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:46'!forFontInStyle: aTextStyle do: aBlock	aBlock value: (aTextStyle fontAt: fontNumber)! !!TextFontChange methodsFor: 'as yet unclassified'!printOn: strm	super printOn: strm.	strm nextPutAll: ' font: '; print: fontNumber! !!TextFontChange methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:22'!writeScanOn: strm	strm nextPut: $f.	fontNumber printOn: strm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextFontChange class	instanceVariableNames: ''!!TextFontChange class methodsFor: 'as yet unclassified'!font1	^ self new fontNumber: 1! !!TextFontChange class methodsFor: 'as yet unclassified'!font2	^ self new fontNumber: 2! !!TextFontChange class methodsFor: 'as yet unclassified'!font3	^ self new fontNumber: 3! !!TextFontChange class methodsFor: 'as yet unclassified'!font4	^ self new fontNumber: 4! !!TextFontChange class methodsFor: 'as yet unclassified'!fontNumber: n	^ self new fontNumber: n! !TextFontChange subclass: #TextFontReference	instanceVariableNames: 'font '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextFontReference commentStamp: 'di 5/22/1998 16:38' prior: 0!TextFontReference comment:'A TextFontReference encodes a font change applicable over a given range of text.  The font reference is absolute:  unlike a TextFontChange, it is independent of the textStyle governing display of this text.'!!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [font == font]! !!TextFontReference methodsFor: 'as yet unclassified'!emphasizeScanner: scanner	"Set the actual font for text display"	scanner setActualFont: font! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 11/9/97 17:47'!forFontInStyle: aTextStyle do: aBlock	aBlock value: font! !!TextFontReference methodsFor: 'as yet unclassified'!toFont: aFont	font _ aFont! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextFontReference class	instanceVariableNames: ''!!TextFontReference class methodsFor: 'as yet unclassified'!toFont: aFont	^ self new toFont: aFont! !TextAttribute subclass: #TextKern	instanceVariableNames: 'kern active '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextKern commentStamp: 'di 5/22/1998 16:38' prior: 0!TextKern comment:'A TextKern encodes a kerning change applicable over a given range of text.  Positive values of kern spread letters out, negative kern will cause them to overlap more.  Note that kerns other than 0 will display somewhat slower, as kerning is not yet supported in the text scanning primitive. '!!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:15'!= other 	^ (other class == self class) 		and: [other kern = kern]! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 13:10'!dominatedByCmd0	"Cmd-0 should turn off kerning"	^ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:10'!dominates: other	"NOTE: The use of active in this code is specific to its use in the method		Text class addAttribute: att toArray: others"	(active and: [other class == self class and: [other kern + kern = 0]])		ifTrue: [active _ false.  ^ true].  "can only dominate once"	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:50'!emphasizeScanner: scanner	"Augment (or diminish) the kerning offset for text display"	scanner addKern: kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:12'!kern	^ kern! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 09:59'!kern: kernValue	kern _ kernValue.	self reset.! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:04'!reset	active _ true! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 10/31/97 11:11'!set	^ active! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:31'!writeScanOn: strm	kern > 0 ifTrue: [		kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		0-kern do: [:kk | strm nextPut: $-]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextKern class	instanceVariableNames: ''!!TextKern class methodsFor: 'as yet unclassified' stamp: 'di 10/29/97 11:49'!kern: kernValue	^ self new kern: kernValue! !Object subclass: #TextLine	instanceVariableNames: 'left right top bottom firstIndex lastIndex internalSpaces paddingWidth baseline leftMargin '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextLine commentStamp: 'di 5/22/1998 16:38' prior: 0!TextLine comment:'A TextLine embodies the layout of a line of composed text.	left right top bottom		The full line rectangle	firstIndex lastIndex		Starting and stopping indices in the full text	internalSpaces		Number of spaces to share paddingWidth	paddingWidth		Number of pixels of extra space in full line	baseline				Distance of baseline below the top of the line	leftMargin			Left margin due to paragraph indentationTextLine''s rather verbose message protocol is required for compatibility with the old CharacterScanners.'!!TextLine methodsFor: 'accessing'!baseline	^ baseline! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!bottom	^ bottom! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!bottomRight	^ right@bottom! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:12'!first	^ firstIndex! !!TextLine methodsFor: 'accessing'!internalSpaces	"Answer the number of spaces in the line."	^internalSpaces! !!TextLine methodsFor: 'accessing'!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces _ spacesInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:14'!last	^ lastIndex! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!left	^ left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!leftMargin	"This has to get fixed -- store during composition"	^ self left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:47'!leftMargin: lm	leftMargin _ lm! !!TextLine methodsFor: 'accessing' stamp: 'di 10/26/97 16:03'!leftMarginForAlignment: alignmentCode	alignmentCode = 1 ifTrue: [^ self left + paddingWidth].  "right flush"	alignmentCode = 2 ifTrue: [^ self left + (paddingWidth//2)].  "centered"	^ self left  "leftFlush and justified"! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!lineHeight	^ bottom - top! !!TextLine methodsFor: 'accessing'!paddingWidth	"Answer the amount of space to be added to the font."	^paddingWidth! !!TextLine methodsFor: 'accessing'!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth _ padWidthInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 20:00'!rectangle	^ self topLeft corner: self bottomRight! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:59'!rectangle: lineRectangle	left _ lineRectangle left.	right _ lineRectangle right.	top _ lineRectangle top.	bottom _ lineRectangle bottom.	leftMargin _ left! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!right	^ right! !!TextLine methodsFor: 'accessing' stamp: 'di 10/21/97 20:42'!rightMargin	"This has to get fixed -- store during composition"	^ self right! !!TextLine methodsFor: 'accessing' stamp: 'di 11/26/97 16:18'!setRight: x	right _ x! !!TextLine methodsFor: 'accessing' stamp: 'di 10/20/97 23:27'!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	lastIndex _ stopInteger! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!top	^ top! !!TextLine methodsFor: 'accessing' stamp: 'di 10/23/97 19:58'!topLeft	^ left @ top! !!TextLine methodsFor: 'accessing' stamp: 'di 11/26/97 16:58'!width	^ right - left! !!TextLine methodsFor: 'comparing' stamp: 'di 10/20/97 23:24'!= line	self species = line species		ifTrue: [^((firstIndex = line first and: [lastIndex = line last])				and: [internalSpaces = line internalSpaces])				and: [paddingWidth = line paddingWidth]]		ifFalse: [^false]! !!TextLine methodsFor: 'scanning'!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!TextLine methodsFor: 'scanning'!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	extraPad _ paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!TextLine methodsFor: 'updating' stamp: 'di 11/7/97 08:32'!moveBy: delta 	"Move my rectangle by the given delta"	left _ left + delta x.	right _ right + delta x.	top _ top + delta y.	bottom _ bottom + delta y.! !!TextLine methodsFor: 'updating' stamp: 'di 10/20/97 23:25'!slide: delta 	"Change the starting and stopping points of the line by delta."	firstIndex _ firstIndex + delta.	lastIndex _ lastIndex + delta! !!TextLine methodsFor: 'private' stamp: 'di 10/20/97 23:08'!firstIndex: firstInteger lastIndex: lastInteger	firstIndex _ firstInteger.	lastIndex _ lastInteger! !!TextLine methodsFor: 'private'!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces _ spacesInteger.	paddingWidth _ padWidthInteger! !!TextLine methodsFor: 'private' stamp: 'di 10/23/97 19:57'!lineHeight: height baseline: ascent	bottom _ top + height.	baseline _ ascent! !!TextLine methodsFor: 'private' stamp: 'di 10/23/97 23:19'!printOn: aStream	super printOn: aStream.	aStream space; print: firstIndex; nextPutAll: ' to: '; print: lastIndex! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextLine class	instanceVariableNames: ''!!TextLine class methodsFor: 'instance creation' stamp: 'di 10/20/97 23:08'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| line |	line _ self new firstIndex: startInteger lastIndex: stopInteger.	^ line internalSpaces: spacesInteger paddingWidth: padWidthInteger! !Interval subclass: #TextLineInterval	instanceVariableNames: 'internalSpaces paddingWidth lineHeight baseline '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!TextLineInterval commentStamp: 'di 5/22/1998 16:38' prior: 0!TextLineInterval comment:'My instances specify the starting and stopping points in a String of a composed line. The step is always 1.'!!TextLineInterval methodsFor: 'accessing'!baseline	^ baseline! !!TextLineInterval methodsFor: 'accessing'!internalSpaces	"Answer the number of spaces in the line."	^internalSpaces! !!TextLineInterval methodsFor: 'accessing'!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces _ spacesInteger! !!TextLineInterval methodsFor: 'accessing'!lineHeight	^ lineHeight! !!TextLineInterval methodsFor: 'accessing'!paddingWidth	"Answer the amount of space to be added to the font."	^paddingWidth! !!TextLineInterval methodsFor: 'accessing'!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth _ padWidthInteger! !!TextLineInterval methodsFor: 'accessing'!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	stop _ stopInteger! !!TextLineInterval methodsFor: 'comparing'!= line	self species = line species		ifTrue: [^((start = line first and: [stop = line last])				and: [internalSpaces = line internalSpaces])				and: [paddingWidth = line paddingWidth]]		ifFalse: [^false]! !!TextLineInterval methodsFor: 'scanning'!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!TextLineInterval methodsFor: 'scanning'!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad _ paddingWidth // internalSpaces.	extraPad _ paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!TextLineInterval methodsFor: 'updating'!slide: delta 	"Change the starting and stopping points of the line by delta."	start _ start + delta.	stop _ stop + delta! !!TextLineInterval methodsFor: 'private'!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces _ spacesInteger.	paddingWidth _ padWidthInteger! !!TextLineInterval methodsFor: 'private'!lineHeight: height baseline: ascent	lineHeight _ height.	baseline _ ascent! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextLineInterval class	instanceVariableNames: ''!!TextLineInterval class methodsFor: 'instance creation'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| newSelf |	newSelf _ super from: startInteger to: stopInteger by: 1.	^newSelf internalSpaces: spacesInteger paddingWidth: padWidthInteger! !TextAction subclass: #TextLink	instanceVariableNames: 'classAndMethod '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/28/97 23:11'!actOnClickFor: anObject	"Open an new LinkedMessageSet and show this method in it.  If anObject is already a LinkedMessageSet, then just add to the end of the list.  (Class method) (Class Comment) (Class Definition) (Class Hierarchy)"	anObject linkMethod: classAndMethod.	^ true! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:49'!analyze: aString	| list |	list _ super analyze: aString.	classAndMethod _ list at: 1.	^ list at: 2! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 20:52'!analyze: aString with: nonMethod	"Initalize this attribute holder with a piece text the user typed into a paragraph.  Returns the text to emphesize (may be different from selection)  Does not return self!!.  nonMethod is what to show when clicked, i.e. the last part of specifier (Comment, Definition, or Hierarchy).  May be of the form:Point<Point>Click Here<Point><Point>Click Here"	"Obtain the showing text and the instructions"	| b1 b2 trim |	b1 _ aString indexOf: $<.	b2 _ aString indexOf: $>.	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"		classAndMethod _ self validate: aString, ' ', nonMethod.		^ classAndMethod size = 0 ifTrue: [nil] ifFalse: [aString]].	"Two parts"	trim _ aString withBlanksTrimmed.	(trim at: 1) == $< 		ifTrue: [(trim last) == $>			ifTrue: ["only instructions" 				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] ifFalse: [classAndMethod]]			ifFalse: ["at the front"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: b2+1 to: aString size]]]		ifFalse: [(trim last) == $>			ifTrue: ["at the end"				classAndMethod _ self validate: (aString copyFrom: b1+1 to: b2-1), ' ', nonMethod.				^ classAndMethod size = 0 ifTrue: [nil] 						ifFalse: [aString copyFrom: 1 to: b1-1]]			ifFalse: ["Illegal -- <> has text on both sides"				^ nil]]! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/5/97 17:09'!classAndMethod: aString	classAndMethod _ aString! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ classAndMethod! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/6/97 19:28'!validate: specString	"Can this string be decoded to be Class space Method (or Comment, Definition, Hierarchy)? If so, return it in valid format, else nil" 	| list first mid last |	list _ specString findTokens: ' 	.|'.	list size > 3 ifTrue: [^ nil].	list size < 2 ifTrue: [^ nil].	Symbol hasInterned: list first ifTrue: [:sym | first _ sym].	first ifNil: [^ nil].	Smalltalk at: first ifAbsent: [^ nil].	mid _ list size = 3 		ifTrue: [(list at: 2) = 'class' ifTrue: ['class '] ifFalse: [^ nil]]		ifFalse: [''].	"OK if method name is not interned -- may not be defined yet"	last _ list last.	last first isUppercase ifTrue: [		(#('Comment' 'Definition' 'Hierarchy') includes: last) ifFalse: [^ nil]].	^ first, ' ', mid, last! !!TextLink methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:44'!writeScanOn: strm	strm nextPut: $L; nextPutAll: classAndMethod; nextPut: $;! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextLink class	instanceVariableNames: ''!!TextLink class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:53'!scanFrom: strm	"read a link in the funny format used by Text styles on files. LPoint +;LPoint Comment;"	^ self new classAndMethod: (strm upTo: $;)! !Morph subclass: #TextMorph	instanceVariableNames: 'textStyle text wrapFlag paragraph editor container predecessor successor '	classVariableNames: 'CaretForm '	poolDictionaries: ''	category: 'Morphic-Basic'!!TextMorph commentStamp: 'di 5/22/1998 16:38' prior: 0!TextMorph comment:'TextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as imbedded hot links, and the (soon to be released) ability to embed submorphs in the text.  If text has been embedded in another object, one can elect to fill the owner''s bounds, in which case the text will be laid out in the shape of the owner''s shadow image (including any submorphs othe than the text).  One can also elect to have the text avoid occlusions, in which case it will avoid the bounds of any sibling morphs that appear in front of it.  It may be necessary to update bounds in order for the text runaround to notice the presence of a new occluding shape.'!!TextMorph methodsFor: 'initialization' stamp: 'di 12/29/97 14:42'!beAllFont: aFont	textStyle _ TextStyle fontArray: (Array with: aFont).	self releaseCachedState; changed! !!TextMorph methodsFor: 'initialization' stamp: 'sw 10/2/97 15:16'!configureForKids	super configureForKids.	self lock! !!TextMorph methodsFor: 'initialization' stamp: 'di 11/12/97 09:31'!copy	^ super copy text: text copy textStyle: textStyle copy 		wrap: wrapFlag color: color		predecessor: nil successor: nil! !!TextMorph methodsFor: 'initialization' stamp: 'di 9/30/97 09:25'!initialize	super initialize.	color _ Color black.	textStyle _ TextStyle default copy.	wrapFlag _ true.! !!TextMorph methodsFor: 'initialization' stamp: 'jm 11/13/97 16:32'!releaseCachedState	super releaseCachedState.	self releaseParagraph.! !!TextMorph methodsFor: 'initialization' stamp: 'di 10/20/97 20:14'!string: aString fontName: aName size: aSize	self contentsWrapped: aString.	textStyle _ (TextStyle named: aName asSymbol) copy.	textStyle ifNil: [self halt: 'Error: font ', aName, ' not found.'].	text addAttribute: (TextFontChange fontNumber: (textStyle fontIndexOfSize: aSize))! !!TextMorph methodsFor: 'accessing' stamp: 'sw 1/12/98 23:40'!asText	^ text! !!TextMorph methodsFor: 'accessing'!contents	^ text! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:48'!contents: stringOrText	^ self contentsAsIs: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 4/14/98 08:33'!contents: stringOrText wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result."	self newContents: ''.	wrapFlag _ true.	super extent: width truncated@self height.	self newContents: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:48'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	self newContents: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 09:51'!contentsWrapped: stringOrText	"Accept new text contents.  Lay it out, wrapping within my current width.	Then fit my height to the result."	wrapFlag _ true.	self newContents: stringOrText! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/29/97 11:47'!copyRecordingIn: dict	"Overridden to copy deeper text structure."	^ (super copyRecordingIn: dict)		text: text copy textStyle: textStyle copy! !!TextMorph methodsFor: 'accessing' stamp: 'di 4/11/98 16:31'!editor	^ self installEditor! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 15:37'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text _ newText.	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:19'!centered 	self paragraph centered.	self updateFromParagraph ! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!justified 	self paragraph justified.	self updateFromParagraph! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!leftFlush 	self paragraph leftFlush.	self updateFromParagraph! !!TextMorph methodsFor: 'alignment' stamp: 'di 10/25/97 19:20'!rightFlush 	self paragraph rightFlush.	self updateFromParagraph! !!TextMorph methodsFor: 'drawing' stamp: 'di 12/1/97 03:27'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	container ifNil:			[aCanvas frameRectangle: bounds color: Color green]		ifNotNil:			[self paragraph lines do:				[:line | aCanvas frameRectangle: line rectangle color: Color green]].! !!TextMorph methodsFor: 'drawing' stamp: 'sw 4/23/1998 22:07'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size	ifTrue:		["make null text frame visible"		aCanvas fillRectangle: bounds color: Color lightRed]	ifFalse:		[aCanvas newParagraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 10:57'!acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing.	This default implementation does nothing."	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 4/22/1998 11:00'!cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing.	This default implementation does nothing."	self releaseParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:27'!chooseAlignment	self installEditor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:27'!chooseEmphasis	self installEditor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:28'!chooseFont	self installEditor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 9/30/97 10:28'!chooseStyle	self installEditor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'sw 1/12/98 23:34'!clearTypeIn	self newContents: ' '! !!TextMorph methodsFor: 'editing' stamp: 'di 4/12/98 11:36'!handleEdit: editBlock	"Ensure that changed areas get suitably redrawn"	self selectionChanged.  "Note old selection"		editBlock value.	self selectionChanged.  "Note new selection"	self updateFromParagraph  "Propagate changes as necessary"! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 19:59'!handleInteraction: interActionBlock fromEvent: evt	self installEditor.  "Make sure editor is installed"	editor sensor: (KeyboardBuffer new startingEvent: evt).  "Fool MVC"	self selectionChanged.  "Note old selection"		interActionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'jm 11/4/97 15:00'!handlesMouseDown: evt	(self hasProperty: #partsDonor) ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'editing' stamp: 'di 9/29/97 11:46'!hasFocus	^ editor ~~ nil! !!TextMorph methodsFor: 'editing' stamp: 'di 4/21/1998 13:22'!hasUnacceptedEdits: aBoolean	"Ignored here, but noted in TextMorphForEditView"! !!TextMorph methodsFor: 'editing' stamp: 'di 11/7/97 12:55'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self installEditor]]		ifFalse: ["A hand has clicked elsewhere..."				w _ self world.				(w notNil and: 					[(w hands collect: [:h | h keyboardFocus]) includes: self])					ifFalse: ["Release control unless some hand is still holding on"							self releaseEditor]].! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:05'!keyStroke: evt	"Handle a keystroke event."	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseDown: evt	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	evt hand newKeyboardFocus: self.	self handleInteraction: [editor mouseDown: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseMove: evt	evt redButtonPressed ifFalse: [^ self].	self handleInteraction: [editor mouseMove: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 12/3/97 20:04'!mouseUp: evt	self handleInteraction: [editor mouseUp: evt] fromEvent: evt! !!TextMorph methodsFor: 'editing' stamp: 'di 11/7/97 12:58'!passKeyboardFocusTo: otherMorph	| w |	w _ self world.	w notNil ifTrue: 		[w hands do:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].	"Release control unless some hand is still holding on"	self releaseEditor.! !!TextMorph methodsFor: 'editing'!xeqLinkText: sourceString withParameter: param	self confirm: 'xeqLinkText:' asText allBold , sourceString asText! !!TextMorph methodsFor: 'printing'!fullPrintOn: aStream	aStream nextPutAll: '('.	super fullPrintOn: aStream.	aStream nextPutAll: ') contents: '; print: text! !!TextMorph methodsFor: 'geometry' stamp: 'di 3/1/98 11:35'!bounds	container ifNil: [^ bounds].	^ container bounds! !!TextMorph methodsFor: 'geometry' stamp: 'jm 10/28/97 18:31'!container	"Return the container for composing this text.  There are four cases:	1.  container is specified as, eg, an arbitrary shape,	2.  container is specified as the bound rectangle, because		this morph is linked to others,	3.  container is nil, and wrap is true -- grow downward as necessary,	4.  container is nil, and wrap is false -- grow in 2D as nexessary."	container ifNil:		[successor ifNotNil: [^ self bounds].		wrapFlag ifTrue: [^ self bounds withHeight: 99999].		^ self position extent: 99999@99999].	^ container! !!TextMorph methodsFor: 'geometry' stamp: 'jm 11/19/97 22:57'!containsPoint: aPoint	self startingIndex > text size ifTrue:		["make null text frame visible"		^ true].	^ self paragraph containsPoint: aPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 4/14/98 09:31'!extent: aPoint 	self releaseParagraph.  "invalidate the paragraph cache"	super extent: (aPoint truncated max: 9@(textStyle lineGrid+2)).	self fit! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/16/97 16:52'!goBehind	"We need to save the container, as it knows about fill and run-around"	| cont |	container ifNil: [^ super goBehind].	self releaseParagraph.  "Cause recomposition"	cont _ container.  "Save the container"	super goBehind.  "This will change owner, nilling the container"	container _ cont.  "Restore the container"	self changed! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/12/97 09:33'!layoutChanged	self releaseParagraph.	super layoutChanged! !!TextMorph methodsFor: 'geometry' stamp: 'di 11/13/97 14:46'!privateMoveBy: delta	self releaseEditor.	super privateMoveBy: delta.	paragraph ifNotNil: [paragraph moveBy: delta].	container ifNotNil: [container releaseCachedState]! !!TextMorph methodsFor: 'geometry' stamp: 'di 3/1/98 11:40'!textBounds	^ bounds! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	((owner isKindOf: PolygonMorph) and: [owner isOpen]) ifTrue:		[container == nil			ifTrue: [aCustomMenu add: 'follow owner''s curve' action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' action: #setCurveBaseline:]]		ifFalse:		[(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'menu' stamp: 'sw 8/12/97 17:33'!addOptionalHandlesTo: aHalo box: box	| aHandle |	aHandle _ aHalo addHandleAt: box bottomLeft color: Color lightGreen.	aHandle on: #mouseDown send: #chooseFont to: self.	aHandle _ aHalo addHandleAt: (box bottomLeft + (20@0)) color: Color lightRed.	aHandle on: #mouseDown send: #chooseStyle to: self.	aHandle _ aHalo addHandleAt: (box bottomLeft + (40@0)) color: Color lightBrown.	aHandle on: #mouseDown send: #chooseEmphasis to: self.! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 09:32'!followCurve	container _ TextOnCurveContainer new baseline: 0; textDirection: 1.	self changed! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 09:40'!reverseCurveDirection	container textDirection: container textDirection negated.	self paragraph composeAll! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:25'!setCurveBaseline: evt	| handle origin |	origin _ evt cursorPoint.	handle _ HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		container baseline: (newPoint - origin) y negated asInteger // 5.		self paragraph composeAll].	evt hand attachMorph: handle.	handle startStepping	! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:31'!addPredecessor: evt	| newMorph |	newMorph _ TextMorph new text: text textStyle: textStyle wrap: wrapFlag			color: color predecessor: predecessor successor: self.	newMorph extent: self width @ 100.	predecessor ifNotNil: [predecessor setSuccessor: newMorph].	self setPredecessor: newMorph.	predecessor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:31'!addSuccessor: evt	| newMorph |	newMorph _ TextMorph new text: text textStyle: textStyle wrap: wrapFlag			color: color predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	evt hand attachMorph: newMorph! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/8/97 15:51'!firstCharacterIndex	^ self paragraph firstCharacterIndex! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!firstInChain	"Return the first morph in a chain of textMorphs"	| first |	first _ self.  	[first predecessor == nil]		whileFalse: [first _ first predecessor].	^ first! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/16/97 15:15'!isLinkedTo: aMorph	self firstInChain withSuccessorsDo:		[:m | m == aMorph ifTrue: [^ true]].	^ false! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!lastCharacterIndex	^ self paragraph lastCharacterIndex! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!predecessor	^ predecessor! !!TextMorph methodsFor: 'linked frames' stamp: 'di 11/12/97 09:10'!recomposeChain	"Recompose this textMorph and all that follow it."	self withSuccessorsDo:		[:m |  m text: text textStyle: textStyle;  "Propagate new style if any"				releaseParagraph;  "Force recomposition"				fit  "and propagate the change"]! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!startingIndex	predecessor == nil ifTrue: [^ 1].	^ predecessor lastCharacterIndex + 1! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!successor	^ successor! !!TextMorph methodsFor: 'linked frames' stamp: 'jm 10/28/97 18:31'!withSuccessorsDo: aBlock	"Evaluate aBlock for each morph in my successor chain"	| each |	each _ self.	[each == nil]		whileFalse: [aBlock value: each.					each _ each successor]! !!TextMorph methodsFor: 'private' stamp: 'di 11/8/97 16:02'!adjustLineIndicesBy: delta	paragraph ifNotNil: [paragraph adjustLineIndicesBy: delta]! !!TextMorph methodsFor: 'private' stamp: 'di 11/7/97 10:00'!delete	predecessor ifNotNil: [predecessor setSuccessor: successor].	successor ifNotNil: [successor setPredecessor: predecessor.						successor recomposeChain].	super delete! !!TextMorph methodsFor: 'private' stamp: 'di 4/14/98 09:30'!fit	"Adjust bounds to fit the text if not in a rigid container."	| newExtent para |	newExtent _ (self paragraph extent max: 9@textStyle lineGrid) + (0@2).	newExtent ~= bounds extent ifTrue:		[(container == nil and: [successor == nil]) ifTrue:			[para _ paragraph.  "Save para (layoutChanged smashes it)"			super extent: newExtent.			paragraph _ para]].	container ifNotNil:		[self privateBounds: container bounds truncated].	self paragraph positionWhenComposed: self position.	successor ifNotNil:		[successor predecessorChanged].	self changed. "Too conservative: only paragraph composition					should cause invalidation."! !!TextMorph methodsFor: 'private' stamp: 'di 11/7/97 12:55'!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'di 11/13/97 15:17'!loadCachedState	"Prepare for fast response -- next page of a book?"	self paragraph! !!TextMorph methodsFor: 'private' stamp: 'sw 4/23/1998 22:07'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: owner)					compose: text style: textStyle copy					from: self startingIndex in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'private' stamp: 'jm 11/19/97 19:30'!paragraphClass	container ifNil: [^ NewParagraph].	^ container paragraphClass! !!TextMorph methodsFor: 'private' stamp: 'di 11/8/97 15:55'!predecessorChanged	| newStart oldStart |	newStart _ predecessor == nil		ifTrue: [1]		ifFalse: [predecessor lastCharacterIndex + 1].	(self paragraph adjustedFirstCharacterIndex ~= newStart or: [newStart >= text size])		ifTrue: [paragraph composeAllStartingAt: newStart.				self fit]		ifFalse: ["If the offset to end of text has not changed, just slide"				oldStart _ self firstCharacterIndex.				self withSuccessorsDo:					[:m | m adjustLineIndicesBy: newStart - oldStart]].! !!TextMorph methodsFor: 'private' stamp: 'di 12/3/97 10:44'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 11/13/97 14:47'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	self releaseEditor.	paragraph ifNotNil:		[paragraph _ nil].	container ifNotNil:		[container releaseCachedState]! !!TextMorph methodsFor: 'private' stamp: 'di 11/30/97 12:13'!selectionChanged	self paragraph selectionRects do: [:r | self invalidRect: r]! !!TextMorph methodsFor: 'private' stamp: 'sw 4/23/1998 22:09'!setDefaultContentsIfNil	text ifNil: [text _ 'Text forEditing' asText allBold]! !!TextMorph methodsFor: 'private' stamp: 'di 10/25/97 17:11'!setPredecessor: newPredecessor	predecessor _ newPredecessor! !!TextMorph methodsFor: 'private' stamp: 'di 10/25/97 17:10'!setSuccessor: newSuccessor	successor _ newSuccessor! !!TextMorph methodsFor: 'private' stamp: 'di 10/24/97 11:35'!text: t textStyle: s	"Private -- for use only in morphic duplication"	text _ t.	textStyle _ s.	paragraph ifNotNil: [paragraph textStyle: s]! !!TextMorph methodsFor: 'private' stamp: 'di 11/12/97 09:30'!text: t textStyle: s wrap: wrap color: c	predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	text _ t.	textStyle _ s.	wrapFlag _ wrap.	color _ c.	paragraph _ editor _ container _ nil.	predecessor _ pred.	successor _ succ! !!TextMorph methodsFor: 'private' stamp: 'di 5/12/1998 20:56'!updateFromParagraph	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last]! !!TextMorph methodsFor: 'private' stamp: 'di 11/11/97 20:45'!updateReferencesUsing: refDict	| anchors range new |	super updateReferencesUsing: refDict.	"Update any anchors in the text of a newly copied morph"	anchors _ IdentityDictionary new.	text runs withStartStopAndValueDo:		[:start :stop :attributes |		attributes do: [:att | (att isMemberOf: TextAnchor)							ifTrue: [anchors at: att put: (start to: stop)]]].	anchors isEmpty ifTrue: [^ self].	anchors keysDo:		[:old |  range _ anchors at: old.		text removeAttribute: old from: range first to: range last.		new _ TextAnchor new anchoredMorph:					(refDict at: old anchoredMorph).		text addAttribute: new from: range first to: range last].	self layoutChanged "for good measure"! !!TextMorph methodsFor: 'object fileIn' stamp: 'di 10/1/97 19:47'!convertbosfceptthpeh0: varDict bosfcepttwpe0: smartRefStrm	"These variables are automatically stored into the new instance ('textStyle' 'text' 'paragraph' 'editor' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('wrapFlag' ) and deal with the information in ('hasFocus' 'hideSelection' )"	wrapFlag _ true.	editor _ nil.	self updateFromParagraph; releaseParagraph.! !!TextMorph methodsFor: 'object fileIn' stamp: 'di 10/24/97 22:01'!convertbosfcepttwpe0: varDict bosfcepttwpecps0: smartRefStrm	"These variables are automatically stored into the new instance ('textStyle' 'text' 'wrapFlag' 'paragraph' 'editor' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('container' 'predecessor' 'successor' ) and deal with the information in ()" 	container _ predecessor _ successor _ nil! !!TextMorph methodsFor: 'containment' stamp: 'di 11/4/97 15:37'!fillingOnOff	"Establish a container for this text, with opposite filling status"	self setContainer:	(container		ifNil: [TextContainer new for: self minWidth: textStyle lineGrid*2]		ifNotNil: [(container fillsOwner and: [container avoidsOcclusions not])			ifTrue: [nil  "Return to simple rectangular bounds"]			ifFalse: [container fillsOwner: container fillsOwner not]])! !!TextMorph methodsFor: 'containment' stamp: 'di 11/4/97 15:37'!occlusionsOnOff	"Establish a container for this text, with opposite occlusion avoidance status"	self setContainer:	(container	ifNil: [(TextContainer new for: self minWidth: textStyle lineGrid*2)							fillsOwner: false; avoidsOcclusions: true]	ifNotNil: [(container avoidsOcclusions and: [container fillsOwner not])			ifTrue: [nil  "Return to simple rectangular bounds"]			ifFalse: [container avoidsOcclusions: container avoidsOcclusions not]])! !!TextMorph methodsFor: 'containment' stamp: 'di 11/16/97 15:15'!ownerChanged	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'containment' stamp: 'di 10/28/97 11:00'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [self setContainer: nil]! !!TextMorph methodsFor: 'containment' stamp: 'di 11/12/97 09:06'!setContainer: newContainer	"Adopt (or abandon) container shape"	self changed.	container _ newContainer.	self releaseParagraph! !!TextMorph methodsFor: 'anchors' stamp: 'di 2/25/98 20:25'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphFront: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld transform: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TextMorph methodsFor: 'anchors' stamp: 'di 2/25/98 20:37'!privateRemoveMorph: aMorph	| range |	range _ text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil:		[self paragraph replaceFrom: range first to: range last				with: Text new displaying: false.		self fit].	super privateRemoveMorph: aMorph! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextMorph class	instanceVariableNames: ''!!TextMorph class methodsFor: 'as yet unclassified' stamp: 'jm 11/5/97 12:26'!initialize	"TextMorph initialize"	"Initialize constants shared by classes associated with text display."	CaretForm _ (ColorForm extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -2@0)					colors: (Array with: Color transparent with: self new selectionColor).! !ParagraphEditor subclass: #TextMorphEditor	instanceVariableNames: 'morph oldInterval pivotBlock '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextMorphEditor methodsFor: 'initialization'!morph: aMorph	"Install a link back to the morph being editted (esp for text links)"	morph _ aMorph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 5/22/1998 00:54'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'events' stamp: 'di 5/22/1998 09:26'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'events' stamp: 'di 5/22/1998 09:29'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'events' stamp: 'di 4/22/1998 09:38'!readKeyboard	super readKeyboard.	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 4/21/1998 20:30'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"	morph acceptContents! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 4/22/1998 10:59'!cancel	"Cancel the changes made so far to this text"	morph cancelEdits! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 1/14/98 09:58'!changeEmphasis: characterStream 	"May be a request to create a link (Cmd-6).  Intercept if so, else call super"	| keyCode attribute index colors |	"Test if it's really the droids we're looking for..."	keyCode _ ('0123456789-=' indexOf: sensor keyboardPeek ifAbsent: [1]) - 1.	keyCode ~= 6 ifTrue: [^ super changeEmphasis: characterStream "handle other keys"].	sensor keyboard  "Yes, it is Cmd-6;  consume the command character".	colors _ #(black magenta red yellow green blue cyan white).	index _ (PopUpMenu labelArray: colors , #(active)							lines: (Array with: colors size)) startUp.	index = 0 ifTrue: [^ true].	index <= colors size ifTrue:		[attribute _ TextColor color: (Color perform: (colors at: index))].	(index - colors size) = 1 ifTrue:		[attribute _ TextMorphHotLink new sourceString: self selection asString					targetMorph: morph					parameterString: (FillInTheBlank										request: 'Secondary text for this link (or CR)...'										initialAnswer: '')].	self replaceSelectionWith: (self selection addAttribute: attribute).	^ true! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'jm 10/28/97 18:31'!align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	paragraph textStyle alignment: paragraph textStyle alignment + 1.	self recomputeInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/16/1998 11:33'!controlInitialize	"No-op for MVC ParagraphEditor compatibility"! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/16/1998 11:33'!controlTerminate	"No-op for MVC ParagraphEditor compatibility"! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/22/1998 10:21'!flash	^ morph flash! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 10/2/97 11:38'!mvcRedisplay	"Ignore mvcRedisplay requests."! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 10/2/97 09:08'!scrollBy: ignore 	"Ignore scroll requests."! !!TextMorphEditor methodsFor: 'mvc compatibility'!select	"Ignore selection redraw requests."! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'jm 10/28/97 18:31'!selectAndScroll	"Ignore scroll requests."! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 11/30/97 11:27'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 5/12/1998 20:56'!storeSelectionInParagraph	paragraph selectionStart: startBlock selectionStop: stopBlock! !!TextMorphEditor methodsFor: 'mvc compatibility'!updateMarker	"Ignore scrollbar redraw requests."! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/21/1998 14:11'!userHasEdited	"Note that my text is free of user edits."	morph hasUnacceptedEdits: true! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/21/1998 13:26'!userHasNotEdited	"Note that my text is free of user edits."	morph hasUnacceptedEdits: false! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 4/22/1998 09:38'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextMorphEditor methodsFor: 'command keys' stamp: 'tk 5/8/1998 11:08'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line."	sensor keyboard.		"flush character"	self inspectIt.	^ true! !TextMorph subclass: #TextMorphForEditView	instanceVariableNames: 'editView '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextMorphForEditView methodsFor: 'all' stamp: 'di 4/22/1998 10:57'!acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing."	self updateFromParagraph.	editView accept.! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 4/22/1998 11:03'!cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing."	self releaseParagraph.	editView cancel! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 5/7/1998 08:48'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self startingIndex > text size" false "try out" ifFalse:		[aCanvas newParagraph: self paragraph bounds: bounds color: color].! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 4/21/1998 13:23'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my view."	editView hasUnacceptedEdits: aBoolean! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 5/10/1998 22:53'!keyStroke: evt	self editor model: editView model.  "For evaluateSelection"	super keyStroke: evt.	editView scrollSelectionIntoView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 5/22/1998 12:36'!mouseMove: evt	super mouseMove: evt.	(editView scrollSelectionIntoView: evt) ifTrue: [evt hand updateMouseDownTransform]! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 5/22/1998 12:36'!mouseUp: evt	super mouseUp: evt.	editView scrollSelectionIntoView: evt! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 4/21/1998 13:09'!setEditView: editPane	editView _ editPane! !TextAction subclass: #TextMorphHotLink	instanceVariableNames: 'evalString targetMorph parameterString '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextMorphHotLink methodsFor: 'all'!actOnClickFor: anObject	"MouseDown on this link"	targetMorph xeqLinkText: evalString withParameter: parameterString.	^ true! !!TextMorphHotLink methodsFor: 'all'!sourceString: str1 targetMorph: morph parameterString: str2	evalString _ str1.	targetMorph _ morph.	parameterString _ str2! !NewParagraph subclass: #TextOnCurve	instanceVariableNames: 'lastCharacterIndex curve '	classVariableNames: 'CachedWarpColor CachedWarpDepth CachedWarpMap '	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextOnCurve commentStamp: 'di 5/22/1998 16:39' prior: 0!TextOnCurve comment:'This subclass of Paragraph composes and displays text along a segmented line or curve.  It does this by using all the normal text composition machinery, but just to lay text out for each segment of the curve in question.  The display process is somewhat complicated, as it involves rotating the text for each segment, and then merging it into the destination Form with background, selection highlight, and transparency all handled correctly.Because TextMorph flushes its paragraph to save space, the enduring specification of curve layout (direction, baseline, and margin) must be stored in the container.'!!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/4/97 09:47'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	"Here we determine the 'lines' of text that will fit along each segment of the curve. For each line, we determine its rectangle, then the dest wuadrilateral that it willbe rotated to.  Then, we take the outer hull to determine a dest rectangle for WarpBlt.  In addition we need the segment pivot point and angle, from which the source quadrilateral may be computed."	| charIndex scanner line firstLine curveSegments segIndex pa pb segLen lineRect textSegments segDelta segAngle destRect destQuad i oldBounds |	(oldBounds _ container bounds) ifNotNil:		[curve invalidRect: oldBounds].	charIndex _ startingIndex.	lines _ startingLines.	curveSegments _ curve lineSegments.	container textDirection < 0 ifTrue:		[curveSegments _ curveSegments reversed collect:				[:seg | Array with: (seg at: 2) with: (seg at: 1)]].	textSegments _ OrderedCollection new.	scanner _ SegmentScanner new text: text textStyle: textStyle.	segIndex _ 1.  "For curves, segIndex is just an index."	firstLine _ true.	pa _ curveSegments first first.	[charIndex <= text size and: [segIndex <= curveSegments size]]		whileTrue:		[curve isCurve ifFalse: [pa _ (curveSegments at: segIndex) first].		pb _ (curveSegments at: segIndex) last.		segDelta _ pb - pa.  "Direction of this segment"		segLen _ segDelta r.		lineRect _ 0@0 extent: segLen asInteger@textStyle lineGrid.		line _ scanner composeFrom: charIndex inRectangle: lineRect						firstLine: firstLine leftSide: true rightSide: true.		line setRight: scanner rightX.		line width > 0 ifTrue:			[lines addLast: line.			segAngle _ segDelta theta.			destQuad _ line rectangle corners collect:						[:p | (p translateBy: pa - (0@(line baseline + container baseline)))								rotateBy: segAngle negated about: pa].			destRect _ Rectangle encompassing: destQuad.			textSegments addLast: (Array with: destRect truncated with: pa with: segAngle).			pa _ pa + ((pb-pa) * line width / segLen).			charIndex _ line last + 1].		segIndex _ segIndex + 1.		firstLine _ false].	lines size = 0 ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (0@0 extent: 10@textStyle lineGrid);				lineHeight: textStyle lineGrid baseline: textStyle baseline.		lines _ Array with: line.		textSegments addLast:			(Array with: (curve vertices first extent: line rectangle extent) 					with: curve vertices first with: 0.0).].	"end of segments, now attempt word break."	lines last last < text size ifTrue:		[[lines size > 1 and: [(text at: (i _ lines last last)+1) ~= Character space]]			whileTrue:			[i = lines last first				ifTrue: [lines removeLast.  textSegments removeLast]				ifFalse: [lines last stop: i-1]]].	lines _ lines asArray.	container textSegments: textSegments asArray.	curve invalidRect: container bounds.	^ maxRightX! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!containsPoint: aPoint	"Return true if aPoint is in the actual text areas."	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now check if really in text area"			(line rectangle containsPoint:				(self pointInLine: line forDestPoint: aPoint					segStart: segStart segAngle: segAngle))				ifTrue: [^ true]]].	^ false! !!TextOnCurve methodsFor: 'all' stamp: 'tk 12/8/97 14:26'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| maxExtent lineForm leftInRun lineRect warp sourceQuad backgroundColor lineCanvas |	warp _ nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may hot have to display at all."				maxExtent _ lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm _ Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect _ lineForm boundingBox.				leftInRun _ 0.				backgroundColor _ (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp _ (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas _ FormCanvas on: lineForm].			sourceQuad _ destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun _ displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!TextOnCurve methodsFor: 'all' stamp: 'jm 11/19/97 22:38'!extent	^ curve bounds extent! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 20:23'!moveBy: delta	positionWhenComposed _ positionWhenComposed + delta.	container _ container translateBy: delta! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 10:24'!pointInLine: line forDestPoint: p segStart: segStart segAngle: segAngle	^ (p rotateBy: segAngle about: segStart)			translateBy: (0@(line baseline + container baseline)) - segStart! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 20:15'!releaseCachedState	super releaseCachedState.	CachedWarpMap _ CachedWarpDepth _ CachedWarpColor _ nil! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:06'!selectionRectsFrom: characterBlock1 to: characterBlock2	"Return an array of rectangles encompassing the area	between the two character blocks, presumably a selection."	| rects |	rects _ OrderedCollection new.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(characterBlock1 stringIndex <= line last			and: [characterBlock2 stringIndex >= line first]) ifTrue:			[rects addLast: destRect].		line first > characterBlock2 stringIndex ifTrue:			[^ rects]].	^ rects! !!TextOnCurve methodsFor: 'all' stamp: 'jm 11/19/97 20:29'!textOwner: theCurve	curve _ theCurve! !!TextOnCurve methodsFor: 'all' stamp: 'di 12/3/97 09:10'!textSegmentsDo: blockForLineDestPivotAngle	| segments segSpec |	(segments _ container textSegments) ifNil: [^ self].	1 to: lines size do:		[:i | segSpec _ segments at: i.		blockForLineDestPivotAngle			value: (lines at: i)			value: (segSpec at: 1)			value: (segSpec at: 2)			value: (segSpec at: 3)]! !!TextOnCurve methodsFor: 'all' stamp: 'di 11/29/97 12:20'!warpMapForDepth: destDepth withTransparentFor: bkgndColor	(CachedWarpDepth = destDepth and: [CachedWarpColor = bkgndColor])		ifTrue: ["Map is OK as is -- return it"				^ CachedWarpMap].	(CachedWarpMap == nil or: [CachedWarpDepth ~= destDepth])		ifTrue: ["Have to recreate the map"				CachedWarpMap _ Color computeColormapFrom: 32 to: destDepth.				CachedWarpDepth _ destDepth]		ifFalse: ["Map is OK, if we restore prior color substiution"				CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap)					put: (CachedWarpColor pixelValueForDepth: destDepth)].	"Now map the background color into transparent, and return the new map"	CachedWarpColor _ bkgndColor.	CachedWarpMap at: (CachedWarpColor indexInMap: CachedWarpMap)					put: 0.	^ CachedWarpMap! !Object subclass: #TextOnCurveContainer	instanceVariableNames: 'baseline inset textDirection textSegments '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextOnCurveContainer commentStamp: 'di 5/22/1998 16:39' prior: 0!TextOnCurveContainer comment:'I am not really a container in the sense of TextContainer.  However, I get stored in the same field of a textMorph.  My baseline specifies the vertical displacement of the character baselines from the curve center (0 means on center, 5 would mean, eg, the character baselines are 5 pixels above the curve center).  This is ssential enduring information.  I also cache temporary layout information, including the locations, angles and bounding boxes of each of the characters as displayed.'!!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 10:22'!baseline	baseline ifNil: [^ 0].	^ baseline! !!TextOnCurveContainer methodsFor: 'all' stamp: 'jm 11/19/97 19:30'!baseline: newBaseline	baseline _ newBaseline! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 08:32'!bounds	textSegments ifNil: [^ nil].	^ textSegments inject: (textSegments first at: 1)		into: [:bnd :each | bnd merge: (each at: 1)]! !!TextOnCurveContainer methodsFor: 'all' stamp: 'jm 11/19/97 19:28'!paragraphClass	^ TextOnCurve! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 08:28'!releaseCachedState	textSegments _ nil.! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:16'!textDirection	^ textDirection! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/4/97 09:23'!textDirection: plusOrMinusOne	textDirection _ plusOrMinusOne! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:29'!textSegments	^ textSegments! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 12/3/97 09:29'!textSegments: segments	textSegments _ segments! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 11/21/97 21:48'!top	^ 1  "for compatibility"! !!TextOnCurveContainer methodsFor: 'all' stamp: 'di 1/9/98 11:49'!translateBy: delta	textSegments == nil ifTrue: [^ self].	textSegments _ textSegments collect:		[:ls | Array with: ((ls at: 1) translateBy: delta)					with: ((ls at: 2) translateBy: delta)					with: (ls at: 3)]! !Object subclass: #TextPrinter	instanceVariableNames: 'form para paperSize landscape resolution depth offset columns docTitle noHeader noFooter '	classVariableNames: 'DefaultPaperSize '	poolDictionaries: ''	category: 'Graphics-Support'!!TextPrinter methodsFor: 'initialize' stamp: 'ar 4/30/98 19:26'!defaultPaperSize	"Return the default paper size (inches) for printing"	^self class defaultPaperSize! !!TextPrinter methodsFor: 'initialize' stamp: 'ar 4/30/98 15:06'!defaultResolution	"Return the default resolution (DPI) for printing"	^96.0@96.0! !!TextPrinter methodsFor: 'initialize' stamp: 'ar 4/30/98 19:39'!initialize	self paperSize: self defaultPaperSize.	self resolution: self defaultResolution.	self blackAndWhite.	self landscape: false.	self offsetRect: (1.0@1.0 corner: 1.0@1.0).	self columns: 1.	self noHeader: false.	self noFooter: false.	self documentTitle: 'Squeak Document (from ', Date today printString,')'.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!bestColor	"Set the reproduction quality to true color"	depth := 32.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!blackAndWhite	"Set the reproduction quality to black and white"	depth := 1.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:50'!columns	^columns! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:50'!columns: aNumber	columns := aNumber asInteger max: 1.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 20:14'!documentTitle	^docTitle! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 20:14'!documentTitle: aString	docTitle := aString! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!goodColor	"Set the reproduction quality to 8 bit color depth"	depth := 8.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!landscape	^landscape! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!landscape: aBoolean	landscape := aBoolean! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:23'!noFooter	^noFooter! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noFooter: aBoolean	"Turn off footer printing"	noFooter := aBoolean.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noHeader	^noHeader! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:22'!noHeader: aBoolean	"Turn off header printing"	noHeader := aBoolean.! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:27'!offsetRect	^offset! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 19:27'!offsetRect: aRectangle	"Set the offset rectangle"	offset := aRectangle! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!paperSize	^paperSize! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:42'!paperSize: aPoint	paperSize := aPoint! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:43'!resolution	^resolution! !!TextPrinter methodsFor: 'accessing' stamp: 'ar 4/30/98 18:43'!resolution: aPoint	resolution := aPoint! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 20:41'!flushPage	"The current page has been set up. Send it to the printer."	form primPrintHScale: self resolution x vScale: self resolution y landscape: self landscape.	"Uncomment the following for testing"	"form displayOn: Display. (Delay forSeconds: 5) wait."! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 19:19'!printParagraph	| pageNum nextIndex |	para destinationForm: form.	pageNum := 1.	nextIndex := 1.	[form fillColor: Color white.	self printHeader: pageNum.	self printFooter: pageNum.	nextIndex := self formatPage: pageNum startingWith: nextIndex.	self flushPage.	nextIndex isNil] whileFalse:[pageNum := pageNum + 1].! !!TextPrinter methodsFor: 'printing' stamp: 'ar 4/30/98 18:55'!printText: aText	"Print aText"	form isNil ifTrue:[		form := Form extent: self pixelSize depth: depth.	].	para := Paragraph withText: aText asText.	Cursor wait showWhile:[		self printParagraph.	].! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:25'!columnRect: n	"Return a rectangle describing the n-th column"	| area left right |	area := self textArea.	left := area left + ((n-1) * self columnWidth).	left := left + ((n-1) * self columnSkip).	right := left + self columnWidth.	^(self in2pix: left @ area top) corner: 		(self in2pix: right @ area bottom)! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:20'!columnSkip	"Return the separating space between two columns in inches"	^0.2! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:21'!columnWidth	^(self textWidth - ((self columns-1) * self columnSkip)) / self columns! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:29'!formatColumn: columnNum startingWith: anIndex	"Format a new column starting at the given string index. Return the string index indicating the start of the next column or nil if no more columns need printing."	| colRect blk |	colRect := self columnRect: columnNum.	anIndex > 1 ifTrue:[para text: (para text copyFrom: anIndex to: para text size)].	para compositionRectangle: colRect.	para clippingRectangle: colRect.	para composeAll.	para displayOn: form.	para visibleRectangle corner y <= colRect extent y ifTrue:[^nil].	"More columns -- find the character block of the last line and adjust clip rect"	blk := para characterBlockAtPoint: para visibleRectangle bottomLeft.	para clearVisibleRectangle. "Make sure that the background is clean"	para clippingRectangle: (colRect topLeft corner: colRect right@blk top).	para displayOn: form.	^blk stringIndex.! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:29'!formatPage: pageNum startingWith: anIndex	"Format a new page starting at the given string index. Return the string index indicating the start of the next page or nil if no more pages need printing."	| nextIndex |	nextIndex := anIndex.	1 to: self columns do:[:i|		nextIndex := self formatColumn: i startingWith: nextIndex.		nextIndex isNil ifTrue:[^nil].	].	^nextIndex! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:58'!textArea	^(self offsetRect origin + (0.0@self headerHeight)) corner:		(self realPaperSize - self offsetRect corner - (0.0@self footerHeight))! !!TextPrinter methodsFor: 'formatting' stamp: 'ar 4/30/98 19:23'!textWidth	^self textArea extent x! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 19:23'!headerHeight	"Return the (additional) height of the header in inches."	self noHeader ifTrue:[^0.0].	^(self pix2in: 0@TextStyle default lineGrid) y * 2! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 20:11'!headerParagraph	"Return a paragraph for the footer"	| hPara rect |	hPara := Paragraph new.	hPara destinationForm: form.	rect := (self in2pix: self textArea topLeft - (0.0@self headerHeight)) corner: 				(self in2pix: self textArea topRight).	hPara clippingRectangle: rect.	hPara compositionRectangle: rect.	^hPara! !!TextPrinter methodsFor: 'header' stamp: 'ar 4/30/98 19:23'!printHeader: pageNumber	"Print the header for the given page number"	| fPara |	self noHeader ifTrue:[^self].	fPara := self headerParagraph.	fPara centered.	fPara text: self documentTitle asText.	fPara displayOn: form.! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 19:23'!footerHeight	"Return the (additional) height of the footer in inches."	self noFooter ifTrue:[^0.0].	^(self pix2in: 0@TextStyle default lineGrid) y * 2! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 20:11'!footerParagraph	"Return a paragraph for the footer"	| fPara rect |	fPara := Paragraph new.	fPara destinationForm: form.	rect := (self in2pix: self textArea bottomLeft) corner: 				(self in2pix: self textArea bottomRight + (0.0@self footerHeight)).	fPara clippingRectangle: rect.	fPara compositionRectangle: rect.	^fPara! !!TextPrinter methodsFor: 'footer' stamp: 'ar 4/30/98 19:24'!printFooter: pageNumber	"Print the footer for the given page number"	| fPara |	self noFooter ifTrue:[^self].	fPara := self footerParagraph.	fPara centered.	fPara text: ('Page ', pageNumber printString) asText.	fPara displayOn: form.! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:39'!in2mm: aPoint	"Convert aPoint from millimeters to inches"	^aPoint * 25.4! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:38'!in2pix: aPoint	"Convert aPoint from inches to actual pixels"	^(aPoint * self resolution) rounded! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:38'!mm2in: aPoint	"Convert aPoint from millimeters to inches"	^aPoint / 25.4! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:40'!mm2pix: aPoint	"Convert aPoint from millimeters to actual pixels"	^self in2pix: (self mm2in: aPoint)! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:39'!pix2in: aPoint	"Convert aPoint from a pixel value to inches"	^aPoint / self resolution! !!TextPrinter methodsFor: 'other' stamp: 'ar 4/30/98 18:40'!pix2mm: aPoint	"Convert aPoint from a pixel value to millimeters"	^self in2mm: (self pix2in: aPoint)! !!TextPrinter methodsFor: 'private' stamp: 'ar 4/30/98 19:40'!pixelSize	"Return the size of the page in pixels"	^self in2pix: (self realPaperSize)! !!TextPrinter methodsFor: 'private' stamp: 'ar 4/30/98 19:39'!realPaperSize	^self landscape		ifTrue:[self paperSize y @ self paperSize x]		ifFalse:[self paperSize]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextPrinter class	instanceVariableNames: ''!!TextPrinter class methodsFor: 'class initialization' stamp: 'ar 4/30/98 18:30'!initialize	"TextPrinter initialize"	self defaultPaperSize: self paperSizeA4.! !!TextPrinter class methodsFor: 'instance creation' stamp: 'ar 4/30/98 15:42'!new	^super new initialize! !!TextPrinter class methodsFor: 'accessing' stamp: 'ar 4/30/98 18:31'!defaultPaperSize	^DefaultPaperSize! !!TextPrinter class methodsFor: 'accessing' stamp: 'ar 4/30/98 18:31'!defaultPaperSize: aPoint	DefaultPaperSize := aPoint! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:30'!mm2in: aPoint	"Convert aPoint from millimeters to inches"	^aPoint / 25.4! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSize10x14	^10.0@14.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSize11x17	^11.0@17.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeA3	^self mm2in: 297@420! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeA4	^self mm2in: 210@297! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeA5	^self mm2in: 148@210! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeB4	^self mm2in: 250@354! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:27'!paperSizeB5	^self mm2in: 182@257! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeCSheet	^17.0@22.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeDSheet	^22.0@34.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeESheet	^34.0@44.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelope10	^4.125@9.5! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelope11	^4.5@10.375! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelope12	^4.75@11! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelope14	^5.0@11.5! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelope9	^3.875@8.875! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelopeB4	^self mm2in: 250@353! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelopeB5	^self mm2in: 176@250! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelopeB6	^self mm2in: 176@125! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:28'!paperSizeEnvelopeC3	^self mm2in: 324@458! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeEnvelopeC4	^self mm2in: 229@324! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeEnvelopeC5	^self mm2in: 162@229! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeEnvelopeC6	^self mm2in: 114@162! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeEnvelopeC65	^self mm2in: 114@229! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeFanfoldGerman	"German standard fanfold"	^8.5@12.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeFanfoldLegalGerman	"German legal fanfold"	^8.5@13.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeFanfoldUS	"US standard fanfold"	^14.875@11.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeFolio	^8.5@13.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeLegal	^8.5@14.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeLetter	^8.5@11.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:29'!paperSizeNote	^8.5@11.0! !!TextPrinter class methodsFor: 'paper sizes' stamp: 'ar 4/30/98 18:30'!paperSizeTabloid	^11.0@17.0! !WriteStream subclass: #TextStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!TextStream methodsFor: 'as yet unclassified'!applyAttribute: att beginningAt: startPos	collection addAttribute: att from: startPos to: self position! !!TextStream methodsFor: 'as yet unclassified'!nextPutAll: aCollection 	"Optimized access to get around Text at:Put: overhead"	| n |	n _ aCollection size.	((aCollection isMemberOf: String) not or: [position + n > writeLimit])		ifTrue: [^ super nextPutAll: aCollection].	collection string		replaceFrom: position+1		to: position + n		with: aCollection		startingAt: 1.	position _ position + n! !!TextStream methodsFor: 'as yet unclassified'!withAttribute: att do: strmBlock	| pos1 val |	pos1 _ self position.	val _ strmBlock value.	collection addAttribute: att from: pos1+1 to: self position.	^ val! !Object subclass: #TextStyle	instanceVariableNames: 'fontArray fontFamilySize lineGrid baseline alignment firstIndent restIndent rightIndent tabsArray marginTabsArray leading '	classVariableNames: ''	poolDictionaries: 'TextConstants '	category: 'Graphics-Support'!!TextStyle commentStamp: 'di 5/22/1998 16:39' prior: 0!A textStyle comprises the formatting information for composing and displaying a unit (usually a paragraph) of text.  Typically one makes a copy of a master textStyle (such as TextStyle default), and then that copy may get altered in the process of editing.  Bad things can happen if you do not copy first.Each of my instances consists of...	fontArray		An array of StrikeFonts	fontFamilySize	unused	lineGrid			An integer; default line spacing for paragraphs	baseline			An integer; default baseline (dist from line top to bottom of an 'a')	alignment		An integer; text alignment, see TextStyle alignment:	firstIndent		An integer; indent of first line in pixels	restIndent		An integer; indent of remaining lines in pixels	rightIndent		An integer; indent of right margin rel to section	tabsArray		An array of integers giving tab offsets in pixels	marginTabsArray	An array of margin tabs	leading			An integer giving default vertical line separationFor a concrete example, look at TextStyle default copy inspect!]style[(367 10 211 20 381 30)f1,f1LStrikeFont Comment;,f1,f1LTextStyle alignment:;,f1,f1dTextStyle default copy inspect;;!!TextStyle methodsFor: 'accessing' stamp: 'di 10/24/97 11:17'!= other	other class == self class ifFalse: [^ false].	1 to: self class instSize do:		[:i | (self instVarAt: i) == (other instVarAt: i) ifFalse: [^ false]].	^ true! !!TextStyle methodsFor: 'accessing'!alignment	"Answer the code for the current setting of the alignment."	^alignment! !!TextStyle methodsFor: 'accessing'!alignment: anInteger 	"Set the current setting of the alignment to be anInteger:	0=left flush, 1=centered, 2=right flush, 3=justified."	alignment _ anInteger \\ (Justified + 1)! !!TextStyle methodsFor: 'accessing'!baseline	"Answer the distance from the top of the line to the bottom of most of the 	characters (by convention, bottom of the letter 'A')."	^baseline! !!TextStyle methodsFor: 'accessing'!baseline: anInteger 	"Set the distance from the top of the line to the bottom of most of the 	characters."	baseline _ anInteger! !!TextStyle methodsFor: 'accessing'!centered	alignment _ 2! !!TextStyle methodsFor: 'accessing'!defaultFont	"Answer the first font in the font family."	^fontArray at: 1! !!TextStyle methodsFor: 'accessing'!firstIndent	"Answer the horizontal indenting of the first line of a paragraph in the 	style of the receiver."	^firstIndent! !!TextStyle methodsFor: 'accessing'!firstIndent: anInteger 	"Set the horizontal indenting of the first line of a paragraph in the style 	of the receiver to be the argument, anInteger."	firstIndent _ anInteger! !!TextStyle methodsFor: 'accessing'!fontNamed: fontName  "TextStyle default fontNamed: 'TimesRoman10'"	^ fontArray detect: [:x | x name sameAs: fontName]! !!TextStyle methodsFor: 'accessing'!fontNames  "TextStyle default fontNames"	^ fontArray collect: [:x | x name]! !!TextStyle methodsFor: 'accessing'!justified	alignment _ 3! !!TextStyle methodsFor: 'accessing'!leading	"Leading (from typographers historical use of extra lead (type metal))	is the extra spacing above and beyond that needed just to accomodate	the various font heights in the set."	^ leading! !!TextStyle methodsFor: 'accessing'!leading: yDelta	leading _ yDelta! !!TextStyle methodsFor: 'accessing'!leftFlush	alignment _ 0! !!TextStyle methodsFor: 'accessing'!lineGrid	"Answer the relative space between lines of a paragraph in the style of 	the receiver."	^lineGrid! !!TextStyle methodsFor: 'accessing'!lineGrid: anInteger 	"Set the relative space between lines of a paragraph in the style of the 	receiver to be the argument, anInteger."	lineGrid _ anInteger! !!TextStyle methodsFor: 'accessing' stamp: 'di 10/24/97 11:26'!printOn: aStream	super printOn: aStream.	aStream space; nextPutAll: self defaultFont familySizeFace first! !!TextStyle methodsFor: 'accessing'!restIndent	"Answer the indent for all but the first line of a paragraph in the style 	of the receiver."	^restIndent! !!TextStyle methodsFor: 'accessing'!restIndent: anInteger 	"Set the indent for all but the first line of a paragraph in the style of the 	receiver to be the argument, anInteger."	restIndent _ anInteger! !!TextStyle methodsFor: 'accessing'!rightFlush	alignment _ 1! !!TextStyle methodsFor: 'accessing'!rightIndent	"Answer the right margin indent for the lines of a paragraph in the style 	of the receiver."	^rightIndent! !!TextStyle methodsFor: 'accessing'!rightIndent: anInteger 	"Answer the right margin indent for the lines of a paragraph in the style 	of the receiver to be the argument, anInteger."	rightIndent _ anInteger! !!TextStyle methodsFor: 'tabs and margins'!clearIndents	"Reset all the margin (index) settings to be 0."	self firstIndent: 0.	self restIndent: 0.	self rightIndent: 0! !!TextStyle methodsFor: 'tabs and margins'!leftMarginTabAt: marginIndex 	"Set the 'nesting' level of left margin indents of the paragraph in the 	style of the receiver to be the argument, marginIndex."	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^(marginTabsArray at: marginIndex) at: 1]		ifFalse: [^0]		"The marginTabsArray is an Array of tuples.  The Array is indexed according 	to the marginIndex, the 'nesting' level of the requestor."! !!TextStyle methodsFor: 'tabs and margins'!nextTabXFrom: anX leftMargin: leftMargin rightMargin: rightMargin 	"Tab stops are distances from the left margin. Set the distance into the 	argument, anX, normalized for the paragraph's left margin."	| normalizedX tabX |	normalizedX _ anX - leftMargin.	1 to: tabsArray size do: 		[:i | (tabX _ tabsArray at: i) > normalizedX 				ifTrue: [^leftMargin + tabX min: rightMargin]].	^rightMargin! !!TextStyle methodsFor: 'tabs and margins'!rightMarginTabAt: marginIndex 	"Set the 'nesting' level of right margin indents of the paragraph in the 	style of the receiver to be marginIndex."	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^(marginTabsArray at: marginIndex) at: 2]		ifFalse: [^0]	"The marginTabsArray is an Array of tuples.  The Array is indexed according 	to the marginIndex, the 'nesting' level of the requestor."! !!TextStyle methodsFor: 'tabs and margins'!tabWidth	"Answer the width of a tab."	^DefaultTab! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 11/24/97 16:02'!collectionFromFileNamed: fileName	"Read the file.  It is an Array of StrikeFonts.  File format is the ReferenceStream format.  (Do not use SmartRefStream, it is too smart.  It only writes a DiskProxy!!)   For any fonts with new names, add them to DefaultTextStyle.fontArray.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		ff nextPut: (TextStyle default fontArray).		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this names |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.		"Only works if file created by ReferenceStream, not SmartRefStream"	this class == Array ifTrue:			[names _ self fontNames.			this do: [:each | each class == StrikeFont ifTrue:				[(names includes: each name) ifFalse:					[fontArray _ fontArray copyWith: each]]]].! !!TextStyle methodsFor: 'fonts and font indexes'!flushFonts	"Clean out the fonts, an aid when snapshotting claims too many are 	holding onto Display."	(self confirm: 'flushFonts is very dangerous.Are you foolish or clever enough to proceed?')		ifTrue: [1 to: fontArray size do: [:index | fontArray at: index put: nil]]		ifFalse: [Transcript cr; show: 'flushFonts cancelled']	"TextStyle default flushFonts"! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:23'!fontIndexOfSize: desiredHeight	"Returns an index in fontArray of the font with height <= desiredHeight"	"Leading is not inluded in the comparison"	| bestMatch bestIndex d |	bestMatch _ 9999.  bestIndex _ 1.	1 to: fontArray size do:		[:i | d _ desiredHeight - (fontArray at: i) height.		d = 0 ifTrue: [^ i].		(d > 0 and: [d < bestMatch]) ifTrue: [bestIndex _ i. bestMatch _ d]].	^ bestIndex! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'di 10/11/97 09:33'!fontOfSize: aHeight	"See fontIndexOfSize.	Returns the actual font.  Leading not considered."	^ fontArray at: (self fontIndexOfSize: aHeight)! !!TextStyle methodsFor: 'private'!consolidate	"If this style includes any fonts that are also in the default style,	then replace them with references to the default ones.""	TextStyle allInstancesDo: [:s | s == TextStyle default ifFalse: [s consolidate]]"	| defFonts font |	defFonts _ TextStyle default fontArray.	1 to: fontArray size do:		[:i | font _ fontArray at: i.		1 to: defFonts size do:			[:j | (font name asUppercase copyWithout: $ )			= ((defFonts at: j) name asUppercase copyWithout: $ )			ifTrue: [fontArray at: i put: (defFonts at: j)]]]! !!TextStyle methodsFor: 'private'!fontArray	"Only for writing out fonts, etc.  8/16/96 tk"	^ fontArray! !!TextStyle methodsFor: 'private'!fontAt: index 	"This is private because no object outside TextStyle should depend on the 	representation of the font family in fontArray."	((fontArray atPin: index) isMemberOf: StrikeFont)				ifTrue: [^fontArray atPin: index].	((fontArray at: 1) isMemberOf: StrikeFont)				ifTrue: [^fontArray at: 1].	self error: 'No valid fonts in font array'! !!TextStyle methodsFor: 'private'!fontAt: index put: font	"Automatically grow the array.  8/20/96 tk"	index > fontArray size ifTrue: [		fontArray _ fontArray, (Array new: index - fontArray size)].	fontArray at: index put: font! !!TextStyle methodsFor: 'private'!gridForFont: fontIndex withLead: leadInteger 	"Force whole style to suit one of its fonts. Assumes only one font referred	to by runs."	| font |	font _ self fontAt: fontIndex.	self lineGrid: font height + leadInteger.	self baseline: font ascent.	self leading: leadInteger! !!TextStyle methodsFor: 'private'!marginTabAt: marginIndex side: sideIndex 	"The marginTabsArray is an Array of tuples.  The Array is indexed	according to the marginIndex, the 'nesting' level of the requestor.	sideIndex is 1 for left, 2 for right."	(marginIndex > 0 and: [marginIndex < marginTabsArray size])		ifTrue: [^(marginTabsArray at: marginIndex) at: sideIndex]		ifFalse: [^0]! !!TextStyle methodsFor: 'private' stamp: 'tk 8/20/96'!newFontArray: anArray	"Currently there is no supporting protocol for changing these arrays. If an editor wishes to implement margin setting, then a copy of the default should be stored with these instance variables.  	, Make size depend on first font."	fontArray _ anArray.	lineGrid _ (fontArray at: 1) height + leading.	"For whole family"	baseline _ (fontArray at: 1) ascent + leading.	alignment _ 0.	firstIndent _ 0.	restIndent _ 0.	rightIndent _ 0.	tabsArray _ DefaultTabsArray.	marginTabsArray _ DefaultMarginTabsArray"TextStyle allInstancesDo: [:ts | ts newFontArray: TextStyle default fontArray]."! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 5/13/97'!storeDataOn: aDataStream	"Store myself on a DataStream. This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  Need this to share tabsArray and marginTabsArray.  Fonts will take care of themselves.  "	| cntInstVars cntIndexedVars instVars ti tm |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	ti _ (instVars indexOf: 'tabsArray').	tm _ (instVars indexOf: 'marginTabsArray').	(ti = 0) | (tm = 0) | (ti > tm) ifTrue: [self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	tabsArray == DefaultTabsArray 		ifTrue: [aDataStream nextPut: (DiskProxy global: #TextConstants selector: #at: 						args: #(DefaultTabsArray))]		ifFalse: [aDataStream nextPut: tabsArray].	ti+1 to: tm-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	marginTabsArray == DefaultMarginTabsArray		ifTrue: [aDataStream nextPut: (DiskProxy global: #TextConstants selector: #at: 						args: #(DefaultMarginTabsArray))]		ifFalse: [aDataStream nextPut: marginTabsArray].	tm+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextStyle class	instanceVariableNames: ''!!TextStyle class methodsFor: 'instance creation' stamp: 'di 6/16/97 12:31'!changeDefaultFontSizeBy: delta      "TextStyle changeDefaultFontSizeBy: 1"	"This sample method recreates the default textStyle, with font 1 being a size	larger than the smallest.  It then initializes most references in the system	as well, although most windows will have to beclosed and reopened to get the effect."	| allFonts |	allFonts _ TextStyle default fontArray asSortedCollection: [:a :b | a height < b height].	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: ((1 to: allFonts size) collect: [:i | allFonts atWrap: i+delta])).	PopUpMenu initialize.  "Change this method for difft menu font"	ListParagraph initialize.  "Change this method for difft ListPane font"	StandardSystemView initialize.  "Change this method for difft Window label font"! !!TextStyle class methodsFor: 'instance creation'!fontArray: anArray 	"Answer an instance of me with fonts those in the argument, anArray."	^self new newFontArray: anArray! !!TextStyle class methodsFor: 'instance creation'!initDefaultFontsAndStyle	"This provides the system with 10 and 12-pt basal fonts.	Bold and italic versions will be automatically generated as needed"	| fontArray |		fontArray _ Array new: 2.	fontArray at: 1 put: (StrikeFont new readFromStrike2: 'NewYork10.sf2').	fontArray at: 2 put: (StrikeFont new readFromStrike2: 'NewYork12.sf2').	TextConstants at: #DefaultTextStyle put:		(TextStyle fontArray: fontArray).	"TextStyle initDefaultFontsAndStyle."! !!TextStyle class methodsFor: 'instance creation'!new	^ super new leading: 2! !!TextStyle class methodsFor: 'constants'!default	"Answer the system default text style."	^DefaultTextStyle! !!TextStyle class methodsFor: 'constants' stamp: 'di 10/20/97 20:08'!named: familyName	^ TextConstants at: familyName asSymbol ifAbsent: [nil]! !TextAction subclass: #TextURL	instanceVariableNames: 'url '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Text'!!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 11:11'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response |	(url asLowercase endsWith: '.gif') ifTrue: [		HTTPSocket httpShowGif: url].	"opens a new window"	response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Sorry, we don''t have a web browser yet'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:47'!analyze: aString	| list |	list _ super analyze: aString.	url _ list at: 1.	^ list at: 2! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/30/97 10:33'!info	^ url! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 08:55'!url: aString	url _ aString! !!TextURL methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 13:45'!writeScanOn: strm	strm nextPut: $R; nextPutAll: url; nextPut: $;! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TextURL class	instanceVariableNames: ''!!TextURL class methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 09:24'!scanFrom: strm	"read a link in the funny format used by Text styles on files. Rhttp://www.disney.com;"	^ self new url: (strm upTo: $;)! !ImageMorph subclass: #ThreePhaseButtonMorph	instanceVariableNames: 'offImage pressedImage state target actionSelector arguments actWhen '	classVariableNames: 'AuthorModeOwner '	poolDictionaries: ''	category: 'Morphic-Widgets'!!ThreePhaseButtonMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!A button morph with separate images for on, off, and pressed with the mouse. When the event actWhen occurs, send actionSelector with 'arguments' to target.  For other events, default to my eventHandler.  The current event is not supplied in the arguments to the actionSelector.  image (a.k.a. onImage) may not be nil.  offImage and pressedImage may be nil.  nil there means be transparent and show the underlying object.  Tools for debugging:Display the images momentarily under program control (for positioning) (self is an instance).	self state: #on.  self state: #off.	self state: #pressed.  self state: #off.Display a rectangle where the button is.	Display fillWithColor: bounds + (self world viewBox origin).	self invalidRect: bounds.!!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actionSelector	^ actionSelector! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:49'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen _ condition! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 12:39'!arguments	^ arguments! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 08:39'!arguments: aCollection	arguments _ aCollection asArray copy.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/29/97 21:04'!authorModeOwner: aMorph	AuthorModeOwner _ aMorph! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:52'!doButtonAction	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		Cursor normal showWhile: [			target perform: actionSelector withArguments: arguments]].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/29/97 21:02'!dragIfAuthoring: evt	"Allow simple dragging if the class var is set to my owner."	owner == AuthorModeOwner ifTrue: [		self center: evt cursorPoint].	^ owner == AuthorModeOwner! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:03'!drawOn: aCanvas	state == #off ifTrue: [		offImage ifNotNil: [aCanvas image: offImage at: bounds origin]].	state == #pressed ifTrue: [		pressedImage ifNotNil: [aCanvas image: pressedImage at: bounds origin]].	state == #on ifTrue: [		image ifNotNil: [aCanvas image: image at: bounds origin]].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 09:14'!extent	"Do it normally"	^ bounds extent! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 09:14'!extent: aPoint	"Do it normally"		self changed.	bounds _ bounds topLeft extent: aPoint.	self layoutChanged.	self changed.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:52'!handlesMouseDown: evt	^ true! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 7/1/97 08:34'!initialize	super initialize.	state _ #off.	target _ nil.	actionSelector _ #flash.	arguments _ EmptyArray.	actWhen _ #buttonUp.	"self on: #mouseStillDown send: #dragIfAuthoring: to: self."		"real move should include a call on dragIfAuthoring: "! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 3/3/98 09:08'!mouseDown: evt	self state: #pressed.	actWhen == #buttonDown		ifTrue: [self doButtonAction]		ifFalse: [super mouseDown: evt].			"Allow on:send:to: to set the response to events other than actWhen"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 3/3/98 09:08'!mouseMove: evt(self containsPoint: evt cursorPoint)	ifTrue: [self state: #pressed.			actWhen == #whilePressed 				ifTrue: [self doButtonAction]				ifFalse: [super mouseMove: evt]]						"Allow on:send:to: to set the response to events other than actWhen"	ifFalse: [self state: #off].! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 3/3/98 08:40'!mouseUp: evt	actWhen == #buttonUp ifTrue: [		(self containsPoint: evt cursorPoint)			ifTrue: [self state: #on.				self doButtonAction]			ifFalse: [self state: #off.				target ifNotNil: [target mouseUpBalk: evt]]]				"Allow owner to keep it selected for radio buttons"	ifFalse: [super mouseUp: evt]			"Allow on:send:to: to set the response to events other than actWhen"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!offImage	^ offImage! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:08'!offImage: aForm	offImage _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!onImage	^ image! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:08'!onImage: aForm	image _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 10/19/97 15:02'!pressedImage	^ pressedImage! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:09'!pressedImage: aForm	pressedImage _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'sw 4/2/98 14:53'!printOn: aStream	| string |	aStream nextPutAll: '3PButton'.	arguments size > 0 ifTrue: [string _ arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	(string ~~ nil and: [string ~~ self]) ifTrue:			[aStream print: string; space]. 	aStream print: self identityHash;			nextPutAll: ')'.! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 11:01'!state: newState	"Change the image and invalidate the rect."	newState == state ifTrue: [^ self].	state _ newState.	self invalidRect: bounds.	"All three images must be the same size"! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:50'!target	^ target! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'tk 6/30/97 10:50'!target: anObject	target _ anObject! !!ThreePhaseButtonMorph methodsFor: 'all' stamp: 'jm 7/28/97 11:56'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then update it to point to the new copy. This method also copies the arguments array itself, which is important!!"	super updateReferencesUsing: aDictionary.	arguments _ arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !RectangleMorph subclass: #ThumbnailMorph	instanceVariableNames: 'objectToView viewSelector lastSketchForm '	classVariableNames: 'RecursionDepth RecursionMax '	poolDictionaries: ''	category: 'Morphic-Widgets'!!ThumbnailMorph methodsFor: 'all' stamp: 'jm 2/27/98 16:38'!actualViewee	"Return the actual morph to be viewed, or nil if there isn't an appropriate morph to view."	| aMorph actualViewee |	aMorph _ self morphToView ifNil: [^ nil]. 	aMorph isInWorld ifFalse: [^ nil].	actualViewee _ viewSelector ifNil: [aMorph] ifNotNil: [objectToView perform: viewSelector].	actualViewee == 0 ifTrue: [^ nil].  "valueAtCursor result for an empty HolderMorph"	actualViewee ifNil: [actualViewee _ objectToView].	actualViewee isMorph ifFalse: [actualViewee _ actualViewee costume].	^ actualViewee! !!ThumbnailMorph methodsFor: 'all' stamp: 'jm 2/27/98 16:47'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].	(actualViewee isKindOf: SketchMorph)		ifTrue:			[diag _ actualViewee form extent r asInteger.			viewedMorphBox _				(actualViewee bounds center - (diag // 2)) extent: diag@diag]		ifFalse:			[viewedMorphBox _ actualViewee fullBounds].	myBox _ self innerBounds.	scale _ myBox width / (viewedMorphBox width max: viewedMorphBoxheight).	c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.	c _ c copyOffset: viewedMorphBox topLeft negated.	actualViewee fullDrawOn: c.		"recursion happens here"	shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.	aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter.	RecursionDepth _ RecursionDepth - 1.	"up a level"! !!ThumbnailMorph methodsFor: 'all'!initialize	super initialize.	self extent: 25@25.	self color: (Color r: 0.781 g: 0.781 b: 0.781).	self borderWidth: 1.! !!ThumbnailMorph methodsFor: 'all' stamp: 'jm 2/27/98 16:43'!morphToView	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[objectToView costume]! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 1/29/98 21:10'!objectToView: aMorphOrNil	self objectToView: aMorphOrNil viewSelector: #yourself! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 2/3/98 15:13'!objectToView: objectOrNil viewSelector: aSelector	(objectOrNil isMorph and: [objectOrNil allMorphs includes: self]) ifTrue:		["cannot view a morph containing myself or drawOn: goes into infinite recursion"		objectToView _ nil.		^ self].	objectToView _ objectOrNil.	viewSelector _ aSelector! !!ThumbnailMorph methodsFor: 'all' stamp: 'jm 2/27/98 16:49'!step	"Optimization: Don't redraw if we're viewing some kind of SketchMorph and its rotated Form hasn't changed."	| viewee f |	viewee _ self actualViewee.	(viewee isKindOf: SketchMorph) ifTrue: [		f _ viewee rotatedForm.		f == lastSketchForm ifTrue: [^ self].		lastSketchForm _ f].	self changed.! !!ThumbnailMorph methodsFor: 'all'!stepTime	^ 50! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ThumbnailMorph class	instanceVariableNames: ''!!ThumbnailMorph class methodsFor: 'as yet unclassified' stamp: 'tk 9/8/9708:30'!initialize	RecursionMax _ 2.	RecursionDepth _ 0.! !!ThumbnailMorph class methodsFor: 'as yet unclassified' stamp: 'sw 5/3/1998 19:12'!recursionReset	"ThumbnailMorph recursionReset"	"Reset the RecursionDepth counter in case the user interruptedduring a thumbnail being drawn.  Do this just once in a while when nodrawOn: is being called.  tk 9/8/97"	RecursionDepth _ 0.! !RectangleMorph subclass: #TileMorph	instanceVariableNames: 'type slotName literal operatorOrExpression actualObject downArrow upArrow suffixArrow typeColor lastArrowTick nArrowTicks operatorReadoutString '	classVariableNames: 'DownPicture SuffixArrowAllowance SuffixPicture UpArrowAllowance UpPicture UpdatingOperators '	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!TileMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!TileMorph comment:'A tile with up, down and suffix arrows.To install new Forms for the arrows, just nil out UpPicture, DownPicture,or SuffixPicture.Create actors with the picture you want and write it out with these file names:''tile inc arrow.morph'' ''tile dec arrow.morph'' ''tile suffixarrow.morph''.  Make sure that file is in the same directory as the image.Open an EToy.'!!TileMorph methodsFor: 'misc' stamp: 'sw 11/3/97 01:11'!copyRecordingIn: aDict	| new |	new _ super copyRecordingIn: aDict.	downArrow ifNotNil:		[new downArrow: 			((aDict includesKey: downArrow)				ifTrue: [aDict at: downArrow]				ifFalse: [downArrow copyRecordingIn: aDict])].	upArrow ifNotNil:		[new upArrow: 			((aDict includesKey: upArrow)				ifTrue: [aDict at: upArrow]				ifFalse: [upArrow copyRecordingIn: aDict])].	suffixArrow ifNotNil:		[new suffixArrow: 			((aDict includesKey: suffixArrow)				ifTrue: [aDict at: suffixArrow]				ifFalse: [suffixArrow copyRecordingIn: aDict])].	"actualObject gets fixed by a different mechanism.  The commented-out code below caused big difficulties when a script was being copied for use in the same actor""	actualObject ifNotNil:		[new actualObject: 			((aDict includesKey: actualObject)				ifTrue: [aDict at: actualObject]				ifFalse: [actualObject copyRecordingIn: aDict])]."	^ new! !!TileMorph methodsFor: 'misc' stamp: 'tk 10/1/97 18:24'!isTileLike	"Can be dropped into a script"	^ true! !!TileMorph methodsFor: 'misc' stamp: 'sw 4/21/1998 21:34'!isTileScriptingElement	^ true! !!TileMorph methodsFor: 'misc' stamp: 'sw 10/3/97 14:22'!minimumWidth	| aWidth |	aWidth _ self class defaultW.	upArrow ifNotNil: [aWidth _ aWidth + UpArrowAllowance].	suffixArrow ifNotNil: [aWidth _ aWidth + SuffixArrowAllowance].	^ aWidth	! !!TileMorph methodsFor: 'misc' stamp: 'sw 1/29/98 00:45'!numericValue	literal isNumber ifFalse: [^ 0].	^ literal! !!TileMorph methodsFor: 'misc' stamp: 'sw 4/28/1998 00:14'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' - ', type printString.	operatorOrExpression ifNotNil: [aStream nextPutAll: ' op= ', operatorOrExpression printString].	slotName ifNotNil: [aStream nextPutAll: ' op= ', slotName printString].! !!TileMorph methodsFor: 'misc' stamp: 'sw 1/21/98 17:44'!restoreTypeColor	self borderColor: Color black.	typeColor ifNotNil: [self color: typeColor]! !!TileMorph methodsFor: 'misc' stamp: 'sw 4/3/98 23:36'!typeColor: aColor	borderColor _ aColor.	typeColor _ aColor.	color _ typeColor! !!TileMorph methodsFor: 'misc' stamp: 'sw 5/2/1998 15:01'!useUniformTileColor	self color: ScriptingSystem uniformTileInteriorColor! !!TileMorph methodsFor: 'misc' stamp: 'sw 11/5/97 12:18'!wantsKeyboardFocusFor: aSubmorph	^ type == #literal ! !!TileMorph methodsFor: 'initialization' stamp: 'sw 10/3/97 18:00'!actualObject	^ actualObject! !!TileMorph methodsFor: 'initialization' stamp: 'sw 9/12/97 19:36'!bePossessive	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'sw 2/11/98 23:29'!bringUpToDate	type == #objRef ifTrue:		[self line1: actualObject externalName]	! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/6/1998 13:14'!donorActor: donorActor ownActor: ownActor	(actualObject == donorActor) ifTrue: [actualObject _ ownActor].	(type == #objRef and: [actualObject == ownActor])		ifTrue:			[self line1: actualObject externalName]	! !!TileMorph methodsFor: 'initialization' stamp: 'sw 4/28/1998 00:17'!initialize	super initialize.	self typeColor: (Color r: 0.8 g: 1.0 b: 0.6).	self borderWidth: 1.	type _ #literal.  "#literal, #slotRef, #objRef, #operator, #expression"	slotName _ ''.	literal _ 1.! !!TileMorph methodsFor: 'initialization'!setExpression: exprString label: labelString	type _ #expression.	operatorOrExpression _ exprString.	self line1: labelString.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/2/1998 15:01'!setLiteral: anObject	| m |	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.  "BUT this doesn't do it, damnit"	m target: self; getSelector: #literal; putSelector: #literal:.	self addMorph: m.	self literal: anObject.! !!TileMorph methodsFor: 'initialization' stamp: 'sw 4/28/1998 00:24'!setObjectRef: aString actualObject: anObject.	type _ #objRef.	"aString is historical and no longer used"	actualObject _ anObject.	self line1: anObject externalName! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/4/1998 00:29'!setOperator: aString	type _ #operator.	operatorOrExpression _ aString asSymbol. 	self line1: (ScriptingSystem wordingForOperator: aString).	operatorOrExpression isInfix ifTrue: [self addArrows; updateLiteralLabel].	"operatorOrExpression == #heading ifTrue: [self halt]."! !!TileMorph methodsFor: 'initialization' stamp: 'sw 5/4/1998 00:30'!setOperatorAndUseArrows: aString	type _ #operator.	operatorOrExpression _ aString asSymbol. 	self line1: (ScriptingSystem wordingForOperator: aString).	self addArrows; updateLiteralLabel! !!TileMorph methodsFor: 'initialization' stamp: 'sw 1/30/98 16:31'!setSlotRefOperator: aString	type _ #operator.	operatorOrExpression _ Utilities getterSelectorFor: aString.	operatorReadoutString _ aString. 	self line1: aString! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/1/97 01:48'!downArrow: a	downArrow _ a! !!TileMorph methodsFor: 'accessing' stamp: 'sw 4/27/1998 16:10'!labelMorph	^ submorphs detect: [:m | m isKindOf: StringMorph] ifNone: [nil].! !!TileMorph methodsFor: 'accessing'!literal	^ literal! !!TileMorph methodsFor: 'accessing' stamp: 'di 9/18/97 12:02'!literal: anObject	literal _ anObject.	self updateLiteralLabel.	self acceptNewLiteral.		"Show that we are out of date, install is needed"! !!TileMorph methodsFor: 'accessing'!operatorOrExpression	^ operatorOrExpression! !!TileMorph methodsFor: 'accessing' stamp: 'sw 4/28/1998 00:06'!playerBearingCode	"Answer the actual Player object who will be the 'self' when the receiver is being asked to generate code"	| anEditor |	(anEditor _ self topEditor) ifNotNil: [^ anEditor playerScripted].	^ (self nearestOwnerThat: [:m | m isKindOf: PartsViewer]) scriptedPlayer! !!TileMorph methodsFor: 'accessing' stamp: 'sw 2/12/98 10:16'!resultType	type == #literal ifTrue:		[(literal isKindOf: Number) ifTrue: [^ #number]].	type == #expression ifTrue:		[^ #number].	type == #objRef ifTrue: [^ #player].	^ #unknown! !!TileMorph methodsFor: 'accessing'!slotName	^ slotName! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/1/97 01:48'!suffixArrow: a	suffixArrow _ a! !!TileMorph methodsFor: 'accessing' stamp: 'sw 10/18/97 18:03'!topEditor	^ self outermostMorphThat: [:m | 		(m isKindOf: ScriptEditorMorph) or: [m isKindOf: CompoundTileMorph]].! !!TileMorph methodsFor: 'accessing'!type	^ type! !!TileMorph methodsFor: 'accessing' stamp: 'sw 11/1/97 01:48'!upArrow: a	upArrow _ a! !!TileMorph methodsFor: 'mouse handling' stamp: 'sw 9/17/97 22:18'!handlesMouseDown: evt	| aPoint |	aPoint _ evt cursorPoint.	upArrow ifNotNil: [((upArrow containsPoint: aPoint) or: [downArrow containsPoint: aPoint])		ifTrue: [^ true]].	suffixArrow ifNotNil: [(suffixArrow containsPoint: aPoint)		ifTrue: [^ true]].	^ super handlesMouseDown: evt! !!TileMorph methodsFor: 'mouse handling' stamp: 'di 1/21/98 09:04'!mouseDown: evt	| aPoint |	aPoint _ evt cursorPoint.	nArrowTicks _ 0.	upArrow ifNotNil:		[(upArrow containsPoint: aPoint) ifTrue: [^ self].		(downArrow containsPoint: aPoint) ifTrue: [^ self]].	suffixArrow ifNotNil:		[(suffixArrow containsPoint: aPoint)			 ifTrue: [self showSuffixChoices.  ^ self]].	^ super mouseDown: evt! !!TileMorph methodsFor: 'mouse handling' stamp: 'di 1/21/98 09:47'!mouseMove: evt	"See if arrows are being pressed and call arrowAction:..."	upArrow ifNotNil:		[(upArrow containsPoint: evt cursorPoint) ifTrue:			[self readyForAnotherTick ifTrue: [^ self arrowAction: 1]].		(downArrow containsPoint: evt cursorPoint) ifTrue:			[self readyForAnotherTick ifTrue: [^ self arrowAction: -1]]].	super mouseMove: evt.! !!TileMorph methodsFor: 'mouse handling' stamp: 'sw 10/3/97 14:30'!trumpsMouseDown: evt	"Return true if this morph wants to handle mouse down events even when the mouse is pressed under a submorph that also wishes to preepmpt mouse down events. Complete the comment."	| aPoint |	upArrow ifNotNil:		[(upArrow containsPoint: (aPoint _ evt cursorPoint))			ifTrue: [^ true].		(downArrow containsPoint: aPoint)			ifTrue: [^ true]].	^ false! !!TileMorph methodsFor: 'arrows' stamp: 'sw 9/17/97 22:15'!addArrows	downArrow _ ImageMorph new image: DownPicture.	upArrow _ ImageMorph new image: UpPicture.	upArrow position: bounds topLeft + (2@2).	downArrow align: downArrow bottomLeft				with: bounds topLeft + (0 @ TileMorphdefaultH) + (2@-2).	self addMorph: downArrow.	self addMorph: upArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'sw 1/21/98 20:48'!addSuffixArrow	suffixArrow _ ImageMorph new image: SuffixPicture.	self addMorph: suffixArrow.	suffixArrow align: suffixArrow topLeft with:		bounds topRight + (-2@(self height//2)) - (0@(suffixArrowheight//2)).	self extent: self fullBounds extent! !!TileMorph methodsFor: 'arrows' stamp: 'tk 10/12/97 15:05'!addSuffixIfCan	"Should this tile have a suffix arrow?"	self addSuffixArrow.! !!TileMorph methodsFor: 'arrows' stamp: 'sw 5/4/1998 00:31'!arrowAction: delta	"Figure out what to do when the up or down arrow is pressed.	May be overridden in subclasses"	| index aList |	owner ifNil: [^ self].	(type == #literal and: [literal isNumber])		ifTrue: [^ self literal: literal + delta].	(type == #literal and: [literal isKindOf: Boolean])		ifTrue: [^ self literal: literal not].	operatorOrExpression ifNotNil:		[aList _ #(+ - * / min: max:).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[self setOperatorAndUseArrows: (aList atWrap: index + delta)].		aList _ #(< <= = ~= > >=).		index _ aList indexOf: operatorOrExpression.		index  > 0 ifTrue:			[owner firstSubmorph type = #number 				ifTrue: [self setOperator: (aList atWrap: index + delta)]				ifFalse: [self setOperator: (#(= ~=) atWrap: index - 2 + delta)]].						"Color does not understand <"			^ self acceptNewLiteral]	! !!TileMorph methodsFor: 'arrows' stamp: 'tk 10/12/97 18:48'!deleteSuffixArrow	suffixArrow delete.	suffixArrow _ nil.	self updateLiteralLabel! !!TileMorph methodsFor: 'arrows' stamp: 'di 11/17/97 18:01'!readyForAnotherTick	"Just call this once, when you need it,		since it may change lastArrowTick."	| now delay |	now _ Time millisecondClockValue.	delay _ nArrowTicks		ifNil: [300]		ifNotNil: [nArrowTicks > 5 ifTrue: [100] ifFalse: [300]].	(lastArrowTick == nil		or: [now < lastArrowTick  "clock rollover"		or: [now > (lastArrowTick + delay)]])		ifTrue: [lastArrowTick _ now.				nArrowTicks ifNotNil: [nArrowTicks _ nArrowTicks + 1].				^ true]		ifFalse: [^ false]! !!TileMorph methodsFor: 'arrows' stamp: 'sw 4/27/1998 22:13'!showSuffixChoices	"The user wants to know what can follow this tile"	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: 1 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ (self world findA: EToyPalette) phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter coloredTilesEnabled ifFalse:		[phrase topEditor			ifNotNil:				[phrase topEditor makeAllTilesGreen]			ifNil:				[phrase makeAllTilesGreen]]! !!TileMorph methodsFor: 'code generation' stamp: 'sw 2/12/98 13:23'!acceptNewLiteral	"Tell the scriptEditor who I belong to that I have a new literal value."	| topScript |	topScript _ self outermostMorphThat:		[:m | m isKindOf: ScriptEditorMorph].	topScript ifNotNil: [topScript installWithNewLiteral]! !!TileMorph methodsFor: 'code generation'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s.	^ s contents! !!TileMorph methodsFor: 'code generation'!precedingTileType	"Return the slot reference type of the preceding TileMorph in my owner."	| row i tile |	row _ owner submorphs.	i _ row indexOf: self.	((i > 1) and: [(tile _ row at: i - 1) isKindOf: TileMorph])		ifTrue: [^ tile type]		ifFalse: [^ #unknown].! !!TileMorph methodsFor: 'code generation' stamp: 'sw 9/26/97 10:51'!scriptEdited	"Tell the scriptEditor who I belong to that I have changed.  "	| him |	(him _ self outermostMorphThat: [:m| m isKindOf: ScriptEditorMorph])		ifNotNil: [him scriptEdited]! !!TileMorph methodsFor: 'code generation' stamp: 'sw 4/28/1998 00:15'!storeCodeOn: aStream	| op refType playerBearingCode |	"Must determine whom is scripted for what follows to work"	playerBearingCode _ self playerBearingCode.  "If it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["This is the critical point -- if the object is the method's own 'self' then we MUST, rather than just MAY, put out self rather than the referencer call, though the latter will temporarily work as long we have true uniclasses."				aStream nextPutAll: 'self']			ifFalse:				[aStream nextPutAll: 'self class '.				aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'private' stamp: 'tk 10/10/97 21:39'!fullBounds	super fullBounds.	owner class == TilePadMorph ifTrue: [owner bounds: bounds].	^ fullBounds! !!TileMorph methodsFor: 'private' stamp: 'sw 5/2/1998 15:01'!line1: line1	| m desiredW |	self removeAllMorphs.	m _ StringMorph contents: line1 font: ScriptingSystem fontForTiles.	desiredW _ m width + 6.	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	m position: self center - (m extent // 2).	self addMorph: m.! !!TileMorph methodsFor: 'private' stamp: 'sw 5/2/1998 15:01'!line1: line1 line2: line2	| m1 m2 desiredW |	self removeAllMorphs.	m1 _ StringMorph contents: line1 font: ScriptingSystem fontForTiles.	m2 _ StringMorph contents: line2 font: ScriptingSystem fontForTiles.	desiredW _ (m1 width max: m2 width) + 6.	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	m1 position: (bounds center x - (m1 width // 2) + 1)@(bounds top + 1).	m2 position: (bounds center x - (m2 width // 2) + 1)@(m1 bottom - 2).	self addMorph: m1; addMorph: m2.! !!TileMorph methodsFor: 'private' stamp: 'sw 5/2/1998 15:01'!updateLiteralLabel	"now works for operator tiles also"	|  desiredW leader myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel contents:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + (leader + 0)) @ (bounds top + 5); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!TileMorph methodsFor: 'private' stamp: 'sw 5/13/1998 14:53'!updateLiteralLabelClipped	"now works for operator tiles also"	|  desiredW leader myLabel |	myLabel _ nil.	submorphs do: [:m | (m isKindOf: StringMorph) ifTrue: [myLabel _ m]].	myLabel ifNil: [^ self].	myLabel contentsClipped:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + leader)@(bounds top + 5).	suffixArrow ifNotNil: [		suffixArrow			align: suffixArrow topRight			with: bounds topRight + (-2@(self height//2)) - (0@(suffixArrow height//2))].	self changed.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TileMorph class	instanceVariableNames: ''!!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:40'!downPicture	^ DownPicture! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:39'!downPicture: p	DownPicture _ p! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 17:30'!fixCaretForms	"TileMorph fixCaretForms"	"UpPicture storeString"	"DownPicture storeString"	UpPicture _  Form	extent: 9@8	depth: 16	fromArray: #( 0 0 60817408 0 0 0 0 60818336 0 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 60818336 60818336 60818336 0 928 60818336 60818336 60818336 0 928 60818336 60818336 60818336 60817408 60818336 60818336 60818336 60818336 60817408)	offset: 0@0.	DownPicture _ Form	extent: 9@8	depth: 16	fromArray: #( 60818336 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 60817408 928 60818336 60818336 60818336 0 0 60818336 60818336 60818336 0 0 928 60818336 60817408 0 0 928 60818336 60817408 0 0 0 60818336 0 0 0 0 60817408 0 0)	offset: 0@8.	SuffixPicture _  Form	extent: 10@8	depth: 16	fromArray: #( 928 0 0 0 0 60818336 60818336 0 0 0 60818336 60818336 60818336 60817408 0 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 60818336 0 60818336 60818336 60818336 0 0)	offset: 0@0! !!TileMorph class methodsFor: 'class initialization' stamp: 'tk 10/12/97 15:16'!initialize	"TileMorph readInArrowGraphics    -- call manually if necessary to bring graphics forward"	"TileMorph initialize"	UpdatingOperators _ Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.	SuffixArrowAllowance _ 12.	UpArrowAllowance _ 10.! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 10/3/97 14:20'!readInArrowGraphics	"TileMorph readInArrowGraphics"	| obj |	obj _ (FileStream oldFileNamed: 'tile inc arrow.morph') fileInObjectAndCode.	UpPicture _ obj form.	obj _ (FileStream oldFileNamed: 'tile dec arrow.morph') fileInObjectAndCode.	DownPicture _ obj form.	obj _ (FileStream oldFileNamed: 'tile suffix arrow.morph')fileInObjectAndCode.	SuffixPicture _ obj form.! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:48'!suffixPicture	^ SuffixPicture! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:48'!suffixPicture: p	SuffixPicture _ p! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:29'!upPicture	^ UpPicture! !!TileMorph class methodsFor: 'class initialization' stamp: 'sw 1/21/98 16:29'!upPicture: p	UpPicture _ p! !!TileMorph class methodsFor: 'constants' stamp: 'tk 9/17/97 17:24'!defaultH	^ 22! !!TileMorph class methodsFor: 'constants' stamp: 'sw 9/30/97 21:11'!defaultW	^ 18! !Morph subclass: #TilePadMorph	instanceVariableNames: 'type '	classVariableNames: 'ColorsForType '	poolDictionaries: ''	category: 'Morphic-Scripting-Tiles'!!TilePadMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!TilePadMorph comment:'The drop target for colored tiles.  Landing pad.  In the hierarchy, but not a tile itself.  Would like to eliminate this, but an attempt at it failed. '!!TilePadMorph methodsFor: 'all' stamp: 'sw 4/22/1998 16:42'!acceptDroppingMorph: aMorph event: evt	| editor |	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	(editor _ self topEditor) ifNotNil: [editor install].  "accept the change now"! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 08:30'!canAccept: aMorph	((aMorph isKindOf: PhraseTileMorph) or:	 [aMorph isKindOf: TileMorph]) ifTrue: [		^ aMorph resultType == type].	^ false! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/25/97 16:57'!handlesMouseOver: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 08:30'!inPartsBin	| o |	o _ self owner.	[o == nil] whileFalse: [		(o isKindOf: PartsBinMorph) ifTrue: [^ true].		o _ o owner].	^ false! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 21:57'!mouseEnter: evt	"Show drag/drop feedback."	| h m |	h _ evt hand.	h submorphCount ~= 1 ifTrue: [^ self].	m _ h firstSubmorph.	(self canAccept: m) ifTrue: [		self color: (TilePadMorph brightColorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue: [				subM color: (TilePadMorph brightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 21:57'!mouseLeave: evt	"Clear drag/drop feedback."	color ~= (TilePadMorph colorForType: type) ifTrue: [		self color: (TilePadMorph colorForType: type).		self submorphsDo: [:subM |			(subM isKindOf: TileMorph) ifTrue: [				subM color: (TilePadMorph unbrightColorFor: subM color)]]].! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 22:20'!prepareToUndoDropOf: aMorph	| m |	self mouseLeave: MorphicEvent new.	m _ self owner.	[m == nil] whileFalse: [		(m isKindOf: ScriptEditorMorph) ifTrue: [^ m prepareToUndoDropOf: aMorph].		m _ m owner].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/13/97 00:43'!printString	^ super printString, ' type=', type printString! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 20:51'!rootForGrabOf: aMorph	"Allow submorph to be extracted."	| root |true ifTrue: [^ super rootForGrabOf: aMorph].	self inPartsBin ifTrue: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root = self] whileFalse: [		root owner = self ifTrue: [			root color: (TilePadMorph colorForType: root resultType).			^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 08:30'!setType: aSymbol	type _ aSymbol.	self color: (TilePadMorph colorForType: type).	self extent: (TileMorph defaultW)@(TileMorph defaultH).! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 10:26'!storeCodeOn: aStream	submorphs do: [:m | m storeCodeOn: aStream].! !!TilePadMorph methodsFor: 'all' stamp: 'tk 10/31/97 10:14'!topEditor	^ self outermostMorphThat: [:m | 		(m isKindOf: ScriptEditorMorph) or: [m isKindOf: CompoundTileMorph]].! !!TilePadMorph methodsFor: 'all' stamp: 'sw 10/3/97 18:00'!type	^ type! !!TilePadMorph methodsFor: 'all' stamp: 'jm 6/26/97 08:30'!wantsDroppedMorph: aMorph event: evt	^ self canAccept: aMorph! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TilePadMorph class	instanceVariableNames: ''!!TilePadMorph class methodsFor: 'all' stamp: 'jm 6/26/97 20:17'!brightColorFor: aColor	ColorsForType do: [:pair |		(pair at: 1) = aColor ifTrue: [^ (pair at: 2)]].	^ aColor! !!TilePadMorph class methodsFor: 'all' stamp: 'jm 6/25/97 16:53'!brightColorForType: typeSymbol	^ (ColorsForType		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 2! !!TilePadMorph class methodsFor: 'all' stamp: 'jm 6/26/97 08:30'!colorForType: typeSymbol	^ (ColorsForType		at: typeSymbol asSymbol		ifAbsent: [^ Color magenta]) at: 1! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 5/8/1998 13:40'!colorFudge	^ 0.4! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 5/8/1998 13:39'!initialize	"TilePadMorph initialize"	ColorsForType _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(point			(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | ColorsForType at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!TilePadMorph class methodsFor: 'all' stamp: 'jm 6/26/97 20:17'!unbrightColorFor: aColor	ColorsForType do: [:pair |		(pair at: 2) = aColor ifTrue: [^ (pair at: 1)]].	^ aColor! !Magnitude subclass: #Time	instanceVariableNames: 'hours minutes seconds '	classVariableNames: ''	poolDictionaries: ''	category: 'Numeric-Magnitudes'!!Time commentStamp: 'di 5/22/1998 16:39' prior: 0!Time comment:'I represent the time of day.'!!Time methodsFor: 'accessing'!hours	"Answer the number of hours the receiver represents."	^hours! !!Time methodsFor: 'accessing'!minutes	"Answer the number of minutes the receiver represents."	^minutes! !!Time methodsFor: 'accessing'!seconds	"Answer the number of seconds the receiver represents."	^seconds! !!Time methodsFor: 'arithmetic'!addTime: timeAmount	"Answer a Time that is timeInterval after the receiver. timeInterval is an 	instance of Date or Time."	^Time fromSeconds: self asSeconds + timeAmount asSeconds! !!Time methodsFor: 'arithmetic'!subtractTime: timeAmount 	"Answer a Time that is timeInterval before the receiver. timeInterval is 	an instance of Date or Time."	^Time fromSeconds: self asSeconds - timeAmount asSeconds! !!Time methodsFor: 'comparing'!< aTime 	"Answer whether aTime is earlier than the receiver."	hours ~= aTime hours ifTrue: [^hours < aTime hours].	minutes ~= aTime minutes ifTrue: [^minutes < aTime minutes].	^seconds < aTime seconds! !!Time methodsFor: 'comparing'!= aTime 	"Answer whether aTime represents the same second as the receiver."	self species = aTime species		ifTrue: [^hours = aTime hours 					& (minutes = aTime minutes) 					& (seconds = aTime seconds)]		ifFalse: [^false]! !!Time methodsFor: 'comparing'!hash	"Hash must be redefined since = was redefined."	^((hours hash bitShift: 3) bitXor: minutes) bitXor: seconds! !!Time methodsFor: 'printing' stamp: 'tk 1/28/98 12:54'!intervalString	"Treat the time as a difference.  Give it in hours and minutes with two digits of accuracy."	| hh mm ss |	hh _ hours = 0 ifTrue: [''] ifFalse: [' ', hours printString, ' hours'].	mm _ minutes = 0 ifTrue: [''] ifFalse: [' ', minutes printString, ' minutes'].	ss _ seconds = 0 ifTrue: [''] ifFalse: [' ', seconds printString, ' seconds'].	hh size > 0 ifTrue: [ss _ ''].	^ hh, mm, ss! !!Time methodsFor: 'printing'!print24: hr24 on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am' "	hr24	ifTrue:		[hours < 10 ifTrue: [aStream nextPutAll: '0'].		hours printOn: aStream]	ifFalse:		[hours > 12		ifTrue: [hours - 12 printOn: aStream]		ifFalse: [hours < 1				ifTrue: [12 printOn: aStream]				ifFalse: [hours printOn: aStream]]].	aStream nextPutAll: (minutes < 10 ifTrue: [':0']									  ifFalse: [':']).	minutes printOn: aStream.	aStream nextPutAll: (seconds < 10 ifTrue: [':0']									  ifFalse: [':']).	seconds printOn: aStream.	hr24 ifFalse:		[ aStream nextPutAll: (hours < 12 ifTrue: [' am']										ifFalse: [' pm'])]! !!Time methodsFor: 'printing'!printOn: aStream 	^ self print24: false on: aStream! !!Time methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(', self class name, ' readFromString: ';		print: self printString;		nextPut: $)! !!Time methodsFor: 'converting'!asSeconds	"Answer the number of seconds since midnight of the receiver."	^3600 * hours + (60 * minutes + seconds)! !!Time methodsFor: 'private'!hours: anInteger	hours _ anInteger! !!Time methodsFor: 'private'!hours: hourInteger minutes: minInteger seconds: secInteger	hours _ hourInteger.	minutes _ minInteger.	seconds _ secInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Time class	instanceVariableNames: ''!!Time class methodsFor: 'instance creation'!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	| secondsInHour hours secs |	secs _ secondCount asInteger.	hours _ secs // 3600.	secondsInHour _ secs \\ 3600.	^self new hours: hours			   minutes: secondsInHour // 60			   seconds: secondsInHour \\ 60! !!Time class methodsFor: 'instance creation'!now	"Answer an instnace of me representing the time right now--this is a 24 	hour clock."	^self dateAndTimeNow at: 2! !!Time class methodsFor: 'instance creation'!readFrom: aStream	"Read a Time from the stream in the form:		<hour>:<minute>:<second> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"	| hour minute second |	hour _ Integer readFrom: aStream.	minute _ 0.	second _ 0.	(aStream peekFor: $:) ifTrue:		[minute _ Integer readFrom: aStream.		(aStream peekFor: $:) ifTrue:			[second _ Integer readFrom: aStream]].	aStream skipSeparators.	(aStream atEnd not and: [aStream peek isLetter])		ifTrue:			[aStream next asLowercase = $p ifTrue: [hour _ hour + 12].			(aStream peekFor: $m) ifFalse: [aStream peekFor: $M]].	^self fromSeconds: 60*(60*hour+minute)+second	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !!Time class methodsFor: 'general inquiries' stamp: 'jm 12/4/97 19:59'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Time fromSeconds: secondCount \\ 86400)		with: (Date fromDays: secondCount // 86400)! !!Time class methodsFor: 'general inquiries'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	| secondCount d t |	secondCount _ self primSecondsClock.	d _ Date fromDays: secondCount // 86400.	t _ Time fromSeconds: secondCount \\ 86400.	^ Array with: d with: t! !!Time class methodsFor: 'general inquiries'!millisecondClockValue	"Answer the number of milliseconds since the millisecond clock was last 	reset or rolled over."	^ self primMillisecondClock! !!Time class methodsFor: 'general inquiries'!millisecondsToRun: timedBlock 	"Answer the number of milliseconds timedBlock takes to return its value."	| initialMilliseconds |	initialMilliseconds _ self millisecondClockValue.	timedBlock value.	^self millisecondClockValue - initialMilliseconds! !!Time class methodsFor: 'general inquiries'!totalSeconds	"Answer the total seconds from January 1, 1901."	^ self primSecondsClock! !!Time class methodsFor: 'private'!primMillisecondClock	"Primitive. Answer the number of milliseconds since the millisecond clock	 was last reset or rolled over. Answer zero if the primitive fails.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 135>	^ 0! !!Time class methodsFor: 'private'!primSecondsClock	"Answer the number of seconds since 00:00 on the morning of	 January 1, 1901 (a 32-bit unsigned number).	 Essential. See Object documentation whatIsAPrimitive. "	<primitive: 137>	self primitiveFailed! !SketchMorph subclass: #TinyPaint	instanceVariableNames: 'brush brushSize brushColor lastMouse '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!TinyPaint methodsFor: 'initialization' stamp: 'jm 11/4/97 07:15'!initialize	super initialize.	color _ Color veryVeryLightGray.	brushColor _ Color red.	brushSize _ 3.	self clear.! !!TinyPaint methodsFor: 'events' stamp: 'sw 5/11/1998 14:02'!handlesMouseDown: evt	^ self inPartsBin not! !!TinyPaint methodsFor: 'events' stamp: 'jm 5/6/1998 16:28'!mouseDown: evt	lastMouse _ evt cursorPoint.	brush drawFrom: lastMouse - bounds origin to: lastMouse - bounds origin.	self invalidRect:		((lastMouse - brush sourceForm extent) corner:		 (lastMouse + brush sourceForm extent)).! !!TinyPaint methodsFor: 'events' stamp: 'jm 11/4/97 07:15'!mouseMove: evt	| p |	p _ evt cursorPoint.	p = lastMouse ifTrue: [^ self].	brush drawFrom: lastMouse - bounds origin to: p - bounds origin.	self invalidRect: (		((lastMouse min: p) - brush sourceForm extent) corner:		((lastMouse max: p) + brush sourceForm extent)).	lastMouse _ p.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'clear' action: #clear.	aCustomMenu add: 'pen color' action: #setPenColor:.	aCustomMenu add: 'pen size' action: #setPenSize.	aCustomMenu add: 'fill' action: #fill.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor	brushColor _ aColor.	brush color: aColor.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 5/6/1998 16:23'!clear	self form: ((Form extent: 125@100 depth: 8) fillColor: color).	brush _ Pen newOnForm: originalForm.	brush roundNib: brushSize.	brush color: brushColor.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self world viewBox origin - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor:.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:16'!setPenSize	| menu sizes nibSize |	menu _ CustomMenu new.	sizes _ (0 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w | menu add: w printString action: w].	nibSize _ menu startUp.	nibSize ifNotNil: [		brushSize _ nibSize.		brush roundNib: nibSize].! !ThreePhaseButtonMorph subclass: #ToggleButtonMorph	instanceVariableNames: 'stateSelector '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 10/2/97 16:52'!buttonDownToToggleState	| targetState |	self doButtonAction.	targetState _ (target perform: stateSelector) ifTrue: [#on] ifFalse: [#off].	targetState = state ifFalse: [self toggleState]! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:11'!mouseDown: evt	self buttonDownToToggleState! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:06'!mouseMove: evt! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:02'!mouseUp: evt! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 19:43'!setInitialState	state _ (target perform: stateSelector) == true		ifTrue:			[#on]		ifFalse:			[#off]! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 9/19/97 15:23'!stateSelector: sym	stateSelector _ sym! !!ToggleButtonMorph methodsFor: 'all' stamp: 'sw 10/2/97 17:03'!toggleState	self state: ((state == #off) ifTrue: [#on] ifFalse: [#off])! !WriteStream subclass: #TranscriptStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!TranscriptStream commentStamp: 'di 5/22/1998 16:39' prior: 0!This class is a much simpler implementation of Transcript protocol that supports multiple views and very simple conversion to morphic.  Because it inherits from Stream, it is automatically compatible with code that is designe to write to streams.!!TranscriptStream methodsFor: 'all' stamp: 'di 5/13/1998 14:31'!characterLimit	"Tell the views how much to retain on screen"	^ 3000! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 12:35'!clear	"Clear all characters and redisplay the view"	self changed: #clearText.	self reset! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/7/1998 22:46'!defaultBackgroundColor	^ #lightOrange! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 12:35'!endEntry	"Display all the characters since the last endEntry, and reset the stream"	self changed: #appendEntry.	self reset! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 13:12'!open	| openCount |	openCount _ 0.	self dependents do:		[:d | ((d isKindOf: PluggableTextView) or:			[d isKindOf: PluggableTextMorph]) ifTrue: [openCount _ openCount + 1]].	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 20:16'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: nil)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/14/1998 09:46'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	World ifNotNil: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: nil.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 12:35'!pastEndPut: anObject	"If the stream reaches its limit, just output the contents and reset."	self endEntry.	^ self nextPut: anObject! !!TranscriptStream methodsFor: 'all' stamp: 'di 5/8/1998 13:32'!show: aString  "TextCollector compatibility"	self nextPutAll: aString.	self endEntry ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TranscriptStream class	instanceVariableNames: ''!!TranscriptStream class methodsFor: 'all' stamp: 'di 5/8/1998 13:51'!new	^ self on: (String new: 1000)"INSTALLING:TextCollector allInstances do:	[:t | t breakDependents.	t become: TranscriptStream new].TESTING: (Execute this text in a workspace)Do this first...	tt _ TranscriptStream new.	tt openLabel: 'Transcript test 1'.Then this will open a second view -- ooooh...	tt openLabel: 'Transcript test 2'.And finally make them do something...	tt clear.	[Sensor anyButtonPressed] whileFalse:		[1 to: 20 do: [:i | tt print: (2 raisedTo: i-1); cr; endEntry]]."! !!TranscriptStream class methodsFor: 'all' stamp: 'di 5/8/1998 12:44'!newTranscript: aTextCollector 	"Store aTextCollector as the value of the system global Transcript."	Smalltalk at: #Transcript put: aTextCollector! !Morph subclass: #TransformMorph	instanceVariableNames: 'transform smoothing '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!TransformMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!A TransformMorph introduces a 2-D transformation between its (global) coordinates and the (local) coordinates of its submorphs, while also clipping all display to its bounds.  Specifically, with no offset, angle or scaling, a submorph with coordinates (0@0) will appear exactly at the topLeft of the windowMorph (its position).  Rotation and scaling are relative to the local origin, (0@0).TransformMorphs operate with two different display strategies, depending on whether the transformation is a pure translation or not.  If so, then they simply use a clipping canvas and display their submorphs with the appropriate offset.  If the transformation includes scaling or rotation, then a caching canvas is used, whose active area covers the fullBounds of the submorphs intersected with the source quadrilateral corresponding to the window bounds.!!TransformMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color lightGreen.	smoothing _ 1.	transform _ MorphicTransform identity.! !!TransformMorph methodsFor: 'accessing'!angle	^ transform angle! !!TransformMorph methodsFor: 'accessing'!angle: newAngle	transform _ transform withAngle: newAngle.	self changed! !!TransformMorph methodsFor: 'accessing'!offset	^ transform offset + self innerBounds topLeft! !!TransformMorph methodsFor: 'accessing'!offset: newOffset	transform _ transform withOffset: newOffset - self innerBounds topLeft.	self changed! !!TransformMorph methodsFor: 'accessing'!scale	^ transform scale! !!TransformMorph methodsFor: 'accessing' stamp: 'jm 4/17/1998 05:23'!scale: newScale	self changed.	transform _ transform withScale: newScale.	self layoutChanged.	self changed.! !!TransformMorph methodsFor: 'accessing'!setOffset: newOffset angle: newAngle scale: newScale	transform _ MorphicTransform offset: newOffset angle: newAngle scale: newScale.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothing: cellSize	smoothing _ cellSize.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothingOff	smoothing _ 1.	self changed! !!TransformMorph methodsFor: 'accessing'!smoothingOn	smoothing _ 2.	self changed! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:48'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform transform: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/22/97 23:46'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform transform: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'di 2/23/98 14:44'!colorForInsets	^ owner ifNil: [color] ifNotNil: [owner color]! !!TransformMorph methodsFor: 'drawing'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageForm.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformMorph methodsFor: 'drawing' stamp: 'di 5/13/1998 20:48'!topDownDrawOn: aCanvas	self fullDrawOn: aCanvas! !!TransformMorph methodsFor: 'geometry' stamp: 'di 2/23/98 14:58'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m containsPoint: (transform transform: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !!TransformMorph methodsFor: 'geometry'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!TransformMorph methodsFor: 'geometry' stamp: 'jm 5/16/1998 19:54'!privateFullMoveBy: delta	"Private!! Relocate me, but not my subMorphs."	self privateMoveBy: delta.	transform _ transform withOffset: (transform offset - delta).! !!TransformMorph methodsFor: 'geometry'!submorphBounds	| subBounds |	subBounds _ nil.	self submorphsDo:		[:m |		subBounds ifNil: [subBounds _ m fullBounds]				ifNotNil: [subBounds _ subBounds quickMerge: m fullBounds]].	^ subBounds! !!TransformMorph methodsFor: 'change reporting'!changed	"Needs to be overridden to call superclass's invalidRect:."	super invalidRect: self fullBounds.! !!TransformMorph methodsFor: 'change reporting' stamp: 'di 5/13/1998 16:30'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	owner ifNil: [^ self].	^ owner invalidRect: ((transform invertRect: damageRect) intersect: bounds)! !!TransformMorph methodsFor: 'events'!transformFrom: uberMorph	"Return a transform to map coorinates of uberMorph, a morph above me in my owner chain, into the coordinates of my submorphs."	owner == uberMorph ifTrue: [^ transform].	owner ifNil: [^ transform].	^ (owner transformFrom: uberMorph) composedWith: transform! !!TransformMorph methodsFor: 'events' stamp: 'sw 2/11/98 23:24'!wantsHalo	"The TransformMorph should never be the one to offer up a halo by default"	^ false! !!TransformMorph methodsFor: 'menu' stamp: 'di 11/4/97 09:04'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	smoothing = 1		ifTrue: [aCustomMenu add: 'turn on smoothing' action: #smoothingOn]		ifFalse: [aCustomMenu add: 'turn off smoothing' action: #smoothingOff]! !TransformMorph subclass: #TransformationMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Basic'!!TransformationMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!A TransformationMorph is like a transformMorph, except that it does not clip, and its bounds include its entire submorph.  TransformationMorphs are assumed to have only one submorph -- the idea is that it is a wrapper that enables its submorph to scale and rotate.  A TMorph may come to have more than one submorph if, eg, a menu sprouts a sub menu, using the transformationMorph temporarily as its world, but this ability is only sparsely supported (as in layoutChanged).!!TransformationMorph methodsFor: 'initialization' stamp: 'di 2/21/98 14:35'!asFlexOf: aMorph	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	| pos |	pos _ aMorph position.	self addMorph: aMorph.	aMorph position: (aMorph extent // 2) negated.	self position: pos.	transform _ transform withOffset: aMorph position - pos! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 2/21/98 19:30'!extent: newExtent	| r0 |	self adjustAfter:		[r0 _ self firstSubmorph extent r.		self scale: ((newExtent r / r0 max: 0.1)				 detentBy: 0.1 atMultiplesOf: 1.0 snap: false)]! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/25/1998 05:55'!hasNoScaleOrRotation	^ transform isPureTranslation! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 5/13/1998 10:32'!innocuousName	| r |	^ (r _ self renderedMorph) == self		ifTrue: [super innocuousName] ifFalse: [r innocuousName]! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/17/1998 00:44'!isFlexMorph	^ true! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 5/7/1998 13:46'!isRenderer	^ true! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/29/1998 11:28'!referencePosition	^ self center! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/17/1998 03:53'!referencePosition: aPoint	self position: aPoint - (self extent // 2).! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 2/20/98 14:53'!rotationDegrees	^ self angle radiansToDegrees negated! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/17/1998 00:57'!rotationDegrees: degrees	self adjustAfter:		[self angle: degrees degreesToRadians negated].! !!TransformationMorph methodsFor: 'accessing' stamp: 'jm 4/27/1998 03:18'!scaleToFit: anExtent	| scalePoint scaleFactor |	scalePoint _ anExtent / submorphs first fullBounds extent.	scaleFactor _ (scalePoint x abs min: scalePoint y abs) asFloat.	((scaleFactor - 1.0) abs < 0.05) ifTrue: [scaleFactor _ 1.0].	self scale: ((scaleFactor min: 8.0) max: 0.05).! !!TransformationMorph methodsFor: 'drawing' stamp: 'di 2/23/98 19:59'!drawOn: aCanvas	submorphs isEmpty ifTrue: [super drawOn: aCanvas]! !!TransformationMorph methodsFor: 'change reporting' stamp: 'di 2/23/98 15:41'!layoutChanged	"Recompute bounds as a result of change"	self hasSubmorphs ifTrue:		[bounds _ Rectangle merging:			(self submorphs collect:				[:m | transform invertRect: m fullBounds])].	super layoutChanged! !!TransformationMorph methodsFor: 'menu' stamp: 'sw 5/22/1998 12:44'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	(anActorState _ self valueOfProperty: #actorState) ifNotNil:		[unflexed setProperty: #actorState toValue: anActorState].	(aName _ self valueOfProperty: #name) ifNotNil:		[unflexed setProperty: #name toValue: aName].	unflexed costumee: costumee.	costumee ifNotNil:		[costumee rawCostume: unflexed.		costumee _ nil].	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !!TransformationMorph methodsFor: 'private' stamp: 'di 2/21/98 19:29'!adjustAfter: changeBlock	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldCenter |	oldCenter _ self center.	changeBlock value.	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self layoutChanged.	self position: oldCenter - (self extent // 2)! !ArrayedCollection variableSubclass: #TranslatedMethod	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TranslatedMethod class	instanceVariableNames: ''!!TranslatedMethod class methodsFor: 'class initialization' stamp: 'ikp 1/10/98 02:34'!initialize	self becomeCompact.	Smalltalk recreateSpecialObjectsArray.	Smalltalk specialObjectsArray size = 41		ifFalse: [self error: 'Please check size of special objects array!!']! !Color subclass: #TranslucentColor	instanceVariableNames: 'alpha '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!TranslucentColor commentStamp: 'di 5/22/1998 16:39' prior: 0!TranslucentColor comment:'A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the high byte of a 32-bit pixelValue.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.'!!TranslucentColor methodsFor: 'accessing'!alpha	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."	^ alpha asFloat / 255.0! !!TranslucentColor methodsFor: 'equality'!hash	^ rgb bitXor: alpha! !!TranslucentColor methodsFor: 'printing'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ basicPixelWord bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'private'!privateAlpha	"Return my raw alpha value, an integer in the range 0..255. Used for fast equality testing."	^ alpha! !!TranslucentColor methodsFor: 'private'!setRgb: rgbValue alpha: alphaValue	"Set the state of this translucent color. Alpha is represented internally by an integer in the range 0..255."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgbValue.	alpha _ (255.0 * alphaValue) asInteger min: 255 max: 0.! !Color subclass: #TransparentColor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Display Objects'!!TransparentColor commentStamp: 'di 5/22/1998 16:39' prior: 0!TransparentColor class comment:'An instance of me is the transparent color.  My pixel value is 0 in any depth.  A NullColor is also used when no fill color is desired, as with the background of transparent text.  It will produce all zeroes in any color map entry initialized from it.  In combination with BitBlt paint mode (which does not store zeroes), this will result in transparency.  Note that when this approach is being used in RGB, true black will look the same as a null color, unless you put something in the alpha bits, or use an off-color black.Transparent _ NullColor r: 0 g: 0 b: 0.Color transparent'!!TransparentColor methodsFor: 'equality' stamp: 'di 10/1/97 20:13'!= aColor	^ aColor isColor and: [aColor isTransparent]! !!TransparentColor methodsFor: 'equality'!hash	^ 0! !!TransparentColor methodsFor: 'queries'!isTransparent	^ true! !!TransparentColor methodsFor: 'transformations'!* aFactor	^ self! !!TransparentColor methodsFor: 'transformations'!+ aColor	^ aColor! !!TransparentColor methodsFor: 'transformations'!- aColor	^ self! !!TransparentColor methodsFor: 'transformations'!/ aFactor	^ self! !!TransparentColor methodsFor: 'transformations'!darker	^ self! !!TransparentColor methodsFor: 'transformations'!lighter	^ self! !!TransparentColor methodsFor: 'transformations'!mixed: proportion with: aColor	^ aColor alpha: (1.0 - proportion)! !!TransparentColor methodsFor: 'printing'!shortPrintString	^ 'Transparent'! !!TransparentColor methodsFor: 'printing'!storeOn: aStream	aStream nextPutAll: '(Color transparent)'.! !!TransparentColor methodsFor: 'conversions'!bitPatternForDepth: depth	^ Bitmap with: 0! !!TransparentColor methodsFor: 'conversions'!pixelValueForDepth: d	^ 0! !!TransparentColor methodsFor: 'conversions'!pixelWordForDepth: depth	^ 0! !!TransparentColor methodsFor: 'private'!setRed: r green: g blue: b	"Ignored."! !ThreePhaseButtonMorph subclass: #TrashCanMorph	instanceVariableNames: 'containsHands handsOverMe '	classVariableNames: 'TrashPic TrashPicOn '	poolDictionaries: ''	category: 'Morphic-Widgets'!!TrashCanMorph methodsFor: 'initialization' stamp: 'jm 5/22/1998 11:11'!initialize	super initialize.	handsOverMe _ IdentitySet new.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'jm 5/22/1998 11:25'!handEntering: aHand	"Set by step when the given hand enters me."	((aHand submorphCount > 0) and:	 [aHand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseEnterSound].			aHand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: aHand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'jm 5/22/1998 11:25'!handExiting: aHand	"Set by step when the given hand exits me."	((aHand submorphCount > 0) and:	 [aHand submorphs first ~~ self])		ifTrue: [			self world soundsEnabled ifTrue: [self class playMouseLeaveSound].			aHand endDisplaySuppression.			self state: #off]		ifFalse: [			self stopShowingStampIn: aHand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'jm 5/22/1998 10:25'!handlesMouseDown: evt	^ true! !!TrashCanMorph methodsFor: 'event handling' stamp: 'jm 5/22/1998 10:31'!mouseDown: evt	self state: #pressed.	self openTrash.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'jm 5/22/1998 10:35'!mouseUp: evt	"Close the lid when you're through!!"	self state: #off.! !!TrashCanMorph methodsFor: 'stepping' stamp: 'jm 5/22/1998 11:11'!step	"Handle hand enter and exits."	"Details: The normal mouseOver: mechanism is disabled (for good reasons!!) when the mouse button is down and/or the hand is carrying some object. This exceptional case is handled using the step mechanism."	self inPartsBin ifTrue: [^ self].  "inactive when in parts bin"	handsOverMe ifNil: [handsOverMe _ IdentitySet new].  "lazy initialization"	self world hands do: [:h |		(self containsPoint: h position)			ifTrue: [				(handsOverMe includes: h) ifFalse: [					self handEntering: h.					handsOverMe add: h]]			ifFalse: [				(handsOverMe includes: h) ifTrue: [					self handExiting: h.					handsOverMe remove: h]]].! !!TrashCanMorph methodsFor: 'stepping' stamp: 'jm 5/22/1998 11:24'!stepTime	^ 50! !!TrashCanMorph methodsFor: 'dropping' stamp: 'jm 5/22/1998 09:15'!acceptDroppingMorph: aMorph event: evt	| palette |	self world soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self world findA: EToyPalette.	palette ifNotNil: [palette addToTrash: aMorph].! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 11/16/97 21:46'!wantsDroppedMorph: aMorph event: evt	^ aMorph ~~ self! !!TrashCanMorph methodsFor: 'private' stamp: 'jm 5/22/1998 11:29'!findActivePaintBox	"If painting, return the active PaintBoxMorph. If not painting, or if the paint box cannot be found, return nil."	| w m |	w _ self world.	w ifNil: [^ nil].	(w findA: SketchEditorMorph) ifNil: [^ nil].  "not painting"	(m _ w findA: PaintBoxMorph) ifNotNil: [^ m].	(m _ w findA: EToyPalette) ifNotNil: [^ m paintPalette].	^ nil! !!TrashCanMorph methodsFor: 'private' stamp: 'jm 5/22/1998 10:34'!openTrash	"User wants to see what is in the trash."	| palette paintBox |	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"	palette _ self world findA: EToyPalette.	palette ifNotNil: [^ palette showTrashPalette].! !!TrashCanMorph methodsFor: 'private' stamp: 'jm 5/22/1998 10:13'!showStampIn: aHand	"If painting and in stamp mode, show the stamp that is about to be thrown away."	| paintBox curs |	paintBox _ self findActivePaintBox.	paintBox ifNotNil: [		"See if a stamp is being dropped into the trash. It is not actually held by the hand."		paintBox getSpecial == #stamp: ifTrue: [			curs _ paintBox actionCursor.			aHand showTemporaryCursor: curs hotSpotOffset: curs center]].! !!TrashCanMorph methodsFor: 'private' stamp: 'jm 5/22/1998 10:16'!stopShowingStampIn: aHand	"Revert to the normal cursor."	aHand showTemporaryCursor: nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TrashCanMorph class	instanceVariableNames: ''!!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 11:00'!playDeleteSound	"TrashCanMorph playDeleteSound"	| snd |	Smalltalk at: #SampledSound ifPresent: [:sampledSound |		snd _ sampledSound			samples: self samplesForDelete			samplingRate: 22050.		snd play].! !!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 11:01'!playMouseEnterSound	"TrashCanMorph playMouseEnterSound"	| snd |	Smalltalk at: #SampledSound ifPresent: [:sampledSound |		snd _ sampledSound				samples: self samplesForMouseEnter			samplingRate: 22050.		snd play].! !!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 11:03'!playMouseLeaveSound	"TrashCanMorph playMouseLeaveSound"	| snd |	Smalltalk at: #SampledSound ifPresent: [:sampledSound |		snd _ sampledSound			samples: self samplesForMouseLeave				samplingRate: 22050.		snd play].! !!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 11:00'!samplesForDelete	^ #(0 11 5 18 42 35 28 54 42 59 52 44 16 18 33 6 -39 -30 -39 -37 -61 -61 -55 -83 -71 -42 -66 -45 -61 -40 -22 1 -3 33 61 69 44 59 59 64 44 81 62 79 91 62 45 55 1 -8 -10 -1 -16 -33 -20 -57 -54 -18 10 5 -1 -6 25 62 47 49 79 52 20 50 76 94 74 91 100 94 69 67 76 76 44 71 62 64 91 93 96 113 93 125 120 108 76 67 79 54 79 69 64 83 37 39 35 6 -13 -57 -62 -52 -79 -94 -100 -78 -105 -101 -59 -69 -64 -25 -55 -33 -57 -33 -39 -33 -16 -16 -16 -30 -25 -1 -27 -32 -39 -44 -1 -18 -23 -61 -55 -45 -67 -74 -47 -23 -22 -55 -50 -18 -47 -39 -22 -32 -28 -45 -28 -50 -69 -83 -83 -66 -93 -84 -74 -74 -84 -76 -94 -52 -69 -62 -35 -3 11 -16 28 5 -10 0 3 25 -1 20 32 25 44 59 18 11 -32 0 -11 -28 -55 -67 -62 -64 -57 -49 -76 -239 -980 -1731 -1565 -478 1153 2646 2919 1799 -1385 -5482 -8325 -8427 -4347 2556 9606 13864 12797 7894 731 -6395 -9218 -6222 1491 9207 12724 10783 3258 -6050 -12631 -14020 -9175 -454 8771 14419 13457 7050 -1679 -8875 -11346 -7670 960 10478 16383 15908 10112 2191 -5150 -8398 -6123 644 8334 12364 11062 5163 -2966 -9760 -12327 -9012 -1947 4977 8880 8495 4412 -1704 -6697 -7935 -5491 -186 5557 9289 9235 4955 -819 -4990 -5843 -3005 2128 7204 9606 7728 2439 -3872 -8469 -9930 -7226 -1385 4532 7567 6452 2154 -3136 -7248 -8045 -4493 1794 7582 10089 8636 3994 -1994 -6473 -7257 -3774 1894 6760 9011 7177 1979 -4364 -8760 -9067 -5465 332 5596 7764 5742 284 -5345 -8517 -7840 -3480 2838 8592 10639 7918 2485 -3435 -7177 -7341 -3630 2542 7333 8449 5514 15 -5645 -9192 -8368 -3540 3111 8083 9218 6558 941 -5119 -8500 -7748 -2905 3329 8259 9891 6975 1192 -4921 -8285 -7411 -3123 3090 7961 9206 5967 -130 -5728 -8793 -7886 -3061 3637 8965 9864 6471 683 -5121 -8324 -7547 -2720 3679 8050 8714 5236 -373 -6032 -9138 -7679 -2653 3679 8166 8982 5906 -111 -5825 -8561 -7094 -2091 3874 8412 9128 5533 -361 -5918 -8320 -6939 -2222 4016 8376 8831 4987 -943 -6130 -8678 -7102 -2117 4149 8322 8296 4768 -744 -5827 -8144 -6444 -1172 4732 8463 8412 4659 -1111 -6519 -8782 -6838 -1876 3818 7423 7601 3966 -1852 -6722 -8505 -6354 -1297 4366 8266 8217 4386 -1206 -5891 -7589 -5647 -595 5092 8402 7645 3372 -2274 -7031 -8958 -6814 -1560 4329 7654 7123 3477 -1869 -6393 -7899 -5367 88 5572 8632 8001 3994 -1711 -6441 -7793 -5287 -393 4497 7216 6430 2176 -3494 -7572 -8412 -5660 -476 4873 7782 6690 2393 -2805 -6588 -7323 -4649 614 5879 8327 6904 2609 -2773 -6848 -7927 -5150 117 5087 7272 5923 1730 -3616 -7575 -8117 -4951 332 5082 7314 6100 1716 -3587 -7162 -7338 -4064 1063 5860 7922 6178 1477 -3845 -7267 -7575 -4571 537 5260 7199 5292 826 -4115 -7486 -7689 -4446 938 5637 7201 5421 1063 -3815 -7109 -7141 -3667 1448 5660 6990 4983 519 -4622 -7833 -7543 -3996 1080 5323 6922 5028 385 -4480 -7416 -7070 -3789 1145 5533 6878 4693 40 -4734 -7506 -7268 -3827 1353 5650 6756 4347 -161 -4821 -7581 -7051 -3301 1993 5847 6707 4347 -198 -4888 -7582 -6814 -2926 2076 5860 6719 4339 -313 -5104 -7557 -6685 -2960 1915 5679 6573 3945 -814 -5333 -7572 -6588 -2787 2269 6052 6597 3789 -877 -5189 -7406 -6525 -2636 2447 5996 6307 3497 -1070 -5450 -7609 -6463 -2340 2658 5945 6230 3482 -1158 -5519 -7458 -5949 -1767 3039 6341 6612 3603 -1267 -5625 -7343 -5857 -1774 3033 6279 6346 3156 -1653 -5721 -7357 -5877 -1742 3158 6256 6039 2848 -1752 -5721 -7285 -5643 -1223 3635 6464 6159 2960 -1731 -5771 -7229 -5280 -936 3662 6266 5823 2488 -2386 -6329 -7457 -5362 -1044 3521 6339 5962 2564 -2183 -5850 -6875 -4841 -536 4120 6763 6062 2488 -2111 -5681 -6838 -4873 -605 3845 6190 5268 1777 -2759 -6413 -7419 -5162 -680 3692 5964 5234 1888 -2556 -5979 -6624 -4157 242 4497 6702 5860 2200 -2597 -6054 -6732 -4381 -111 4183 6330 5153 1346 -3170 -6430 -7031 -4688 -198 4213 6335 5180 1519 -2753 -5777 -6198 -3531 958 5024 6619 5234 1523 -3048 -6295 -6753 -4157 137 3986 5665 4412 788 -3545 -6449 -6469 -3735 539 4539 6246 4921 1172 -3100 -5918 -6010 -3352 905 4800 6313 4702 865 -3363 -6118 -6254 -3609 753 4529 5842 4178 466 -3628 -6305 -6174 -3231 1195 4854 6112 4497 715 -3550 -6183 -5972 -3043 1265 4843 6030 4203 264 -3915 -6352 -5945 -2961 1328 4907 6001 4025 50 -3949 -6240 -5808 -2731 1620 5085 5932 3872 5 -3961 -6174 -5640 -2408 1971 5204 5806 3587 -347 -4320 -6493 -5674 -2252 2103 5245 5818 3709 -300 -4249 -6215 -5309 -2066 2078 5077 5591 3262 -809 -4558 -6335 -5384 -2111 2062 5097 5460 3022 -951 -4570 -6283 -5192 -1733 2491 5348 5475 3024 -912 -4546 -6217 -5077 -1557 2597 5245 5301 2785 -1263 -4934 -6522 -5226 -1716 2385 5104 5206 2680 -1328 -4860 -6276 -4933 -1472 2549 5211 5238 2602 -1389 -4778 -6118 -4834 -1379 2664 5109 4880 2156 -1731 -5007 -6259 -4754 -1121 2883 5297 4973 2318 -1620 -4939 -6086 -4395 -697 3187 5426 5082 2242 -1738 -5026 -6037 -4332 -754 3012 5156 4665 1777 -2237 -5294 -6125 -4310 -676 3177 5313 4707 1704 -2171 -5167 -5962 -4134 -434 3307 5221 4456 1421 -2371 -5287 -5974 -3954 -188 3542 5297 4424 1389 -2456 -5362 -5854 -3667 161 3709 5435 4476 1255 -2671 -5472 -5828 -3589 215 3804 5409 4402 1138 -2724 -5324 -5599 -3384 378 3901 5396 4091 868 -2871 -5385 -5572 -3270 525 3884 5155 3828 575 -3119 -5518 -5503 -2994 826 4095 5277 3886 615 -3100 -5348 -5202 -2603 1202 4405 5579 4064 602 -3109 -5419 -5272 -2790 899 4067 5100 3521 122 -3477 -5592 -5270 -2585 1314 4537 5531 3905 485 -3089 -5226 -4956 -2347 1443 4476 5236 3463 11 -3604 -5711 -5257 -2473 1341 4363 5141 3385 -28 -3584 -5504 -4973 -2164 1586 4456 5218 3413 -64 -3496 -5321 -4707 -1969 1721 4571 5109 3195 -329 -3723 -5474 -4821 -1969 1776 4503 4921 2919 -522 -3845 -5506 -4654 -1676 2057 4687 5036 3068 -415 -3721 -5323 -4408 -1430 2169 4614 4882 2788 -695 -3915 -5313 -4337 -1396 2132 4519 4702 2544 -905 -3866 -5124 -3993 -988 2586 4865 4841 2573 -877 -3859 -5050 -3949 -902 2556 4668 4510 2223 -1141 -4108 -5170 -3808 -703 2720 4719 4553 2271 -1131 -3972 -4907 -3489 -390 2919 4890 4537 2088 -1385 -4154 -4934 -3447 -337 2949 4792 4325 1743 -1562 -4181 -4856 -3273 -33 3316 5041 4439 1923 -1424 -3959 -4570 -2910 317 3423 4907 4088 1355 -2054 -4624 -5056 -3187 140 3307 4809 4030 1323 -2069 -4432 -4695 -2724 597 3694 5114 4179 1360 -1966 -4229 -4478 -2602 675 3715 5019 3932 1027 -2281 -4537 -4753 -2714 656 3687 4919 3859 1085 -2127 -4312 -4403 -2332 965 3786 4910 3750 882 -2391 -4437 -4402 -2254 933 3703 4646 3397 396 -2761 -4724 -4539 -2305 980 3754 4756 3469 590 -2468 -4317 -4120 -1871 1389 4050 4788 3321 318 -2715 -4503 -4201 -1837 1438 4025 4685 3201 220 -2892 -4629 -4167 -1665 1653 4171 4763 3180 93 -2975 -4602 -4015 -1499 1777 4212 4668 2927 -195 -3214 -4712 -4027 -1443 1877 4278 4609 2759 -451 -3440 -4853 -4093 -1385 1983 4334 4570 2726 -405 -3326 -4680 -3794 -1068 2210 4410 4547 2595 -554 -3460 -4715 -3725 -987 2203 4300 4352 2317 -875 -3669 -4760 -3687 -941 2237 4312 4330 2291 -778 -3453 -4486 -3475 -775 2271 4218 4105 1969 -1070 -3682 -4656 -3518 -661 2424 4262 4018 1854 -1197 -3718 -4505 -3141 -252 2809 4564 4264 2067 -1039 -3611 -4369 -3028 -201 2761 4427 4040 1772 -1318 -3740 -4352 -2907 -52 2939 4553 4008 1657 -1414 -3784 -4364 -2858 71 3089 4629 4098 1794 -1219 -3535 -4025 -2500 373 3224 4571 3896 1487 -1553 -3828 -4269 -2661 281 3126 4547 3891 1552 -1413 -3640 -3989 -2363 529 3341 4719 4010 1545 -1452 -3640 -3988 -2305 653 3467 4729 3866 1292 -1740 -3849 -4091 -2325 671 3436 4602 3716 1219 -1733 -3760 -3867 -1994 1031 3708 4758 3730 1100 -1925 -3891 -3898 -1938 1044 3640 4625 3557 921 -2020 -3859 -3776 -1813 1116 3687 4617 3465 815 -2079 -3828 -3713 -1708 1263 3759 4544 3307 641 -2169 -3855 -3674 -1608 1362 3750 4410 3090 425 -2383 -4022 -3725 -1533 1491 3835 4488 3167 390 -2378 -3928 -3509 -1257 1728 4013 4573 3123 286 -2473 -3894 -3404 -1080 1884 4078 4466 2853 -5 -2678 -4035 -3440 -1097 1857 3996 4295 2678 -137 -2821 -4118 -3421 -983 1959 4054 4283 2648 -196 -2873 -4054 -3273 -751 2161 4159 4334 2556 -320 -2965 -4064 -3201 -743 2176 4144 4225 2424 -491 -2999 -4011 -3065 -524 2366 4218 4166 2266 -527 -3007 -3950 -2995 -441 2446 4186 4011 2055 -793 -3221 -4122 -3048 -497 2269 3910 3759 1847 -951 -3318 -4032 -2861 -261 2461 4044 3777 1764 -1048 -3282 -3888 -2595 8 2720 4200 3747 1609 -1195 -3413 -4006 -2727 -94 2586 4001 3501 1396 -1321 -3396 -3835 -2456 164 2756 3984 3385 1253 -1458 -3540 -3889 -2427 161 2654 3835 3194 978 -1743 -3638 -3838 -2295 322 2819 3964 3211 939 -1698 -3550 -3689 -2147 446 2883 3884 3016 726 -1901 -3667 -3765 -2123 530 2870 3745 2848 568 -2028 -3721 -3652 -1884 743 3014 3804 2827 478 -2144 -3779 -3686 -1910 685 2910 3669 2636 249 -2295 -3828 -3676 -1867 787 3011 3681 2564 169 -2269 -3684 -3424 -1508 1109 3282 3789 2575 134 -2334 -3779 -3482 -1543 1073 3099 3608 2339 -127 -2620 -3944 -3519 -1525 1092 3151 3535 2273 -193 -2580 -3787 -3318 -1296 1326 3309 3652 2234 -256 -2634 -3888 -3409 -1348 1282 3204 3491 2125 -346 -2666 -3811 -3204 -1114 1441 3253 3462 2008 -432 -2714 -3692 -3007 -861 1662 3399 3499 1940 -547 -2821 -3765 -2983 -854 1648 3346 3394 1743 -761 -2958 -3849 -3087 -822 1676 3304 3282 1636 -822 -2963 -3772 -2878 -644 1835 3375 3296 1599 -831 -2924 -3667 -2702 -446 1998 3489 3307 1604 -885 -2949 -3667 -2658 -408 1984 3421 3207 1407 -1005 -3028 -3592 -2493 -223 2183 3519 3168 1323 -1124 -3078 -3621 -2468 -157 2191 3465 3090 1216 -1211 -3123 -3584 -2390 -106 2201 3424 2983 1031 -1414 -3236 -3594 -2278 52 2393 3518 2982 1026 -1372 -3185 -3492 -2174 217 2481 3558 2990 999 -1399 -3104 -3323 -1944 391 2603 3528 2824 765 -1645 -3338 -3516 -2118 259 2439 3404 2700 654 -1716 -3375 -3479 -1952 439 2602 3455 2704 617 -1772 -3360 -3404 -1901 493 2585 3413 2571 442 -1901 -3413 -3358 -1742 676 2719 3458 2583 442 -1862 -3275 -3184 -1514 848 2836 3482 2495 313 -1981 -3404 -3224 -1543 771 2719 3268 2198 22 -2217 -3523 -3218 -1457 934 2870 3380 2242 59 -2137 -3336 -3000 -1255 1077 2880 3290 2110 -83 -2249 -3472 -3087 -1267 1111 2885 3257 2040 -176 -2349 -3455 -3004 -1129 1255 3036 3316 2039 -227 -2339 -3367 -2824 -929 1423 3077 3287 1959 -317 -2425 -3404 -2826 -843 1430 3068 3162 1762 -476 -2500 -3382 -2659 -727 1562 3083 3145 1742 -512 -2522 -3314 -2559 -602 1664 3136 3073 1555 -715 -2690 -3413 -2556 -503 1757 3190 3055 1450 -804 -2731 -3387 -2464 -390 1826 3150 2944 1301 -988 -2887 -3487 -2491 -402 1808 3073 2807 1145 -1095 -2921 -3406 -2352 -208 1950 3141 2802 1072 -1204 -2977 -3394 -2252 -139 2044 3163 2751 988 -1284 -2999 -3350 -2217 -88 2015 3102 2629 783 -1424 -3044 -3346 -2157 -30 2050 2988 2449 636 -1582 -3178 -3411 -2135 33 2055 3016 2424 588 -1604 -3153 -3331 -2032 105 2123 3004 2344 451 -1704 -3204 -3309 -1933 240 2208 3055 2334 446 -1723 -3175 -3231 -1818 359 2308 3090 2346 386 -1787 -3260 -3265 -1820 356 2266 2999 2193 254 -1933 -3348 -3302 -1774 369 2222 2917 2042 49 -2030 -3348 -3221 -1676 551 2424 2995 2054 59 -2069 -3306 -3095 -1494 698 2522 3017 1974 -76 -2184 -3380 -3114 -1440 812 2568 3072 2033 -28 -2128 -3285 -2956 -1228 978 2724 3102 2010 -72 -2132 -3243 -2871 -1197 1016 2712 3029 1879 -193 -2206 -3229 -2775 -1056 1151 2797 3009 1818 -259 -2251 -3228 -2729 -924 1199 2758 2960 1718 -366 -2324 -3206 -2607 -812 1346 2836 2951 1687 -417 -2296 -3068 -2403 -625 1489 2924 2973 1616 -495 -2352 -3067 -2391 -554 1545 2861 2807 1397 -666 -2452 -3170 -2430 -598 1455 2785 2736 1312 -666 -2441 -3082 -2300 -371 1625 2866 2787 1319 -715 -2419 -3014 -2215 -357 1630 2768 2593 1134 -895 -2544 -3051 -2178 -300 1721 2892 2634 1145 -873 -2515 -2951 -2057 -198 1786 2807 2505 988 -1041 -2620 -2987 -2040 -173 1787 2775 2424 878 -1146 -2653 -2960 -1923 -22 1884 2870 2447 839 -1131 -2622 -2897 -1799 150 2027 2955 2466 880 -1138 -2624 -2885 -1730 215 2008 2792 2244 532 -1406 -2788 -2907 -1703 271 2074 2865 2293 571 -1377 -2724 -2844 -1597 359 2159 2905 2247 524 -1426 -2756 -2770 -1526 385 2118 2799 2111 366 -1521 -2792 -2805 -1494 476 2227 2856 2176 419 -1497 -2702 -2664 -1365 576 2242 2846 2050 288 -1597 -2805 -2685 -1346 610 2278 2780 1937 101 -1784 -2922 -2737 -1321 656 2274 2778 1906 101 -1762 -2860 -2610 -1156 798 2368 2831 1903 113 -1745 -2832 -2569 -1114 817 2385 2771 1847 64 -1781 -2734 -2446 -980 972 2488 2827 1830 -37 -1804 -2773 -2381 -854 1075 2529 2805 1762 -115 -1871 -2814 -2424 -863 995 2388 2588 1572 -262 -1977 -2756 -2281 -768 1187 2551 2702 1616 -217 -1921 -2693 -2156 -525 1368 2688 2802 1681 -176 -1843 -2583 -2054 -486 1362 2622 2668 1482 -310 -1964 -2658 -2030 -407 1440 2632 2615 1414 -419 -1998 -2603 -1949 -308 1501 2646 2553 1251 -544 -2111 -2641 -1891 -203 1606 2693 2558 1221 -636 -2152 -2639 -1867 -169 1662 2737 2547 1212 -588 -2088 -2498 -1655 66 1843 2843 2575 1178 -659 -2118 -2500 -1614 84 1874 2810 2476 1056 -807 -2218 -2522 -1633 91 1833 2736 2359 912 -917 -2295 -2539 -1521 210 1962 2793 2374 877 -956 -2273 -2486 -1486 273 1960 2763 2318 846 -924 -2200 -2364 -1294 463 2123 2812 2301 746 -1033 -2281 -2395 -1277 478 2088 2770 2203 668 -1089 -2273 -2325 -1138 593 2156 2782 2140 586 -1177 -2335 -2295 -1131 673 2266 2788 2115 527 -1240 -2337 -2291 -1065 714 2232 2751 2049 415 -1301 -2344 -2203 -912 893 2398 2875 2103 441 -1287 -2285 -2145 -860 919 2373 2787 1955 291 -1384 -2390 -2218 -926 895 2315 2670 1786 118 -1521 -2456 -2156 -763 1043 2485 2775 1905 215 -1428 -2301 -1988 -605 1143 2486 2773 1811 106 -1504 -2330 -1949 -517 1224 2539 2766 1765 -1 -1609 -2354 -1901 -485 1265 2576 2702 1630 -103 -1664 -2429 -1998 -532 1202 2383 2439 1382 -313 -1859 -2522 -1972 -449 1268 2454 2522 1407 -266 -1801 -2391 -1793 -269 1458 2597 2563 1399 -335 -1806 -2393 -1781 -264 1457 2571 2525 1296 -424 -1881 -2419 -1738 -169 1570 2620 2485 1246 -483 -1893 -2373 -1645 -76 1594 2564 2400 1128 -595 -2039 -2476 -1670 -79 1582 2556 2366 1092 -661 -2010 -2352 -1514 42 1745 2668 2398 1085 -602 -1954 -2271 -1428 161 1794 2649 2296 1000 -680 -1991 -2286 -1416 208 1781 2580 2232 882 -783 -2025 -2223 -1270 357 1925 2659 2237 856 -861 -2084 -2254 -1331 264 1833 2527 2105 724 -924 -2098 -2169 -1211 463 2013 2658 2137 717 -951 -2037 -2125 -1067 580 2088 2704 2156 712 -922 -1998 -2030 -975 687 2101 2625 2033 553 -1068 -2105 -2113 -992 614 2054 2544 1925 393 -1209 -2193 -2120 -978 659 2095 2553 1852 371 -1175 -2167 -2055 -907 712 2117 2532 1833 351 -1221 -2191 -2064 -904 722 2089 2497 1755 251 -1306 -2191 -1996 -809 793 2079 2441 1687 159 -1350 -2232 -1959 -717 875 2159 2439 1591 74 -1423 -2210 -1928 -710 904 2117 2327 1511 0 -1455 -2184 -1832 -544 1070 2242 2419 1545 6 -1440 -2161 -1769 -468 1124 2271 2393 1463 -93 -1541 -2206 -1748 -459 1145 2278 2366 1367 -193 -1575 -2225 -1774 -398 1206 2305 2327 1348 -193 -1597 -2240 -1767 -379 1195 2225 2232 1192 -351 -1692 -2218 -1655 -300 1255 2262 2245 1173 -381 -1740 -2223 -1589 -193 1358 2339 2254 1162 -359 -1698 -2137 -1513 -130 1419 2361 2208 1099 -480 -1771 -2242 -1558 -110 1399 2259 2096 965 -566 -1838 -2200 -1501 -69 1440 2279 2064 956 -566 -1796 -2127 -1367 47 1509 2339 2071 854 -666 -1862 -2105 -1321 125 1599 2378 2079 834 -676 -1816 -2062 -1279 167 1625 2349 1998 792 -726 -1860 -2055 -1178 296 1692 2369 1979 714 -802 -1893 -2084 -1211 261 1664 2237 1779 464 -1005 -2033 -2147 -1245 259 1594 2166 1720 434 -1065 -2061 -2095 -1133 371 1750 2251 1742 417 -1055 -2010 -2003 -1033 476 1747 2210 1621 274 -1178 -2098 -2074 -1051 405 1660 2091 1502 145 -1277 -2162 -2062 -1043 446 1704 2091 1430 117 -1302 -2130 -2008 -924 534 1752 2081 1391 6 -1401 -2186 -2016 -924 551 1669 1938 1233 -144 -1443 -2208 -1949 -810 656 1764 2040 1273 -74 -1399 -2100 -1818 -690 741 1816 2006 1199 -137 -1418 -2110 -1808 -673 737 1740 1866 1055 -293 -1597 -2213 -1793 -644 736 1752 1869 1050 -301 -1584 -2159 -1776 -568 810 1796 1871 1005 -364 -1608 -2164 -1706 -534 843 1798 1833 919 -422 -1660 -2137 -1655 -454 917 1830 1784 866 -449 -1647 -2147 -1604 -424 965 1801 1743 821 -566 -1743 -2128 -1562 -305 1000 1820 1704 753 -619 -1781 -2127 -1565 -334 1000 1874 1733 710 -631 -1726 -2074 -1487 -225 1072 1849 1676 690 -670 -1771 -2072 -1409 -150 1134 1842 1630 622 -744 -1801 -2088 -1375 -118 1112 1793 1572 517 -861 -1860 -2061 -1360 -125 1153 1801 1499 435 -863 -1843 -2011 -1287 -15 1250 1871 1496 419 -888 -1866 -2020 -1263 25 1240 1801 1457 354 -941 -1864 -1971 -1153 123 1290 1808 1416 300 -992 -1882 -1974 -1136 101 1265 1735 1287 169 -1145 -2027 -2006 -1172 88 1243 1709 1223 74 -1185 -2022 -1994 -1090 201 1290 1665 1151 -5 -1270 -2037 -1964 -1029 254 1341 1723 1148 -30 -1243 -1998 -1893 -990 313 1404 1692 1116 -88 -1318 -2061 -1901 -966 335 1372 1657 1007 -184 -1409 -2127 -1972 -1012 273 1297 1553 922 -283 -1502 -2195 -1944 -924 359 1353 1581 934 -257 -1472 -2069 -1782 -743 544 1508 1721 1005 -239 -1430 -2013 -1728 -726 568 1513 1687 946 -274 -1453 -2000 -1706 -615 656 1560 1662 916 -303 -1462 -2018 -1660 -619 641 1506 1558 765 -459 -1584 -2078 -1667 -602 614 1463 1504 707 -507 -1609 -2050 -1591 -502 732 1547 1574 746 -434 -1467 -1896 -1414 -320 873 1638 1558 717 -546 -1572 -1920 -1423 -303 914 1626 1499 622 -576 -1601 -1947 -1440 -315 878 1564 1413 497 -700 -1630 -1901 -1340 -235 943 1635 1450 505 -673 -1626 -1838 -1268 -117 1063 1699 1487 566 -598 -1531 -1754 -1133 6 1155 1725 1477 520 -692 -1577 -1721 -1087 50 1187 1782 1497 541 -634 -1526 -1698 -1005 122 1201 1737 1426 424 -741 -1599 -1704 -1051 98 1219 1728 1363 347 -795 -1614 -1650 -910 278 1353 1830 1470 405 -761 -1553 -1575 -782 407 1414 1867 1394 356 -827 -1587 -1589 -810 320 1326 1735 1304 232 -916 -1650 -1601 -790 378 1401 1748 1262 196 -924 -1606 -1538 -720 463 1453 1774 1262 215 -880 -1591 -1465 -619 542 1487 1760 1224 169 -924 -1567 -1379 -486 658 1604 1874 1328 256 -834 -1433 -1297 -476 680 1601 1816 1236 149 -922 -1492 -1307 -434 705 1579 1733 1136 59 -1005 -1540 -1331 -395 756 1616 1789 1146 67 -944 -1440 -1162 -234 897 1698 1796 1162 54 -965 -1433 -1126 -196 909 1742 1826 1116 39 -951 -1385 -1117 -179 985 1740 1777 1100 -3 -973 -1397 -1065 -139 965 1709 1708 1009 -83 -1061 -1492 -1114 -176 914 1630 1640 902 -188 -1100 -1497 -1082 -135 948 1676 1636 887 -137 -1063 -1382 -966 10 1061 1728 1681 890 -196 -1095 -1360 -888 52 1082 1706 1594 775 -300 -1194 -1472 -994 -25 1014 1628 1484 690 -420 -1262 -1480 -1007 -10 1063 1653 1467 631 -413 -1268 -1460 -951 27 1033 1557 1336 508 -544 -1350 -1552 -999 1 1027 1506 1307 486 -568 -1367 -1492 -904 123 1082 1574 1307 437 -602 -1372 -1474 -880 135 1083 1518 1204 320 -717 -1489 -1574 -980 22 965 1401 1092 188 -858 -1536 -1564 -893 120 1029 1372 1038 173 -824 -1484 -1470 -809 225 1095 1435 1063 156 -851 -1492 -1482 -804 189 1075 1357 992 79 -941 -1541 -1513 -817 186 1038 1329 909 -1 -951 -1550 -1487 -776 242 1068 1319 907 -37 -970 -1562 -1433 -703 281 1111 1338 877 -22 -994 -1547 -1382 -646 359 1158 1375 877 -39 -917 -1424 -1279 -513 488 1246 1396 895 -42 -944 -1430 -1251 -444 493 1180 1296 748 -193 -1056 -1523 -1294 -507 471 1189 1294 754 -176 -1068 -1426 -1178 -354 617 1314 1423 832 -137 -1029 -1413 -1138 -379 566 1257 1306 693 -251 -1112 -1494 -1204 -366 595 1224 1217 608 -351 -1167 -1513 -1184 -340 595 1201 1206 551 -368 -1260 -1558 -1240 -403 519 1117 1089 435 -536 -1324 -1623 -1250 -366 575 1173 1122 468 -466 -1309 -1516 -1111 -244 680 1257 1162 486 -441 -1211 -1443 -1011 -161 763 1258 1160 463 -481 -1258 -1414 -955 -105 773 1243 1104 435 -491 -1216 -1382 -949 -118 800 1263 1089 332 -585 -1250 -1363 -926 -47 832 1262 1027 296 -598 -1258 -1368 -829 54 919 1299 1085 378 -515 -1153 -1219 -703 189 997 1391 1145 393 -517 -1141 -1201 -678 213 1036 1363 1104 303 -605 -1216 -1279 -683 193 983 1304 1011 249 -641 -1223 -1251 -646 245 1046 1299 1002 205 -671 -1216 -1173 -554 354 1136 1397 1043 225 -659 -1189 -1133 -498 368 1139 1391 1004 178 -646 -1160 -1056 -478 432 1160 1401 978 161 -653 -1138 -1089 -420 459 1139 1341 927 115 -695 -1170 -1038 -381 468 1148 1316 893 61 -744 -1201 -1061 -376 503 1173 1341 899 49 -731 -1155 -1000 -312 536 1168 1335 853 27 -754 -1167 -983 -279 575 1219 1297 797 -8 -790 -1145 -931 -234 617 1223 1245 737 -89 -863 -1195 -949 -218 617 1167 1202 693 -183 -895 -1216 -951 -220 629 1172 1199 664 -128 -836 -1134 -844 -108 731 1265 1229 659 -157 -860 -1119 -809 -91 734 1240 1178 595 -229 -975 -1194 -870 -111 678 1150 1136 537 -283 -943 -1165 -800 -71 766 1226 1106 520 -271 -924 -1129 -800 -49 785 1221 1072 476 -361 -980 -1162 -753 1 768 1204 1063 415 -364 -994 -1122 -678 83 868 1268 1109 498 -329 -938 -1039 -631 137 880 1234 1009 354 -422 -1041 -1109 -663 72 832 1182 994 335 -478 -1029 -1136 -649 152 885 1234 1004 320 -471 -999 -1044 -539 247 926 1272 1070 373 -381 -939 -987 -490 256 966 1294 1007 305 -461 -972 -963 -469 278 966 1228 927 218 -529 -1044 -1041 -517 264 924 1143 853 105 -632 -1104 -1048 -507 313 943 1143 788 98 -670 -1100 -1019 -429 339 968 1141 822 117 -603 -1002 -907 -334 454 1050 1195 795 96 -612 -1014 -934 -369 412 983 1073 680 -47 -759 -1153 -1021 -419 335 919 1053 697 -15 -724 -1067 -916 -332 420 966 1055 659 -67 -734 -1106 -917 -349 385 929 1034 600 -96 -734 -1029 -885 -217 513 1060 1082 676 -40 -698 -1005 -785 -193 580 1063 1097 670 -45 -707 -1005 -787 -178 512 1029 1016 505 -217 -829 -1094 -827 -196 517 949 944 480 -229 -836 -1041 -753 -135 602 1100 1068 615 -83 -695 -948 -644 27 710 1133 1073 549 -179 -793 -1005 -736 -71 617 1044 990 463 -266 -831 -1017 -680 -45 658 1063 978 430 -245 -815 -944 -624 42 707 1034 910 376 -327 -880 -1014 -653 -55 636 966 812 290 -393 -917 -1022 -612 61 698 1034 902 327 -386 -912 -1005 -598 44 673 1002 838 261 -464 -944 -1053 -661 27 676 949 739 130 -537 -1031 -1097 -687 -18 653 922 690 113 -547 -1036 -1033 -597 105 719 983 751 149 -536 -978 -983 -546 125 737 949 681 79 -573 -1005 -1002 -559 108 720 895 648 28 -653 -1050 -1011 -524 137 681 834 536 -93 -754 -1160 -1085 -624 79 603 758 463 -184 -829 -1189 -1080 -563 79 631 788 434 -178 -809 -1129 -965 -454 201 724 861 497 -139 -724 -1082 -980 -405 227 729 804 430 -206 -814 -1158 -992 -439 218 683 751 351 -264 -890 -1177 -988 -449 159 661 726 356 -295 -904 -1131 -936 -415 242 697 707 301 -307 -870 -1106 -926 -337 296 739 739 356 -300 -829 -1053 -814 -212 407 821 839 378 -268 -829 -1026 -814 -232 361 749 744 274 -366 -910 -1090 -814 -254 347 751 676 184 -402 -924 -1077 -785 -189 419 763 683 240 -354 -885 -1017 -707 -117 481 812 722 290 -296 -793 -919 -590 -15 576 897 805 322 -312 -809 -890 -598 -64 544 839 715 242 -385 -836 -895 -592 10 602 878 765 291 -315 -731 -815 -454 123 707 955 826 300 -291 -717 -775 -434 139 710 973 788 254 -347 -732 -765 -391 189 714 961 776 249 -330 -707 -709 -332 230 736 941 736 196 -398 -783 -805 -408 195 663 838 632 94 -490 -849 -815 -435 162 648 822 607 83 -481 -826 -768 -320 259 731 873 649 135 -429 -734 -664 -247 335 802 921 629 89 -463 -753 -681 -300 247 693 792 513 -27 -566 -838 -714 -315 271 697 798 493 -22 -564 -860 -707 -245 281 722 819 541 -13 -505 -734 -617 -195 390 814 858 539 11 -520 -739 -607 -149 449 815 848 497 -45 -510 -790 -605 -171 369 775 780 461 -103 -603 -809 -639 -189 329 693 687 354 -183 -671 -843 -654 -193 368 739 770 376 -149 -575 -761 -578 -93 452 839 804 403 -134 -568 -726 -508 -45 498 778 773 371 -161 -625 -766 -530 -57 485 824 731 378 -179 -598 -727 -532 -25 502 773 698 291 -212 -670 -790 -546 -83 420 712 608 218 -293 -703 -787 -524 -49 471 739 649 274 -249 -661 -739 -452 57 532 810 710 274 -234 -619 -698 -413 61 558 758 602 169 -351 -732 -798 -517 -28 435 653 493 52 -408 -810 -817 -490 20 525 719 532 89 -407 -780 -804 -474 1 463 656 466 40 -463 -785 -809 -459 22 452 642 493 13 -435 -754 -717 -366 113 541 714 471 33 -456 -773 -748 -429 61 495 625 420 -15 -502 -838 -751 -402 106 500 610 395 -37 -510 -787 -739 -342 157 549 646 427 -20 -463 -734 -670 -290 208 608 709 452 -20 -469 -724 -666 -273 218 622 648 390 -44 -495).! !!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 11:01'!samplesForMouseEnter	^ #(-37 -24 -30 -30 -25 -23 -11 -8 -38 -40 -34 -21 -18 -27 -34 -20 2 11 8 10 5 7 10 14 34 28 34 54 59 47 54 25 27 43 33 48 23 40 59 63 47 46 27 47 43 41 46 50 64 57 46 57 44 48 12 17 24 28 18 23 27 -7 -17 2 4 1 -4 18 12 11 34 25 43 18 11 20 43 43 11 12 31 -5 -11 -43 -41 -17 -23 -28 -38 -33 -48 -64 -61 -53 -61 -54 -56 -73 -73 -48 -48 -63 -92 -102 -90 -92 -115 -93 -90 -109 -120 -112 -119 -141 -136 -128 -146 -143 -141 -129 -118 -139 -132 -120 -103 -100 -96 -79 -71 -83 -79 -77 -87 -73 -73 -43 -24 -5 -10 20 23 -5 -4 0 28 20 -11 20 4 -11 -23 20 27 7 8 -2 -7 -15 -27 4 0 -8 -34 -31 -38 -34 -50 -40 -64 -46 -59 -51 -82 -80 -82 -80 -89 -95 -122 -89 -97 -67 -64 -31 -21 -34 -56 -25 -35 -48 -63 -37 -54 -34 8 40 82 161 306 503 921 1638 2549 3458 4074 4290 3947 2988 1528 -293 -2417 -4592 -6693 -8734 -10727 -12641 -14255 -15466 -16249 -16383 -15965 -15159 -14019 -12574 -10934 -9124 -7214 -5191 -3092 -856 1418 3639 5667 7543 9156 10532 11608 12361 12795 12922 12755 12307 11574 10473 8964 7129 5084 2911 596 -1773 -4103 -6374 -8593 -10593 -12355 -13748 -14599 -14866 -14527 -13593 -12109 -10146 -7697 -4933 -2022 881 3689 6302 8638 10580 12067 13052 13602 13774 13543 13046 12276 11271 9965 8426 6677 4771 2731 607 -1469 -3420 -5217 -6790 -8196 -9401 -10377 -11001 -11242 -11095 -10600 -9729 -8581 -7114 -5423 -3563 -1566 488 2577 4556 6448 8234 9786 11143 12136 12756 13034 12936 12489 11744 10678 9320 7673 5775 3813 1813 -182 -2113 -3924 -5606 -7123 -8439 -9477 -10213 -10688 -10855 -10663 -10109 -9278 -8125 -6682 -5004 -3147 -1171 791 2762 4655 6386 7944 9222 10201 10800 11120 11163 10885 10313 9434 8363 7050 5604 4048 2395 711 -872 -2376 -3707 -4894 -5875 -6667 -7214 -7489 -7480 -7251 -6739 -6039 -5102 -3987 -2754 -1475 -207 1094 2392 3590 4686 5639 6469 7178 7758 8142 8273 8187 7883 7398 6803 6056 5188 4152 3075 1968 866 -184 -1197 -2143 -2964 -3615 -4163 -4572 -4907 -5100 -5141 -5018 -4723 -4288 -3725 -3031 -2198 -1246 -276 704 1661 2529 3377 4140 4835 5333 5721 5941 6098 6048 5846 5498 5047 4467 3816 3131 2444 1659 856 57 -636 -1301 -1946 -2549 -3099 -3548 -3871 -4057 -4143 -4153 -3999 -3753 -3380 -2893 -2338 -1742 -1098 -391 380 1111 1822 2543 3206 3784 4283 4638 4868 4955 4894 4713 4385 3938 3365 2679 1910 1089 272 -564 -1379 -2145 -2902 -3583 -4127 -4562 -4866 -5010 -4949 -4785 -4468 -4026 -3463 -2817 -2070 -1256 -398 462 1297 2147 2922 3613 4211 4732 5178 5449 5617 5608 5456 5168 4727 4120 3404 2561 1646 706 -218 -1212 -2160 -3018 -3688 -4293 -4726 -5015 -5195 -5231 -5096 -4788 -4321 -3754 -3057 -2240 -1363 -433 515 1446 2340 3118 3820 4401 4851 5133 5256 5195 5011 4696 4209 3627 2934 2168 1334 434 -475 -1357 -2211 -2981 -3669 -4285 -4771 -5116 -5322 -5382 -5315 -5067 -4701 -4169 -3518 -2775 -1937 -1036 -165 735 1626 2440 3115 3681 4154 4467 4625 4681 4589 4344 4008 3583 3008 2353 1615 777 -57 -872 -1713 -2486 -3206 -3843 -4391 -4840 -5116 -5273 -5277 -5128 -4831 -4418 -3868 -3252 -2533 -1744 -898 -67 780 1570 2300 2913 3463 3874 4159 4331 4353 4248 4028 3668 3184 2633 1949 1216 426 -341 -1109 -1852 -2512 -3102 -3597 -3983 -4224 -4349 -4339 -4183 -3910 -3520 -3065 -2510 -1885 -1242 -588 54 685 1249 1839 2352 2777 3106 3327 3466 3488 3417 3234 2948 2617 2185 1671 1117 564 -15 -608 -1174 -1700 -2196 -2650 -3039 -3296 -3481 -3587 -3568 -3460 -3273 -2983 -2614 -2156 -1658 -1154 -626 -89 421 921 1413 1865 2266 2602 2818 3004 3090 3036 2944 2824 2565 2214 1837 1422 954 469 -15 -490 -960 -1413 -1806 -2139 -2421 -2703 -2877 -2949 -2974 -2964 -2820 -2608 -2340 -1972 -1592 -1154 -680 -190 267 745 1183 1592 1947 2225 2473 2624 2696 2723 2692 2565 2408 2219 1916 1579 1200 797 368 -115 -549 -994 -1408 -1767 -2037 -2241 -2394 -2469 -2497 -2427 -2317 -2150 -1887 -1551 -1197 -778 -346 103 544 942 1390 1766 2077 2353 2535 2657 2697 2700 2615 2473 2257 1980 1677 1287 871 466 21 -377 -757 -1134 -1464 -1713 -1932 -2096 -2208 -2243 -2235 -2168 -2051 -1854 -1566 -1229 -888 -499 -100 319 719 1124 1481 1801 2084 2306 2434 2469 2476 2431 2287 2101 1825 1527 1194 836 483 123 -231 -593 -931 -1251 -1541 -1796 -1978 -2122 -2188 -2162 -2106 -1903 -1717 -1467 -1140 -814 -463 -115 254 617 950 1284 1550 1753 1880 1992 1988 1930 1829 1695 1475 1226 924 603 293 -27 -345 -640 -954 -1217 -1471 -1687 -1832 -1917 -1985 -1960 -1900 -1750 -1546 -1356 -1092 -771 -469 -135 200 555 895 1176 1429 1628 1786 1920 1968 1966 1924 1842 1704 1464 1200 922 600 285 -21 -348 -614 -840 -1073 -1266 -1397 -1501 -1595 -1635 -1638 -1585 -1464 -1311 -1151 -971 -735 -501 -267 -43 210 398 643 865 1050 1206 1333 1419 1418 1410 1383 1281 1147 996 803 621 437 226 23 -148 -309 -466 -611 -748 -849 -912 -964 -1016 -1039 -1032 -990 -868 -757 -621 -440 -256 -118 43 194 354 470 564 653 718 780 809 793 748 672 587 453 321 151 8 -142 -308 -499 -647 -819 -950 -1073 -1169 -1243 -1276 -1282 -1262 -1219 -1140 -1016 -921 -809 -624 -475 -335 -142 25 182 339 483 613 702 796 856 899 898 902 858 826 735 656 529 395 263 146 -14 -167 -346 -480 -633 -715 -806 -878 -955 -958 -978 -930 -891 -794 -705 -616 -477 -336 -243 -112 4 109 205 276 332 430 480 519 508 521 513 518 463 384 319 227 112 -8 -100 -202 -348 -505 -596 -725 -833 -906 -951 -940 -927 -883 -806 -692 -542 -365 -207 -60 80 249 400 483 584 626 650 657 634 585 493 443 351 238 158 63 -30 -123 -185 -279 -359 -400 -470 -529 -570 -561 -594 -601 -588 -570 -524 -477 -414 -328 -236 -141 -37 48 99 204 287 391 441 472 495 516 476 418 371 292 204 99 -10 -43 -118 -207 -253 -303 -341 -349 -359 -342 -338 -305 -264 -227 -164 -119 -46 38 99 138 174 227 234 215 231 262 234 227 237 273 218 198 192 192 135 119 90 44 -27 -40 -73 -99 -132 -149 -154 -128 -92 -46 -23 38 59 59 51 57 50 28 17 37 -10 2 -4 -40 -71 -96 -126 -142 -194 -227 -274 -300 -345 -362 -369 -357 -345 -335 -303 -256 -223 -191 -141 -116 -71 -80 -96 -74 -86 -120 -141 -181 -249 -315 -372 -388 -397 -430 -449 -460 -462 -417 -391 -357 -299 -253 -175 -119 -34 43 128 198 241 282 357 410 436 444 472 473 441 413 358 260 191 96 -12 -74 -164 -270 -346 -437 -513 -594 -652 -704 -728 -750 -735 -668 -626 -544 -456 -341 -244 -138 -34 89 195 293 381 459 476 549 597 600 620 601 572 532 475 417 351 233 135 63 -44 -142 -230 -295 -385 -405 -450 -472 -492 -463 -482 -477 -460 -440 -393 -339 -326 -257 -190 -126 -35 63 146 201 283 355 393 401 427 441 411 382 335 282 241 200 133 90 30 -8 -64 -116 -142 -175 -213 -223 -244 -274 -280 -272 -280 -264 -241 -262 -249 -228 -211 -156 -128 -64 -21 43 80 129 142 187 215 227 230 237 243 254 266 267 273 256 254 251 253 236 208 164 128 69 54 30 -18 -69 -86 -106 -143 -167 -188 -218 -246 -247 -233 -220 -169 -138 -95 -44 -23 18 69 116 188 236 298 380 440 503 516 538 544 516 485 475 427 374 310 292 220 109 57 5 -100 -184 -276 -362 -436 -480 -512 -539 -531 -524 -511 -452 -371 -302 -260 -169 -95 -46 59 156 208 262 336 397 421 436 441 427 427 414 368 332 298 237 197 145 93 46 0 -48 -89 -112 -138 -132 -118 -73 -23 0).! !!TrashCanMorph class methodsFor: 'all' stamp: 'jm 5/16/1998 10:58'!samplesForMouseLeave	^ #(230 254 256 242 234 246 206 211 179 175 133 111 106 91 46 53 35 54 17 40 67 98 79 114 127 167 162 133 130 119 91 82 98 90 75 87 45 19 -17 1 -16 -1 8 12 -1 53 71 85 109 117 106 159 138 154 133 161 122 138 85 72 67 51 46 20 6 3 -8 8 -8 -4 -1 22 38 53 43 85 71 103 88 87 45 51 43 59 16 -9 -17 1 -45 -20 -32 -8 -38 3 -20 20 43 53 43 37 24 54 30 58 59 32 20 33 17 8 -30 -56 -72 -111 -133 -127 -122 -111 -129 -111 -108 -112 -108 -111 -135 -100 -130 -111 -158 -125 -121 -104 -96 -111 -135 -106 -111 -104 -133 -111 -143 -137 -140 -130 -109 -103 -119 -62 -59 -67 -62 -33 -41 -12 -43 -46 -43 -38 -71 -87 -100 -80 -125 -124 -145 -132 -145 -111 -148 -106 -95 -79 -51 -14 -17 8 22 85 93 111 116 127 138 133 96 67 53 72 45 -22 -30 -20 -33 16 27 121 177 335 500 756 1023 1362 1738 2131 2465 2769 2932 3032 2951 2609 1980 1102 -43 -1326 -2769 -4181 -5598 -6852 -7906 -8630 -9014 -8982 -8390 -7257 -5645 -3637 -1415 1029 3476 5953 8267 10196 11595 12386 12531 12089 10938 9187 6826 4120 1124 -1933 -4946 -7699 -10138 -12005 -13244 -13719 -13418 -12384 -10706 -8485 -5808 -2796 421 3640 6629 9344 11524 13121 14054 14261 13735 12528 10643 8209 5307 2125 -1265 -4592 -7693 -10426 -12683 -14290 -15200 -15273 -14514 -12881 -10583 -7628 -4171 -448 3303 6911 10154 12921 14914 16133 16383 15750 14259 12040 9164 5772 2083 -1721 -5395 -8751 -11629 -13799 -15261 -15758 -15399 -14104 -11989 -9176 -5801 -2022 1844 5593 9006 11905 14064 15405 15842 15387 13957 11834 9005 5754 2215 -1402 -4888 -8044 -10744 -12739 -14054 -14519 -14216 -13070 -11186 -8680 -5729 -2501 789 4023 6924 9450 11320 12489 12920 12629 11614 9949 7764 5214 2411 -495 -3327 -5845 -8006 -9690 -10820 -11288 -11133 -10271 -8914 -6992 -4820 -2357 174 2643 4910 6853 8361 9360 9729 9537 8811 7573 5908 3939 1799 -448 -2695 -4641 -6343 -7628 -8525 -8926 -8785 -8177 -7118 -5640 -3861 -1943 43 2047 3813 5332 6502 7292 7601 7455 6837 5872 4578 3054 1305 -482 -2228 -3781 -5133 -6187 -6850 -7136 -7039 -6529 -5688 -4489 -3071 -1489 109 1726 3166 4447 5398 6034 6235 6151 5651 4847 3747 2483 997 -464 -1915 -3221 -4323 -5159 -5708 -5929 -5812 -5328 -4601 -3635 -2478 -1165 75 1324 2432 3366 4011 4423 4557 4439 3961 3326 2470 1494 422 -616 -1596 -2506 -3267 -3797 -4124 -4258 -4142 -3740 -3235 -2527 -1702 -832 43 919 1718 2391 2820 3151 3276 3206 2988 2569 1983 1321 587 -125 -837 -1516 -2112 -2554 -2854 -2951 -2883 -2669 -2285 -1771 -1186 -539 119 779 1363 1889 2223 2457 2528 2451 2177 1776 1271 681 88 -500 -1079 -1592 -2009 -2283 -2420 -2354 -2230 -1904 -1460 -942 -385 198 766 1263 1660 1967 2138 2185 2094 1889 1518 1102 577 56 -463 -971 -1423 -1799 -2070 -2222 -2244 -2112 -1910 -1554 -1166 -679 -162 353 797 1195 1505 1733 1844 1863 1696 1489 1144 731 267 -201 -706 -1157 -1525 -1834 -2036 -2089 -2033 -1893 -1644 -1281 -865 -367 85 572 968 1342 1591 1783 1812 1699 1481 1186 811 413 -66 -534 -965 -1333 -1699 -1920 -2046 -2022 -1964 -1721 -1410 -989 -505 -14 471 929 1337 1673 1863 1989 1993 1854 1634 1318 898 477 -50 -484 -940 -1320 -1657 -1852 -1978 -1928 -1778 -1531 -1199 -785 -316 174 634 1092 1470 1789 2022 2107 2081 1999 1715 1374 939 488 -27 -493 -953 -1326 -1644 -1880 -1997 -1960 -1875 -1639 -1345 -927 -511 -85 342 834 1202 1570 1801 1938 1989 1893 1721 1436 1068 663 216 -185 -632 -1040 -1384 -1625 -1783 -1857 -1836 -1659 -1466 -1131 -748 -359 46 476 852 1200 1445 1600 1678 1710 1544 1297 1003 676 246 -175 -621 -990 -1353 -1628 -1855 -1947 -1965 -1851 -1639 -1341 -973 -524 -106 376 776 1160 1492 1715 1815 1838 1738 1589 1279 979 559 106 -285 -731 -1128 -1450 -1731 -1922 -2001 -2005 -1863 -1636 -1316 -948 -545 -137 306 755 1126 1466 1717 1893 1955 1915 1760 1531 1190 844 384 -61 -511 -921 -1299 -1584 -1773 -1889 -1880 -1730 -1520 -1152 -716 -256 156 622 1057 1437 1709 1873 1925 1902 1718 1431 1103 706 272 -164 -563 -915 -1224 -1450 -1592 -1642 -1596 -1441 -1194 -879 -527 -133 274 705 1015 1294 1515 1610 1671 1592 1412 1195 876 556 214 -153 -495 -800 -1037 -1189 -1307 -1308 -1260 -1087 -879 -626 -335 8 321 651 900 1137 1299 1402 1387 1341 1165 950 689 388 50 -266 -572 -823 -1028 -1203 -1287 -1265 -1197 -1052 -847 -539 -253 72 411 708 976 1236 1404 1470 1433 1350 1181 965 679 366 71 -217 -547 -789 -971 -1039 -1082 -1008 -884 -726 -476 -185 104 403 697 939 1097 1232 1247 1257 1124 955 756 534 224 -38 -332 -537 -731 -889 -981 -992 -937 -839 -747 -547 -324 -111 116 343 547 724 847 924 910 902 777 676 482 301 85 -104 -272 -445 -597 -702 -779 -782 -800 -766 -653 -500 -390 -187 -59 114 259 417 508 603 643 676 626 572 463 366 200 54 -119 -237 -398 -501 -637 -698 -731 -722 -714 -624 -519 -369 -246 -82 54 248 372 492 540 592 589 526 426 358 211 56 -90 -206 -372 -476 -592 -640 -666 -661 -598 -487 -367 -211 -66 151 290 430 526 663 695 753 719 724 629 563 430 300 153 20 -85 -158 -251 -296 -309 -301 -269 -217 -153 -51 33 151 230 345 429 495 527 558 568 572 508 421 321 240 111 43 -114 -175 -232 -267 -288 -305 -300 -214 -180 -79 4 104 206 324 403 511 555 580 585 618 563 498 458 382 308 279 198 148 108 95 51 51 50 66 91 104 116 162 183 214 195 253 261 274 279 267 266 285 266 285 254 258 254 243 269 235 180 175 154 179 159 119 164 216 227 274 314 371 398 461 495 532 509 485 498 401 325 271 164 100 -27 -116 -166 -204 -230 -227 -222 -166 -106 -4 127 258 364 485 577 663 708 753 743 718 608 547 440 298 188 75 -71 -153 -204 -227 -246 -208 -198 -140 -85 43 137 254 343 438 524 593 610 631 605 572 511 456 338 250 154 62 -17 -33 -103 -77 -114 -69 -38 59 117 193 288 369 390 429 438 456 408 353 303 235 140 80 -29 -95 -164 -192 -208 -185 -166 -119 -58 95 198 288 371 488 519 563 598 582 547 482 387 277 112 4 -132 -179 -319 -376 -447 -416 -416 -382 -298 -169 -80 69 211 364 490 624 718 774 789 811 768 721 601 509 384 271 154 33 -95 -138 -216 -259 -253 -237 -198 -171 -109 -22 56 167 264 374 450 530 551 584 595 553 500 458 348 275 146 51 -62 -166 -201 -254 -295 -266 -253 -164 -137 -59 11 98 214 343 403 514 550 603 632 593 543 509 405 337 196 111 17 -61 -146 -188 -242 -229 -224 -201 -187 -129 -104 -37 77 112 166 237 275 311 292 292 290 235 162 111 43 4 -59 -72 -124 -140 -140 -117 -108 -61 -24 56 109 158 169 240 264 284 292 275 266 256 185 124 109 64 1 -41 -72 -87 -80 -77 -46 -35 -11 41 43 56 69 101 116 119 133 108 51 56 53 59 9 43 32 67 95 104 109 150 167 171 183 204 213 190 171 172 122 130 98 95 30 16 -20 -46 -88 -83 -74 -56 -19 33 85 119 201 272 279 319 342 364 369 376 335 325 282 213 158 108 8 -30 -116 -130 -169 -182 -164 -140 -137 -82 -54 32 116 175 225 284 317 379 369 377 342 314).! !Boolean subclass: #True	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!True commentStamp: 'di 5/22/1998 16:39' prior: 0!True comment:'I represent the logical value true.'!!True methodsFor: 'logical operations'!& alternativeObject 	"Evaluating conjunction -- answer alternativeObject since receiver is true."	^alternativeObject! !!True methodsFor: 'logical operations'!not	"Negation--answer false since the receiver is true."	^false! !!True methodsFor: 'logical operations'!| aBoolean 	"Evaluating disjunction (OR) -- answer true since the receiver is true."	^self! !!True methodsFor: 'controlling'!and: alternativeBlock 	"Nonevaluating conjunction -- answer the value of alternativeBlock since	the receiver is true."	^alternativeBlock value! !!True methodsFor: 'controlling'!ifFalse: alternativeBlock 	"Since the condition is true, the value is the true alternative, which is nil. 	Execution does not actually reach here because the expression is compiled 	in-line."	^nil! !!True methodsFor: 'controlling'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock 	"Answer the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^trueAlternativeBlock value! !!True methodsFor: 'controlling'!ifTrue: alternativeBlock 	"Answer the value of alternativeBlock. Execution does not actually 	reach here because the expression is compiled in-line."	^alternativeBlock value! !!True methodsFor: 'controlling'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 	"Answer with the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^trueAlternativeBlock value! !!True methodsFor: 'controlling'!or: alternativeBlock 	"Nonevaluating disjunction -- answer true since the receiver is true."	^self! !!True methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'true'! !Object subclass: #URLmap	instanceVariableNames: 'pages directory action '	classVariableNames: ''	poolDictionaries: ''	category: 'PluggableWebServer'!!URLmap methodsFor: 'linking' stamp: 'mjg 2/9/98 11:44'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(((uString indexOfSubCollection: 'HTTP' startingAt: 1) = 1) or:	[((uString indexOfSubCollection: 'FTP' startingAt: 1) = 1) or:	[((uString indexOfSubCollection: 'MAILTO' startingAt: 1) = 1)]])	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string asLowercase ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		(aList indexOf: newpage) ~= 0 ifFalse: [aList add: newpage]. "Add only if not there"		^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'tk 2/3/98 15:24'!linkFor: string to: peer withPrefix: prefix storingTo: aList	| uString newpage |	uString _ string asUppercase.	(uString indexOfSubCollection: 'HTTP' startingAt: 1) = 1	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!! Gotta provide-a-link!!"		[newpage _ pages at: string asLowercase ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.].		aList add: newpage.		^'<a href="',prefix,'.',newpage coreID,'">',string,'</a>']! !!URLmap methodsFor: 'linking' stamp: 'mjg 3/23/98 12:03'!linkForCache: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(((uString indexOfSubCollection: 'HTTP' startingAt: 1) = 1) or:	[((uString indexOfSubCollection: 'FTP' startingAt: 1) = 1) or:	[((uString indexOfSubCollection: 'MAILTO' startingAt: 1) = 1)]])	ifTrue:		[((uString endsWith: 'GIF') or: [(uString endsWith: 'JPEG') or:			[uString endsWith: 'JPG']])		ifTrue: [^'<image src="',string,'">']		ifFalse: [^'<a href="',string,'">',string,'</a>']]	ifFalse: "Serious!!!! Gotta provide-a-link!!!!"		[newpage _ pages at: string asLowercase ifAbsent: [nil].		newpage isNil ifTrue: [ "Create a new page"			newpage _ self newpage: string from: peer.			action generate: newpage from: peer].		(aList indexOf: newpage) ~= 0 ifFalse: [aList add: newpage]. "Add only if not there"		^self pageCacheURL: newpage]! !!URLmap methodsFor: 'searching' stamp: 'mjg 12/3/97 09:06'!recent	| response sortedPages currentDate |	sortedPages _ pages asSortedCollection: [:a :b | a date > b date].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'. 	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDate printString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(page address).].	response nextPutAll: '</ul>'. 	^response contents				! !!URLmap methodsFor: 'searching' stamp: 'mjg 3/18/98 12:22'!recentCache	| response sortedPages currentDate |	sortedPages _ pages asSortedCollection: [:a :b | a date > b date].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'. 	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDate printString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageCacheURL: page),'...',(page address).].	response nextPutAll: '</ul>'. 	^response contents				! !!URLmap methodsFor: 'searching' stamp: 'mjg 3/18/98 13:02'!searchCacheFor: aString	| hitlines response |	hitlines _ pages select: [:each | each text includesSubstring: aString caseSensitive: false].	hitlines isEmpty	ifTrue: [^aString, ' not found']	ifFalse: [		response _ WriteStream on: String new.		response nextPutAll: '<h2>Search results for ',aString,'</h2><ul>'.		hitlines do: [:each			|response nextPutAll: '<li>',(self pageCacheURL: each),'...',(each address)].		response nextPutAll: '</ul>'.		^response contents].! !!URLmap methodsFor: 'searching' stamp: 'mjg 12/5/97 12:21'!searchFor: aString	| hitlines response |	hitlines _ pages select: [:each | each text includesSubstring: aString caseSensitive: false].	hitlines isEmpty	ifTrue: [^aString, ' not found']	ifFalse: [		response _ WriteStream on: String new.		response nextPutAll: '<h2>Search results for ',aString,'</h2><ul>'.		hitlines do: [:each			|response nextPutAll: '<li>',(self pageURL: each),'...',(each address)].		response nextPutAll: '</ul>'.		^response contents].! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!action	"Answer the receiver's 'action'."	^action! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!action: anObject	"Set the receiver's instance variable 'action' to be anObject."	action := anObject! !!URLmap methodsFor: 'accessing' stamp: 'tk 2/3/98 15:47'!at: key	"Return page of a given key."	^pages at: key asLowercase ifAbsent: [nil]! !!URLmap methodsFor: 'accessing' stamp: 'tk 2/3/98 15:47'!at: key put: anObject	"Add anObject to the pages list."	pages at: key asLowercase put: anObject! !!URLmap methodsFor: 'accessing' stamp: 'tk 2/14/98 12:29'!atID: id	"Return page of a given key."	| idString |	idString _ id isInteger ifTrue: [id printString] ifFalse: [id].	^pages detect: [:page | page coreID = idString] ifNone: [pages at: 'front page']! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!directory	"Answer the receiver's 'directory'."	^directory! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!directory: anObject	"Set the receiver's instance variable 'directory' to be anObject."	directory := anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 3/18/98 12:10'!pageCacheURL: aPage	^'<a href="',(action cacheURL),(action name),'/',aPage coreID,'.html">',(aPage name),'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!pages	"Answer the receiver's 'pages'."	^pages! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 16:31'!pages: anObject	"Set the receiver's instance variable 'pages' to be anObject."	pages := anObject! !!URLmap methodsFor: 'accessing' stamp: 'mjg 11/25/97 13:52'!pageURL: aPage	^'<a href="',(action name),'.',aPage coreID,'">',(aPage name),'</a>'! !!URLmap methodsFor: 'creating' stamp: 'mjg 11/26/97 12:27'!allPagesFrom: pageRef	^self allPagesFrom: pageRef for: '' "Probably won't create new pages here"! !!URLmap methodsFor: 'creating' stamp: 'mjg 12/3/97 11:25'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse: [peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (HTMLformatter swikify: (pageRef text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: refPages]).	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPage formatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)								linkhandler: [:link | self linkFor: link													from: peer													storingTo: (OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THE page"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'tk 2/14/98 11:53'!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p | 		p coreID asNumber > max ifTrue: [p coreID asNumber] 				ifFalse: [max]]) + 1) printString.	newpage _ SwikiPage new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory), 		directory, (ServerAction pathSeparator), newfile).	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'tk 1/27/98 18:26'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page text: text.	page address: peer.	^ page! !!URLmap methodsFor: 'creating' stamp: 'tk 1/27/98 07:42'!storePage: page text: text from: peer	page date: (Date today).	page text: text.	page address: peer.! !DynamicInterpreterSimulator subclass: #UncheckedDynamicInterpreterSimulator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Jitter'!!UncheckedDynamicInterpreterSimulator commentStamp: 'di 5/22/1998 16:39' prior: 0!UncheckedDynamicInterpreterSimulator comment:'I am a subclass of DynamicInterpreterSimulator.  I override the various assertions defined in my superclass in order to speed up execution of the interpreter simulator.  This extra speed comes at the expense of safety, since the (many) assertions in the interpreter implementation are effectively disabled.'!!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/3/97 13:05'!assert: boolean! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 11/30/97 17:48'!assertIsArray: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/29/97 21:39'!assertIsArrayOrNil: t1 ! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedBaseContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedBlockContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCachedMethodContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCompiledMethod: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsCompiledMethodOrInteger: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsIntegerObject: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalCachedTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalInstructionIndex: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalInstructionPointer: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStableTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStackOffsetInContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalStackPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalTempOffset: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsLegalTempPointer: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 14:52'!assertIsLegalTranslatedInstructionIndex: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/1/97 22:21'!assertIsLegalTranslatedInstructionPointer: t1 in: t2 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsNotNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsOop: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsProcess: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoActiveContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsPseudoContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableBaseContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableBlockContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextClass: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNil: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNilOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableContextOrNull: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsStableMethodContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 1/1/98 23:53'!assertIsTranslatedMethod: anObject! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 1/5/98 17:55'!assertIsValidPseudoContextAt: cp! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertIsWordAligned: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/18/97 17:59'!assertNotIntegerObject: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertStackPointerIsExternal	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!assertStackPointerIsInternal	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyCachedContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify' stamp: 'ikp 12/30/97 01:20'!verifyMethodCache	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyStableContext: t1 	^ self! !!UncheckedDynamicInterpreterSimulator methodsFor: 'assert-verify'!verifyStack	^ self! !UncheckedDynamicInterpreterSimulator subclass: #UncheckedDynamicInterpreterSimulatorLSB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Squeak-Jitter'!!UncheckedDynamicInterpreterSimulatorLSB commentStamp: 'di 5/22/1998 16:39' prior: 0!UncheckedDynamicInterpreterSimulatorLSB comment:'I am a version of UncheckedDynamicInterpreterSimulator tweaked to run on little-endian machines.'!!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'initialization' stamp: 'ikp 10/27/97 23:47'!nextLongFrom: aStream	"Read a 32-bit quantity from the given (binary) stream."	| bytes |	bytes _ aStream nextInto: (ByteArray new: 4).	^ Integer		byte1: (bytes at: 1)		byte2: (bytes at: 2)		byte3: (bytes at: 3)		byte4: (bytes at: 4)! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 10/27/97 23:48'!byteAt: byteAddress	| lowBits |	lowBits _ byteAddress bitAnd: 3.	^((self longAt: byteAddress - lowBits)		bitShift: (0 - lowBits) * 8)		bitAnd: 16rFF! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'memory access' stamp: 'ikp 10/27/97 23:48'!byteAt: byteAddress put: byte	| longWord shift lowBits |	lowBits _ byteAddress bitAnd: 3.	longWord _ self longAt: byteAddress - lowBits.	shift _ lowBits * 8.	longWord _ longWord - (longWord bitAnd: (16rFF bitShift: shift)) + (byte bitShift: shift).	self longAt: byteAddress - lowBits put: longWord! !!UncheckedDynamicInterpreterSimulatorLSB methodsFor: 'debug support' stamp: 'ikp 10/27/97 23:48'!charsOfLong: long	^ (1 to: 4) collect:		[:i | ((long digitAt: i) between: 14 and: 126)					ifTrue: [(long digitAt: i) asCharacter]					ifFalse: [$?]]! !Object subclass: #UndefinedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!UndefinedObject commentStamp: 'di 5/22/1998 16:39' prior: 0!UndefinedObject comment:'I describe the behavior of my sole instance, nil. nil represents a prior value for variables that have not been initialized, or for results which are meaningless.'!!UndefinedObject methodsFor: 'copying' stamp: 'sw 9/26/97 10:31'!copyRecordingIn: aDictionary	^ self! !!UndefinedObject methodsFor: 'copying'!deepCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying'!shallowCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'printing'!storeOn: aStream 	"Refer to the comment in Object|storeOn:." 	aStream nextPutAll: 'nil'! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!haltIfNil	self halt! !!UndefinedObject methodsFor: 'testing'!ifNil: aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!UndefinedObject methodsFor: 'testing'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!UndefinedObject methodsFor: 'testing'!ifNotNil: aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!UndefinedObject methodsFor: 'testing'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!UndefinedObject methodsFor: 'testing'!isNil 	"Refer to the comment in Object|isNil."	^true! !!UndefinedObject methodsFor: 'testing'!notNil 	"Refer to the comment in Object|notNil."	^false! !!UndefinedObject methodsFor: 'dependents access'!addDependent: ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !!UndefinedObject methodsFor: 'dependents access'!release	"Nil release is a no-op"! !!UndefinedObject methodsFor: 'dependents access'!suspend	"Kills off processes that didn't terminate properly"	"Display reverse; reverse."  "<-- So we can catch the suspend bug"	Processor terminateActive! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ikp 9/26/97 14:45'!removeSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy'!subclass: nameOfClass  "Define root (superclass = nil) of a class hierarchy"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	| newClass |	newClass _ Object subclass: nameOfClass  "First, define as a normal class"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category.	Object removeSubclass: newClass.   "Then remove it from the old hierarchy"	newClass superclass: nil.	^ newClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UndefinedObject class	instanceVariableNames: ''!!UndefinedObject class methodsFor: 'instance creation'!new	self error: 'You may not create any more undefined objects--use nil'! !FileDirectory subclass: #UnixFileDirectory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Files'!!UnixFileDirectory commentStamp: 'di 5/22/1998 16:39' prior: 0!I represent a Unix FileDirectory.!!UnixFileDirectory methodsFor: 'file names' stamp: 'jm 9/17/97 15:48'!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue: [''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !!UnixFileDirectory methodsFor: 'private' stamp: 'jm 12/4/97 23:43'!setPathName: pathString	"Unix path names start with a leading delimiter character."	(pathString isEmpty or: [pathString first ~= self pathNameDelimiter])		ifTrue: [pathName _ self pathNameDelimiter asString, pathString]		ifFalse: [pathName _ pathString].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnixFileDirectory class	instanceVariableNames: ''!!UnixFileDirectory class methodsFor: 'platform specific' stamp: 'jm 9/17/97 15:48'!pathNameDelimiter	^ $/! !RectangleMorph subclass: #UpdatingRectangleMorph	instanceVariableNames: 'target lastValue getSelector putSelector contents '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting-Support'!!UpdatingRectangleMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!UpdatingRectangleMorph comment:'Intended for use as a color swatch coupled to a color obtained from the target, but made just slightly more general than that.'!!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents	^ contents! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 9/4/97 21:43'!contents: c	contents _ c! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector _ aSymbol.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector	^ putSelector! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 10/30/97 00:55'!putSelector: aSymbol	putSelector _ aSymbol! !!UpdatingRectangleMorph methodsFor: 'accessing'!target	^ target! !!UpdatingRectangleMorph methodsFor: 'accessing'!target: anObject	target _ anObject.! !!UpdatingRectangleMorph methodsFor: 'stepping' stamp: 'sw 9/4/97 21:46'!step	| s |		s _ self readFromTarget.		s = contents ifFalse:			[self contents: s.			self color: s]! !!UpdatingRectangleMorph methodsFor: 'stepping'!stepTime	^ 50! !!UpdatingRectangleMorph methodsFor: 'target access' stamp: 'jm 4/25/1998 05:03'!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	target isInWorld ifFalse: [^ contents].	v _ target scriptPerformer perform: getSelector.	lastValue _ v.	^ v ! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 10/30/97 01:05'!handlesMouseDown: evt	^ putSelector ~~ nil! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'jm 11/4/97 15:41'!mouseUp: evt	evt hand changeColorTarget: self selector: #setTargetColor:.! !!UpdatingRectangleMorph methodsFor: 'setting' stamp: 'sw 2/15/98 13:52'!setTargetColor: aColor	putSelector ifNotNil:		[self color: aColor.		contents _ aColor.		target scriptPerformer perform: self putSelector withArguments: (Array with: aColor)]! !StringMorph subclass: #UpdatingStringMorph	instanceVariableNames: 'format target lastValue getSelector putSelector floatPrecision growable '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!UpdatingStringMorph commentStamp: 'di 5/22/1998 16:39' prior: 0!UpdatingStringMorph comment:'floatPrecision = 1. to round to integer.floatPrecision = .1 to round to 1 decimal place, etc.'!!UpdatingStringMorph methodsFor: 'initialization'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/97 21:52'!floatPrecision	floatPrecision ifNil: [floatPrecision _ 1].	^ floatPrecision! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/97 21:52'!floatPrecision: aNumber	floatPrecision _ aNumber! !!UpdatingStringMorph methodsFor: 'accessing'!getSelector	^ getSelector! !!UpdatingStringMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector _ aSymbol.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 3/11/98 16:37'!growable	^ growable ~~ false! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 3/11/98 16:37'!growable: aBoolean	growable _ aBoolean! !!UpdatingStringMorph methodsFor: 'accessing'!putSelector	^ putSelector! !!UpdatingStringMorph methodsFor: 'accessing'!putSelector: aSymbol	putSelector _ aSymbol.! !!UpdatingStringMorph methodsFor: 'accessing'!target	^ target! !!UpdatingStringMorph methodsFor: 'accessing'!target: anObject	target _ anObject.! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 10/3/97 13:55'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse: [self contentsClipped: s]].! !!UpdatingStringMorph methodsFor: 'stepping'!stepTime	^ 50! !!UpdatingStringMorph methodsFor: 'formats'!useDefaultFormat	"Use the object's own printString format."	format _ #default.! !!UpdatingStringMorph methodsFor: 'formats'!useStringFormat	format _ #string.! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 3/11/98 16:38'!informTarget	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue:		[newValue _ self valueFromContents.		newValue ifNotNil:			[target scriptPerformer perform: putSelector with: newValue.			target isMorph ifTrue: [target changed]].			self growable ifTrue:				[self readFromTarget; fitContents.				owner updateLiteralLabel]]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 1/28/98 18:13'!readFromTarget	| v |	((target == nil) or: [getSelector == nil]) ifTrue: [^ contents].	v _ target scriptPerformer perform: getSelector.	lastValue _ v.	format = #string ifTrue: [^ v].	(format = #default and: [v isNumber]) ifTrue:		[v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString  "default: use object's printString"! !!UpdatingStringMorph methodsFor: 'target access'!valueFromContents	"Return a new value from the current contents string."	format = #string ifTrue: [^ contents].	^ Compiler evaluate: contents! !!UpdatingStringMorph methodsFor: 'editing'!acceptContents	self informTarget.! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 11/5/97 14:40'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue:			[^ self uncoveredAt: evt cursorPoint].	^ super handlesMouseDown: evt! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 5/2/1998 22:58'!keyStroke: evt	"Handle a keystroke event. Accept change if enter key or Cmd-S is pressed."	| ch contentsString |	ch _ evt keyCharacter.	ch = Character backspace ifTrue: [  "backspace"		contents size > 0 ifTrue: [			self contentsClipped: (contents copyFrom: 1 to: contents size - 1)].		^ self].	(ch = $x and: [evt commandKeyPressed]) ifTrue: [  "cut"		Smalltalk clipboardText: contents.		^ self contentsClipped: ''].	(ch = $c and: [evt commandKeyPressed]) ifTrue: [  "copy"		Smalltalk clipboardText: contents.		^ self].	(ch = $v and: [evt commandKeyPressed]) ifTrue: [  "paste"		^ self contentsClipped: Smalltalk clipboardText].	((evt keyCharacter = Character enter) or:	 [(evt keyCharacter = Character cr) or:	 [evt keyCharacter = $s and: [evt commandKeyPressed]]]) ifTrue: [  "accept"		self informTarget.		evt hand newKeyboardFocus: evt hand world.		^ self].	contentsString _ self contents ifNil: [''] ifNotNil: [contents].	self contentsClipped: (contentsString copyWith: ch).  "append the character"! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 11/3/97 02:11'!mouseDown: evt	(owner wantsKeyboardFocusFor: self) ifTrue:		[evt hand newKeyboardFocus: self]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 5/6/1998 12:59'!wouldAcceptKeyboardFocus	^ (self hasProperty: #okToTextEdit) or: [super wouldAcceptKeyboardFocus]! !ScriptInstantiation subclass: #UserScript	instanceVariableNames: 'currentScriptEditor formerScriptEditors '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Scripting'!!UserScript commentStamp: 'di 5/22/1998 16:39' prior: 0!Holds the ScriptEditorMorph structures for the current version of a user-defined tile script, as well as previous versions thereof.	currentScriptEditor	The current version of the ScriptEditorMorph for the script	formerScriptEditors 	Earlier versions of the script, for recapturing via the Versions feature							(a dictionary, <timeStamp> -> ScriptEditorMorph!!UserScript methodsFor: 'initialization' stamp: 'sw 5/13/1998 12:49'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [currentScriptEditor donorActor: player1 ownActor: player2].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!UserScript methodsFor: 'initialization' stamp: 'sw 5/19/1998 12:28'!initializeForPlayer: aPlayer afterShallowCopyFrom: aDonorUserScript	player _ aPlayer.	formerScriptEditors _ nil.	aDonorUserScript isTextuallyCoded		ifFalse:			[currentScriptEditor _ currentScriptEditor fullCopy.			currentScriptEditor playerScripted: aPlayer.			currentScriptEditor donorActor: aDonorUserScript player ownActor: aPlayer]		! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/19/1998 12:18'!allScriptVersionsDo: aBlock	self isTextuallyCoded ifFalse: [aBlock value: currentScriptEditor].	formerScriptEditors ifNotNil: [formerScriptEditors do:		[:ed | aBlock value: ed]]! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/13/1998 15:38'!bringUpToDate	self allScriptVersionsDo: [:v | v bringUpToDate]! !!UserScript methodsFor: 'script editor' stamp: 'sw 1/29/98 22:55'!currentScriptEditor: anEditor	currentScriptEditor _ anEditor! !!UserScript methodsFor: 'script editor' stamp: 'sw 5/19/1998 15:27'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume startStepping]].		^ currentScriptEditor! !!UserScript methodsFor: 'textually coded' stamp: 'sw 5/19/1998 14:13'!becomeTextuallyCoded	currentScriptEditor _ #textuallyCoded! !!UserScript methodsFor: 'textually coded' stamp: 'sw 5/19/1998 09:55'!isTextuallyCoded	^ currentScriptEditor == #textuallyCoded! !!UserScript methodsFor: 'versions' stamp: 'sw 5/19/1998 15:19'!revertScriptVersionFrom: anEditor	| aMenu result aPosition |	formerScriptEditors size == 0 ifTrue: [^ self beep].	aMenu _ SelectionMenu labelList: (formerScriptEditors collect: [:e | e timeStamp])		selections: formerScriptEditors.	result _ aMenu startUp.	result ifNotNil:		[aPosition _ anEditor position.		anEditor delete.		currentScriptEditor _ result bringUpToDate install.		player costume viewAfreshShowingScript: selector at: aPosition]! !!UserScript methodsFor: 'versions' stamp: 'sw 5/19/1998 14:12'!saveScriptVersion: timeStampCurrentlyIgnored	self isTextuallyCoded ifFalse:		[formerScriptEditors == nil ifTrue: [formerScriptEditors _ OrderedCollection new].		currentScriptEditor ifNotNil: [formerScriptEditors add: currentScriptEditor fullCopy].		formerScriptEditors size > 100 ifTrue: [^ self halt: 'apparent runaway versions']]! !Object subclass: #Utilities	instanceVariableNames: ''	classVariableNames: 'AuthorInitials CommonRequestStrings RecentSubmissions UpdateUrlLists '	poolDictionaries: ''	category: 'System-Support'!!Utilities commentStamp: 'di 5/22/1998 16:39' prior: 0!Utilities comment:'A repository for general and miscellaneous utilities; much of what is here are in effect global methods that don''t naturally attach to anything else.  1/96 sw'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Utilities class	instanceVariableNames: ''!!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/11/1998 19:34'!absorbUpdatesFromServer	"Go to two common servers and look for updates.  Do not bring themto the user's disk.  A file on the server called updates.list has the namesof the last N update files.  We look backwards for the first one we do nothave, and start there bringing them in.  tk 9/10/97""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""Utilities absorbUpdatesFromServer"| doc urls failed str |Cursor wait showWhile: [	Utilities chooseUpdateList.	"ask the user which kind of updates"	(Smalltalk includesKey: #EToySystem)		ifTrue: [(Smalltalk at: #EToySystem) guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']).	failed _ 0.	urls do: [:this |		doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.		"check here that it worked"		doc class == String			ifTrue: [failed _ failed + 1]	"an error loading"			ifFalse: [				doc reset; text.				doc peek asciiValue = 4	"pure object file"					ifTrue: [failed _ failed + 1]	"Must be fileIn, not pure object file"					ifFalse: [						"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."							"HTML source code not supported here yet"						ChangeSorter newChangesFromStream: doc							named: (this findTokens: '/') last.						self saveUpdate: doc onFile: (this findTokens: '/') last]]].	"if wanted"	].str _ 'Loaded ', (urls size - failed) printString ,' new update files.'.failed > 0 ifTrue: [str _ str, '\Could not find ' withCRs, failed printString ,' update files.'].self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 5/12/1998 12:38'!absorbUpdatesWriteFiles: doWrite zapNums: zapNumbers	"Utilities absorbUpdatesWriteFiles: true zapNums: true"	"Absorb all updates from the server of your choice, and write each update to a local file on your disk.  Chop off the sequence numbers, if indicated."	| didWrite didZap |	didWrite _ Preferences valueOfFlag: #updateSavesFile.	didZap _ Preferences valueOfFlag: #updateRemoveSequenceNum.	Preferences setPreference: #updateSavesFile toValue: doWrite.	Preferences setPreference: #updateRemoveSequenceNum toValue: zapNumbers.	self absorbUpdatesFromServer.	Preferences setPreference: #updateSavesFile toValue: didWrite.	Preferences setPreference: #updateRemoveSequenceNum toValue: didZap.	! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:23'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list."	| index him |	UpdateUrlLists size > 1 ifTrue: [		index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 			startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.		index > 0 ifTrue: [			him _ UpdateUrlLists at: index.			UpdateUrlLists removeAt: index.			UpdateUrlLists addFirst: him]].! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 9/21/97 01:12'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| delims lines ii out eToySystem |	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNil: [^ #()].	delims _ String with: Character cr with: Character linefeed.	lines _ list findTokens: delims.	ii _ lines indexOf: '#', eToySystem version.	ii = 0 ifTrue: [^ #()].	out _ OrderedCollection new.	[(ii _ ii + 1) <= lines size] whileTrue:		[(lines at: ii) first == $# ifTrue: [^ out "next version"].		(lines at: ii) first == $* ifFalse: [out addLast: (lines at: ii)]].	"keep, except comments"	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/16/98 16:16'!lastUpdateNum: updatesFileStrm	"Look in the Updates file and see what the last sequence number is.  Warn the user if the version it is under is not this image's version."	| verIndex seqIndex char ver seqNum |	verIndex _ seqIndex _ 0.	 "last # starting a line and last digit starting a line"	seqNum _ 0.	updatesFileStrm reset; ascii.	[char _ updatesFileStrm next.	 updatesFileStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updatesFileStrm peek == $# ifTrue: [verIndex _ updatesFileStrm position +1.				seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"					updatesFileStrm position: seqIndex.					ver _ SmallInteger readFrom: updatesFileStrm.					seqNum _ seqNum max: ver.					updatesFileStrm position: verIndex-1]].			updatesFileStrm peek isDigit ifTrue: [seqIndex _ updatesFileStrm position]]].	seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"		updatesFileStrm position: seqIndex.		ver _ SmallInteger readFrom: updatesFileStrm.		seqNum _ seqNum max: ver.		updatesFileStrm setToEnd].	^ seqNum! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 5/6/1998 16:40'!newUpdatesOn: serverList	"Return a list of fully formed URLs of update files we do not yethave.  Go to the listed servers and look at the file 'updates.list' for thenames of the last N update files.  We look backwards for the first one wehave, and make the list from there.  tk 9/10/97"	| existing doc list out ff |	out _ OrderedCollection new.	existing _ ChangeSorter allChangeSetNames.	existing _ existing collect: [:cngSet | cngSet copyReplaceAll: '/' with: '_'].			"Replace slashes with underbars"	serverList do: [:server |		doc _ HTTPSocket httpGet: server,'updates.list' accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue: [			list _ doc reset; contents.	"one file name per line"			list _ self extractThisVersion: list.			list reverseDo: [:fileName |				ff _ (fileName findTokens: '/') last.	"allow subdirectories"				(existing includes: ff sansPeriodSuffix)					ifFalse: [out addFirst: server,fileName]					ifTrue: [^ out]].			^ out "need them all"].		"Server was down, try next one"].	PopUpMenu notify: 'All code update servers seem to be unavailable'.	^ out! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:38'!objectStrmFromUpdates: fileName	"Go to the known servers and look for this file in the updates folder.  It is an auxillery file, like .morph or a .gif.  Return a RWBinaryOrTextStream on it.    Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."| urls doc |Cursor wait showWhile: [	urls _ Utilities serverUrls collect: [:url | url, 'updates/', fileName].	urls do: [:aUrl |		doc _ HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.		"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue: [^ doc reset]]].PopUpMenu notify: 'All update servers are unavailable, or bad file name'.^ nil! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/16/98 16:43'!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].						"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [						foundIt _ true					]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:04'!removeDisney	"remove the Disney server from the update lists.  For external release."	UpdateUrlLists copy do: [:pair |		(pair first includesSubstring: 'Disney' caseSensitive: false) ifTrue: [			UpdateUrlLists remove: pair]].	Smalltalk removeKey: #UpdatesAtDOL ifAbsent: [].	Smalltalk removeKey: #UpdatesAtWebPage ifAbsent: [].! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/11/1998 20:52'!saveUpdate: doc onFile: fileName	"See if the user wants the update stored on a local file.  With or without the update number on the front."| file fName |(Preferences valueOfFlag: #updateSavesFile) ifTrue: [	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue: [		1 to: 100 do: [:pos | 			(fName at: pos) isDigit ifFalse: [				fName _ fName copyFrom: pos to: fName size.				doc reset; ascii.				(FileDirectory default fileExists: fName) ifFalse: [					file _ FileStream newFileNamed: fName.					file nextPutAll: doc contents.					file close].				^ self]]]].! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:02'!serverUrls	"Return the current list of server URLs.  For code updates.  Format of UpdateUrlLists is #( ('squeak updates' ('url1' 'url2'))    ('some other updates' ('url3' 'url4')))"	^ UpdateUrlLists first last! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:03'!updateUrlLists	UpdateUrlLists ifNil: [UpdateUrlLists _ OrderedCollection new].	^ UpdateUrlLists! !!Utilities class methodsFor: 'debugging'!inspectCollection: aCollection notifying: aView	aCollection size = 0 		ifTrue: [aView notNil 			ifTrue: [^ aView flash]			ifFalse: [^ self]].	aCollection size = 1		ifTrue: [aCollection first inspect]		ifFalse: [aCollection asArray inspect]! !!Utilities class methodsFor: 'investigations'!inspectGlobals	"Utilities  inspectGlobals"	| associations aDict |	associations _ ((Smalltalk keys select: [:aKey | ((Smalltalk at: aKey) isKindOf: Class) not]) asSortedArray collect:		[:aKey | Smalltalk associationAt: aKey]).	aDict _ IdentityDictionary new.	associations do: [:as | aDict add: as].	aDict inspectWithLabel: 'The Globals'! !!Utilities class methodsFor: 'investigations'!reportSenderCountsFor: selectorList	"Produce a report on the number of senders of each of the selectors in the list.  1/27/96 sw"	| total report thisSize |	total _ 0.	report _ ''.	selectorList do:		[:selector | thisSize _ (Smalltalk allCallsOn: selector) size.		report _ report, thisSize printString, Character tab, selector printString, Character cr.		total _ total + thisSize].	report _ report, '--- ------------------'.	report _ report, total printString, Character tab, 'TOTAL'.	^ report! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:48'!authorInitials	"Answer the initials to be used to identify the current code author.  "	[AuthorInitials isEmpty] whileTrue: [self setAuthorInitials].	^ AuthorInitials! !!Utilities class methodsFor: 'identification' stamp: 'tk 4/10/98 06:25'!changeStamp 	"Answer a string to be pasted into source code to mark who changed it and when."	^ self authorInitials , ' ' , Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification'!copyrightNotice	^ 'Copyright 1985-96, Apple Computer, Inc.'! !!Utilities class methodsFor: 'identification' stamp: 'tk 4/10/1998 07:16'!dateStamp	"Utilities dateStamp"	^ Date today mmddyyyy, ' ',		((String streamContents: [:s | Time now print24: true on: s]) copyFrom: 1 to: 5)! !!Utilities class methodsFor: 'identification'!dateTimeSuffix	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc.  1/18/96 sw"	"Utilities dateTimeSuffix"	| dateTime headString tailString |	dateTime _ Time dateAndTimeNow.	headString _ dateTime first printString copyFrom: 1 to: 6.	headString _ headString copyWithout: $ .	tailString _ dateTime last printString copyWithout: $:.	^ headString, (tailString copyFrom: 1 to: tailString size - 5), (tailString copyFrom: tailString size -1 to: tailString size)! !!Utilities class methodsFor: 'identification' stamp: 'di 6/13/97 13:52'!fixStamp: changeStamp 	| parts |	parts _ changeStamp findTokens: ' '.	(parts size > 0 and: [parts last first isLetter]) ifTrue:		["Put initials first in all time stamps..."		^ String streamContents:				[:s | s nextPutAll: parts last.				parts allButLast do: [:p | s space; nextPutAll: p]]].	^ changeStamp! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:47'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	self setAuthorInitials:		(FillInTheBlank request: 'Please type your initals: '					initialAnswer: AuthorInitials)! !!Utilities class methodsFor: 'identification' stamp: 'dhhi 11/6/97 16:44'!setAuthorInitials: aString	AuthorInitials _ aString! !!Utilities class methodsFor: 'support windows' stamp: 'tk 1/1/98 17:29'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'W	Selectors containing itV	Paste author's initials<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'jm 5/3/1998 20:03'!openCommandKeyHelp	"Open a window giving command key help.  1/17/96 sw"	"Utilities openCommandKeyHelp"	Utilities		openScratchWorkspaceLabeled: 'Command Keys'		contents: self commandKeyMappings.! !!Utilities class methodsFor: 'support windows' stamp: 'jm 5/3/1998 20:03'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	Utilities		openScratchWorkspaceLabeled: ('Useful Expressions ', Date today printString)		contents: self standardWorkspaceContents.! !!Utilities class methodsFor: 'support windows'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 5000.(FileStream oldFileNamed: 'DryRot.cs') edit.(FileStream oldFileNamed: 'change.cs') fileInChangeList browseFile: 'Elvis.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')InputState browseAllAccessesTo: 'deltaTime'.StandardSystemView doCacheBits  ""restore fast windows mode""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.BrowserView browseFullForClass: ControlManager.FormView allInstances inspect.ScrollController someInstance inspectSystemOrganization categoryOfElement: #Controller. Component organization categoryOfElement: #contentView .ChangeList browseRecentLog.ChangeList browseRecent: 2000.StringHolderView openSystemWorkspace. ""edit shared sys workspace""Cursor wait showWhile: [Sensor waitButton].Smalltalk spaceLeft.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop]."! !!Utilities class methodsFor: 'user interface' stamp: 'jm 5/6/1998 21:19'!informUser: aString during: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait]"	World ifNotNil: [		(MVCMenuMorph from: (SelectionMenu labels: '') title: aString)			displayAt: Sensor cursorPoint during: [aBlock value].		^ self].	(SelectionMenu labels: '')		displayAt: Sensor cursorPoint		withCaption: aString		during: [aBlock value].! !!Utilities class methodsFor: 'miscellaneous'!awaitMouseUpIn: box repeating: doBlock ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock. 5/11/96 sw	6/10/96 sw: call new method that adds extra feature"	^ self awaitMouseUpIn: box whileMouseDownDo: doBlock whileMouseDownInsideDo: [] ifSucceed: succBlock! !!Utilities class methodsFor: 'miscellaneous'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw"	| p inside lightForm darkForm |	p _ Sensor cursorPoint.	inside _ box insetBy: 1.	lightForm _ Form fromDisplay: inside.	darkForm _ lightForm deepCopy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p _ Sensor cursorPoint))			ifTrue: [doBlock2 value..					darkForm displayAt: inside origin]			ifFalse: [lightForm displayAt: inside origin]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !!Utilities class methodsFor: 'miscellaneous'!emergencyCollapse	ScheduledControllers screenController emergencyCollapse! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/30/98 15:44'!getterSelectorFor: aName	"Utilities getterSelectorFor: #elvis"	^ ('get', (aName asString capitalized)) asSymbol! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 3/24/98 18:12'!inherentSelectorForGetter: aGetterSelector	"Given a selector of the form #getAbc, return the inherent slotname selector that corresponds, which is to say, getterSelector with the leading 'get' removed and with the next character forced to lower case; this is the inverse of #getterSelectorFor:"	"Utilities inherentSelectorForGetter: #getWidth"	((aGetterSelector size < 4) or: [(aGetterSelector beginsWith: 'get') not])			ifTrue: [ ^ aGetterSelector].	^ (aGetterSelector at: 4) asLowercase asString, (aGetterSelector copyFrom: 5 to: aGetterSelector size)! !!Utilities class methodsFor: 'miscellaneous'!isObject: anObject memberOfOneOf: aCollectionOfClassnames	aCollectionOfClassnames do:		[:classname | (anObject isMemberOf: (Smalltalk at: classname)) ifTrue: [^ true]].	^ false! !!Utilities class methodsFor: 'miscellaneous'!keyLike: aString satisfying: aBlock	"Return a key like aString that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem newKey |	(aBlock value: aString) ifTrue: [^ aString].	stemAndSuffix _ aString stemAndNumericSuffix.	suffix _ stemAndSuffix last + 1.	stem _ stemAndSuffix first.	[aBlock value: (newKey _ stem, suffix printString)]		whileFalse:			[suffix _ suffix + 1].	^ newKey! !!Utilities class methodsFor: 'miscellaneous'!keyLike: aString withTrailing: trailerString satisfying: aBlock	"Return a key like (aString, trailerString) that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem composite |	composite _ aString, trailerString.	(aBlock value: composite) ifTrue: [^ composite].	stemAndSuffix _ aString stemAndNumericSuffix.	suffix _ stemAndSuffix last + 1.	stem _ stemAndSuffix first.	[aBlock value: (composite _ stem, suffix printString, trailerString)]		whileFalse:			[suffix _ suffix + 1].	^ composite! !!Utilities class methodsFor: 'miscellaneous'!nextClockwiseSideAfter: aSide 	aSide == #left ifTrue:		[^ #top].	aSide == #right ifTrue:		[^ #bottom].	aSide == #top ifTrue:		[^ #right].	^ #left! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 5/3/1998 20:12'!openScratchWorkspaceLabeled: labelString contents: initialContents	"Open a scratch text view with the given label on the given string. A scratch text view won't warn you about unsaved changes when you close it."	"Utilities openScratchWorkspaceLabeled: 'Scratch' contents: 'Hello. world!!'"	| model topView stringView |	model _ StringHolder new contents: initialContents.	topView _ StandardSystemView new.	topView		model: model;		label: labelString;		minimumSize: 180@120.	topView borderWidth: 1.	stringView _ PluggableTextView on: model 		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	stringView		askBeforeDiscardingEdits: false;		window: (0@0 extent: 180@120).	topView addSubView: stringView.	topView controller open.! !!Utilities class methodsFor: 'miscellaneous'!oppositeCornerFrom: aCorner	"Answer the corner diagonally opposite to aCorner.  6/27/96 sw"	aCorner == #topLeft		ifTrue:			[^ #bottomRight].	aCorner == #topRight		ifTrue:			[^ #bottomLeft].	aCorner == #bottomLeft		ifTrue:			[^ #topRight].	^ #topLeft! !!Utilities class methodsFor: 'miscellaneous'!oppositeModeTo: aMode 	aMode == #readOnly ifTrue: [^ #writeOnly].	aMode == #writeOnly ifTrue: [^ #readOnly].	^ aMode! !!Utilities class methodsFor: 'miscellaneous'!oppositeSideTo: aSide 	aSide == #left ifTrue:		[^ #right].	aSide == #right ifTrue:		[^ #left].	aSide == #top ifTrue:		[^ #bottom].	^ #top! !!Utilities class methodsFor: 'miscellaneous'!setClassAndSelectorFrom: messageIDString in: csBlock	"Decode strings of the form <className> [class] <selectorName>.  Derived from method setClassAndSelectorIn: of class MessageSet.  6/28/96 sw"	| aStream aClass maybeClass sel |	aStream _ ReadStream on: messageIDString.	aClass _ Smalltalk at: (aStream upTo: $ ) asSymbol.	maybeClass _ aStream upTo: $ .	sel _ aStream upTo: $ .	(maybeClass = 'class') & (sel size ~= 0)		ifFalse: [csBlock value: aClass value: maybeClass asSymbol]		ifTrue: [csBlock value: aClass class value: sel asSymbol]"Utilities setClassAndSelectorFrom: 'Utilities class oppositeModeTo:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString].Utilities setClassAndSelectorFrom: 'MessageSet setClassAndSelectorIn:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString]."! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/30/98 15:12'!setterSelectorFor: aName	"Utilities setterSelectorFor: #elvis"	^ (('set', (aName asString capitalized)), ':') asSymbol! !!Utilities class methodsFor: 'common requests' stamp: 'sw 12/12/96'!commonRequestStrings: aString	"Initialize the common request strings from aString.  "	CommonRequestStrings _ StringHolder new contents: aString! !!Utilities class methodsFor: 'common requests' stamp: 'tk 5/4/1998 17:35'!editCommonRequestStrings	"Let the user edit the common request strings.  2/1/96 sw"	CommonRequestStrings openLabel: 'Common Request Strings'! !!Utilities class methodsFor: 'common requests'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result _ Compiler new				evaluate: aString				in: aContext				to: aReceiver				notifying: nil				ifFail: [^ #failedDoit].	^ result! !!Utilities class methodsFor: 'common requests'!initialize	"Initialize the class variables.  5/16/96 sw"	self initializeCommonRequestStrings.	RecentSubmissions _ OrderedCollection new! !!Utilities class methodsFor: 'common requests'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw	 5/10/96 sw: converted over to new format of StringHolder"	CommonRequestStrings _ StringHolder new contents: 'Sensor keyboardCuror normal showTranscript cr; show: ''testing''Smalltalk sendersOf: #hotUtilities emergencyCollapseCharRecog reinitializeCharacterDictionary'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'common requests'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is anumber or string -- show it in the Transcript.  Revised technique 5/10/96 sw as per a suggestion from JM	6/6/96 sw: bug fix: if no choice, don't treat it as if the first item was chosen"	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings _ CommonRequestStrings contents.	normalItemCount _ strings lineCount.	aMenu _ PopUpMenu labels: (strings, 'edit this menu') lines: (Array with: normalItemCount).	index _ aMenu startUp.	index == 0 ifTrue: [^ self].	reply _ aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result _ self evaluate: reply in: nil to: nil.	(result isKindOf: Number) | (result isKindOf: String)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 1/17/97'!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw.	5/29/96 sw: fixed so the browser doesn't go all wonkie after you submit more code	: reverse the order, have most recent submissions at the top of the list		: use RecentMessageList"	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size == 0 ifTrue:		[^ SelectionMenu notify: 'There are no recent submissions'].		recentMessages _ RecentSubmissions copy reversed.	RecentMessageSet openMessageList: recentMessages name: 'Recently submitted methods -- youngest first ' autoSelect: nil! !!Utilities class methodsFor: 'recent method submissions'!noteMethodSubmission: selectorName forClass: className	| aSubmission |	aSubmission _ className asString, ' ', selectorName.	(self recentMethodSubmissions includes: aSubmission)		ifTrue:			[RecentSubmissions remove: aSubmission]		ifFalse:			[(RecentSubmissions size >= self numberOfRecentSubmissionsToStore) 				ifTrue: [RecentSubmissions removeFirst]].	RecentSubmissions addLast: aSubmission! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 2/16/98 04:48'!numberOfRecentSubmissionsToStore	"Answer how many methods back the 'recent method submissions' history should store"	^ 30! !!Utilities class methodsFor: 'recent method submissions'!recentMethodSubmissions	"Answer the list of recent method submissions, in order.  5/16/96 sw"	RecentSubmissions == nil ifTrue: [RecentSubmissions _ OrderedCollection new].	^ RecentSubmissions! !!Utilities class methodsFor: 'recent method submissions'!recentlySubmittedMessages	^ RecentSubmissions copy reversed! !!Utilities class methodsFor: 'graphical support'!showFormsAcrossTopOfScreen: aFormList	"Display the given array of forms across the top of the screen, wrapping to subsequent lines if needed.    Useful for example for looking at sets of rotations and animations.  6/10/96 sw"	| position maxHeight screenBox ceiling |	position _ 20.	maxHeight _ 0.	ceiling _ 0.	screenBox _ Display boundingBox.	aFormList do:		[:elem | elem displayAt: (position @ ceiling).			maxHeight _ maxHeight max: elem boundingBox height.			position _ position + elem boundingBox width + 5.			position > (screenBox right - 100) ifTrue:				[position _ 20.				ceiling _ ceiling + maxHeight + 10.				maxHeight _ 0]]! !!Utilities class methodsFor: 'graphical support'!showFormsDictAcrossTopOfScreen: formDict	"Display the given Dictionary of forms across the top of the screen, wrapping to subsequent lines if needed.  Beneath each, put the name of the associated key."	"Utilities showFormsDictAcrossTopOfScreen: HaloIcons"	| position maxHeight screenBox ceiling elem box h labelWidth keyString |	position _ 20.	maxHeight _ 0.	ceiling _ 0.	screenBox _ Display boundingBox.	formDict associationsDo:		[:assoc | (elem _ assoc value) displayAt: (position @ ceiling).			box _ elem boundingBox.			h _ box height.			keyString _ (assoc key isKindOf: String) ifTrue: [assoc key] ifFalse: [assoc key printString].			keyString displayAt: (position @ (ceiling + h)).			labelWidth _ keyString asDisplayText boundingBox width.			maxHeight _ maxHeight max: h.			position _ position + (box width max: labelWidth) + 5.			position > (screenBox right - 100) ifTrue:				[position _ 20.				ceiling _ ceiling + maxHeight + 15.				maxHeight _ 0]]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/16/97 13:13'!chooseFileWithSuffix: aSuffix	"Utilities chooseFileWithSuffix: '.gif'"	| aList aName |	aList _ FileDirectory default fileNamesMatching: '*', aSuffix.	aList size > 0		ifTrue:			[aName _ (SelectionMenu selections: aList) startUpWithCaption: 'Choose a file'.			^ aName]		ifFalse:			[self inform: 'Sorry, there are no fileswhose names end with "', aSuffix, '".'.			^ nil]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 9/13/97 20:44'!classCategoriesStartingWith: aPrefix	"Answer a list of system class categories beginning with the given prefix"	"Utilities classCategoriesStartingWith: 'Files'"	^ SystemOrganization categories select:		[:aCat | (aCat asString findString:  aPrefix startingAt: 1) = 1]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'jm 5/3/1998 20:01'!fontSizeSummary	"Utilities fontSizeSummary"	| aStream aList |	aStream _ ReadWriteStream on: ''.	aList _ Utilities knownTextStyles.	aList do: [:aStyleName |		aStream nextPutAll:			aStyleName, '  ',			(Utilities fontSizesFor: aStyleName) asArray storeString.		aStream cr].	Utilities		openScratchWorkspaceLabeled: 'Font styles and sizes'		contents: aStream contents.! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 10/20/97 20:16'!fontSizesFor: aName	| aStyle |	aStyle _ TextStyle named: aName asSymbol.	aStyle ifNil: [self halt: 'not found'].	^ aStyle fontArray collect: [:f | f height]"Utilities fontSizesFor: 'Palatino'"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 4/30/1998 12:20'!inviolateInstanceVariableNames	"Answer a list of instance variable names not to be used.  (Place holder for real list)"	^ #('thisContext' 'self')! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 4/30/1998 12:20'!isLegalInstVarName: aString	"Answer whether aString is a legal instance variable name."	^ ((Scanner isLiteralSymbol: aString) and: [(aString includes: $:) not]) and:		[(self inviolateInstanceVariableNames includes:  aString) not]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 10/20/97 20:22'!knownTextStyles   "Utilities knownTextStyles"	^ (TextConstants select: [:thang | thang isKindOf: TextStyle]) keys asSortedArray! !!Utilities class methodsFor: 'summer97 additions' stamp: 'tk 4/21/1998 07:59'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	| list tab stab aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ self].	sel ifNil: [^ self].	aClassNonMeta _ aClass theNonMetaClass.	isMeta _ aClassNonMeta ~~ aClass.	list _ OrderedCollection new.	tab _ ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab _ tab , '  '].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta _ isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: sel) ifTrue:			[stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].			list addLast: tab , stab , theClassOrMeta name, ' ', sel]]	 	startingLevel: 0.	Smalltalk browseMessageList: list		name: 'Inheritance of ' , sel"Utilities methodHierarchyBrowserForClass: ParagraphEditor selector: #isControlActive"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 9/13/97 20:44'!removeMorphicClassesFromChanges	| morphicCats |	morphicCats _ self classCategoriesStartingWith: 'Morphic'.	morphicCats do:		[:cat |		(SystemOrganization superclassOrder: cat)			do: [:class | class removeFromChanges]].! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 7/31/97 17:37'!removeUserClassesFromChanges	"Remove from the current ChangeSet all user-spawned classes, which are recognized by the fact their names end in digits"	"Utiliies removeUserClassesFromChanges"	(Object withAllSubclasses select: [:c | c name endsWithDigit]) do:		[:aClass | aClass removeFromChanges]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'tk 4/7/98 14:00'!spawnHierarchyForClass: aClass selector: aSelector	"Create and schedule a new class hierarchy browser on the requested class/selector."	| newBrowser |	(aClass == nil)  ifTrue: [^ self].	(newBrowser _ Browser new) setClass: aClass selector: aSelector.	newBrowser spawnHierarchy."Utilities spawnHierarchyForClass: SmallInteger selector: #hash"! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 20:12'!durableChangesMenu	"Utilities durableChangesMenu"	self windowFromMenu: ScheduledControllers screenController changesMenu target: ScheduledControllers screenController title: 'Change controls'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 16:15'!durableHelpMenu	"Utilities durableHelpMenu"	self windowFromMenu: ScheduledControllers screenController helpMenu target: ScheduledControllers screenController title: 'Help'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 18:20'!durableOpenMenu	"Utilities durableOpenMenu"	self windowFromMenu: ScheduledControllers screenController openMenu target: ScheduledControllers screenController title: 'Openers'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 20:11'!durableWindowMenu	"Utilities durableWindowMenu"	self windowFromMenu: ScheduledControllers screenController windowMenu target: ScheduledControllers screenController title: 'Window controls'! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 9/30/97 09:54'!windowFromMenu: aMenu target: aTarget title: aTitle	| n labelList colorPattern targetList selectionList |	"Utilities windowFromMenu: ScheduledControllers screenController helpMenu target: ScheduledControllers screenController title: 'Help'"	n _ aMenu selections size.	labelList _ (1 to: n) asArray  collect:		[:ind | aMenu labelString lineNumber: ind].	colorPattern _ #(lightRed lightGreen lightBlue lightYellow lightGray).				targetList _  (1 to: n) asArray  collect: [:ind | aTarget].	selectionList _ aMenu selections.	self windowMenuWithLabels:  labelList colorPattern: colorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'sw 10/2/97 23:23'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld n   colorList  pos delta aButton  rightmost |	aWorld _ WorldMorph new.	n _ labelList size.	colorList _  (1 to: n) asArray  collect:		[:ind | Color perform: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 2.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	aWorld setProperty: #initialExtent toValue: ((rightmost @ aButton bottom) + (10@10)).	aWorld openWithTitle: aTitle! !!Utilities class methodsFor: 'vm statistics' stamp: 'jm 2/3/98 14:11'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		Utilities vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount mcMisses mcHits icHits upTime sendCount tms tmSize |	params _ Smalltalk getVMParameters.	oldSpaceEnd			_ params at: 1.	youngSpaceEnd		_ params at: 2.	memoryEnd			_ params at: 3.	fullGCs				_ params at: 7.	fullGCTime			_ params at: 8.	incrGCs				_ params at: 9.	incrGCTime			_ params at: 10.	tenureCount			_ params at: 11.	mcMisses			_ params at: 15.	mcHits				_ params at: 16.	icHits				_ params at: 17.	upTime _ Time millisecondClockValue.	sendCount _ mcMisses + mcHits + icHits.	tms _ TranslatedMethod allInstances.	tmSize _ tms inject: 0 into: [:sum :tm | sum + (tm size * 4)].	^String streamContents: [:str |		str	nextPutAll: 'uptime			';			print: (upTime / 1000 / 60 // 60); nextPut: $h;			print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;			print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.		str	nextPutAll: 'memory			';			nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.		str	nextPutAll:	'	old			';			nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	young		';			nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	used		';			nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	free		';			nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: 'GCs				';			nextPutAll: (fullGCs + incrGCs) asStringWithCommas;			nextPutAll: ' ('; print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); nextPutAll: 'ms between GCs)'; cr.		str	nextPutAll: '	full			';			print: fullGCs; nextPutAll: ' in '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((fullGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime)'.		fullGCs = 0 ifFalse:			[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].		str	cr.		str	nextPutAll: '	incr		';			print: incrGCs; nextPutAll: ' in '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((incrGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.		str	nextPutAll: '	tenures		';			nextPutAll: tenureCount asStringWithCommas.		tenureCount = 0 ifFalse:			[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].		str	cr.		sendCount > 0 ifTrue: [			str	nextPutAll: 'sends			';				nextPutAll: sendCount asStringWithCommas; cr.			str	nextPutAll: '	full			';				nextPutAll: mcMisses asStringWithCommas;				nextPutAll: ' ('; print: ((mcMisses / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.			str	nextPutAll: '	m-cache	';				nextPutAll: mcHits asStringWithCommas;				nextPutAll: ' ('; print: ((mcHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.			str	nextPutAll: '	i-cache		';				nextPutAll: icHits asStringWithCommas;				nextPutAll: ' ('; print: ((icHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr].		icHits > 0 ifTrue: [			str	nextPutAll: 'methods			';				nextPutAll: tms size asStringWithCommas; nextPutAll: ' translated'; cr.			str	nextPutAll: '	size			';				nextPutAll: tmSize asStringWithCommas; nextPutAll: ' bytes, avg ';				print: ((tmSize / tms size) roundTo: 0.1); nextPutAll: ' bytes/method'; cr.			str	nextPutAll: '	memory		';				print: ((tmSize / youngSpaceEnd * 100) roundTo: 0.1); nextPutAll: '% of used, ';				print: ((tmSize / memoryEnd * 100) roundTo: 0.1); nextPutAll: '% of available'; cr]].! !!Utilities class methodsFor: 'tailoring system' stamp: 'sw 5/7/1998 22:54'!stripMethods: tripletList messageCode: messageString	"Used to 'cap' methods that need to be protected for proprietary reasons, etc.; call this with a list of triplets of symbols of the form  (<class name>  <#instance or #class> <selector name>), and with a string to be produced as part of the error msg if any of the methods affected is reached"	| aClass sel keywords codeString |	tripletList do:		[:triplet |  			(aClass _ (Smalltalk at: triplet first ifAbsent: [nil])) notNil ifTrue:				[triplet second == #class ifTrue:					[aClass _ aClass class].				sel _ triplet third.				keywords _ sel keywords.				(keywords size == 1 and: [keywords first asSymbol isKeyword not])					ifTrue:						[codeString _ keywords first asString]					ifFalse:						[codeString _ ''.						keywords withIndexDo:							[:kwd :index |								codeString _ codeString, ' ', (keywords at: index), ' ',									'arg', index printString]].				codeString _ codeString, '	self codeStrippedOut: ', (messageString surroundedBySingleQuotes).				aClass compile: codeString classified: 'stripped']]! !LeafNode subclass: #VariableNode	instanceVariableNames: 'name '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Compiler'!!VariableNode commentStamp: 'di 5/22/1998 16:39' prior: 0!VariableNode comment:'I am a parse tree leaf representing a variable. Note that my name and key are different for pool variables: the key is the Object Reference.'!!VariableNode methodsFor: 'initialize-release'!asStorableNode: encoder	^ self! !!VariableNode methodsFor: 'initialize-release'!name: varName index: i type: type	"Only used for initting instVar refs"	name _ varName.	self key: varName		index: i		type: type! !!VariableNode methodsFor: 'initialize-release'!name: string key: object code: byte	"Only used for initting std variables, nil, true, false, self, etc."	name _ string.	key _ object.	code _ byte! !!VariableNode methodsFor: 'initialize-release'!name: varName key: objRef index: i type: type	"Only used for initting global (litInd) variables"	name _ varName.	self key: objRef		index: i		type: type! !!VariableNode methodsFor: 'testing'!assignmentCheck: encoder at: location	(encoder cantStoreInto: name)		ifTrue: [^ location]		ifFalse: [^ -1]! !!VariableNode methodsFor: 'testing'!canBeSpecialArgument	"Can I be an argument of (e.g.) ifTrue:?"	^code < LdNil! !!VariableNode methodsFor: 'testing'!isSelfPsuedoVariable	"Answer if this ParseNode represents the 'self' psuedo-variable."	^key = 'self'! !!VariableNode methodsFor: 'testing'!isTemp	^ false! !!VariableNode methodsFor: 'testing'!isVariableReference	^true! !!VariableNode methodsFor: 'code generation'!emitForReturn: stack on: strm	(code >= LdSelf and: [code <= LdNil])		ifTrue: 			["short returns"			strm nextPut: EndMethod - 4 + (code - LdSelf).			stack push: 1 "doesnt seem right"]		ifFalse: 			[super emitForReturn: stack on: strm]! !!VariableNode methodsFor: 'code generation'!emitForValue: stack on: strm	code < 256		ifTrue: 			[strm nextPut: (code = LdSuper ifTrue: [LdSelf] ifFalse: [code]).			stack push: 1]		ifFalse: 			[self emitLong: LoadLong on: strm.			stack push: 1]! !!VariableNode methodsFor: 'code generation'!emitStore: stack on: strm	self emitLong: Store on: strm! !!VariableNode methodsFor: 'code generation'!emitStorePop: stack on: strm	(code between: 0 and: 7)		ifTrue: 			[strm nextPut: ShortStoP + code "short stopop inst"]		ifFalse:			[(code between: 16 and: 23)				ifTrue: [strm nextPut: ShortStoP + 8 + code - 16 "short stopop temp"]				ifFalse: [(code >= 256 and: [code \\ 256 > 63 and: [code // 256 = 4]])						ifTrue: [self emitLong: Store on: strm. strm nextPut: Pop]						ifFalse: [self emitLong: StorePop on: strm]]].	stack pop: 1! !!VariableNode methodsFor: 'code generation'!sizeForReturn: encoder	(code >= LdSelf and: [code <= LdNil])		ifTrue: ["short returns" ^1].	^super sizeForReturn: encoder! !!VariableNode methodsFor: 'code generation'!sizeForStore: encoder	self reserve: encoder.	code < 256 ifTrue: [^ 2].	(code \\ 256) <= 63 ifTrue: [^ 2].	^ 3! !!VariableNode methodsFor: 'code generation'!sizeForStorePop: encoder	self reserve: encoder.	(code < 24 and: [code noMask: 8]) ifTrue: [^ 1].	code < 256 ifTrue: [^ 2].	code \\ 256 <= 63 ifTrue: [^ 2].  "extended StorePop"	code // 256 = 1 ifTrue: [^ 3].  "dbl extended StorePopInst"	code // 256 = 4 ifTrue: [^ 4].  "dbl extended StoreLitVar , Pop"	self halt.  "Shouldn't get here"! !!VariableNode methodsFor: 'printing'!printOn: aStream indent: level 	aStream nextPutAll: name! !!VariableNode methodsFor: 'C translation'!asTranslatorNode	^TVariableNode new setName: name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VariableNode class	instanceVariableNames: ''!!VariableNode class methodsFor: 'class initialization'!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder _ Encoder new.	StdVariables _ Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors _ Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals _ LiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil _ encoder encodeVariable: 'nil'.	NodeTrue _ encoder encodeVariable: 'true'.	NodeFalse _ encoder encodeVariable: 'false'.	NodeSelf _ encoder encodeVariable: 'self'.	NodeThisContext _ encoder encodeVariable: 'thisContext'.	NodeSuper _ encoder encodeVariable: 'super'! !Object subclass: #View	instanceVariableNames: 'model controller superView subViews transformation viewport window displayTransformation insetDisplayBox borderWidth borderColor insideColor boundingBox '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Framework'!!View commentStamp: 'di 5/22/1998 16:39' prior: 0!View comment:'My instances are intended to be components in a structured picture. Each View in the structured picture can contain other Views as sub-components. These sub-components are called subViews. A View can be a subView of only one View. This View is called its superView. The set of Views in a structured picture forms a hierarchy. The one View in the hierarchy that has no superView is called the topView of the structured picture. A View in a structured picture with no subViews is called a bottom View. A View and all of its subViews, and all of their subViews and so on, are treated as a unit in many operations on the View. For example, if a View is displayed, all of its subViews are displayed as well. There are several categories of operations that can be performed on a View. Among these are the following:		1.	Adding subViews to a View.	2.	Positioning subViews within a View.	3.	Deleting subViews from a View.	4.	Transforming a View.	5.	Displaying a View.	Each View has its own coordinate system. In order to change from one coordinate system to another, each View has two transformations associated with it. The local transformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the coordinate system of the superView of the View. The displayTransformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the display screen coordinate system.	The part of the space that is to be made visible is represented by the window of the View. The window of a View is a Rectangle expressed in the coordinate system of the View. The area occupied by a View in the coordinate system of its superView is called its viewport. The viewport of a View is its window transformed by its local transformation. The region of the display screen occupied by a View is called its displayBox. The display box of a View can include a border. The width of the border expressed in display screen coordinates is called the border width of the View. The color of the border is called the border color. The region of the display box of a View excluding the border is called the inset display box. The color of the inset display box is called the inside color of the View.'!!View methodsFor: 'initialize-release'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	self resetSubViews.	transformation _ WindowingTransformation identity.	self borderWidth: 0! !!View methodsFor: 'initialize-release'!release	"Remove the receiver from its model's list of dependents (if the model	exists), and release all of its subViews. It is used to break possible cycles	in the receiver and should be sent when the receiver is no longer needed.	Subclasses should include 'super release.' when redefining release."	model removeDependent: self.	model _ nil.	controller release.	controller _ nil.	subViews ~~ nil ifTrue: [subViews do: [:aView | aView release]].	subViews _ nil.	superView _ nil! !!View methodsFor: 'initialize-release'!setDefaultBackgroundColor	"Obtain the background color from the receiver's model, unless the #uniformWindowColors preference is set to true, in which case obtain it from generic Object; and install it as the receiver's background color.  5/1/96 sw"	| colorToUse |	colorToUse _ Preferences uniformWindowColors		ifTrue:			[Object new defaultBackgroundColor]		ifFalse:			[model defaultBackgroundColor].	self backgroundColor: colorToUse! !!View methodsFor: 'testing'!bordersOn: otherView along: herSide 	| myBox herBox |	myBox _ self displayBox.	herBox _ otherView displayBox.	(herSide = #right and: [myBox left = herBox right])	| (herSide = #left and: [myBox right = herBox left])		ifTrue:		[^ (myBox top max: herBox top) <= (myBox bottom min: herBox bottom)].	(herSide = #bottom and: [myBox top = herBox bottom])	| (herSide = #top and: [myBox bottom = herBox top])		ifTrue:		[^ (myBox left max: herBox left) <= (myBox right min: herBox right)].	^ false! !!View methodsFor: 'testing' stamp: 'tk 4/13/1998 22:58'!canDiscardEdits	"Return true if this pane is not dirty."	^ true! !!View methodsFor: 'testing'!containsPoint: aPoint	"Answer whether aPoint is within the receiver's display box. It is sent to 	a View's subViews by View|subViewAt: in order to determine which 	subView contains the cursor point (so that, for example, control can be 	pass down to that subView's controller)."	^ self insetDisplayBox containsPoint: aPoint! !!View methodsFor: 'testing' stamp: 'jm 3/17/98 13:35'!hasUnacceptedEdits	"Return true if this view has unaccepted edits."	^ false! !!View methodsFor: 'testing'!isObscured	| topController displayRect |	(topController _ self topView controller)		== ScheduledControllers activeController			ifTrue: [^false].	displayRect _ self insetDisplayBox.	ScheduledControllers scheduledControllers do: [:ctrlr |		ctrlr == topController ifTrue: [^false].		(displayRect intersects: ctrlr view insetDisplayBox)			ifTrue: [^true]].	self error: 'not in ScheduledControllers'.	^false! !!View methodsFor: 'model access'!model	"Answer the receiver's model."	^model! !!View methodsFor: 'model access'!model: aModel 	"Set the receiver's model to aModel. The model of the receiver's controller 	is also set to aModel."	self model: aModel controller: controller! !!View methodsFor: 'superView access'!isTopView	"Answer whether the receiver is a top view, that is, if it has no 	superView."	^superView == nil! !!View methodsFor: 'superView access'!superView	"Answer the superView of the receiver."	^superView! !!View methodsFor: 'superView access'!topView	"Answer the root of the tree of Views in which the receiver is a node. 	The root of the tree is found by going up the superView path until 	reaching a View whose superView is nil."	superView == nil		ifTrue: [^self]		ifFalse: [^superView topView]! !!View methodsFor: 'subView access'!firstSubView	"Answer the first subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews first]! !!View methodsFor: 'subView access'!lastSubView	"Answer the last subView in the receiver's list of subViews if it is not 	empty, else nil."	subViews isEmpty		ifTrue: [^nil]		ifFalse: [^subViews last]! !!View methodsFor: 'subView access'!resetSubViews	"Set the list of subviews to an empty collection."		subViews _ OrderedCollection new! !!View methodsFor: 'subView access'!subViewContaining: aPoint 	"Answer the first subView that contains aPoint within its window and 	answer nil, otherwise. It is typically sent from a Controller in order to 	determine where to pass control (usually to the Controller of the View 	returned by View|subViewContaining:)."	subViews reverseDo: 		[:aSubView | 		(aSubView displayBox containsPoint: aPoint) ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'subView access'!subViews	"Answer the receiver's collection of subViews."	^subViews! !!View methodsFor: 'subView access'!subViewSatisfying: aBlock	"Return the first subview that satisfies aBlock, or nil if none does.  1/31/96 sw"	^ subViews detect: [:aView | aBlock value: aView] ifNone: [nil]! !!View methodsFor: 'subView access'!textEditorView	"Return the first view in the receiver whose controller is a ParagraphEdior, or nil if none.  1/31/96 sw"	(controller isKindOf: ParagraphEditor) ifTrue: [^ self].	^ self subViewSatisfying:		[:v | v textEditorView ~~ nil]! !!View methodsFor: 'controller access'!controller	"If the receiver's controller is nil (the default case), answer an initialized 	instance of the receiver's default controller. If the receiver does not 	allow a controller, answer the symbol #NoControllerAllowed."	controller == nil ifTrue: [self controller: self defaultController].	^controller! !!View methodsFor: 'controller access'!controller: aController 	"Set the receiver's controller to aController. #NoControllerAllowed can be 	specified to indicate that the receiver will not have a controller. The 	model of aController is set to the receiver's model."	self model: model controller: aController! !!View methodsFor: 'controller access'!defaultController	"Answer an initialized instance of the receiver's default controller. 	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new! !!View methodsFor: 'controller access'!defaultControllerClass	"Answer the class of the default controller for the receiver. Subclasses 	should redefine View|defaultControllerClass if the class of the default 	controller is not Controller."	^Controller! !!View methodsFor: 'controller access'!model: aModel controller: aController 	"Set the receiver's model to aModel, add the receiver to aModel's list of 	dependents, and set the receiver's controller to aController. Subsequent 	changes to aModel (see Model|change) will result in View|update: 	messages being sent to the receiver. #NoControllerAllowed for the value 	of aController indicates that no default controller is available; nil for the 	value of aController indicates that the default controller is to be used 	when needed. If aController is neither #NoControllerAllowed nor nil, its 	view is set to the receiver and its model is set to aModel."	model ~~ nil & (model ~~ aModel)		ifTrue: [model removeDependent: self].	aModel ~~ nil & (aModel ~~ model)		ifTrue: [aModel addDependent: self].	model _ aModel.	aController ~~ nil		ifTrue: 			[aController view: self.			aController model: aModel].	controller _ aController! !!View methodsFor: 'basic control sequence'!subViewWantingControl	"Answer the first subView that has a controller that now wants control."	subViews reverseDo: 		[:aSubView | aSubView controller isControlWanted ifTrue: [^aSubView]].	^nil! !!View methodsFor: 'window access'!defaultWindow	"Build the minimum Rectangle that encloses all the windows of the 	receiver's subViews. The answer is a Rectangle obtained by expanding 	this minimal Rectangle by the borderWidth of the receiver. If the 	receiver has no subViews, then a Rectangle enclosing the entire display 	screen is answered. It is used internally by View methods if no window 	has been specified for the View. Specialized subclasses of View should 	redefine View|defaultWindow to handle the default case for instances 	that have no subViews."	| aRectangle |	subViews isEmpty ifTrue: [^DisplayScreen boundingBox].	aRectangle _ self firstSubView viewport.	subViews do: [:aView | aRectangle _ aRectangle merge: aView viewport].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'window access'!insetWindow	"Answer a Rectangle that is obtained by insetting the receiver's window 	rectangle by the border width."	^self getWindow insetBy: borderWidth! !!View methodsFor: 'window access'!window	"Answer a copy of the receiver's window."	^self getWindow copy! !!View methodsFor: 'window access'!window: aWindow 	"Set the receiver's window to a copy of aWindow."	self setWindow: aWindow copy! !!View methodsFor: 'viewport access'!viewport	"Answer a copy of the receiver's viewport."	^self getViewport copy! !!View methodsFor: 'display box access'!apparentDisplayBox	^self insetDisplayBox expandBy: 2 @ 2! !!View methodsFor: 'display box access'!boundingBox	"Answer the bounding box which for the default case is the rectangular 	area surrounding the bounding boxes of all the subViews."	boundingBox ~~ nil		ifTrue: [^boundingBox]		ifFalse: [^self computeBoundingBox]! !!View methodsFor: 'display box access'!computeBoundingBox	"Answer the minimum Rectangle that encloses the bounding boxes of the 	receiver's subViews. If the receiver has no subViews, then the bounding 	box is the receiver's window. Subclasses should redefine 	View|boundingBox if a more suitable default for the case of no subViews 	is available."	| aRectangle |	subViews isEmpty ifTrue: [^self getWindow].	aRectangle _ self firstSubView transform: self firstSubView boundingBox.	subViews do: 		[:aView | 		aRectangle _ aRectangle merge: (aView transform: aView boundingBox).].	^aRectangle expandBy: borderWidth! !!View methodsFor: 'display box access'!displayBox	"Answer the receiver's inset display box (see View|insetDisplayBox) 	expanded by the borderWidth. The display box represents the region of 	the display screen in which the receiver (including the border) is 	displayed. If the receiver is totally clipped by the display screen and its 	superView, the resulting Rectangle will be invalid."	^self insetDisplayBox expandBy: borderWidth! !!View methodsFor: 'display box access'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox == nil ifTrue: [insetDisplayBox _ self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'lock access'!isLocked	"Answer whether the receiver is locked. A View is 'locked' if its display 	transformation and inset display box are defined. If these are undefined, 	the View is 'unlocked'. The display transformation and inset display box 	become undefined when the transformation of the View (or the 	transformation of a View in its superView chain) is changed, or when 	the superView of the View is changed, or any other change to the View 	that affects the display screen coordinates of the View. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired (see View|lock, and 	View|unlock)."	displayTransformation == nil | (insetDisplayBox == nil)		ifTrue: [^false]		ifFalse: [^true]! !!View methodsFor: 'lock access'!isUnlocked	"Answer whether the receiver is unlocked. See comment in 	View|isLocked."	^displayTransformation == nil & (insetDisplayBox == nil)! !!View methodsFor: 'lock access'!lock	"'Lock' the receiver and all of its subViews (see View|isLocked). This has 	the effect of computing and storing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews. The locking 	and unlocking of a View is handled automatically by the internal 	methods of the View, but can also be done explicitly if desired."	self isLocked ifTrue: [^self].	displayTransformation _ self computeDisplayTransformation.	insetDisplayBox _ self computeInsetDisplayBox.	subViews do: [:aSubView | aSubView lock]! !!View methodsFor: 'lock access'!unlock	"Unlock the receiver and all of its subViews (see View|isUnlocked). This 	has the effect of forcing the display transformation (see 	View|displayTransformation) and inset display box (see 	View|insetDisplayBox) of the receiver and all its subViews to be 	recomputed the next time they are referenced. The locking and 	unlocking of a View is handled automatically by the internal methods of 	the View, but can also be done explicitly if desired."	self isUnlocked ifTrue: [^self].	displayTransformation _ nil.	insetDisplayBox _ nil.	subViews do: [:aSubView | aSubView unlock]! !!View methodsFor: 'subView inserting'!addSubView: aView 	"Remove aView from the tree of Views it is in (if any) and adds it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	self addSubView: aView ifCyclic: [self error: 'cycle in subView structure.']! !!View methodsFor: 'subView inserting'!addSubView: aSubView above: lowerView	"Adds aView (see View|addSubView:) so that it lies above topView."	self addSubView: aSubView		align: aSubView viewport bottomLeft		with: lowerView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView align: aPoint1 with: aPoint2 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and translate aView so that aPoint1 coincides with aPoint2. It is typically 	used to build up a hierarchy of Views (a structured picture). Normally, 	aPoint1 is a point on aView's viewport (e.g. aView viewport topLeft), 	and aPoint2 is either an arbitrary point in the receiver's coordinate 	system or a point on the receiver's window (e.g., self window topRight)."	self addSubView: aSubView.	aSubView align: aPoint1 with: aPoint2! !!View methodsFor: 'subView inserting'!addSubView: aSubView below: lowerView	"Add the argument, aSubView, (see View|addSubView:) so that it lies 	below the view, topView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: lowerView viewport bottomLeft! !!View methodsFor: 'subView inserting'!addSubView: aView ifCyclic: exceptionBlock 	"Remove aView from the tree of Views it is in (if any) and add it to the 	rear of the list of subViews of the receiver. Set the superView of aView 	to be the receiver. It is typically used to build up a hierarchy of Views 	(a structured picture). An error notification is generated if aView is the 	same as the receiver or its superView, and so on."	(self isCyclic: aView)		ifTrue: [exceptionBlock value]		ifFalse: 			[aView removeFromSuperView.			subViews addLast: aView.			aView superView: self]! !!View methodsFor: 'subView inserting'!addSubView: aSubView toLeftOf: rightView	"Adds aView (see addSubView:) so that it lies to the right of rightView."	self addSubView: aSubView		align: aSubView viewport topRight		with:  rightView viewport topLeft! !!View methodsFor: 'subView inserting'!addSubView: aSubView toRightOf: leftView	"Add the argument, aSubView, (see View|addSubView:) so that it lies to 	the right of the view, leftView."	self addSubView: aSubView		align: aSubView viewport topLeft		with: leftView viewport topRight! !!View methodsFor: 'subView inserting'!addSubView: aView viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) and 	applies to aView a scale and translation computed from its window and 	aViewport (such that its window fills aViewport)."	self addSubView: aView.	aView window: aView window viewport: aViewport! !!View methodsFor: 'subView inserting'!addSubView: aView window: aWindow viewport: aViewport 	"Add aView to the receiver's list of subViews (see View|addSubView:) 	and applies to aView a scale and translation computed from aWindow 	and aViewport (such that aWindow fills aViewport)."	self addSubView: aView.	aView window: aWindow viewport: aViewport! !!View methodsFor: 'subView removing'!releaseSubView: aView 	"Delete aView from the receiver's list of subViews and send it the 	message 'release' (so that it can break up cycles with subViews, etc.)."	self removeSubView: aView.	aView release! !!View methodsFor: 'subView removing'!releaseSubViews	"Release (see View|releaseSubView:) all subViews in the receiver's list of 	subViews."	subViews do: [:aView | aView release].	self resetSubViews! !!View methodsFor: 'subView removing'!removeFromSuperView	"Delete the receiver from its superView's collection of subViews."	superView ~= nil ifTrue: [superView removeSubView: self]! !!View methodsFor: 'subView removing'!removeSubView: aView 	"Delete aView from the receiver's list of subViews. If the list of subViews 	does not contain aView, create an error notification."	subViews remove: aView.	aView superView: nil.	aView unlock! !!View methodsFor: 'subView removing'!removeSubViews	"Delete all the receiver's subViews."	subViews do: 		[:aView | 		aView superView: nil.		aView unlock].	self resetSubViews! !!View methodsFor: 'displaying'!clippingTo: rect do: aBlock	superView clippingTo: rect do: aBlock! !!View methodsFor: 'displaying'!display	"Display the receiver's border, display the receiver, then display the 	subViews of the receiver. Can be sent to the top View of a structured 	picture in order to display the entire structure, or to any particular View 	in the structure in order to display that View and its subViews. It is 	typically sent in response to an update request to a View."	self displayBorder.	self displayView.	self displaySubViews! !!View methodsFor: 'displaying'!displayBorder	"Display the receiver's border (using the receiver's borderColor)."	borderWidth = 0		ifTrue:			[insideColor == nil				ifFalse: 					[Display fill: self displayBox fillColor: self backgroundColor]]		ifFalse:			[Display				border: self displayBox				widthRectangle: borderWidth				rule: Form over				fillColor: self foregroundColor.			insideColor == nil ifFalse:				[Display fill: self insetDisplayBox fillColor: self backgroundColor]]! !!View methodsFor: 'displaying'!displayClippingTo: rect	| bigRect |	bigRect _ rect insetBy: -1.	self clippingTo: bigRect do: [Display clippingTo: bigRect do: [self display]]! !!View methodsFor: 'displaying'!displayDeEmphasized	self display; deEmphasize! !!View methodsFor: 'displaying'!displaySubViews	"Display all the subViews of the receiver."	subViews do: [:aSubView | aSubView display]! !!View methodsFor: 'displaying'!displayView	"Subclasses should redefine View|displayView in order to display 	particular objects associated with the View such as labels, lines, and 	boxes."	^self! !!View methodsFor: 'displaying'!displayViewDeEmphasized	self displayView; deEmphasizeView! !!View methodsFor: 'displaying'!inspectFirstSubView	subViews notNil ifTrue:		[subViews size > 0 ifTrue:			[(subViews at: 1) inspect]]! !!View methodsFor: 'displaying'!inspectModel	model notNil		ifTrue: [^ model inspect]		ifFalse: [self flash]! !!View methodsFor: 'displaying'!inspectView	^self inspect! !!View methodsFor: 'displaying'!maximumSize	"Answer the maximum size of the receiver."	^ 10000 @ 10000	! !!View methodsFor: 'displaying'!minimumSize	"Answer the minimum size of the receiver."	^ 10 @ 10	! !!View methodsFor: 'deEmphasizing'!deEmphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is not presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self deEmphasizeView.	self deEmphasizeSubViews! !!View methodsFor: 'deEmphasizing'!deEmphasizeForDebugger	"Overridden by StandardSystemView. This default behavior does nothing."! !!View methodsFor: 'deEmphasizing'!deEmphasizeSubViews	"Send the deEmphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView deEmphasize]! !!View methodsFor: 'deEmphasizing'!deEmphasizeView	"Subclasses should redefine View|deEmphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'deEmphasizing'!emphasize	"Modify the emphasis (highlighting, special tabs) of the receiver. This 	includes objects such as labels, lines, and boxes. Typically used so that 	the receiver is presented as active. Do this for the receiver and then 	for each of the receiver's subViews."	self emphasizeView.	self emphasizeSubViews! !!View methodsFor: 'deEmphasizing'!emphasizeSubViews	"Send the emphasize message to each of the receiver's subviews."	subViews do: [:aSubView | aSubView emphasize]! !!View methodsFor: 'deEmphasizing'!emphasizeView	"Subclasses should redefine View|emphasizeView in order to modify 	the emphasis (highlighting, special tabs) of particular objects associated 	with the View such as labels, lines, and boxes."	^self! !!View methodsFor: 'display transformation'!displayTransform: anObject 	"Apply the display transformation of the receiver to anObject (see 	View|displayTransformation) and answer the resulting scaled, translated 	object. It is normally applied to Rectangles, Points, and other objects with 	coordinates defined in the View's local coordinate system in order to get 	a corresponding object in display coordinates."	^(self displayTransformation applyTo: anObject) rounded! !!View methodsFor: 'display transformation'!displayTransformation	"Answer a WindowingTransformation that is the result of composing all 	local transformations in the receiver's superView chain with the 	receiver's own local transformation. The resulting transformation 	transforms objects in the receiver's coordinate system into objects in the 	display screen coordinate system."	displayTransformation == nil		ifTrue: [displayTransformation _ self computeDisplayTransformation].	^displayTransformation! !!View methodsFor: 'display transformation'!inverseDisplayTransform: aPoint 	"Answer a Point that is obtained from the argument, aPoint, by applying 	to it the inverse of the receiver's display transformation. It is typically 	used by the Controller of the receiver in order to convert a point in 	display coordinates, such as the cursor point, to the local coordinate 	system of the receiver."	^self displayTransformation applyInverseTo: aPoint! !!View methodsFor: 'transforming'!align: aPoint1 with: aPoint2 	"Add a translation of (aPoint2 - aPoint1) to the receiver's local 	transformation. The point in the receiver's coordinate system that 	previously was transformed to aPoint1 in the superView's coordinate 	system will now be transformed to aPoint2 in the superView's coordinate 	system. Other points will be translated by the same amount. It is 	normally used when adding subViews to their superView in order to 	line up the Viewport of one subView with that of another subView (see 	View|addSubView:align:with:). aPoint1 and aPoint2 are usually points on 	the viewports that are to be aligned. For example, 'subView2 align: 	subView2 viewport topLeft with: subView1 viewport topRight' would be 	used to place the viewport of subView2 next to the viewport of 	subView1 with the topLeft and topRight corners, respectively, 	coinciding. It is also possible to align the viewport of a subView with 	the window of the superView, e.g., 'subView align: subView viewport 	center with: superView window center'. View|align:with: assumes that 	the view has been properly scaled, if necessary, to match its superView 	(see View|scaleBy:). Typically, the coordinate systems of the receiver 	and its superView will differ only by a translation offset so that no 	scaling is necessary."	self setTransformation: (transformation align: aPoint1 with: aPoint2)! !!View methodsFor: 'transforming'!scale: aScale translation: aTranslation 	"The x component of aScale (a Point) specifies the scale (translation) in 	the x direction; the y component specifies the scale (translation) in the y 	direction. aScale can optionally be an instance of Integer or Float in 	order to specify uniform scaling in both directions. Create a new local 	transformation for the receiver with a scale factor of aScale and a 	translation offset of aTranslation. When the transformation is applied (see 	View|transform:), the scale is applied first, followed by the translation. It 	is typically used when building a superView from its subViews in order 	to line up the viewports of the subViews in the desired way. If no 	scaling is required between subView and superView, then 	View|align:with: is often more convenient to use."	self setTransformation:		(WindowingTransformation scale: aScale translation: aTranslation)! !!View methodsFor: 'transforming'!scaleBy: aScale 	"The x component of aScale (a Point) specifies the scale in the x 	direction; the y component specifies the scale in the y direction. aScale 	can, optionally, be an instance of Integer or Float in order to specify 	uniform scaling in both directions. Scales the View by aScale. The scale 	is concatenated with the current transformation of the receiver and is 	applied when View|transform is sent. This happens automatically in the 	process of displaying the receiver, for example."	self setTransformation: (transformation scaleBy: aScale)! !!View methodsFor: 'transforming'!transform: anObject 	"Apply the local transformation of the receiver to anObject and answer 	the resulting transformation. It is used to get the superView coordinates 	of an object. For example, the viewport is equal to the window 	transformed."	^transformation applyTo: anObject! !!View methodsFor: 'transforming'!transformation	"Answer a copy of the receiver's local transformation."	^transformation copy! !!View methodsFor: 'transforming'!transformation: aTransformation 	"Set the receiver's local transformation to a copy of aTransformation, 	unlock the receiver (see View|unlock) and set the viewport to undefined 	(this forces it to be recomputed when needed)."	self setTransformation: aTransformation copy! !!View methodsFor: 'transforming'!translateBy: aPoint 	"Translate the receiver by aPoint. The translation is concatenated with 	the current transformation of the receiver and is applied when 	View|transform is sent. This happens automatically in the process of 	displaying the receiver."	self setTransformation: (transformation translateBy: aPoint)! !!View methodsFor: 'transforming'!window: aWindow viewport: aViewport 	"Set the receiver's window to aWindow, set its viewport to aViewport, and 	create a new local transformation for the receiver based on aWindow and 	aViewport. The receiver is scaled and translated so that aWindow, when 	transformed, coincides with aViewport. It is used to position a subView's 	window within some specific region of its superView's area. For example, 	'subView window: aRectangle1 viewport: aRectangle2' sets subView's 	window to aRectangle1, its viewport to aRectangle2, and its local 	transformation to one that transforms aRectangle1 to aRectange2."	self window: aWindow.	self setTransformation:		(WindowingTransformation window: aWindow viewport: aViewport).	self getViewport! !!View methodsFor: 'bordering' stamp: 'di 12/4/97 08:48'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor == nil ifFalse:		[(insideColor isMemberOf: Symbol) ifTrue:			[^ Color perform: insideColor].		^ insideColor].	superView == nil ifFalse: [^ superView backgroundColor].	^ Color white! !!View methodsFor: 'bordering' stamp: 'tk 10/21/97 12:31'!backgroundColor: aColor	Display depth = 1 ifTrue:		[(aColor ~= nil and: [aColor isTransparent not]) ifTrue:			["Avoid stipple due to attempts to match non-whites"			^ insideColor _ Color white]].	insideColor _ aColor! !!View methodsFor: 'bordering'!borderWidth	"Answer either 0, indicating no border, or a Rectangle whose left value is 	the width in display coordinates of the receiver's left border. Right, top, 	and bottom widths are analogous. The border width is initially 0. A 	View with a border width of 0 will not have any border displayed."	^borderWidth! !!View methodsFor: 'bordering'!borderWidth: anInteger	"Set the four border widths of the receiver to anInteger."	self		borderWidthLeft: anInteger		right: anInteger		top: anInteger		bottom: anInteger! !!View methodsFor: 'bordering'!borderWidthLeft: anInteger1 right: anInteger2 top: anInteger3 bottom: anInteger4	"Set the border widths of the receiver. These arguments represent the left, 	right, top, and bottom border widths."	borderWidth _			Rectangle				left: anInteger1				right: anInteger2				top: anInteger3				bottom: anInteger4.	self unlock! !!View methodsFor: 'bordering'!foregroundColor	borderColor == nil ifFalse:		[(borderColor isMemberOf: Symbol) ifTrue:			[^ Color perform: borderColor].		^ borderColor].	superView == nil ifFalse: [^ superView foregroundColor].	^ Color black! !!View methodsFor: 'bordering'!foregroundColor: aColor	borderColor _ aColor! !!View methodsFor: 'bordering'!insideColor: aColor 	^ self backgroundColor: aColor! !!View methodsFor: 'scrolling'!scrollBy: aPoint 	"The x component of aPoint specifies the amount of scrolling in the x 	direction; the y component specifies the amount of scrolling in the y 	direction. The amounts are specified in the receiver's local coordinate 	system. Scroll the receiver up or down, left or right. The window of the 	receiver is kept stationary and the subViews and other objects in the 	receiver are translated relative to it. Scrolling doesn't change the 	insetDisplayBox or the viewport since the change in the transformation 	is canceled by the change in the window. In other words, all display 	objects in the view, except the window, are translated by the scrolling 	operation.	Note: subclasses may override to return false if no scrolling takes place."	| aRectangle |	aRectangle _ insetDisplayBox.	transformation _ transformation scrollBy: aPoint.	window _ self getWindow translateBy: aPoint x negated @ aPoint y negated.	self unlock.	insetDisplayBox _ aRectangle.	^ true! !!View methodsFor: 'clearing'!clear	"Use the border color to paint the display box (including the border, see 	View|displayBox) of the receiver."	borderColor ~= nil ifTrue: [self clear: Color black]! !!View methodsFor: 'clearing'!clear: aColor 	"Use aColor to paint the display box (including the border, see 	View|displayBox) of the receiver."	aColor ~= nil ifTrue: [Display fill: self displayBox fillColor: aColor]! !!View methodsFor: 'clearing'!clearInside	"Use the inside color to paint the inset display box (excluding the border, 	see View|insetDisplayBox) of the receiver."	self clearInside: self backgroundColor! !!View methodsFor: 'clearing'!clearInside: aColor 	"Use aColor to paint the inset display box (excluding the border, see 	View|insetDisplayBox) of the receiver."	aColor ~~ nil ifTrue: [Display fill: self insetDisplayBox fillColor: aColor]! !!View methodsFor: 'indicating'!flash	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement twice in succession."	Display flash: self insetDisplayBox! !!View methodsFor: 'indicating'!highlight	"Cause the inset display box (the display box excluding the border, see 	View|insetDisplayBox) of the receiver to complement."	Display reverse: self insetDisplayBox! !!View methodsFor: 'updating'!update	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	self update: self! !!View methodsFor: 'updating'!update: aParameter 	"Normally sent by the receiver's model in order to notify the receiver of 	a change in the model's state. Subclasses implement this message to do 	particular update actions. A typical action that might be required is to 	redisplay the receiver."	^self! !!View methodsFor: 'private'!computeDisplayTransformation	"Answer a WindowingTransformation that transforms the coordinate 	system of the View into that of the display screen. The transformation is 	computed by composing the View's transformation with all transformations 	along its superView chain. It is sent by View|displayTransformation when	the View is unlocked (see View|unlock)."	self isTopView		ifTrue: [^transformation]		ifFalse: [^superView displayTransformation compose: transformation]! !!View methodsFor: 'private'!computeInsetDisplayBox	"Compute the View's inset display box by intersecting the superView's	inset display box with the View's window transformed to display	coordinates and then inseting the result by the border width. It is sent by 	View|insetDisplayBox if the inset display box is nil.	The insetDisplayBox points are truncated to prevent sending floating point numbers to QuickDraw which will die."	self isTopView		ifTrue:			[^((self displayTransform: self getWindow) insetBy: borderWidth) truncated]		ifFalse:			[^(superView insetDisplayBox				intersect: (self displayTransform: self getWindow)) truncated						insetBy: borderWidth]! !!View methodsFor: 'private'!getController	"Answer the View's controller if one exists. nil indicates that the default	controller is to be used."	^controller! !!View methodsFor: 'private'!getViewport	"Answer the Rectangle representing the View's viewport (in the	coordinate system of the superclass). If no viewport has been specified,	the View's window transformed into the superView's coordinate system is	saved and returned. It should be used by methods of View and subclasses	(instead of directly referring to the viewport) unless it is known that a	viewport actually exists. It should not be used outside of View or	subclasses because the viewport is not sharable."	viewport == nil ifTrue: [viewport _ (self transform: self getWindow) truncated].	^viewport! !!View methodsFor: 'private'!getWindow	"Answer the Rectangle that represents the window of this View. If no	window has been specified, a default window (see View|defaultWindow)	is created, saved, and returned. Should be used by methods of View and	subclasses to access the View window instead of directly accessing the	field unless it is known that a window actually exists. It is not to be used	outside of View (or subclasses) because the window is not sharable.	View|window should be used for outside access to the window."	window == nil ifTrue: [self setWindow: self defaultWindow].	^window! !!View methodsFor: 'private'!isCyclic: aView 	"Answer true if aView is the same as this View or its superView, false 	otherwise."	self == aView ifTrue: [^true].	self isTopView ifTrue: [^false].	^superView isCyclic: aView! !!View methodsFor: 'private'!setTransformation: aTransformation 	"Set the View's local transformation to aTransformation, unlock the View 	(see View|unlock), and set the viewport to undefined (this forces it to be 	recomputed when needed). Should be used instead of setting the 	transformation directly."	transformation _ aTransformation.	self unlock.	viewport _ nil! !!View methodsFor: 'private'!setWindow: aWindow 	"Set the View's window to aWindow and unlock the View (see	View|unlock). View|setWindow should be used by methods of View and	subclasses to set the View window (rather than directly setting the	instance variable) to insure that the View is unlocked."	window _ aWindow.	viewport _ nil.	self unlock! !!View methodsFor: 'private'!superView: aView 	"Set the View's superView to aView and unlock the View (see	View|unlock). It is sent by View|addSubView: in order to properly set all	the links."	superView _ aView.	self unlock! !!View methodsFor: 'miscellaneous'!clipRect	^ superView clipRect! !!View methodsFor: 'miscellaneous'!clipRect: r	superView clipRect: r! !!View methodsFor: 'miscellaneous'!gridSpacing	^ superView gridSpacing! !!View methodsFor: 'miscellaneous'!nestedViewport	"The viewport size used to control scaling of nested user views."	^ (0@0 extent: self viewport extent)			insetBy: 16 @ 16! !!View methodsFor: 'miscellaneous'!printViewSpecOn: strm nested: level	"Print window and viewport specs	of this and all nested views."	strm crtab: level; nextPutAll: self class name.	strm crtab: level; nextPutAll: 'window: '; print: self window.	strm crtab: level; nextPutAll: 'viewport: '; print: self viewport.	strm crtab: level; nextPutAll: 'displayBox: '; print: self displayBox.	strm crtab: level; nextPutAll: 'border: '; print: self borderWidth.	subViews do: [:v | v printViewSpecOn: strm nested: level+1]! !!View methodsFor: 'miscellaneous'!stretchFrame: newFrameBlock startingWith: startFrame 	"Track the outline of a newFrame as long as mouse drags it.	Maintain max and min constraints throughout the drag"	| frame newFrame click |	frame _ startFrame origin extent: ((startFrame extent min: self maximumSize)											max: self minimumSize).	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	click _ false.	[click and: [Sensor noButtonPressed]] whileFalse: 		[Processor yield.		click _ click | Sensor anyButtonPressed.		newFrame _ newFrameBlock value: frame.		newFrame _ newFrame topLeft extent: ((newFrame extent min: self maximumSize)											max: self minimumSize).		newFrame = frame ifFalse:			[Display border: frame width: 2 rule: Form reverse fillColor: Color gray.			Display border: newFrame width: 2 rule: Form reverse fillColor: Color gray.			frame _ newFrame]].	Display border: frame width: 2 rule: Form reverse fillColor: Color gray.	^ frame! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!View class	instanceVariableNames: ''!!View class methodsFor: 'instance creation'!new	"Answer an initialized instance of me. The transformation is an identity 	transformation, the borderWidth is 0, the borderColor is black, and the 	insideColor is transparent."	^super new initialize! !Envelope subclass: #VolumeEnvelope	instanceVariableNames: 'currentVol targetVol mSecsForChange '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Sound'!!VolumeEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 19:36'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			i _ points size.			nextRecomputeTime _ mSecs + 1000000].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ ((points at: i) x - t) max: 0.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 0.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 0.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 18:51'!reset	"Reset the state for this envelope."	super reset.	target initialVolume: points first y * scale.	nextRecomputeTime _ 0.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 07:27'!updateSelector	"Needed by the envelope editor."	^ #volume:! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 2/4/98 19:09'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !BitBlt subclass: #WarpBlt	instanceVariableNames: 'p1x p1y p1z p2x p2y p2z p3x p3y p3z p4x p4y p4z cellSize sourceRGBmap '	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Support'!!WarpBlt commentStamp: 'di 5/22/1998 16:39' prior: 0!WarpBlt comment:'WarpBlt is a little warp-drive added on to BitBlt.  It takes a quadrilateral as its source specification, while its destination is traversed and combined just like any other call to copyBits.The source quadrilateral is specified as an array of points starting with the corner that wants to end up in the topLeft, and proceding to the successive points that want to follow CCW around the destination rectangle.  Note that in specifying a plain old rectangle source, its non topLeft points must be actual pixels, not outside by 1, as with rectangle bottmRight, eg.  See the method Rectangle asQuad.WarpBlt does a fast job of rotation, reflection and scaling, and it can even produce a semblance of perspective.  Depth parameters are included for future improvements in this direction. but the primitve does not support this yet.'!!WarpBlt methodsFor: 'setup'!cellSize	^ cellSize! !!WarpBlt methodsFor: 'setup'!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	cellSize > 3 ifTrue:		[(self confirm:'Do you really want to averagemore than 3x3 pixels?') ifFalse: [self halt]].	colorMap _ Color colorMapIfNeededFrom: 32 to: destForm depth.! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:09'!mixPix: pix sourceMap: sourceMap destMap: destMap	"Average the pixels in array pix to produce a destination pixel.	First average the RGB values either from the pixels directly,	or as supplied in the sourceMap.  Then return either the resulting	RGB value directly, or use it to index the destination color map." 	| r g b rgb nPix bitsPerColor d |	nPix _ pix size.	r _ 0. g _ 0. b _ 0.	1 to: nPix do:		[:i |   "Sum R, G, B values for each pixel"		rgb _ sourceForm depth <= 8				ifTrue: [sourceMap at: (pix at: i) + 1]				ifFalse: [sourceForm depth = 32						ifTrue: [pix at: i]						ifFalse: [self rgbMap: (pix at: i) from: 5 to: 8]].		r _ r + ((rgb bitShift: -16) bitAnd: 16rFF).		g _ g + ((rgb bitShift: -8) bitAnd: 16rFF).		b _ b + ((rgb bitShift: 0) bitAnd: 16rFF)].	destMap == nil		ifTrue: [bitsPerColor _ 3.  "just in case eg depth <= 8 and no map"				destForm depth = 16 ifTrue: [bitsPerColor _ 5].				destForm depth = 32 ifTrue: [bitsPerColor _ 8]]		ifFalse: [destMap size = 512 ifTrue: [bitsPerColor _ 3].				destMap size = 4096 ifTrue: [bitsPerColor _ 4].				destMap size = 32768 ifTrue: [bitsPerColor _ 5]].	d _ bitsPerColor - 8.	rgb _ ((r // nPix bitShift: d) bitShift: bitsPerColor*2)		+ ((g // nPix bitShift: d) bitShift: bitsPerColor)		+ ((b // nPix bitShift: d) bitShift: 0).	destMap == nil		ifTrue: [^ rgb]		ifFalse: [^ destMap at: rgb+1]! !!WarpBlt methodsFor: 'smoothing' stamp: 'di 6/24/97 00:08'!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	self inline: true.	(d _ nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask _ (1 << nBitsIn) - 1.  "Transfer mask"			srcPix _ sourcePixel << d.			mask _ mask << d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d _ nBitsIn - nBitsOut.			mask _ (1 << nBitsOut) - 1.  "Transfer mask"			srcPix _ sourcePixel >> d.			destPix _ srcPix bitAnd: mask.			mask _ mask << nBitsOut.			srcPix _ srcPix >> d.			destPix _ destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !!WarpBlt methodsFor: 'primitives'!copyQuad: pts toRect: destRect	self sourceQuad: pts destRect: destRect.	self warpBits! !!WarpBlt methodsFor: 'primitives'!deltaFrom: x1 to: x2 nSteps: n	"Utility routine for computing Warp increments.	x1 is starting pixel, x2 is ending pixel;  assumes n >= 1"	| fixedPtOne |	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	x2 > x1		ifTrue: [^ x2 - x1 + fixedPtOne // (n+1) + 1]		ifFalse: [x2 = x1 ifTrue: [^ 0].				^ 0 - (x1 - x2 + fixedPtOne // (n+1) + 1)]! !!WarpBlt methodsFor: 'primitives'!sourceQuad: pts destRect: aRectangle	| fixedPt1 |	sourceX _ sourceY _ 0.	self destRect: aRectangle.	fixedPt1 _ (pts at: 1) x isInteger ifTrue: [16384] ifFalse: [16384.0].	p1x _ (pts at: 1) x * fixedPt1.	p2x _ (pts at: 2) x * fixedPt1.	p3x _ (pts at: 3) x * fixedPt1.	p4x _ (pts at: 4) x * fixedPt1.	p1y _ (pts at: 1) y * fixedPt1.	p2y _ (pts at: 2) y * fixedPt1.	p3y _ (pts at: 3) y * fixedPt1.	p4y _ (pts at: 4) y * fixedPt1.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives'!startFrom: x1 to: x2 offset: sumOfDeltas	"Utility routine for computing Warp increments."	x2 >= x1		ifTrue: [^ x1]		ifFalse: [^ x2 - sumOfDeltas]! !!WarpBlt methodsFor: 'primitives'!warpBits	"Move those pixels!!"	self warpBitsSmoothing: cellSize		sourceMap: (Color colorMapIfNeededFrom: sourceForm depth to: 32).! !!WarpBlt methodsFor: 'primitives' stamp: 'di 3/2/98 14:06'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 147>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WarpBlt class	instanceVariableNames: ''!!WarpBlt class methodsFor: 'initialization'!toForm: destinationForm	"Default cell size is 1 (no pixel smoothing)"	^ (super toForm: destinationForm) cellSize: 1! !!WarpBlt class methodsFor: 'examples'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 200@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 200@0).		]! !!WarpBlt class methodsFor: 'examples'!test3   "Display restoreAfter: [WarpBlt test3]"	"The Squeak Release Mandala - 9/23/96 di"	"Move the mouse near the center of the square.	Up and down affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box map d t |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	"Make a color map that steps through the color space"	map _ (Display depth > 8		ifTrue: ["RGB is a bit messy..."				d _ Display depth = 16 ifTrue: [5] ifFalse: [8].				(1 to: 512) collect: [:i | t _ i bitAnd: 511.					((t bitAnd: 16r7) bitShift: d-3)					+ ((t bitAnd: 16r38) bitShift: d-3*2)					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]		ifFalse: ["otherwise simple"				1 to: (1 bitShift: Display depth)])			as: Bitmap.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		colorMap: map;		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples'!test4   "Display restoreAfter: [WarpBlt test4]"	"The Squeak Release Mandala - 9/23/96 di	This version does smoothing"	"Move the mouse near the center ofhe square.	Up and dn affects shrink/grow	Left and right affect rotation angle"	| warp pts p0 p box |	box _ 100@100 extent: 300@300.	Display border: (box expandBy: 2) width: 2.	warp _ (WarpBlt toForm: Display)		clipRect: box;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	p0 _ box center.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ (box insetBy: p y - p0 y) innerCorners			collect: [:pt | pt rotateBy: p x - p0 x / 50.0 about: p0].		warp copyQuad: pts toRect: box]! !!WarpBlt class methodsFor: 'examples'!test5   "Display restoreAfter: [WarpBlt test5]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle fromUser.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 1;		sourceForm: Display;		cellSize: 2;  "installs a colormap"		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		warp copyQuad: pts toRect: (r1 translateBy: r1 width@0)]! !!WarpBlt class methodsFor: 'form rotation' stamp: 'jm 11/16/97 10:50'!rotate: srcForm degrees: angleInDegrees center: aPoint scaleBy: scalePoint smoothing: cellSize	"Rotate the given Form the given number of degrees about the given center and scale its width and height by x and y of the given scale point. Smooth using the given cell size, an integer between 1 and 3, where 1 means no smoothing. Return a pair where the first element is the rotated Form and the second is the position offset required to align the center of the rotated Form with that of the original. Note that the dimensions of the resulting Form generally differ from those of the original."	| srcRect center radians dstOrigin dstCorner p dstRect inverseScale quad dstForm newCenter warpSrc |	srcRect _ srcForm boundingBox.	center _ srcRect center.	radians _ angleInDegrees degreesToRadians.	dstOrigin _ dstCorner _ center.	srcRect corners do: [:corner |		"find the limits of a rectangle that just encloses the rotated		 original; in general, this rectangle will be larger than the		 original (e.g., consider a square rotated by 45 degrees)"		p _ ((corner - center) scaleBy: scalePoint) + center.		p _ (p rotateBy: radians about: center) rounded.		dstOrigin _ dstOrigin min: p.		dstCorner _ dstCorner max: p].	"rotate the enclosing rectangle back to get the source quadrilateral"	dstRect _ dstOrigin corner: dstCorner.	inverseScale _ (1.0 / scalePoint x)@(1.0 / scalePoint y).	quad _ dstRect innerCorners collect: [:corner |		p _ corner rotateBy: radians negated about: center.		((p - center) scaleBy: inverseScale) + center].	"make a Form to hold the result and do the rotation"	warpSrc _ srcForm.	(srcForm isKindOf: ColorForm)		ifTrue: [			cellSize > 1				ifTrue: [					warpSrc _ Form extent: srcForm extent depth: 16.					srcForm displayOn: warpSrc.					dstForm _ Form extent: dstRect extent depth: 16]  "use 16-bit depth to allow smoothing"				ifFalse: [					dstForm _ srcForm class extent: dstRect extent depth: srcForm depth]]		ifFalse: [			dstForm _ srcForm class extent: dstRect extent depth: srcForm depth].	(WarpBlt toForm: dstForm)		sourceForm: warpSrc;		colorMap: (dstForm colormapIfNeededForDepth: warpSrc depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint;		copyQuad: quad toRect: dstForm boundingBox.	(dstForm isKindOf: ColorForm) ifTrue: [dstForm colors: srcForm colors copy].	newCenter _ (center rotateBy: radians about: aPoint) truncated.	^ Array with: dstForm with: dstRect origin + (newCenter - center)! !Object subclass: #WindowingTransformation	instanceVariableNames: 'scale translation '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Framework'!!WindowingTransformation commentStamp: 'di 5/22/1998 16:39' prior: 0!WindowingTransformation comment:'My instances are used to transform objects from a source coordinate system to a destination coordinate system. Each instance contains a scale and a translation which can be applied to objects that respond to scaleBy: and translateBy:. It can be created with a default identity scale and translation, or with a specified scale and translation, or with a scale and translation computed from a window (a Rectangle in the source coordinate system) and a viewport (a Rectangle in the destination coordinate system). In applying a WindowingTransformation to an object, the object is first scaled (around the origin of the source coordinate system) and then translated. WindowingTransformations can be composed to form a single compound transformation.'!!WindowingTransformation methodsFor: 'scrolling'!scrollBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint scaled by 	the current scale. It is used when the translation is known in source 	coordinates, rather than scaled source coordinates (see 	WindowingTransformation|translateBy:). An example is that of scrolling 	objects with respect to a stationary window in the source coordinate 	system. If no scaling is in effect (scale = nil), then 	WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	| newTranslation |	scale == nil		ifTrue: [newTranslation _ aPoint]		ifFalse: [newTranslation _ scale * aPoint].	^self translateBy: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!align: point1 with: point2 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of (aPoint2 - aPoint1). It is normally used when 	the source and destination coordinate systems are scaled the same (that 	is, there is no scaling between them), and is then a convenient way of 	specifying a translation, given two points that are intended to coincide."	^self translateBy: point2 - point1! !!WindowingTransformation methodsFor: 'transforming'!noScale	"Answer true if the identity scale is in effect; answer false, otherwise."	^scale == nil! !!WindowingTransformation methodsFor: 'transforming'!scale	"Answer a copy of the point that represents the current scale of the 	receiver."	scale == nil		ifTrue: [^1.0 @ 1.0]		ifFalse: [^scale copy]! !!WindowingTransformation methodsFor: 'transforming'!scaleBy: aScale 	"Answer a WindowingTransformation with the scale and translation of 	the receiver both scaled by aScale."	| checkedScale newScale newTranslation |	aScale == nil		ifTrue: 			[newScale _ scale.			newTranslation _ translation]		ifFalse: 			[checkedScale _ self checkScale: aScale.			scale == nil				ifTrue: [newScale _ checkedScale]				ifFalse: [newScale _ scale * checkedScale].			newTranslation _ checkedScale * translation].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'transforming'!translateBy: aPoint 	"Answer a WindowingTransformation with the same scale as the receiver 	and with a translation of the current translation plus aPoint. It is used 	when the translation is known in scaled source coordinates, rather than 	source coordinates (see WindowingTransformation|scrollBy:). If no scaling 	is in effect (scale = nil), then WindowingTransformation|translateBy: and 	WindowingTransformation|scrollBy: are equivalent."	^WindowingTransformation scale: scale translation: translation + aPoint! !!WindowingTransformation methodsFor: 'transforming'!translation	"Answer a copy of the receiver's translation."	^translation copy! !!WindowingTransformation methodsFor: 'applying transform'!applyInverseTo: anObject 	"Apply the inverse of the receiver to anObject and answer the result. 	Used to map some object in destination coordinates to one in source 	coordinates."	| transformedObject |	transformedObject _ anObject translateBy: translation x negated @ translation y negated.	scale == nil		ifFalse: [transformedObject _ transformedObject scaleBy: 1.0 / scale x @ (1.0 / scale y)].	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!applyTo: anObject 	"Apply the receiver to anObject and answer the result. Used to map some 	object in source coordinates to one in destination coordinates."	| transformedObject |	scale == nil		ifTrue: [transformedObject _ anObject]		ifFalse: [transformedObject _ anObject scaleBy: scale].	transformedObject _ transformedObject translateBy: translation.	^transformedObject! !!WindowingTransformation methodsFor: 'applying transform'!compose: aTransformation 	"Answer a WindowingTransformation that is the composition of the 	receiver and aTransformation. The effect of applying the resulting 	WindowingTransformation to an object is the same as that of first 	applying aTransformation to the object and then applying the receiver to 	its result."	| aTransformationScale newScale newTranslation |	aTransformationScale _ aTransformation scale.	scale == nil		ifTrue: 			[aTransformation noScale				ifTrue: [newScale _ nil]				ifFalse: [newScale _ aTransformationScale].			newTranslation _ translation + aTransformation translation]		ifFalse: 			[aTransformation noScale				ifTrue: [newScale _ scale]				ifFalse: [newScale _ scale * aTransformationScale].			newTranslation _ translation + (scale * aTransformation translation)].	^WindowingTransformation scale: newScale translation: newTranslation! !!WindowingTransformation methodsFor: 'printing'!printOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPutAll: self class name, ' scale: ';		print: scale; nextPutAll: ' translation: ';		print: translation! !!WindowingTransformation methodsFor: 'private'!checkScale: aScale	"Convert aScale to the internal format of a floating-point Point." 	| checkedScale |	checkedScale _ aScale asPoint.	^checkedScale x asFloat @ checkedScale y asFloat! !!WindowingTransformation methodsFor: 'private'!setScale: aScale translation: aTranslation 	"Sets the scale to aScale and the translation to aTranslation."	scale _ aScale.	translation _ aTranslation! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WindowingTransformation class	instanceVariableNames: ''!!WindowingTransformation class methodsFor: 'instance creation'!identity	"Answer an instance of me with no scaling (nil) and no translation 	(0@0)."	^self new setScale: nil translation: 0 @ 0! !!WindowingTransformation class methodsFor: 'instance creation'!scale: aScale translation: aTranslation 	"Answer an instance of me with a scale factor of aScale and a translation 	offset of aTranslation. When the transformation is applied (see 	WindowingTransformation|apply:), the scale is applied first, followed by 	the translation."	^self new setScale: aScale translation: aTranslation! !!WindowingTransformation class methodsFor: 'instance creation'!window: aWindow viewport: aViewport 	"Answer an instance of me with a scale and translation based on 	aWindow and aViewport. The scale and translation are computed such 	that aWindow, when transformed, coincides with aViewport."	| scale translation |	aViewport width = aWindow width & (aViewport height = aWindow height)		ifTrue:			[scale _ nil]		ifFalse:			[scale _ aViewport width asFloat / aWindow width asFloat						@ (aViewport height asFloat / aWindow height asFloat)].	scale == nil		ifTrue: [translation _ aViewport left - aWindow left								@ (aViewport top - aWindow top)]		ifFalse: [translation _ aViewport left - (scale x * aWindow left)								@ (aViewport top - (scale y * aWindow top))].	^self new setScale: scale translation: translation! !PolygonMorph subclass: #WireMorph	instanceVariableNames: 'pins '	classVariableNames: 'InputPinForm IoPinForm OutputPinForm '	poolDictionaries: ''	category: 'Morphic-Components'!!WireMorph methodsFor: 'all' stamp: 'di 5/3/1998 22:53'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	super addAddHandMenuItemsForHalo: aMenu hand: aHandMorph.	aMenu add: 'delete' action: #dismissMorph! !!WireMorph methodsFor: 'all' stamp: 'di 5/3/1998 22:49'!addHandles	super addHandles.	"Don't show endpoint handles"	handles first delete.	handles last delete! !!WireMorph methodsFor: 'all' stamp: 'di 5/4/1998 00:12'!delete	pins do: [:p | p removeWire: self].	pins first isIsolated 		ifTrue: [pins first removeVariableAccess.				pins second isIsolated					ifTrue: [pins second removeModelVariable]]		ifFalse: [pins second isIsolated					ifTrue: [pins second removeVariableAccess]					ifFalse: [pins second addModelVariable]].	super delete! !!WireMorph methodsFor: 'all' stamp: 'di 5/2/1998 16:05'!fromPin: pin1 toPin: pin2	pins _ Array with: pin1 with: pin2! !!WireMorph methodsFor: 'all' stamp: 'di 5/3/1998 22:35'!handlesMouseDown: evt	^ evt buttons noMask: 16r78  "ie no modifier keys pressed"! !!WireMorph methodsFor: 'all' stamp: 'di 5/3/1998 23:01'!mouseUp: evt	handles == nil		ifTrue: [self addHandles]		ifFalse: [self removeHandles]! !!WireMorph methodsFor: 'all' stamp: 'di 5/2/1998 15:17'!otherPinFrom: aPin	(pins at: 1) = aPin		ifTrue: [^ pins at: 2]		ifFalse: [^ pins at: 1]! !!WireMorph methodsFor: 'all' stamp: 'di 5/6/1998 14:22'!pinMoved	| newVerts |	newVerts _ vertices copy.	newVerts at: 1 put: pins first wiringEndPoint.	newVerts at: newVerts size put: pins last wiringEndPoint.	self setVertices: newVerts! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WireMorph class	instanceVariableNames: ''!!WireMorph class methodsFor: 'as yet unclassified' stamp: 'di 5/3/1998 10:09'!includeInNewMorphMenu	^ false! !StringHolder subclass: #Workspace	instanceVariableNames: 'bindings '	classVariableNames: ''	poolDictionaries: ''	category: 'Interface-Support'!!Workspace methodsFor: 'binding'!bindingOf: aString	bindings isNil		ifTrue: [bindings _ Dictionary new].	(bindings includesKey: aString)		ifFalse: [bindings at: aString put: nil].	^bindings associationAt: aString! !PasteUpMorph subclass: #WorldMorph	instanceVariableNames: 'hands activeHand viewBox canvas damageRecorder stepList lastStepTime playerList '	classVariableNames: 'DisableDeferredUpdates '	poolDictionaries: ''	category: 'Morphic-Kernel'!!WorldMorph methodsFor: 'initialization' stamp: 'jm 5/6/1998 13:46'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	model _ nil.! !!WorldMorph methodsFor: 'initialization'!open	"Open a view on this WorldMorph."	MorphWorldView openOn: self.! !!WorldMorph methodsFor: 'initialization' stamp: 'jm 6/21/97 17:03'!openWithTitle: aString	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString! !!WorldMorph methodsFor: 'install / exit'!exit	Cursor normal show.	"restore the normal cursor"	self canvas: nil.		"free my canvas to save space"	Project current exit.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 5/14/1998 09:18'!install	self viewBox: Display boundingBox.	hands do: [:h | h initForEvents].	SystemWindow noteTopWindowIn: self.	self displayWorld.! !!WorldMorph methodsFor: 'classification'!isWorldMorph	^ true! !!WorldMorph methodsFor: 'accessing' stamp: 'jm 2/20/98 13:47'!activeHand	"Return the hand that is currently processing events. This method can be used by menu, buttons, and event handlers to discover which hand caused them to be invoked. Returns nil except when some hand is actually handling events."	^ activeHand! !!WorldMorph methodsFor: 'accessing'!canvas	^ canvas! !!WorldMorph methodsFor: 'accessing' stamp: 'jm 2/27/98 11:58'!canvas: aCanvas	"Start displaying on the given canvas."	canvas _ aCanvas.	self fullRepaintNeeded.! !!WorldMorph methodsFor: 'accessing' stamp: 'jm 5/13/1998 20:19'!color: aColor	"Set the background color of this world."	color = aColor ifFalse: [		color _ aColor.		self fullRepaintNeeded.		"Propagate to view"		self changed: #newColor].! !!WorldMorph methodsFor: 'accessing'!viewBox		^ viewBox! !!WorldMorph methodsFor: 'accessing' stamp: 'di 6/24/97 10:09'!viewBox: aRectangle	(viewBox == nil or:	 [viewBox extent ~= aRectangle extent])		ifTrue: [self canvas: nil].	viewBox _ aRectangle.	bounds _ 0@0 extent: viewBox extent.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	hands do: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WorldMorph methodsFor: 'accessing' stamp: 'jm 5/6/1998 13:46'!world	^ self! !!WorldMorph methodsFor: 'submorphs-accessing' stamp: 'jm 6/11/97 17:07'!allMorphsDo: aBlock	"Enumerate all morphs in the world, including those held in hands."	super allMorphsDo: aBlock.	hands reverseDo: [:h | h allMorphsDo: aBlock].! !!WorldMorph methodsFor: 'submorphs-accessing' stamp: 'sw 8/15/97 14:54'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	| mList |	mList _ OrderedCollection new.	submorphs do: [:m |		((m fullContainsPoint: aPoint) and: [m isLocked not]) ifTrue: [mList addLast: m]].	^ mList! !!WorldMorph methodsFor: 'drawing' stamp: 'sw 4/1/98 23:37'!assuredCanvas	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or: [canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (FormCanvas extent: viewBox extent)].	^ canvas! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/22/1998 06:11'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/21/1998 23:45'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: (FormCanvas on: f).	"force the entire canvas to be redrawn"	self fullRepaintNeeded.	self drawInvalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/22/1998 00:30'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(canvas == nil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: canvas].	hands reverseDo: [:h | h fullDrawOn: canvas].	canvas form displayOn: Display at: viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/22/1998 00:26'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self == World		ifTrue: [  "this world fills the entire Display"			((canvas == nil) or: [canvas form ~~ Display]) ifTrue: [				self canvas: (FormCanvas on: Display).				self viewBox: Display boundingBox]]		ifFalse: [  "this world is inside an MVC window"			((canvas == nil) or:			 [(canvas form ~~ Display) or:			 [(canvas origin ~= viewBox origin)]]) ifTrue: [				self canvas:					((FormCanvas on: Display)						copyOffset: viewBox origin clipRect: viewBox)]].	^ true! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/19/1998 17:55'!drawInvalidAreasOn: aCanvas	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n intersectors done mm |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: viewBox extent).	damageRecorder reset.	n _ self submorphs size.	intersectors _ OrderedCollection new: n*2.	rectList do: [:r |		c _ aCanvas copyClipRect: r.		true		ifTrue:			["Experimental top-down drawing"			i _ 1. done _ false.			[done or: [i > n]] whileFalse:				[mm _ submorphs at: i.				(mm fullBounds intersects: r) ifTrue:					[intersectors addLast: mm.					done _ mm drawOnFills: r].				i _ i+1].			done ifFalse: [c fillColor: color].			intersectors reverseDo:				[:m | m topDownDrawOn: c].			intersectors reset]		ifFalse: [c fillColor: color.				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 5/22/1998 00:06'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		fillColor: Color opaqueMask;		clipRect: viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r translateBy: viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!WorldMorph methodsFor: 'drawing' stamp: 'jm 2/20/98 18:25'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!WorldMorph methodsFor: 'events'!handlesMouseDown: evt	^ true! !!WorldMorph methodsFor: 'events'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:23'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	lastStepTime _ now.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:09'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!WorldMorph methodsFor: 'stepping' stamp: 'tk 9/30/97 14:42'!isStepping: aMorph	"Return true if the given morph is in the step list."	stepList do: [:entry | entry first == aMorph ifTrue: [^ true]].  "already stepping"	^ false! !!WorldMorph methodsFor: 'stepping' stamp: 'jm 2/23/98 18:52'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world."	| now deletions wakeupTime m |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	stepList do: [:entry |		wakeupTime _ entry at: 2.		m _ entry at: 1.		m world == self			ifTrue: [				wakeupTime <= now					ifTrue: [						m step.						entry at: 2 put: now + m stepTime]]			ifFalse: [				deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: m]].	deletions ifNotNil: [		deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now.! !!WorldMorph methodsFor: 'stepping' stamp: 'ack 7/5/97 16:01'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldMorph methodsFor: 'stepping' stamp: 'jm 10/17/97 15:04'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list. Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m startStepping]].! !!WorldMorph methodsFor: 'stepping' stamp: 'sw 4/16/1998 20:11'!stepAll	self allExtantPlayers do:		[:aPlayer |  aPlayer startRunning; step; stopRunning.		aPlayer costume goHome]! !!WorldMorph methodsFor: 'stepping'!stopStepping: aMorph	"Remove the given morph from the step list."	stepList copy do: [:entry |		entry first == aMorph ifTrue: [stepList remove: entry ifAbsent: []]].! !!WorldMorph methodsFor: 'hands' stamp: 'jm 9/26/97 15:00'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	hands _ hands copyWith: aHandMorph.	aHandMorph privateOwner: self.! !!WorldMorph methodsFor: 'hands'!hands	^ hands copy! !!WorldMorph methodsFor: 'hands' stamp: 'jm 11/4/97 07:16'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		hands _ hands copyWithout: aHandMorph].! !!WorldMorph methodsFor: 'change reporting'!fullRepaintNeeded	damageRecorder doFullRepaint.! !!WorldMorph methodsFor: 'change reporting'!invalidRect: damageRect	"Record the given rectangle in the damage list."	damageRecorder recordInvalidRect: damageRect.! !!WorldMorph methodsFor: 'change reporting'!layoutChanged	fullBounds _ nil.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 2/20/98 13:45'!doOneCycle	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	hands do: [:h |		activeHand _ h.		h processEvents.		activeHand _ nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 2/20/98 13:45'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."	"process user input events, but only for remote hands"	hands do: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			activeHand _ h.			h processEvents.			activeHand _ nil]].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'jm 11/4/97 07:16'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p _ [[true] whileTrue: [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait]] newProcess.	p resume.	^ p! !!WorldMorph methodsFor: 'dropping' stamp: 'sw 10/18/97 18:03'!acceptDroppingMorph: aMorph event: evt	"Add the given morph to this world and make sure it is getting stepped if it wants to be."	self addMorphFront: aMorph.	(aMorph fullBounds intersects: (0@0 extent: self viewBox extent)) ifFalse:		[self beep.  aMorph position: self bounds center].	self startSteppingSubmorphsOf: aMorph.! !!WorldMorph methodsFor: 'painting support' stamp: 'tk 7/14/97 18:06'!installForm: aForm	"Accept a Form from the outside, create a SketchMorph, and put it on the Hand."	| f |	f _ SketchMorph new form: aForm.	hands first attachMorph: f.! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 4/9/98 16:26'!paintArea	"What rectangle should the user be allowed to create a new painting in??  An area beside the paintBox.  Allow playArea to override with its own bounds!!  "	| playfield paintBoxBounds |	playfield _ self submorphNamed: 'playfield' ifNone: [nil].	playfield ifNotNil: [^ playfield bounds].	paintBoxBounds _ self paintBox bounds.	self hands first targetOffset x < paintBoxBounds center x		ifTrue: [^ bounds topLeft corner: paintBoxBounds left@bounds bottom]   "paint on left side"		ifFalse: [^ paintBoxBounds right@bounds top corner: bounds bottomRight].  "paint on right side"! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 4/9/98 16:26'!paintAreaFor: aSketchMorph	"Answer the area to comprise the onion-skinned canvas for painting/repainting aSketchMorph"	| itsOwner |	((itsOwner _ aSketchMorph owner) ~~ nil and: [itsOwner isPlayfieldLike])		ifTrue: [^ itsOwner bounds].  "handles every plausible situation"	^ self paintArea! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 4/18/1998 02:24'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	self allMorphsDo: [:m | (m isKindOf: EToyPalette) ifTrue: [		^ m showPaintPaletteNoSelection]].	"Does not create an object"	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (self topRight - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'sensing'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	| c root |	c _ FormCanvas extent: 1@1 depth: Display depth.	c _ c copyOrigin: aPoint negated clipRect: ((0@0) extent: 1@1).	c fillColor: color.	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsAt: aPoint) reverseDo: [:subM |				subM == aMorph ifTrue: [^ c form colorAt: 0@0].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsAt: aPoint) reverseDo: [:subM |					subM == aMorph ifTrue: [^ c form colorAt: 0@0].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form colorAt: 0@0! !!WorldMorph methodsFor: 'save/store' stamp: 'jm 10/17/97 15:04'!addMorphsAndModel: aDummyWorld	"Dump in submorphs, model, and stepList from a dummyWorld.  Used to bring a world in from an object file.  "	| |	aDummyWorld isMorph ifTrue: [		aDummyWorld isWorldMorph ifFalse: ["one morph, put on hand"			"aDummyWorld installModelIn: self.  	a chance to install model pointers"			self startSteppingSubmorphsOf: aDummyWorld.			self hands first attachMorph: aDummyWorld		] ifTrue: [			model == nil ifTrue: [self setModel: (aDummyWorld modelOrNil)]					ifFalse: [aDummyWorld modelOrNil ifNotNil: [								aDummyWorld modelOrNil privateOwner: nil.								self addMorph: (aDummyWorld modelOrNil)]].			aDummyWorld privateSubmorphs reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				m changed].			(aDummyWorld instVarNamed: 'stepList') do:				[:entry | entry first startStepping]]	] ifFalse: ["list, add them all"		aDummyWorld reverseDo: [:m |			m privateOwner: nil.			self addMorph: m.			self startSteppingSubmorphsOf: m.	"It may not want this!!"			m changed]].! !!WorldMorph methodsFor: 'save/store'!saveAsWorld	| worldName s |	worldName _ FillInTheBlank		request: 'Please give this world a name'		initialAnswer: 'test'.	((self class class includesSelector: worldName asSymbol) and:		[(PopUpMenu confirm: 'OK to overwrite ' , worldName , '?') not])		ifTrue: [^ self].	s _ WriteStream on: (String new: 1000).	s	nextPutAll: worldName; cr; tab;		nextPutAll: '"' , self class name , ' ' , worldName, ' open"'; cr; cr; tab;		nextPutAll: '^ '.	self printConstructorOn: s indent: 0.	s cr.	self class class		compile: s contents		classified: 'examples'		notifying: nil.! !!WorldMorph methodsFor: 'save/store' stamp: 'tk 5/30/97'!storeDataOn: aDataStream	"WorldMorphs only save certain fields when written to the disk.  Save only the world's submorphs, model, and stepList. See DataStream.typeIDFor:  "	| cntInstVars cntIndexedVars instVars data ind |	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	instVars _ self class allInstVarNames.	data _ Array new: instVars size.	"Add any additional fields to write here"	ind _ (instVars indexOf: 'model').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: model].	ind _ (instVars indexOf: 'submorphs').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: submorphs].	ind _ (instVars indexOf: 'stepList').	(ind = 0) ifTrue: [self error: 'this method is out of date']			ifFalse: [data at: ind put: stepList].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (data at: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:11'!abandonAllHalos	self haloMorphs do: [:m | m delete]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 4/17/1998 23:13'!balloonHelpEnabled	^ self presenter balloonHelpEnabled! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:28'!haloMorphOrNil	| m |	^ (m _ self haloMorphs) size > 0 ifTrue: [m first] ifFalse: [nil]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 9/5/97 16:10'!haloMorphs	^ submorphs select: [:m | m isKindOf: HaloMorph]! !!WorldMorph methodsFor: 'halos' stamp: 'sw 4/18/1998 02:27'!mouseOverHalosEnabled	^ self presenter mouseOverHalosEnabled! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/12/1998 10:01'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (self allMorphsIncludingBookPages select: [:m | m costumee ~~ nil] thenCollect: [:m | m costumee]) asArray! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/13/1998 00:15'!allKnownNames	^ self allMorphs collect: [:m | m knownName] thenSelect: [:n | n ~~ nil]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:20'!allScriptEditors	^ self allMorphs select:		[:s | s isKindOf: ScriptEditorMorph]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/21/1998 21:36'!allTileScriptingElements	^ self allMorphs select:		[:s | s isTileScriptingElement]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/27/1998 03:20'!chooseClickTarget	Cursor crossHair showWhile:		[Sensor waitButton].	Cursor down showWhile:		[Sensor anyButtonPressed].	^ (self morphsAt: (Sensor cursorPoint - self viewBox topLeft)) first! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/11/1998 17:14'!flushPlayerListCache	playerList _ nil! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/16/1998 14:03'!goVGA	self standardSystemController view reframeTo: (0@0 extent: 640 @ 440); display! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:29'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid _ Compiler evaluate: (FillInTheBlank request: 'Enter grid size' initialAnswer: '16').	Utilities informUser: 'Choose a background color' during: [backColor _ Color fromUser].	Utilities informUser: 'Choose a line color' during: [lineColor _ Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.	self changed: #newColor! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:28'!makeGraphPaperDefault	self makeGraphPaperGrid: 16		background: (Color r: 0.8 g: 1.0 b: 1.0)		line: (Color r: 0.6 g: 1.0 b: 1.0)	"Note: if called, be sure next to call self changed: #newColor, unless it's too early	in the initialization process"! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:27'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do:		[:i | gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.			gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:31'!nextPage	"backstop for smart next-page buttons that look up the containment hierarchy until they find somone who is willing to field this command.  If we get here, the 'next' button was not embedded in a book, so we can do nothing useful"	self beep! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/17/1998 23:16'!presenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles].	^ presenter! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:31'!previousPage	"backstop for smartprev-page buttons that look up the containment hierarchy until they find somone who is willing to field this command.  If we get here, the button was not embedded in a book, so we can do nothing useful"	self beep! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/29/1998 16:00'!referencePlayfield	^ self submorphNamed: 'playfield'! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/6/1998 11:02'!removeScriptingControls	| toClobber |	toClobber _ self submorphs select: [:m | m hasProperty: #scriptingControl].	toClobber do: [:m | m delete].! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/21/1998 22:24'!residesInPartsBin	"Answer true if the receiver is, or has some ancestor owner who is, a parts bin"	^ self isPartsBin! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/21/1998 15:48'!setStandardTexture	| parms |	parms _ self textureParameters.	self  makeGraphPaperGrid: parms first background: parms second line: parms third.	self fullRepaintNeeded! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/16/1998 20:33'!soundsEnabled	^ self presenter ifNotNil: [self presenter soundsEnabled] ifNil: [true]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/12/1998 10:49'!specialNameInModelFor: aMorph	^ model ifNotNil: [model nameFor: aMorph] ifNil: [nil]! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/22/1998 20:31'!standardHolder	^ self presenter standardHolder! !!WorldMorph methodsFor: 'etoy support' stamp: 'jm 5/16/1998 10:45'!standardPlayerHit	self playSoundNamed: #peaks.! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:31'!standardSystemController	^ ScheduledControllers controllerSatisfying:		[:c | (c view subViews size > 0) and:			[c view firstSubView model == self]].! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 5/11/1998 19:33'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self updateStatusForAllScriptEditors! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:21'!stopRunningAll	"Start running all scripted morphs.  Triggered by user hitting STOP button"	self allExtantPlayers  do: [:aPlayer | aPlayer stopRunning.  aPlayer costume goHome].	self updateStatusForAllScriptEditors! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:28'!textureParameters	"Answer a triplet giving the preferred grid size, background color, and line color.  The choices here are as suggested by Alan, 9/13/97"	^ Array with: 16 with: Color lightYellow with: Color lightGreen lighter lighter! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 4/15/1998 21:20'!updateStatusForAllScriptEditors	self allScriptEditors do: [:anEditor | anEditor updateStatus]! !!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/6/1998 13:45'!addAllMorphs: array	super addAllMorphs: array.	array do: [:m | self startSteppingSubmorphsOf: m].! !!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/6/1998 13:57'!addMorph: aMorph centeredNear: aPoint	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."	| trialRect delta |	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.	delta _ trialRect amountToTranslateWithin: bounds.	aMorph position: trialRect origin + delta.	self addMorph: aMorph.! !!WorldMorph methodsFor: 'object fileIn' stamp: 'di 5/21/1998 19:23'!convertbosfcephvcdslm0: varDict bosfcepcbbfgccpmcpbttloiairfidcuhavcdslp0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('activeHand' 'playerList' ) and deal with the information in ('model' )"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WorldMorph class	instanceVariableNames: ''!!WorldMorph class methodsFor: 'all' stamp: 'sw 5/3/1998 19:01'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'world'! !!WorldMorph class methodsFor: 'all' stamp: 'jm 5/22/1998 00:51'!disableDeferredUpdates: aBoolean	"If the argument is true, disable deferred screen updating."	"Details: When deferred updating is used, Morphic performs double-buffered screen updates by telling the VM to de-couple the Display from the hardware display buffer, drawing directly into the Display, and then forcing the changed regions of the Display to be copied to the screen. This saves both time (an extra BitBlt is avoided) and space (an extra display buffer is avoided). However, on platforms on which the Display points directly to the hardware screen buffer, deferred updating can't be used (you'd see ugly flashing as the layers of the drawing were assembled). In this case, the drawing is composited into an offscreen FormCanvas  and then copied to the hardware display buffer."	DisableDeferredUpdates _ aBoolean.! !!WorldMorph class methodsFor: 'all' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!WorldMorph class methodsFor: 'all' stamp: 'sw 5/6/1998 17:34'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan; standardPlayer.	aWorld addMorph: ((aWorld presenter newStandardPartsBin) position: 10@10).	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !PositionableStream subclass: #WriteStream	instanceVariableNames: 'writeLimit '	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!WriteStream commentStamp: 'di 5/22/1998 16:39' prior: 0!WriteStream comment:'I represent an accessor for a sequence of objects that can only store objects in the sequence.'!!WriteStream methodsFor: 'accessing'!contents	readLimit _ readLimit max: position.	^collection copyFrom: 1 to: position! !!WriteStream methodsFor: 'accessing'!next	self shouldNotImplement! !!WriteStream methodsFor: 'accessing'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	position = writeLimit		ifTrue: [^self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !!WriteStream methodsFor: 'accessing'!size	^readLimit _ readLimit max: position! !!WriteStream methodsFor: 'positioning'!position: anInteger 	"Refer to the comment in PositionableStream|position:."	readLimit _ readLimit max: position.	super position: anInteger! !!WriteStream methodsFor: 'positioning'!reset 	"Refer to the comment in PositionableStream|reset."	readLimit _ readLimit max: position.	position _ 0! !!WriteStream methodsFor: 'character writing'!cr	"Append a return character to the receiver."	self nextPut: Character cr! !!WriteStream methodsFor: 'character writing'!crtab	"Append a return character, followed by a single tab character, to the 	receiver."	self nextPut: Character cr.	self nextPut: Character tab! !!WriteStream methodsFor: 'character writing'!crtab: anInteger 	"Append a return character, followed by anInteger tab characters, to the 	receiver."	self nextPut: Character cr.	anInteger timesRepeat: [self nextPut: Character tab]! !!WriteStream methodsFor: 'character writing'!space	"Append a space character to the receiver."	self nextPut: Character space! !!WriteStream methodsFor: 'character writing'!tab	"Append a tab character to the receiver."	self nextPut: Character tab! !!WriteStream methodsFor: 'fileIn/Out'!nextChunkPut: aString	"Append the argument, aString, to the receiver, doubling embedded terminators."	| i remainder terminator |	terminator _ $!!.	remainder _ aString.	[(i _ remainder indexOf: terminator) = 0] whileFalse:		[self nextPutAll: (remainder copyFrom: 1 to: i).		self nextPut: terminator.  "double imbedded terminators"		remainder _ remainder copyFrom: i+1 to: remainder size].	self nextPutAll: remainder; nextPut: terminator! !!WriteStream methodsFor: 'fileIn/Out' stamp: 'di 2/2/98 13:03'!nextChunkPutWithStyle: aStringOrText	"Append the argument, aText, to the receiver, doubling embedded terminators.  Put out one chunk for the string and one for the style runs.  Mark the style with ]style[."	aStringOrText class == String ifTrue: [^ self nextChunkPut: aStringOrText].	aStringOrText runs coalesce.	aStringOrText unembellished ifTrue: [^ self nextChunkPut: aStringOrText asString].	self nextChunkPut: aStringOrText asString.	self cr; nextPutAll: ']style['.	self nextChunkPut: 		(String streamContents: [:strm | 			aStringOrText runs writeScanOn: strm]).! !!WriteStream methodsFor: 'printing'!print: anObject 	"Have anObject print on the receiver."	anObject printOn: self! !!WriteStream methodsFor: 'printing'!store: anObject 	"Have anObject print on the receiver for purposes of rereading."	anObject storeOn: self! !!WriteStream methodsFor: 'private'!on: aCollection	super on: aCollection.	readLimit _ 0.	writeLimit _ aCollection size! !!WriteStream methodsFor: 'private'!on: aCollection from: firstIndex to: lastIndex	| len |	collection _ aCollection.	readLimit _ 		writeLimit _ lastIndex > (len _ collection size)						ifTrue: [len]						ifFalse: [lastIndex].	position _ firstIndex <= 1				ifTrue: [0]				ifFalse: [firstIndex - 1]! !!WriteStream methodsFor: 'private' stamp: 'di 6/20/97 08:39'!pastEndPut: anObject	collection _ collection ,		(collection class new: ((collection size max: 20) min: 20000)).	writeLimit _ collection size.	collection at: (position _ position + 1) put: anObject! !!WriteStream methodsFor: 'private'!with: aCollection	super on: aCollection.	position _ readLimit _ writeLimit _ aCollection size! !!WriteStream methodsFor: 'private'!withAttribute: att do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WriteStream class	instanceVariableNames: ''!!WriteStream class methodsFor: 'instance creation'!on: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me on a copy of the argument, aCollection, 	determined by the indices firstIndex and lastIndex. Position the instance 	at the beginning of the collection."	^self basicNew		on: aCollection		from: firstIndex		to: lastIndex! !!WriteStream class methodsFor: 'instance creation'!with: aCollection 	"Answer an instance of me on the argument, aCollection, positioned to 	store objects at the end of aCollection."	^self basicNew with: aCollection! !!WriteStream class methodsFor: 'instance creation'!with: aCollection from: firstIndex to: lastIndex 	"Answer an instance of me on the subcollection of the argument, 	aCollection, determined by the indices firstIndex and lastIndex. Position 	the instance to store at the end of the subcollection."	^self basicNew with: (aCollection copyFrom: firstIndex to: lastIndex)! !TransformMorph subclass: #ZoomMorph	instanceVariableNames: 'fromMorph toMorph boundsSeq finalAction '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Widgets'!!ZoomMorph methodsFor: 'all'!initialize	super initialize.	color _ Color transparent! !!ZoomMorph methodsFor: 'all'!step	boundsSeq isEmpty ifTrue:		["If all done, then grant one final request and vanish"		finalAction value.		^ self delete].	"Otherwise, zoom to the next rectangle"	self zoomTo: boundsSeq removeFirst! !!ZoomMorph methodsFor: 'all'!stepTime	^ 40! !!ZoomMorph methodsFor: 'all'!zoomFromMorph: m1 toMorph: m2 andThen: actionBlock	| nSteps topLeft r2 r1 extent ratio r mouthDeltas |	fromMorph _ m1.	toMorph _ m2.	r1 _ fromMorph fullBounds.	r2 _ toMorph fullBounds.	finalAction _ actionBlock.	nSteps _ 8.	boundsSeq _ OrderedCollection new.	r _ (1/nSteps) asFloat.	ratio _ r.r1 _ 105@326 corner: 130@348.mouthDeltas _ {-7@24. -6@21. -6@18. -4@14. -4@10. -3@8. -3@3. 0@0}.	1 to: nSteps do:		[:i | topLeft _ ((r2 topLeft - r1 topLeft) * ratio) asIntegerPoint + r1 topLeft.		extent _ ((r2 extent - r1 extent) * ratio) asIntegerPoint + r1 extent.		boundsSeq addLast: (topLeft + (mouthDeltas at: i) extent: extent).		ratio _ ratio + r].	self addMorph: toMorph.	self step! !!ZoomMorph methodsFor: 'all'!zoomTo: newBounds	| scale |	self bounds: newBounds.	scale _ newBounds extent / toMorph fullBounds extent.	self setOffset: toMorph position - self position angle: 0.0 scale: scale! !